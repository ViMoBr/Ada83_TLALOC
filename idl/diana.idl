--|#################################################################################################
--|	SYMBOLES TERMINAUX
--|#################################################################################################

%terminals

  ABORT	ABS	ACCEPT	ACCESS	ALL	AND	ARRAY	AT BEGIN	BODY	CASE
  CONSTANT	DECLARE	DELAY	DELTA	DIGITS	DO	ELSE	ELSIF	END
  ENTRY	EXCEPTION EXIT	FOR	FUNCTION	GENERIC	GOTO	IF	IN	IS
  LIMITED	LOOP	MOD	NEW	NOT	NULL	OF	OR	OTHERS	OUT
  PACKAGE	PRAGMA	PRIVATE	PROCEDURE	RAISE	RANGE	RECORD	REM	RENAMES	RETURN
  REVERSE	SELECT	SEPARATE	SUBTYPE	TASK	TERMINATE	THEN	TYPE	USE	WHEN
  WHILE	WITH	XOR

  identifier	numeric_literal	string_literal	character_literal

  & ' ( ) * + , - . / : ;  < = >  '|'	=> .. **  := /=  >=  <= <<  >>  <>


--|#################################################################################################
--|	REGLE RACINE
--|#################################################################################################

%start

  compilation


--|#################################################################################################
--|	REGLES (et definitions IDL)
--|#################################################################################################

%rules

--|-------------------------------------------------------------------------------------------------
--|	Standard initial IDL items
--|-------------------------------------------------------------------------------------------------

//  root	=>	xd_high_page	: num_val,
//		xd_user_root	: user_root,
//		xd_source_list	: Seq Of sourceline,
//		xd_err_count	: num_val,
//		spare_1 	: void;
##  root	====>				--| Action sur root
##	call	user_root	@ xd_user_root  root	--| appliquer l'action user_root sur le champ xd_user_root

//  txtrep	=> ;				-- representation of text
//  num_val	=> ;				-- representation of (small) integer

//  BOOLEAN	::=	false | true;
//  false	=> ;				-- used for BOOLEAN
//  true	=> ;

//  nil	=> ;				-- empty list
//  list	=>	xd_head 	: void,		-- list representation
//		xd_tail 	: void;

//  sourceline	=>	xd_number	: num_val,
//		xd_error_list	: Seq Of error;

//  error	=>	xd_srcpos	: Source_Position,
//		xd_text 	: txtrep;

//  symbol_rep	=>	xd_text 	: txtrep,
//		xd_deflist	: Seq Of DEF_NAME;

//  hash	=>	xd_list 	: Seq Of symbol_rep;

//  void	=> ;

// STANDARD_IDL	::=
//	root | txtrep | num_val | BOOLEAN | nil | list | sourceline | error | symbol_rep | hash | void;


--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-- 2.  Lexical Elements
--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

-- Syntax 2.0
--	Pas d'equivalent en syntaxe concrète



--|-------------------------------------------------------------------------------------------------
-- 2.3 Identifiers, 2.4 Numeric Literals, 2.6 String Literals

-- Syntax 2.3
--	Ne concerne pas Diana

--|.................................................................................................
//  DEF_NAME	::=	SOURCE_NAME | PREDEF_NAME;
//  DEF_NAME	=>	lx_symrep	: symbol_rep;
--|.................................................................................................
//  SOURCE_NAME	::=	OBJECT_NAME | TYPE_NAME | UNIT_NAME | LABEL_NAME;
//  SOURCE_NAME	=>	xd_region	: SOURCE_NAME;

##  SOURCE_NAME	====>
##	if_class	OBJECT_NAME
##	call	OBJECT_NAME	SOURCE_NAME
##	if_class	TYPE_NAME
##	call	TYPE_NAME	SOURCE_NAME
##	if_class	UNIT_NAME
##	call	UNIT_NAME	SOURCE_NAME
##	if_class	LABEL_NAME
##	call	LABEL_NAME	SOURCE_NAME
##	if	entry_id
##	call	entry_id	SOURCE_NAME
##	if	exception_id
##	call	exception_id	SOURCE_NAME

--|.................................................................................................
//  OBJECT_NAME	=>	sm_obj_type	: TYPE_SPEC;

##  OBJECT_NAME	====>
##	if	iteration_id
##	call	iteration_id	OBJECT_NAME
##	if_class	INIT_OBJECT_NAME
##	call	INIT_OBJECT_NAME	OBJECT_NAME
##	if_class	ENUM_LITERAL
##	call	ENUM_LITERAL	OBJECT_NAME
--|.................................................................................................
//  UNIT_NAME	=>	sm_first	: DEF_NAME;

##  UNIT_NAME	====>
##	if	task_body_id
##	call	task_body_id	UNIT_NAME
##	if_class	NON_TASK_NAME
##	call	NON_TASK_NAME	UNIT_NAME


--|-------------------------------------------------------------------------------------------------
-- 2.8	Pragmas
--     These productions do not correspond to productions in the
--     concrete syntax.

--|-------------------------------------------------------------------------------------------------
-- Syntax 2.8.A
-- pragma ::=
--     pragma identifier [(argument_association {, argument_association})];

--|-------------------------------------------------------------------------------------------------
pragma	::=
	PRAGMA  used_name_id  [(argument_association{,argument_association})]  ;	====> $2 pragma
	%%
--|.................................................................................................
used_name_id	::=
	identifier				====> $0 used_name_id lx_symrep
	%%
--|.................................................................................................
[(argument_association{,argument_association})] ::=
	empty				====> nil $L general_assoc_s
	|  (  argument_association{,argument_association}  )		====> $L general_assoc_s
	%%
--|.................................................................................................
pragma_s	::=
	pragma {pragma}				====> insert $L pragma_s
	%%
--|.................................................................................................
[pragma_s]	::=
	{pragma} 				====> $L pragma_s
	%%
--|.................................................................................................


//  pragma	=>
//	as_used_name_id	: used_name_id,
//	as_general_assoc_s	: general_assoc_s;			-- seq of EXP and/or assoc
--|.................................................................................................
//  general_assoc_s	=>
//	as_list	: Seq Of GENERAL_ASSOC;


--|-------------------------------------------------------------------------------------------------
-- Syntax 2.8.B
--  argument_association ::=
--	  [argument_identifier  =>] name
--	| [argument_identifier  =>] expression

--|-------------------------------------------------------------------------------------------------
argument_association  ::=
	expression
	|  used_name_id  =>  expression			====> exch_1 $2 assoc
	%%
--|.................................................................................................


--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-- 3.  Declarations and Types
--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-- 3.1	Declarations

-- Syntax 3.1
--  basic_declaration ::=
--     object_declaration	| number_declaration
--     | type_declaration	| subtype_declaration
--     | subprogram_declaration	| package_declaration
--     | task_declaration	| generic_declaration
--     | exception_declaration	| generic_instantiation
--     | renaming_declaration	| deferred_constant_declaration
--|-------------------------------------------------------------------------------------------------

basic_declaration	::=
	  var_declaration	     | number_declaration
	| type_declaration	     | subtype_declaration
	| subprogram_declaration | package_declaration
	| task_declaration	     | generic_declaration
	| exception_declaration  | generic_instantiation
	| renaming_declaration   | constant_declaration
	%%
--|.................................................................................................


//  DECL		::=
//	ID_S_DECL | ID_DECL;

##  DECL	====>
##	if_class	ID_S_DECL
##	call	ID_S_DECL	DECL
##	if_class	ID_DECL
##	call	ID_DECL	DECL

--|.................................................................................................
//  ID_DECL		::=
//	type_decl | subtype_decl | task_decl | UNIT_DECL;
//  ID_DECL		=>
//	as_source_name	: SOURCE_NAME;

##  ID_DECL	====>
##	if	type_decl
##	call	type_decl	ID_DECL
##	if	subtype_decl
##	call	subtype_decl	ID_DECL
##	if	task_decl
##	call	task_decl	ID_DECL
##	if_class	UNIT_DECL
##	call	UNIT_DECL	ID_DECL
--|.................................................................................................
//  ID_S_DECL		::=
//	EXP_DECL | exception_decl | deferred_constant_decl;
//  ID_S_DECL		=>
//	as_source_name_s	: source_name_s;

##  ID_S_DECL	====>
##	if_class	EXP_DECL
##	call	EXP_DECL	ID_S_DECL
##	if	exception_decl
##	call	exception_decl	ID_S_DECL
##	if	deferred_constant_decl
##	call	deferred_constant_decl	ID_S_DECL
--|.................................................................................................
//  EXP_DECL		::=
//	OBJECT_DECL | number_decl;
//  EXP_DECL		=>
//	as_exp	: EXP;

##  EXP_DECL	====>
##	if_class	OBJECT_DECL
##	call	OBJECT_DECL	EXP_DECL
##	if	number_decl
##	call	number_decl	EXP_DECL


--|-------------------------------------------------------------------------------------------------
-- 3.2	Objects and Named Numbers

-- Syntax 3.2.A
--  object_declaration ::=
--     identifier_list : [constant] subtype_indication [:= expression];
--   | identifier_list : [constant] constrained_array_definition [:= expression

--** Declarations defined such that xxx_id nodes not created until after
--** the definition has been parsed.  Note that '$DEF' inserts the appropriate
--** node at the beginning of the list which is the first son of the node at
--** the top of the semantic stack.
--|-------------------------------------------------------------------------------------------------

constant_declaration ::=
	  identifier  :  constant_definition  ;			====> $DEF constant_id
	| identifier  ,  constant_declaration			====> $DEF constant_id
	%%
--|.................................................................................................
constant_definition ::=
	  CONSTANT  subtype_indication  :=  expression		====> exch_1 $N3 constant_decl
	| CONSTANT constrained_array_definition := expression		====> exch_1 $N3 constant_decl
	| CONSTANT  type_mark			====> $N2 deferred_constant_decl
	%%
--|.................................................................................................
var_declaration	::=
	  identifier  :  var_definition  ;			====> $DEF variable_id
	| identifier  ,  var_declaration			====> $DEF variable_id
	%%
--|.................................................................................................
var_definition	::=
	  subtype_indication  [:=expression]			====> exch_1 $N3 variable_decl
	| constrained_array_definition  [:=expression]		====> exch_1 $N3 variable_decl
	%%
--|.................................................................................................


--|.................................................................................................
//  CONSTRAINED_DEF		::=
//	subtype_indication;
--|.................................................................................................
//  OBJECT_DECL		::=
//	constant_decl | variable_decl;
//  OBJECT_DECL		=>
//	as_type_def : TYPE_DEF;

##  OBJECT_DECL	====>
## include	DECLARE
## include	  SRC_NAME_SEQ : SEQ_TYPE := LIST ( D ( AS_SOURCE_NAME_S, OBJECT_DECL ) );	--| AMENER LA LISTE DES NOMS DE VAR OU CONST
## include	  SRC_NAME     : TREE;
## include	  TYPE_DEF     : TREE     := D ( AS_TYPE_DEF, OBJECT_DECL );
## include	  TYPE_NAME    : TREE     := D ( AS_NAME, TYPE_DEF );		--| NOM DU TYPE DANS LE CODE SOURCE
## include	BEGIN
## include	  EMITS.TYPE_SYMREP := D ( LX_SYMREP, TYPE_NAME );		--| REPRESENTATION DU SYMBOLE DE TYPE

## include	  WHILE NOT IS_EMPTY ( SRC_NAME_SEQ ) LOOP
## include	    POP ( SRC_NAME_SEQ, SRC_NAME );
## call	  VC_NAME	SRC_NAME			--| TRAITER LE NOM DE VAR CONST DECLARE
## include	  END LOOP;
## include	END;

--|.................................................................................................
//  constant_decl		=> ;			--| Ne fait qu'heriter
--|.................................................................................................
//  variable_decl		=> ;
--|.................................................................................................
//  OBJECT_NAME		::=
//	INIT_OBJECT_NAME;
--|.................................................................................................
//  INIT_OBJECT_NAME	::=			--| Objet var ou cst avec initialisation
//	VC_NAME;
//  INIT_OBJECT_NAME	=>
//	sm_init_exp	: EXP;			--| Attribut expression d'init
--|.................................................................................................
//  VC_NAME		::=
//	variable_id | constant_id;			--| Identificateur variable ou constante
//  VC_NAME		=>
//	sm_renames_obj	: BOOLEAN,			--| Indique un renames (pour var)
//	sm_address	: EXP,			--| EXP OU VIDE
//	cd_comp_unit	: Integer,
//	cd_level	: Integer,
//	cd_offset	: Integer,
//	cd_compiled	: BOOLEAN;

##  VC_NAME	====>
## include	DECLARE
## include	  TYPE_SPEC : TREE := D ( SM_OBJ_TYPE, VC_NAME );		--| LE TYPE ATTACHE A LA DECLARATION VAR CONST
## include	  --|---------------------------------------------------------------------------
## include	  PROCEDURE COMPILE_VC_NAME_INTEGER ( VC_NAME :TREE ) IS		--| VARIABLE DE TYPE ENTIER
## include	  BEGIN
## include	    ALIGN ( INTG_AL );			--| ALIGNER LES OFFSET POUR UN ENTIER
## include	    DECLARE
## include	      LVL      : LEVEL_TYPE    := EMITS.LEVEL;		--| NIVEAU IMBRICATION ACTUEL
## include	      OFS      : OFFSET_TYPE   := - EMITS.OFFSET_ACT;		--| DECALAGE ACTUEL ESPACE DE STOCKAGE
## include	      CPU      : COMP_UNIT_NBR := EMITS.CUR_COMP_UNIT;		--| NUMERO D UNITE ACTUEL
## include	      INIT_EXP : TREE          := D ( SM_INIT_EXP, VC_NAME );
## include	    BEGIN
## include	      DI ( CD_LEVEL, VC_NAME, LVL );			--| STOCKER LE NIVEAU
## include	      DI ( CD_OFFSET, VC_NAME, OFS );			--| LE DECALAGE
## include	      DI ( CD_COMP_UNIT, VC_NAME, CPU );		--| L UNITE
## include	      DB ( CD_COMPILED, VC_NAME, TRUE );		--| INDIQUER QUE C EST COMPILE
## include	      INC_OFFSET ( INTG_SIZE );			--| AUGMENTER LE DECALAGE
## include	      IF INIT_EXP /= TREE_VOID THEN			--| SI EXPRESSION D INITIALISATION
## call	EXP	INIT_EXP			--| EVALUER CETTE EXPRESSION
## include	        GEN_STORE ( I, CPU, LVL, OFS,			--| STOCKER SON RESULTAT COMME VALEUR INITIALE
## include	                  "STO " & PRINT_NAME ( D (LX_SYMREP, VC_NAME ) ) & " VAL INIT" );
## include	      END IF;
## include	    END;
## include	  END COMPILE_VC_NAME_INTEGER;
## include	  --|---------------------------------------------------------------------------
## include	  PROCEDURE COMPILE_VC_NAME_ENUMERATION ( VC_NAME, TYPE_SPEC :TREE ) IS
## include	    NAME             : CONSTANT STRING := PRINT_NAME ( EMITS.TYPE_SYMREP );	--| CHAINE DU NOM DE TYPE

## include	    PROCEDURE COMPILE_VC_NAME_BOOL_CHAR ( VC_NAME :TREE; CT :CODE_TYPE; SIZ, ALI :NATURAL ) IS
## include	    BEGIN
## include	      ALIGN ( ALI );
## include	      DECLARE
## include	        LVL      : LEVEL_TYPE    := EMITS.LEVEL;
## include	        OFS      : OFFSET_TYPE   := - EMITS.OFFSET_ACT;
## include	        CPU      : COMP_UNIT_NBR := EMITS.CUR_COMP_UNIT;
## include	        INIT_EXP : TREE          := D ( SM_INIT_EXP, VC_NAME );
## include	      BEGIN
## include	        DI ( CD_LEVEL, VC_NAME, LVL );			--| STOCKER LE NIVEAU
## include	        DI ( CD_OFFSET, VC_NAME, OFS );			--| LE DECALAGE
## include	        DI ( CD_COMP_UNIT, VC_NAME, CPU );		--| L UNITE
## include	        DB ( CD_COMPILED, VC_NAME, TRUE );		--| INDIQUER QUE C EST COMPILE
## include	        INC_OFFSET ( SIZ );			--| AUGMENTER LE DECALAGE
## include	        IF INIT_EXP /= TREE_VOID THEN			--| SI EXPRESSION D INITIALISATION
## call	EXP	INIT_EXP			--| EVALUER CETTE EXPRESSION
## include	        END IF;
## include	        GEN_STORE ( CT, CPU, LVL, OFS,			--| STOCKER SON RESULTAT COMME VALEUR INITIALE
## include	               PRINT_NAME ( D (LX_SYMREP, VC_NAME ) ) & " := VAL INIT" );
## include	      END;
## include	    END COMPILE_VC_NAME_BOOL_CHAR;

## include	  BEGIN
## include	    IF NAME = "BOOLEAN" THEN
## include	      COMPILE_VC_NAME_BOOL_CHAR ( VC_NAME, B, BOOL_SIZE, BOOL_AL );
## include	    ELSIF NAME = "CHARACTER" THEN
## include	      COMPILE_VC_NAME_BOOL_CHAR ( VC_NAME, C, CHAR_SIZE, CHAR_AL );
## include	    ELSE
## include	      COMPILE_VC_NAME_INTEGER ( VC_NAME );
## include	    END IF;
## include	  END COMPILE_VC_NAME_ENUMERATION;
## include	  --|---------------------------------------------------------------------------
## include	  PROCEDURE COMPILE_ACCESS_VAR ( VAR_ID, TYPE_SPEC :TREE ) IS
## include	  BEGIN
## include	    ALIGN ( ADDR_AL );
## include	    DECLARE
## include	      LVL : LEVEL_TYPE    := EMITS.LEVEL;
## include	      OFS : OFFSET_TYPE   := - EMITS.OFFSET_ACT;
## include	      CPU : COMP_UNIT_NBR := EMITS.CUR_COMP_UNIT;
## include	    BEGIN
## include	      DI ( CD_LEVEL, VAR_ID, LVL );
## include	      DI ( CD_OFFSET, VAR_ID, OFS );
## include	      DI ( CD_COMP_UNIT, VAR_ID, CPU );
## include	      DB ( CD_COMPILED, VAR_ID, TRUE );
## include	      INC_OFFSET ( ADDR_SIZE );
## include	      DECLARE
## include	        INIT_EXP : TREE := D ( SM_INIT_EXP, VAR_ID );
## include	      BEGIN
## include	        IF INIT_EXP = TREE_VOID THEN
## include	          EMIT ( LDC, A, -1, "INIT NIL DE " & PRINT_NAME ( D (LX_SYMREP, VAR_ID ) ) );
## include	        ELSE
## include	          LOAD_TYPE_SIZE ( TYPE_SPEC  );
## include	          EMIT ( ALO, LVL - DI ( CD_LEVEL, TYPE_SPEC ) );
## include	        END IF;
## include	      END;
## include	      GEN_STORE ( A, CPU, LVL, OFS,
## include	               "STO " & PRINT_NAME ( D (LX_SYMREP, VAR_ID ) ) & " VAL INIT" );
## include	    END;
## include	  END COMPILE_ACCESS_VAR;
## include	  --|---------------------------------------------------------------------------
## include	  PROCEDURE COMPILE_ARRAY_VAR ( VC_NAME, TYPE_SPEC :TREE ) IS
## include	    DESCR_PTR : OFFSET_TYPE;
## include	  BEGIN
## include	    ALIGN ( ADDR_AL );
## include	    DECLARE
## include	      LVL       : LEVEL_TYPE := EMITS.LEVEL;
## include	      VALUE_PTR : OFFSET_TYPE := - EMITS.OFFSET_ACT;
## include	      CPU       : COMP_UNIT_NBR := EMITS.CUR_COMP_UNIT;
## include	    BEGIN
## include	      DI ( CD_LEVEL, VC_NAME, LVL );
## include	      DI ( CD_OFFSET, VC_NAME, VALUE_PTR );
## include	      DI ( CD_COMP_UNIT, VC_NAME, CPU );
## include	      DB ( CD_COMPILED, VC_NAME, TRUE );
## include	      INC_OFFSET ( ADDR_SIZE );
## include	      ALIGN ( ADDR_AL );
## include	      DESCR_PTR := - EMITS.OFFSET_ACT;
## include	      INC_OFFSET ( ADDR_SIZE );
            
## include	      IF DB ( CD_COMPILED, TYPE_SPEC ) THEN
## include	        GEN_LOAD_ADDR ( DI ( CD_COMP_UNIT, TYPE_SPEC ) , DI ( CD_LEVEL, TYPE_SPEC ), DI ( CD_OFFSET, TYPE_SPEC ) );
## include	        EMIT ( DPL, A, "DUPLICATE " & PRINT_NAME ( D (LX_SYMREP, VC_NAME ) ) & " ARRAY DESCRIPTOR TYPE_SPEC" );
## include	        GEN_STORE ( A, EMITS.CUR_COMP_UNIT, EMITS.LEVEL, DESCR_PTR, "STO ADRESSE DESCRIPTEUR" );
## include	        EMIT ( IND, I, 0, "CHARGE INDEXE TAILLE TABLEAU DE DESCRIPTEUR" );
## include	        EMIT ( ALO, INTEGER ( 0 ), COMMENT=> "ALLOC TABLEAU" );
## include	        GEN_STORE ( A, EMITS.CUR_COMP_UNIT, EMITS.LEVEL, VALUE_PTR, "STO ADRESSE TABLEAU ALLOUE" );
## include	      ELSE
## include	        PUT_LINE ( "!!! COMPILE_ARRAY_VAR : TYPE_SPEC NON COMPILE" );
## include	        RAISE PROGRAM_ERROR;
## include	      END IF;
## include	    END;
## include	  END COMPILE_ARRAY_VAR;
## include	  --|---------------------------------------------------------------------------
## include	  PROCEDURE COMPILE_RECORD_VAR ( VC_NAME, TYPE_SPEC :TREE ) IS
## include	    INIT_EXP : TREE := D ( SM_INIT_EXP, VC_NAME );
## include	  BEGIN
## include	    ALIGN ( RECORD_AL );
## include	    DECLARE
## include	      LVL : LEVEL_TYPE    := EMITS.LEVEL;
## include	      OFS : OFFSET_TYPE   := - EMITS.OFFSET_ACT;
## include	      CPU : COMP_UNIT_NBR := EMITS.CUR_COMP_UNIT;
## include	    BEGIN
## include	      DI ( CD_LEVEL, VC_NAME, LVL );
## include	      DI ( CD_OFFSET, VC_NAME, OFS );
## include	      DI ( CD_COMP_UNIT, VC_NAME, CPU );
## include	      DB ( CD_COMPILED, VC_NAME, TRUE );
         
## include	      IF INIT_EXP.TY = DN_AGGREGATE THEN
## include	        DECLARE
## include	          GENERAL_ASSOC_SEQ : SEQ_TYPE := LIST ( D ( SM_NORMALIZED_COMP_S, INIT_EXP ) );
## include	          COMP_EXP          : TREE;
## include	        BEGIN
## include	          WHILE NOT IS_EMPTY ( GENERAL_ASSOC_SEQ ) LOOP
## include	            POP ( GENERAL_ASSOC_SEQ, COMP_EXP );
                    
## call	EXP	COMP_EXP
-- ## include	            GEN_STORE ( CODE_TYPE_OF ( COMP_EXP ), CPU, LVL, OFS + field_Ofs,
-- ## include	                        "STO " & PRINT_NAME ( D (LX_SYMREP, VC_NAME ) ) & " VAL INIT CHAMP" );

## include	          END LOOP;
## include	        END;
## include	      END IF;
## include	    END;
## include	  END COMPILE_RECORD_VAR;
## include	  --|---------------------------------------------------------------------------
## include	BEGIN
## include	  CASE TYPE_SPEC.TY IS
## include	  WHEN DN_INTEGER =>
## include	    COMPILE_VC_NAME_INTEGER ( VC_NAME );
               
## include	  WHEN DN_ENUMERATION =>
## include	    COMPILE_VC_NAME_ENUMERATION ( VC_NAME, TYPE_SPEC );
               
## include	  WHEN DN_ACCESS =>
## include	    COMPILE_ACCESS_VAR ( VC_NAME, TYPE_SPEC );
               
## include	  WHEN DN_CONSTRAINED_ARRAY =>
## include	    COMPILE_ARRAY_VAR ( VC_NAME, TYPE_SPEC );
         
## include	  WHEN DN_RECORD =>
## include	    COMPILE_RECORD_VAR ( VC_NAME, TYPE_SPEC );
               
## include	  WHEN OTHERS =>
## include	    PUT_LINE ( "!!! CODE_VC_NAME, TYPE_SPEC.TY = " & NODE_NAME'IMAGE ( TYPE_SPEC.TY ) );
## include	    RAISE PROGRAM_ERROR;
## include	  END CASE;
## include	END;
--|.................................................................................................
//  variable_id		=>
//	sm_is_shared	: BOOLEAN;			--| Si pragma shared applique

##  variable_id	====>
##	include	null;
--|.................................................................................................
//  constant_id		=>
//	sm_first	: DEF_NAME;

##  constant_id	====>
##	include	null;



--|-------------------------------------------------------------------------------------------------
-- Syntax 3.2.B
--  number_declaration ::=
--     identifier_list : constant := universal_static_expression;
--|-------------------------------------------------------------------------------------------------

number_declaration	::=
	  identifier  :  number_definition   ;			====> $DEF number_id
	| identifier  ,  number_declaration			====> $DEF number_id
	%%
--|.................................................................................................
number_definition	::=
	CONSTANT  :=  expression			====> $N2 number_decl
	%%
--|.................................................................................................


//  number_decl		=> ;
##  number_decl	====>
##	include	null;
--|.................................................................................................
//  INIT_OBJECT_NAME	::=    number_id;
--|.................................................................................................
//  number_id		=> ;

##  number_id	====>
##	include	null;



--|-------------------------------------------------------------------------------------------------
-- Syntax 3.2.C
--  identifier_list ::= identifier {, identifier}
--**  Unused syntax, since list is built by means of $DEF's
--|-------------------------------------------------------------------------------------------------


//  source_name_s	=>	    as_list : Seq Of SOURCE_NAME;
##  source_name_s	====>
##	repeat_extract	source_name_s	source_name
##	call	source_name	source_name



--|-------------------------------------------------------------------------------------------------
-- 3.3	Types and Subtypes
-- 3.3.1 Type Declarations
-- Syntax 3.3.1.A
--  type_declaration ::= full_type_declaration
--     | incomplete_type_declaration | private_type_declaration
--
--  full_type_declaration ::=
--     type identifier [discriminant_part] is type_definition;
--|-------------------------------------------------------------------------------------------------

type_declaration	::=
	full_type_declaration | incomplete_type_declaration | private_type_declaration
	%%
--|.................................................................................................
full_type_declaration	::=
	TYPE  identifier  [discriminant_part]__IS  type_definition  ;	====> $V3 type_decl $DEF type_id
	%%
--|.................................................................................................


//  type_decl		=>
//	as_dscrmt_decl_s	: dscrmt_decl_s,
//	as_type_def	: TYPE_DEF;

##  type_decl	====>
## include	DECLARE
## include	  TYPE_DEF  : TREE := D ( AS_TYPE_DEF, TYPE_DECL );
## include	  TYPE_ID   : TREE := D ( AS_SOURCE_NAME, TYPE_DECL );
## include	  TYPE_SPEC : TREE := D ( SM_TYPE_SPEC, TYPE_ID );
## include	  ------------------------------------------------------------------------------
## include	  PROCEDURE COMPILE_ENUMERATION_DEF ( ENUMERATION_DEF :TREE ) IS
## include	    ENUM_LITERAL_S  : TREE     := D ( AS_ENUM_LITERAL_S, ENUMERATION_DEF );
## include	    LITERAL_SEQ     : SEQ_TYPE := LIST ( ENUM_LITERAL_S );
## include	    LITERAL         : TREE;
## include	  BEGIN
## include	    WHILE NOT IS_EMPTY ( LITERAL_SEQ ) LOOP		--| TANT QU IL Y A DES ELEMENTS
## include	      POP ( LITERAL_SEQ, LITERAL );			--| EN EXTRAIRE UN
## include	    END LOOP;
## include	    DI ( CD_LAST, ENUM_LITERAL_S, DI ( SM_REP, LITERAL ) );		--| STOCKER LA VALEUR DU DERNIER
## include	  END;
## include	  ------------------------------------------------------------------------------
## include	  PROCEDURE COMPILE_INTEGER_DEF ( INTEGER_DEF, INTEGER_SPEC :TREE ) IS
## include	    LOWER      : OFFSET_TYPE;			--| LIEU DE LA BORNE BASSE
## include	    UPPER      : OFFSET_TYPE;			--| LIEU DE LA BORNE HAUTE
## include	    INT_RANGE  : TREE := D ( AS_CONSTRAINT, INTEGER_DEF );		--| ETENDUE DU TYPE ENTIER
## include	    EXP_BORNE  : TREE;
## include	  BEGIN
## include	    ALIGN ( INTG_AL );			--| ALIGNER LE SOMMET DE PILE POUR UN ENTIER
## include	    LOWER := - EMITS.OFFSET_ACT;			--| LIEU DE LA BORNE BASSE
## include	    INC_OFFSET ( INTG_SIZE );			--| ALLER AU LIEU LIBRE SUIVANT L'ENTIER
## include	    UPPER := - EMITS.OFFSET_ACT;			--| LIEU DE LA BORNE HAUTE
## include	    INC_OFFSET ( INTG_SIZE );			--| ALLER AU LIEU LIBRE SUIVANT L'ENTIER
      
## include	    DI ( CD_OFFSET, INTEGER_SPEC, LOWER );		--| LIEU DES BORNES
## include	    DI ( CD_LEVEL, INTEGER_SPEC, EMITS.LEVEL );		--| NIVEAU STATIQUE DE LA DEFINITION
## include	    DI ( CD_COMP_UNIT, INTEGER_SPEC, CUR_COMP_UNIT );		--| UNITE PARENTE
## include	    DB ( CD_COMPILED, INTEGER_SPEC, TRUE );		--| DEFINITION TRAITEE
## include	    EXP_BORNE := D ( AS_EXP1, INT_RANGE );		--| EXPRESSION BORNE BASSE
## call	EXP	EXP_BORNE			--| GENERER LE CODE DE CALCUL DE L'EXPRESSION DE BORNE BASSE
## include	    GEN_STORE ( I, EMITS.CUR_COMP_UNIT, EMITS.LEVEL, LOWER, "BORNE BASSE" );	--| STOCKER LE RÉSULTAT DANS LA BORNE BASSE
## include	    EXP_BORNE := D ( AS_EXP2, INT_RANGE );		--| EXPRESSION BORNE HAUTE
## call	EXP	EXP_BORNE			--| GENERER LE CODE DE CALCUL DE L'EXPRESSION DE BORNE HAUTE
## include	    GEN_STORE ( I, EMITS.CUR_COMP_UNIT, EMITS.LEVEL, UPPER, "BORNE HAUTE" );	--| STOCKER LE RÉSULTAT DANS LA HAUTE
## include	  END COMPILE_INTEGER_DEF;
## include	  ------------------------------------------------------------------------------
## include	  PROCEDURE COMPILE_CONSTRAINED_ARRAY_DEF ( TYPE_DEF, TYPE_SPEC :TREE ) IS
## include	    DIMENSIONS_NBR     : NATURAL  := 0;
## include	    SUBTYPE_INDICATION : TREE     := D ( AS_SUBTYPE_INDICATION, TYPE_DEF );	--| SOUS TYPE DE L'ELEMENT
## include	    USED_NAME_ID       : TREE     := D ( AS_NAME, SUBTYPE_INDICATION );
## include	    COMP_TYPE_ID       : TREE     := D ( SM_DEFN, USED_NAME_ID );
## include	    COMP_TYPE          : TREE     := D ( SM_TYPE_SPEC, COMP_TYPE_ID );	--| TYPE_SPEC DU TYPE D'ELEMENT
## include	    INDEX_CONSTRAINT   : TREE     := D ( AS_CONSTRAINT, TYPE_DEF );	--| LA CONTRAINTE DE DEFINITION DU TYPE TABLEAU
## include	    DISCRETE_RANGE_S   : TREE     := D ( AS_DISCRETE_RANGE_S, INDEX_CONSTRAINT );
## include	    DISCRETE_RANGE_SEQ : SEQ_TYPE := LIST ( DISCRETE_RANGE_S );	--| LA SEQUENCE DES INDICAGES
         
## include	    --|-------------------------------------------------------------------------
## include	    PROCEDURE INSTALL_ARRAY_DIMENSION ( DISCRETE_RANGE_SEQ :IN OUT SEQ_TYPE ) IS
## include	      IDXFAC, FIRST, LAST : OFFSET_TYPE;
## include	      DISCRETE_RANGE      : TREE;
## include	    BEGIN
## include	      DIMENSIONS_NBR := DIMENSIONS_NBR + 1;		--| UNE DIMENSION DE PLUS
## include	      ALIGN ( INTG_AL );			--| ALIGNER LE LIEU POUR UN ENTIER
## include	      IDXFAC := - EMITS.OFFSET_ACT;			--| LIEU DU FACTEUR DE L'INDICE (POUR PASSER D'UN ÉLÉMENT AU SUIVANT)
## include	      FIRST := IDXFAC - INTG_SIZE;			--| LIEU DE L'INDICE BAS
## include	      LAST := FIRST - INTG_SIZE;			--| LIEU DE L'INDICE HAUT
## include	      INC_OFFSET ( 3*INTG_SIZE );			--| MONTER LE LIEU LIBRE A 3 ENTIERS PLUS LOIN
            
## include	      POP ( DISCRETE_RANGE_SEQ, DISCRETE_RANGE );		--| EXTRAIRE L'INDIÇAGE DE CETTE DIMENSION
## include	      IF IS_EMPTY ( DISCRETE_RANGE_SEQ ) THEN		--| C'ETAIT LE DERNIER INDICAGE (INDICE "RAPIDE")
## include	        EMITS.LOAD_TYPE_SIZE ( COMP_TYPE );		--| EMPILER LA TAILLE DE L'ELEMENT
## include	        EMIT ( DPL, I, "DUPLICATE INDEX FACTOR" );		--| GENERER UNE DUPLICATION DE CETTE TAILLE
## include	        GEN_STORE ( I, 0, EMITS.LEVEL, IDXFAC, "STORE INDEX FACTOR" );	--| LA STOCKER COMME FACTEUR DE PASSAGE D'UN ELEMENT AU SUIVANT POUR CETTE DIMENSION
## include	      ELSE				--| C'EST UN INDICAGE INTERMEDIAIRE
## include	        INSTALL_ARRAY_DIMENSION ( DISCRETE_RANGE_SEQ );		--| TRAITER LA DIMENSION SUIVANTE
## include	        EMIT ( DPL, I, "DUPLICATE INDEX FACTOR" );		--| DUPLIQUER LE FACTEUR DE PASSAGE
## include	        GEN_STORE ( I, 0, EMITS.LEVEL, IDXFAC, "STORE INDEX FACTOR" );	--| LE STOCKER DANS LE DESCRIPTEUR DU TABLEAU
## include	      END IF;
            
## include	      IF DISCRETE_RANGE.TY = DN_DISCRETE_SUBTYPE THEN
## include	        DECLARE
## include	          SUBTYPE_INDICATION : TREE := D ( AS_SUBTYPE_INDICATION, DISCRETE_RANGE );
## include	        BEGIN
## include	          DISCRETE_RANGE := D ( AS_CONSTRAINT, SUBTYPE_INDICATION );
## include	          IF DISCRETE_RANGE.TY = DN_VOID THEN
## include	            DECLARE
## include	              USED_NAME_ID : TREE := D ( AS_NAME, SUBTYPE_INDICATION );
## include	              DEF_NAME     : TREE := D ( SM_DEFN, USED_NAME_ID );
## include	              TYPE_SPEC    : TREE := D ( SM_TYPE_SPEC, DEF_NAME );
## include	            BEGIN
## include	              DISCRETE_RANGE := D ( SM_RANGE, TYPE_SPEC );
## include	            END;
## include	          END IF;
## include	        END;
## include	      END IF;
         
## include	      IF DISCRETE_RANGE.TY = DN_RANGE_ATTRIBUTE THEN		--| CAS DU "SUBTYPE'RANGE"
## include	        DECLARE
## include	          TYPE_SPEC : TREE := D ( SM_TYPE_SPEC, DISCRETE_RANGE );	--| CHERCHER LE TYPE
## include	        BEGIN
## include	          DISCRETE_RANGE := D ( SM_RANGE, TYPE_SPEC );		--| REMPLACER LE DISCRETE RANGE PAR LE RANGE DU TYPE
## include	        END;
## include	      END IF;
            
## include	      IF DISCRETE_RANGE.TY = DN_RANGE THEN
## include	        DECLARE
## include	          EXP_BORNE : TREE := D ( AS_EXP1, DISCRETE_RANGE );
## include	        BEGIN
## call	EXP	EXP_BORNE			--| GENERER LE CODE DE CALCUL DE L'EXPRESSION DE BORNE BASSE
## include	          GEN_STORE ( I, EMITS.CUR_COMP_UNIT, EMITS.LEVEL, FIRST, "FIRST" );	--| LE STOCKER DANS LE DESCRIPTEUR
## include	          EXP_BORNE := D ( AS_EXP2, DISCRETE_RANGE );
## call	EXP	EXP_BORNE			--| GENERER LE CODE DE CALCUL DE L'EXPRESSION DE BORNE HAUTE
## include	          GEN_STORE ( I, EMITS.CUR_COMP_UNIT, EMITS.LEVEL, LAST, "LAST" );
## include	        END;

## include	        GEN_LOAD_ADDR ( 0, LEVEL, FIRST, "LOAD @FIRST" );		--| GENERER L'EMPILAGE DE L'ADRESSE DE LA SECTION DU DESCRIPTEUR POUR LA DIMENSION
## include	        EMIT ( LEN, "CALCULATE LENGTH" );		--| PROCEDURE DE CALCUL DU LENGTH(DIM)
## include	        EMIT ( MUL, I, "NEXT INDEX FACTOR = LEN * PREVIOUS FACTOR" );	--| LAISSER LE FACTEUR DE PASSAGE (LENGHTH*FACTEUR PRECEDENT) SUR LA PILE
## include	      ELSIF DISCRETE_RANGE.TY = DN_RANGE_ATTRIBUTE THEN
## include	        NULL;
## include	      ELSE
## include	        NULL;      -- DN_RANGE_ATTRIBUTE -- DN_DISCRETE_SUBTYPE
## include	        PUT_LINE ( "!!! COMPILE_TYPE_ARRAY_DIMENSION : DISCRETE_RANGE.TY ILLICITE " & NODE_NAME'IMAGE ( DISCRETE_RANGE.TY ) );
## include	        RAISE PROGRAM_ERROR;
## include	      END IF;
## include	    END INSTALL_ARRAY_DIMENSION;
         
## include	  BEGIN
## include	    ALIGN ( INTG_AL );			--| ALIGNER LE LIEU LIBRE POUR UN ENTIER
## include	    DI ( CD_LEVEL, TYPE_SPEC, EMITS.LEVEL );		--| STOCKER LE NIVEAU STATIQUE
## include	    DI ( CD_COMP_UNIT, TYPE_SPEC, EMITS.CUR_COMP_UNIT );		--| STOCKER L'UNITE COURANTE
## include	    DB ( CD_COMPILED, TYPE_SPEC, TRUE );		--| MARQUER COMME TRAITE
## include	    DECLARE
## include	      OFFSET : INTEGER := - EMITS.OFFSET_ACT;
## include	    BEGIN
## include	      DI ( CD_OFFSET, TYPE_SPEC, OFFSET );		--| STOCKER LE LIEU DU NOMBRE DE DIMENSIONS
## include	      INC_OFFSET ( INTG_SIZE );			--| MONTER AU LIEU LIBRE SUIVANT L'ENTIER
## include	      INSTALL_ARRAY_DIMENSION ( DISCRETE_RANGE_SEQ );		--| METTRE EN PLACE LES FACTEURS D'INDEXATION ET LES LIMITES D'INDICE
## include	      GEN_STORE ( I, EMITS.CUR_COMP_UNIT, EMITS.LEVEL, OFFSET,
## include	             "STORE ARRAY SIZE (LAST INDEX FACTOR)" );		--| GENERER LE STOCKAGE EN PILE DU NOMBRE DE DIMENSIONS
## include	      DI ( CD_DIMENSIONS, TYPE_SPEC, DIMENSIONS_NBR );		--| STOCKER AUSSI DANS LE TYPE_SPEC
## include	    END;
## include	  END COMPILE_CONSTRAINED_ARRAY_DEF;
## include	  ------------------------------------------------------------------------------
## include	  PROCEDURE COMPILE_ACCESS_DEF ( ACCESS_DEF, ACCESS_SPEC :TREE ) IS
## include	    POINTED_TYPE_SPEC : TREE    := D ( SM_DESIG_TYPE, ACCESS_SPEC );
## include	    CONTRAINT         : BOOLEAN := (POINTED_TYPE_SPEC.TY IN CLASS_CONSTRAINED);
## include	  BEGIN
## include	    DB ( CD_CONSTRAINED, ACCESS_SPEC, CONTRAINT );
      
## include	    IF CONTRAINT THEN
## include	      DI ( CD_LEVEL, ACCESS_SPEC, EMITS.LEVEL );		--| STOCKER LE NIVEAU STATIQUE DE LA DEFINITION
## include	      ALIGN ( INTG_AL );			--| ALIGNER LE LIEU LIBRE POUR UN ENTIER
## include	      DECLARE
## include	        OFFSET : OFFSET_TYPE := EMITS.OFFSET_ACT;
## include	      BEGIN
## include	        DI ( CD_OFFSET, ACCESS_SPEC, OFFSET );		--| STOCKER LE LIEU
## include	        INC_OFFSET ( INTG_SIZE );			--| MONTER AU LIEU SUIVANT L'ENTIER
## include	        EMITS.LOAD_TYPE_SIZE ( POINTED_TYPE_SPEC );		--| GENERER LE CHARGEMENT DE LA TAILLE DU TYPE POINTE
## include	        GEN_STORE ( I, 0, EMITS.LEVEL, OFFSET, "STORE POINTERD TYPE SIZE" );	--| LA STOCKER DANS LE LIEU RESERVE
## include	      END;
## include	    END IF;
## include	  END;
## include	  ------------------------------------------------------------------------------

## include	BEGIN
## include	  IF EMITS.CUR_COMP_UNIT /= 1 THEN			--| PAS LE STANDARD
## include	    CASE TYPE_DEF.TY IS
            
## include	    WHEN DN_ENUMERATION_DEF =>
## include	      COMPILE_ENUMERATION_DEF ( TYPE_DEF );
                  
## include	    WHEN DN_INTEGER_DEF =>			--| TYPE TRUCIS RANGE 1..10*U;
## include	      COMPILE_INTEGER_DEF ( TYPE_DEF, TYPE_SPEC );
            
## include	    WHEN DN_FLOAT_DEF =>
## include	      NULL;
            
## include	    WHEN DN_FIXED_DEF =>
## include	      NULL;
            
## include	    WHEN DN_CONSTRAINED_ARRAY_DEF =>
## include	      COMPILE_CONSTRAINED_ARRAY_DEF ( TYPE_DEF, TYPE_SPEC );
                  
## include	    WHEN DN_RECORD_DEF =>
## include	      NULL;
            
## include	    WHEN DN_ACCESS_DEF =>
## include	      COMPILE_ACCESS_DEF ( TYPE_DEF, TYPE_SPEC );
                  
## include	    WHEN DN_DERIVED_DEF =>
## include	      NULL;
                  
## include	    WHEN OTHERS =>
## include	      NULL;	-- DN_SUBTYPE_INDICATION -- DN_L_PRIVATE_DEF -- DN_PRIVATE_DEF -- DN_UNCONSTRAINED_ARRAY_DEF
## include                PUT_LINE ( "!!! COMPILE_TYPE_DECL : TYPE_SPEC.TY ILLICITE " & NODE_NAME'IMAGE ( TYPE_SPEC.TY ) );
## include	      RAISE PROGRAM_ERROR;
## include	    END CASE;
## include	  END IF;
## include	END;
--|.................................................................................................
//  TYPE_NAME		::=
//	type_id;
//  TYPE_NAME		=>
//	sm_type_spec	: TYPE_SPEC;

##  TYPE_NAME	====>
##	if	type_id
##	call	type_id	TYPE_NAME
##	if	subtype_id
##	call	subtype_id	TYPE_NAME
##	if	private_type_id
##	call	private_type_id	TYPE_NAME
##	if	l_private_type_id
##	call	l_private_type_id	TYPE_NAME
--|.................................................................................................
//  type_id		=>
//	sm_first	: DEF_NAME;

##  type_id	====>
##	include	null;



--|-------------------------------------------------------------------------------------------------
-- Syntax 3.3.1.B
--  type_definition ::=
--     enumeration_type_definition  | integer_type_definition
--   | real_type_definition	    | array_type_definition
--   | record_type_definition	    | access_type_definition
--   | derived_type_definition
--|-------------------------------------------------------------------------------------------------

type_definition ::=
	  enumeration_type_definition	| integer_type_definition
	| real_type_definition	| array_type_definition
	| record_type_definition	| access_type_definition
	| derived_type_definition
	%%
--|.................................................................................................


//  TYPE_DEF		::=
//	enumeration_def | CONSTRAINED_DEF | ARR_ACC_DER_DEF | record_def;
--|.................................................................................................
//  CONSTRAINED_DEF		::=
//	integer_def | float_def | fixed_def;
--|.................................................................................................
//  ARR_ACC_DER_DEF		::=
//	constrained_array_def | unconstrained_array_def | access_def | derived_def;
//  ARR_ACC_DER_DEF		=>
//	as_subtype_indication	: subtype_indication;
--|.................................................................................................
//  TYPE_SPEC		::=
//	DERIVABLE_SPEC;
--|.................................................................................................
//  DERIVABLE_SPEC		::=
//	FULL_TYPE_SPEC | PRIVATE_SPEC;
//  DERIVABLE_SPEC		=>
//	xd_source_name	: SOURCE_NAME,
//	sm_derived	: TYPE_SPEC,
//	sm_is_anonymous	: BOOLEAN;
--|.................................................................................................
//  FULL_TYPE_SPEC		::=
//	task_spec | NON_TASK;
//  FULL_TYPE_SPEC		=>
//	cd_comp_unit	: Integer,
//	cd_level	: Integer,
//	cd_compiled	: BOOLEAN;
--|.................................................................................................
//  NON_TASK		::=
//	SCALAR | UNCONSTRAINED | CONSTRAINED;
//  NON_TASK		=>
//	sm_base_type	: TYPE_SPEC;
--|.................................................................................................
//  SCALAR		::=
//	enumeration | Integer | REAL;
//  SCALAR		=>
//	sm_range	: RANGE,
//	cd_impl_size	: Integer;
--|.................................................................................................
//  REAL		::=
//	float | fixed;
//  REAL		=>
//	sm_accuracy	: Value;
--|.................................................................................................
//  UNCONSTRAINED		::=
//	UNCONSTRAINED_COMPOSITE | access;
//  UNCONSTRAINED		=>
//	sm_size	: EXP;		-- exp or void
--|.................................................................................................
//  UNCONSTRAINED_COMPOSITE	::=
//	array | record;
//  UNCONSTRAINED_COMPOSITE	=>
//	sm_is_limited	: BOOLEAN,
//	sm_is_packed	: BOOLEAN;
--|.................................................................................................
//  CONSTRAINED		::=
//	constrained_array | constrained_record | constrained_access;
//  CONSTRAINED		=>
//	sm_depends_on_dscrmt	: BOOLEAN,
//	cd_impl_size		: Integer,
//	cd_alignment		: Integer;



--|-------------------------------------------------------------------------------------------------
-- 3.3.2 Subtype Declarations
-- Syntax 3.3.2.A
--  subtype_declaration ::= subtype identifier is subtype_indication;
--|-------------------------------------------------------------------------------------------------

subtype_declaration	::=
	SUBTYPE  subtype_id  IS  subtype_indication  ;		====> $2 subtype_decl
	%%
--|.................................................................................................
subtype_id	::=
	identifier				====> $0 subtype_id lx_symrep
	%%
--|.................................................................................................


//  subtype_decl		=>
//	as_subtype_indication	: subtype_indication;

##  subtype_decl	====>
##	include	null;
--|.................................................................................................
//  TYPE_NAME		::=
//	subtype_id;
--|.................................................................................................
//  subtype_id		=> ;

##  subtype_id	====>
##	include	null;



--|-------------------------------------------------------------------------------------------------
-- Syntax 3.3.2.B
--  subtype_indication ::= type_mark [constraint]
--
--  type_mark ::= type_name | subtype_name
--|-------------------------------------------------------------------------------------------------

subtype_indication	::=
	type_mark  [constraint]			====> exch_1 $2 subtype_indication
	%%
--|.................................................................................................
type_mark	::=
	expanded_name
	%%
--|.................................................................................................
expanded_name	::=
	  used_id
 	| expanded_name . used_id			====> $2 selected
	%%
--|.................................................................................................


--|.................................................................................................
//  CONSTRAINED_DEF		=>
//	as_constraint	: CONSTRAINT;
--|.................................................................................................
//  subtype_indication	=>
//	as_name	: NAME;


--|-------------------------------------------------------------------------------------------------
-- Syntax 3.3.2.C
--  constraint	::=
--	  range_constraint | floating_point_constraint | fixed_point_constraint
--	| index_constraint | discriminant_constraint
--|-------------------------------------------------------------------------------------------------

constraint	::=
	  range_constraint	|  floating_point_constraint  |  fixed_point_constraint
	| index_constraint__|__discriminant_constraint
	%%
--|.................................................................................................


//  CONSTRAINT		::=
//	DISCRETE_RANGE | REAL_CONSTRAINT | index_constraint | dscrmt_constraint;



--|-------------------------------------------------------------------------------------------------
-- 3.4	Derived Type Definitions
-- Syntax 3.4
--  derived_type_definition ::= new subtype_indication
--|-------------------------------------------------------------------------------------------------

derived_type_definition	::=
	NEW  subtype_indication			====> $1 derived_def
	%%
--|.................................................................................................


//  derived_def	=>	   	xd_derived_subprog_list: Seq Of SUBPROG_NAME;



--|-------------------------------------------------------------------------------------------------
-- 3.5	Scalar Types
-- Syntax 3.5
--  range_constraint ::= range range
--  range	::= range_attribute
--	| simple_expression .. simple_expression
--|-------------------------------------------------------------------------------------------------

range_constraint	::=
	RANGE range
	%%
--|.................................................................................................
range	::=
	  name
 	| simple_expression .. simple_expression		====> $2 range
	%%
--|.................................................................................................


//  DISCRETE_RANGE		::=
//	RANGE | discrete_subtype;
//  RANGE		::=
//	range | range_attribute;
//  RANGE		=>
//	sm_type_spec : TYPE_SPEC;
//  range		=>
//	as_exp1	: EXP,
//	as_exp2	: EXP;
//  range_attribute		=>
//	as_name	: NAME,
//	as_used_name_id	: used_name_id,
//	as_exp	: EXP;			-- EXP or void



--|-------------------------------------------------------------------------------------------------
-- 3.5.1  Enumeration Types
-- Syntax 3.5.1.A
--  enumeration_type_definition ::=
--    (enumeration_literal_specification {, enumeration_literal_specification})
--|-------------------------------------------------------------------------------------------------

enumeration_type_definition ::=
	(  enumeration_literal{,enumeration_literal}  )		 ====> $L enum_literal_s $1 enumeration_def
	%%
--|.................................................................................................


//  enumeration_def		=>
//	as_enum_literal_s	: enum_literal_s;
--|.................................................................................................
//  enum_literal_s		=>
//	as_list	: Seq Of ENUM_LITERAL,
//	cd_alignment	: Integer,
//	cd_impl_size	: Integer,
//	cd_last	: Integer;
--|.................................................................................................
//  enumeration		=>
//	sm_literal_s	: enum_literal_s;



--|-------------------------------------------------------------------------------------------------
-- Syntax 3.5.1.B
--  enumeration_literal_specification ::= enumeration_literal
--
--  enumeration_literal ::= identifier | character_literal
--|-------------------------------------------------------------------------------------------------

enumeration_literal	::=
	identifier				====> $0 enumeration_id lx_symrep
	| character_literal 			====> $0 character_id lx_symrep
	%%
--|.................................................................................................


//  OBJECT_NAME		::=
//	ENUM_LITERAL;
--|.................................................................................................
//  ENUM_LITERAL		::=
//	enumeration_id | character_id;
//  ENUM_LITERAL		=>
//	sm_pos	: Integer,
//	sm_rep	: Integer;

##  ENUM_LITERAL	====>
##	if	enumeration_id
##	call	enumeration_id	ENUM_LITERAL
##	if	character_id
##	call	character_id	ENUM_LITERAL
--|.................................................................................................
//  enumeration_id	=> ;

##  enumeration_id	====>
##	include	null;
--|.................................................................................................
//  character_id	=> ;

##  character_id	====>
##	include	null;



--|-------------------------------------------------------------------------------------------------
-- 3.5.4  Integer Types
-- Syntax 3.5.4
--  integer_type_definition ::= range_constraint
--|-------------------------------------------------------------------------------------------------

integer_type_definition	::=
	range_constraint				====> $1 integer_def
	%%
--|.................................................................................................


//  integer_def	=> ;
--|.................................................................................................
//  Integer	=>
//	cd_offset	: Integer,
//	cd_impl_size	: Integer;



--|-------------------------------------------------------------------------------------------------
-- 3.5.6  Real Types
-- Syntax 3.5.6
--  real_type_definition ::=
--     floating_point_constraint | fixed_point_constraint
--|-------------------------------------------------------------------------------------------------

real_type_definition	::=
	  floating_point_constraint			====> $1 float_def
	| fixed_point_constraint			====> $1 fixed_def
	%%
--|.................................................................................................


//  REAL_CONSTRAINT ::=     float_constraint
//			  | fixed_constraint;
//  REAL_CONSTRAINT	=>	    sm_type_spec : TYPE_SPEC;



--|-------------------------------------------------------------------------------------------------
-- 3.5.7  Floating Point Types
-- Syntax 3.5.7
--  floating_point_constraint ::=
--     floating_accuracy_definition [range_constraint]
--
--  floating_accuracy_definition ::= digits static_simple_expression
--|-------------------------------------------------------------------------------------------------

floating_point_constraint	::=
	DIGITS  simple_expression  [range_constraint]		====> $2 float_constraint
	%%
--|.................................................................................................


//  float_def		=> ;
--|.................................................................................................
//  REAL_CONSTRAINT		=>
//	as_exp	: EXP,
//	as_range	: RANGE;
--|.................................................................................................
//  float_constraint	=> ;
--|.................................................................................................
//  float		=>
//	cd_impl_size	: Integer ;



--|-------------------------------------------------------------------------------------------------
-- 3.5.9  Fixed Point Types
-- Syntax 3.5.9
--  fixed_point_constraint  ::=
--     fixed_accuracy_definition [range_constraint]
--
--  fixed_accuracy_definition ::= delta static_simple_expression
--|-------------------------------------------------------------------------------------------------

fixed_point_constraint	::=
	DELTA  simple_expression  [range_constraint]		====> $2 fixed_constraint
	%%
--|.................................................................................................


//  fixed_def	=> ;
--|.................................................................................................
//  fixed_constraint	=> ;
--|.................................................................................................
//  fixed		=>
//	cd_impl_small	: Value,
//	cd_impl_size	: Integer;



--|-------------------------------------------------------------------------------------------------
-- 3.6	Array Types
-- Syntax 3.6.A
--  array_type_definition ::=
--     unconstrained_array_definition | constrained_array_definition
--
--  unconstrained_array_definition ::=
--     array(index_subtype_definition {, index_subtype_definition}) of
--		    component_subtype_indication
--
--  constrained_array_definition ::=
--     array index_constraint of component_subtype_indication
--|-------------------------------------------------------------------------------------------------

array_type_definition	::=
	unconstrained_array_definition | constrained_array_definition
	%%
--|.................................................................................................

unconstrained_array_definition	::=
	ARRAY  (index_subtype_definition{,index_subtype_definition})  OF
				subtype_indication	====> exch_1 $2 unconstrained_array_def
	%%
--|.................................................................................................
(index_subtype_definition{,index_subtype_definition})	::=
	(  index_subtype_definition{,index_subtype_definition}  )		====> $L index_s
	%%
--|.................................................................................................
constrained_array_definition	::=
	ARRAY  index_constraint  OF  subtype_indication		====> exch_1 $2 constrained_array_def
	%%
--|.................................................................................................


//  constrained_array_def	=>
//	as_constraint	: CONSTRAINT;
--|.................................................................................................
//  index_constraint	=>
//	as_discrete_range_s	: discrete_range_s;
--|.................................................................................................
//  discrete_range_s	=>
//	as_list	: Seq Of DISCRETE_RANGE;
--|.................................................................................................
//  unconstrained_array_def	=>
//	as_index_s	: index_s;
--|.................................................................................................
//  scalar_s		=>
//	as_list	: Seq Of SCALAR;
--|.................................................................................................
//  array		=>
//	sm_index_s	: index_s,
//	sm_comp_type	: TYPE_SPEC;
--|.................................................................................................
//  constrained_array	=>
//	sm_index_subtype_s	: scalar_s,
//	cd_offset	: Integer,
//	cd_dimensions	: Integer;



--|-------------------------------------------------------------------------------------------------
-- Syntax 3.6.B
--  index_subtype_definition ::= type_mark range <>
--|-------------------------------------------------------------------------------------------------

index_subtype_definition	::=
	type_mark__RANGE__<>
	%%
--|.................................................................................................

--** name instead of type_mark to avoid LALR conflict

type_mark__RANGE__<>	::=
	name  RANGE  <>				====> $1 index
	%%
--|.................................................................................................


//  index		=>
//	as_name	: NAME,
//	sm_type_spec	: TYPE_SPEC;
--|.................................................................................................
//  index_s		=>
//	as_list	: Seq Of index;



--|-------------------------------------------------------------------------------------------------
-- Syntax 3.6.C
--  index_constraint ::= (discrete_range {, discrete_range})
--
--  discrete_range ::= discrete_subtype_indication | range
--|-------------------------------------------------------------------------------------------------

index_constraint	::=
	(  discrete_range{,discrete_range}  )			====> $L discrete_range_s $1 index_constraint
	%%
--|.................................................................................................

--** This definition of index_constraint used only in constrained array
--** definitions.  In subtype indications, the wider class,
--** index_constraint__|__discriminant_constraint is used

discrete_range	::=
	  range
	| name  range_constraint			====> exch_1 $2 subtype_indication $1 discrete_subtype
	%%
--|.................................................................................................
--** The name must be an expanded_name

//  discrete_subtype	=>
//	as_subtype_indication	: subtype_indication;



--|-------------------------------------------------------------------------------------------------
-- 3.7	Record Types
-- Syntax 3.7.A
--  record_type_definition ::=
--     record
--	    component_list
--     end record
--|-------------------------------------------------------------------------------------------------

record_type_definition ::=
     RECORD  component_list  END  RECORD	====> $1 record_def
	%%
--|.................................................................................................


--|.................................................................................................
//  record_def		=>
//	as_comp_list	: comp_list;
--|.................................................................................................
//  record		=>
//	sm_discriminant_s	: dscrmt_decl_s,
//	sm_comp_list	: comp_list,
//	sm_representation	: REP;			-- REP or void
//	cd_impl_size		: Integer,
//	cd_alignment		: Integer;
--|.................................................................................................
//  constrained_record	=>
//	sm_normalized_dscrmt_s	: exp_s;



--|-------------------------------------------------------------------------------------------------
-- Syntax 3.7.B
--  component_list ::=
--	 component_declaration {component_declaration}
--     | {component_declaration} variant_part
--     | null;
--
--  component_declaration ::=
--     identifier_list : component_subtype_definition [:= expression];
--
--  component_subtype_definition ::= subtype_indication
--|-------------------------------------------------------------------------------------------------

component_list	::=
	  component_decl_s				====> void nil $L pragma_s $3 comp_list
	| component_decl_s	variant_part  {pragma}		====> $L pragma_s $3 comp_list
	| empty_component_decl_s  variant_part  {pragma}		====> $L pragma_s $3 comp_list
	| {pragma} null_comp {pragma}			====> insert cat $L decl_s void nil $L pragma_s $3 comp_list
	%%
--|.................................................................................................
component_decl_s	::=
	{pragma} component_declaration {pragma}{component_declaration{pragma}}	====> insert cat $L decl_s
	%%
--|.................................................................................................
empty_component_decl_s	::=			====> nil $L decl_s
	%%
--|.................................................................................................
component_declaration	::=
	  identifier  :  component_definition ;			====> $DEF component_id
	| identifier  ,  component_declaration			====> $DEF component_id
	%%
--|.................................................................................................
component_definition	::=
	subtype_indication  [:=expression]			====> exch_1 $N3 variable_decl
	%%
--|.................................................................................................
null_comp	::=
	NULL ;				====> $0 null_comp_decl
	%%
--|.................................................................................................


//  DECL		::=
//	null_comp_decl;
--|.................................................................................................
//  null_comp_decl		=> ;
//		    -- (missing from Intermetrics definition)
--|.................................................................................................
//  INIT_OBJECT_NAME	::=
//	COMP_NAME;
--|.................................................................................................
//  COMP_NAME	::=
//	component_id | discriminant_id;
//  COMP_NAME	=>
//	sm_comp_rep	: COMP_REP_ELEM;

##  COMP_NAME	====>
##	if	component_id
##	call	component_id	COMP_NAME
##	if	discriminant_id
##	call	discriminant_id	COMP_NAME
--|.................................................................................................
//  component_id		=> ;

##  component_id	====>
##	include	null;



--|-------------------------------------------------------------------------------------------------
-- 3.7.1  Discriminants
-- Syntax 3.7.1
--  discriminant_part ::=
--     (discriminant_specification {; discriminant_specification})
--
--  discriminant_specification ::=
--     identifier_list : type_mark [:= expression]
--|-------------------------------------------------------------------------------------------------

discriminant_part	::=
	(  discriminant_specification{;discriminant_specification}  )	====> $L dscrmt_decl_s
	%%
--|.................................................................................................
[discriminant_part] ::=
	  empty				====> nil $L dscrmt_decl_s
	| discriminant_part
	%%
--|.................................................................................................
discriminant_specification	::=
	  identifier  :  discriminant_definition		====> $DEF discriminant_id
	| identifier  ,  discriminant_specification		====> $DEF discriminant_id
	%%
--|.................................................................................................
discriminant_definition	::=
	type_mark [:=expression]			====> $N3 dscrmt_decl
	%%
--|.................................................................................................


//  ITEM		::=
//	DSCRMT_PARAM_DECL;
--|.................................................................................................
//  DSCRMT_PARAM_DECL	::=
//	dscrmt_decl;
//  DSCRMT_PARAM_DECL	=>
//	as_source_name_s	: source_name_s,
//	as_name	: NAME,
//	as_exp	: EXP;
--|.................................................................................................
//  dscrmt_decl_s		=>
//	as_list	: Seq Of dscrmt_decl;
//  dscrmt_decl		=> ;
--|.................................................................................................
//  discriminant_id		=>
//	sm_first	: DEF_NAME;

##  discriminant_id	====>
##	include	null;



--|-------------------------------------------------------------------------------------------------
-- 3.7.2  Discriminant Constraints
-- Syntax 3.7.2
--  discriminant_constraint ::=
--     (discriminant_association {, discriminant_association})
--  discriminant_association ::=
--     [discriminant_simple_name {|discriminant_simple_name}	=>] expression
--
--|-------------------------------------------------------------------------------------------------

index_constraint__|__discriminant_constraint	::=
	  (  discriminant_association{,discriminant_association}  )		====> $L general_assoc_s
	| (  discriminant_association{,discriminant_association}  others_association  )	====> append $L general_assoc_s
	| (  others_association  )			====> list $L general_assoc_s
	%%
--|.................................................................................................
discriminant_association	::=
	  expression
	| simple_expression .. simple_expression		====> $2 range
	| name range_constraint			====> exch_1 $2 subtype_indication
	| discriminant_choice_s  =>  expression			====> exch_1 $2 named
	%%
--** discriminant association includes discrete_range (for index constraint)
--|.................................................................................................
discriminant_choice_s	::=
	discriminant_choice{|discriminant_choice}		====> $L choice_s
	%%
--|.................................................................................................

discriminant_choice	::=
	used_name_id				====> $1 choice_exp
	%%
--|.................................................................................................


//  dscrmt_constraint	=>
//	as_general_assoc_s	: general_assoc_s;



--|-------------------------------------------------------------------------------------------------
-- 3.7.3  Variant Parts
-- Syntax 3.7.3.A
--  variant_part ::=
--     case discriminant_simple_name is
--	   variant
--	  {variant}
--     end case;
--
--  variant  ::=
--     when choice {| choice}	=>
--	   component_list
--|-------------------------------------------------------------------------------------------------

variant_pragma	::=
	pragma				====> $1 variant_pragma
	%%
--|.................................................................................................
variant_part	::=
	CASE  used_id  IS  variant_s  END  CASE  ;		====> $2 variant_part
	%%
--|.................................................................................................
variant_s	::=
	 {variant_pragma}  {variant}  variant			====> append cat $L variant_s
	| {variant_pragma}  {variant}  others_variant		====> append cat $L variant_s
	%%
--|.................................................................................................
--** pragma's between variants picked up in component lists

variant	::=
	WHEN  choice_s  =>  component_list			====> $2 variant
	%%
--|.................................................................................................

choice_s	::=
	choice{|choice}				====> $L choice_s
	%%
--|.................................................................................................


//  VARIANT_PART		::=
//	variant_part;
--|.................................................................................................
//  variant_part		=>
//	as_name	: NAME,
//	as_variant_s	: variant_s;
--|.................................................................................................
//  variant_s		=>
//	as_list	: Seq Of VARIANT_ELEM;
--|.................................................................................................
//  VARIANT_ELEM	::=
//	variant | variant_pragma;
--|.................................................................................................
//  variant		=>
//	as_choice_s	: choice_s,
//	as_comp_list	: comp_list;
--|.................................................................................................
//  choice_s		=>
//	as_list	: Seq Of CHOICE,
//	cd_label	: Integer;

##  choice_s	====>
##	repeat_extract	choice_s	choice
##	call	CHOICE	choice
##	include	IF NOT CHOICE_OTHERS_FLAG THEN
##	include	   EMIT ( JMPT, LABEL_TYPE ( DI ( CD_LABEL, CHOICE_S ) ), COMMENT=> "TRAITE EXCEPTION" );
##	include	END IF;

--|.................................................................................................
//  comp_list		=>
//	as_decl_s	: decl_s,
//	as_variant_part	: VARIANT_PART,
//	as_pragma_s	: pragma_s;
--|.................................................................................................
//  variant_pragma	=>	    as_pragma : pragma;



--|-------------------------------------------------------------------------------------------------
-- Syntax 3.7.3.B
--  choice ::= simple_expression
--     | discrete_range | others | component_simple_name
--
--|-------------------------------------------------------------------------------------------------

choice	::=
	  simple_expression				====> $1 choice_exp
	| simple_expression  ..  simple_expression		====> $2 range $1 choice_range
	| name  range_constraint			====> exch_1 $2 subtype_indication $1 discrete_subtype $1 choice_range
	%%
--** The name must be an expanded_name
--|.................................................................................................

others_variant	::=
	WHEN  others_s  =>  component_list			====> $2 variant
	%%
--|.................................................................................................
others_s	::=
	OTHERS				====> $0 choice_others list $L choice_s
	%%
--|.................................................................................................


//  CHOICE		::=
//	choice_exp | choice_range | choice_others;

##  CHOICE	====>
##	if	choice_exp
##	call	choice_exp	CHOICE
##	if	choice_range
##	call	choice_range	CHOICE
##	if	choice_others
##	call	choice_others	CHOICE
--|.................................................................................................
//  choice_exp		=>
//	as_exp	: EXP;
--	lx_srcpos	:Source_Position

##  choice_exp	====>
##	call	EXP	@ as_EXP	choice_exp
--|.................................................................................................
//  choice_range		=>
//	as_discrete_range	: DISCRETE_RANGE;
--	lx_srcpos	:Source_Position

##  choice_range	====>
##	include	null;
--|.................................................................................................
//  choice_others		=> ;
--	lx_srcpos	:Source_Position

##  choice_others	====>
##	include	choice_Others_Flag := true;



--|-------------------------------------------------------------------------------------------------
-- 3.8	Access Types
-- Syntax 3.8
--  access_type_definition ::= access subtype_indication
--
--|-------------------------------------------------------------------------------------------------

access_type_definition	::=
	ACCESS  subtype_indication			====> $1 access_def
	%%
--|.................................................................................................


//  access_def	=> ;
--|.................................................................................................
//  access		=>
//	sm_storage_size	: EXP,			-- EXP or void
//	sm_is_controlled	: BOOLEAN,
//	sm_desig_type	: TYPE_SPEC,
//	sm_master	: ALL_DECL,
//	cd_offset	: Integer,
//	cd_constrained	: BOOLEAN;
--|.................................................................................................
//  constrained_access	=>
//	sm_desig_type	: TYPE_SPEC;



--|-------------------------------------------------------------------------------------------------
-- 3.8.1 Incomplete Type Declarations
-- Syntax 3.8.1
--  incomplete_type_declaration ::= type identifier [discriminant_part];
--
--|-------------------------------------------------------------------------------------------------

incomplete_type_declaration	::=
	TYPE  identifier  [discriminant_part]  ;		====> void $V3 type_decl $DEF type_id
	%%
--|.................................................................................................

--|.................................................................................................
//  TYPE_SPEC ::=	    incomplete;
--|.................................................................................................
//  incomplete		=>
//	sm_discriminant_s	: dscrmt_decl_s,
//	xd_source_name	: SOURCE_NAME,
//	xd_full_type_spec	: TYPE_SPEC;
--|.................................................................................................



--|-------------------------------------------------------------------------------------------------
-- 3.9	Declarative Parts
-- Syntax 3.9.A
--  declarative_part ::=
--     {basic_declarative_item} {later_declarative_item}
--
--  basic_declarative_item ::= basic_declaration
--     | representation_clause | use_clause
--

--** Following Fisher & Charles, a body is the only later_declarative_item
--** which is not also a basic declarative item; it is used as the boundary.
--|-------------------------------------------------------------------------------------------------

declarative_part	::=
	  {pragma}  {basic_declarative_item{pragma}}		====> cat $L item_s
	| {pragma}  {basic_declarative_item{pragma}}
		body  {pragma}  {later_declarative_item{pragma}}	====> cat insert cat cat $L item_s
	%%
--|.................................................................................................
basic_declarative_item	::=
	basic_declaration | representation_clause | use_clause
	%%
--|.................................................................................................


//  DECL		::=
//	REP | USE_PRAGMA;
--|.................................................................................................
//  USE_PRAGMA	::=
//	use | pragma;



--|-------------------------------------------------------------------------------------------------
-- Syntax 3.9.B
--  later_declarative_item ::= body
--     | subprogram_declaration | package_declaration
--     | task_declaration	| generic_declaration
--     | use_clause		| generic_instantiation
--
--  body  ::=  proper_body | body_stub
--
--  proper_body ::= subprogram_body | package_body | task_body
--|-------------------------------------------------------------------------------------------------

later_declarative_item ::= body
     | subprogram_declaration | package_declaration
     | task_declaration       | generic_declaration
     | use_clause	 | generic_instantiation
	%%
--|.................................................................................................

body ::= proper_body | body_stub
	%%
--|.................................................................................................

proper_body ::= subprogram_body | package_body | task_body
	%%
--|.................................................................................................


//  ITEM		::=
//	DECL | SUBUNIT_BODY;

##  ITEM	====>				--| Action sur ITEM
##	if_class	DECL			--| Si dans classe DECL
##	call	DECL	ITEM		--| Appliquer l'action DECL au paramètre ITEM
##	if_class	SUBUNIT_BODY			--| Si dans classe SUBUNIT_BODY
##	call	SUBUNIT_BODY	ITEM		--| Appliquer l'action subunit_body au paramètre ITEM
--|.................................................................................................
//  item_s		=>
//	as_list	: Seq Of ITEM;

##  item_s	====>
##	repeat_extract	item_s	item
##	call	ITEM	item
--|.................................................................................................
//  UNIT_DECL		::=	    generic_decl | NON_GENERIC_DECL;
//  UNIT_DECL		=>
//	as_header	: HEADER;

## UNIT_DECL	====>				--| Action sur DECL
##	if	generic_decl			--| Si generic_decl
##	call	generic_decl	UNIT_DECL		--| Appliquer l'action generic_decl au paramètre DECL
##	if_class	NON_GENERIC_DECL			--| Si dans classe NON_GENERIC_DECL
##	call	NON_GENERIC_DECL	UNIT_DECL		--| Appliquer l'action NON_GENERIC_DECL au paramètre DECL
--|.................................................................................................
//  NON_GENERIC_DECL	::=
//	subprog_entry_decl | package_decl;
//  NON_GENERIC_DECL	=>
//	as_unit_kind	: UNIT_KIND;

##  NON_GENERIC_DECL	====>			--| Action sur NON_GENERIC_DECL
##	if	subprog_entry_decl			--| Si subprog_entry_decl
##	call	subprog_entry_decl	NON_GENERIC_DECL		--| Appliquer l'action subprog_entry_decl sur le paramètre NON_GENERIC_DECL
##	if	package_decl			--| Si package_decl
##	call	package_decl	NON_GENERIC_DECL		--| Appliquer l'action package_decl sur le paramètre NON_GENERIC_DECL



--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-- 4.  Names and Expressions
--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-- 4.1	Names

-- Syntax 4.1.A
--  name ::= simple_name
--     | character_literal    | operator_symbol
--     | indexed_component    | slice
--     | selected_component   | attribute
--
--  simple_name ::= identifier
--|-------------------------------------------------------------------------------------------------

name	::=
	  selected_component	|  attribute
	| used_id	| used_char	| used_string
	| indexed_component__|__slice
	%%
--|.................................................................................................
used_id	::=
	identifier				====> $0 used_object_id lx_symrep
	%%
--|.................................................................................................
used_char	::=
	character_literal				====> $0 used_char lx_symrep
	%%
--|.................................................................................................
used_string	::=
	string_literal				====> $0 string_literal lx_symrep
	%%
--|.................................................................................................


//  NAME		::=
//	DESIGNATOR | NAME_EXP;

##  NAME	====>
##	if_class	DESIGNATOR
##	call	DESIGNATOR	NAME
##	if_class	NAME_EXP
##	call	NAME_EXP	NAME
--|.................................................................................................
//  NAME_EXP		::=
//	NAME_VAL | indexed | slice | all;
//  NAME_EXP		=>
//	as_name	: NAME,
//	sm_exp_type	: TYPE_SPEC;

##  NAME_EXP	====>
##	if	indexed
##	call	indexed	NAME_EXP
##	if	slice
##	call	slice	NAME_EXP
##	if	all
##	call	all	NAME_EXP
--|.................................................................................................
//  NAME_VAL		::=
//	attribute | selected;
//  NAME_VAL		=>
//	sm_value	: Value;
--|.................................................................................................
//  DESIGNATOR		::=
//	USED_OBJECT | USED_NAME;
//  DESIGNATOR		=>
//	sm_defn	: DEF_NAME,
//	lx_symrep	: symbol_rep;

##  DESIGNATOR	====>
##	if_class	USED_OBJECT
##	call	USED_OBJECT	DESIGNATOR
##	if_class	USED_NAME
##	call	USED_NAME	DESIGNATOR
--|.................................................................................................
//  USED_NAME		::=
//	used_op | used_name_id;
##  USED_NAME	====>
##	if	used_op
##	call	used_op	USED_NAME
##	if	used_name_id
##	call	used_name_id	USED_NAME
--|.................................................................................................
//  used_op		=> ;

##  used_op	====>
##	include	null;
--|.................................................................................................
//  used_name_id		=> ;

##  used_name_id	====>
##  include	DECLARE
##  include	  DEFN   : TREE := D ( SM_DEFN, USED_NAME_ID );		--| RAMENER LA DEFINITION ASSOCIEE AU NOM UTILISE
##  include	  SYMREP : TREE := D ( LX_SYMREP, USED_NAME_ID );		--| RAMENER AUSSI SA REPRESENTATION
##  include	BEGIN

##  include	  IF DEFN.TY = DN_EXCEPTION_ID THEN			--| ON A NOMME UNE EXCEPTION
##  include	    DECLARE
##  include	      LABEL : TREE := D ( CD_LABEL, DEFN );		--| RAMENER LE CHAMP CD_LABEL DE L EXCEPTION
##  include	      LBL : LABEL_TYPE;
##  include	    BEGIN
##  include	      IF LABEL.TY /= DN_NUM_VAL THEN			--| AUCUN RAISE N A ETE VU PUR CETTE EXCEPTION RIEN DANS LE CHAMP CD_LABEL
##  include	        LBL := NEXT_LABEL;			--| DONC ALLOUER UNE ETIQUETTE
##  include	        DI ( CD_LABEL, DEFN, INTEGER ( LBL ) );		--| METTRE CE NUMERO D ETIQUETTE DANS LE CD_LABEL POUR REPERER L EXCEPTION
##  include	        EMIT ( EXL, LBL, S=> PRINT_NAME ( SYMREP ),		--| DECLARER CETTE ASSOCIATION
##  include		COMMENT=> "NUM D EXCEPTION EXTERNE ATTRIBUE SUR USED_NAME_ID" );
##  include	      END IF;
##  include	      EMIT ( DPL, I, COMMENT=> "CODE D EXCEPTION EMPILE" );		--| EMPILAGE DUPLICATA DU CODE ENTIER D EXCEPTION
##  include	      EMIT ( LDC, I, DI ( CD_LABEL, DEFN ), COMMENT=> "EXCEPTION " & PRINT_NAME ( SYMREP ));
##  include	      EMIT ( EQ, I );			--| 
##  include	    END;

##  include	  ELSIF DEFN.TY = DN_PACKAGE_ID THEN
##  include	    IF NOT DB ( CD_COMPILED, DEFN ) THEN		--| REFERENCE A UN PACKAGE NON COMPILE (SPEC)
##  include	      DECLARE
##  include	        PACKAGE_SPEC : TREE := D ( SM_SPEC, DEFN );		--| UN HEADER (PACKAGE SPEC)
##  include	      BEGIN
##  include	        EMIT ( RFP, EMITS.CUR_COMP_UNIT, s=> PRINT_NAME ( SYMREP ) );	--| EMETTRE UNE REFERENCE A PACKAGE
##  include	        EMITS.GENERATE_CODE := FALSE;			--| PAS DE CODE GENERE (SEULEMENT FAIRE LES OPERATIONS ETIQUETAGE PLACEMENT ETC. )
##  include	        DB ( CD_COMPILED, DEFN, TRUE );			--| INDIQUER DES A PRESENT QUE L ON A COMPILE CE PACKAGE WITHE POUR NE FAIRE CELA QU UNE SEULE FOIS

##  call	decl_s	@ as_DECL_S1 package_Spec		--| TRAITER LES DECLARATIONS DE CE PACKAGE

##  include	      END;
##  include	    END IF;
##  include	    EMITS.CUR_COMP_UNIT := CUR_COMP_UNIT + 1;		--| NUMERO D UNITE SUIVANT

##  include	  ELSIF DEFN.TY = DN_PROCEDURE_ID THEN			--| REFERENCE A UNE PROCEDURE DE LIBRAIRIE
##  include	    IF NOT DB ( CD_COMPILED, DEFN ) THEN		--| SI PAS COMPILEE
##  include	      DECLARE
##  include	        PROC_LBL : LABEL_TYPE := NEXT_LABEL;		--| ALLOCATION ETIQUETTE D ENTREE DE LA PROCEDURE REFERENCEE
##  include	      BEGIN
##  include	        EMITS.GENERATE_CODE := TRUE;			--| IL FAUT GENERER LA REFERENCE
##  include	        EMIT ( RFP, INTEGER( 0 ), s=> PRINT_NAME ( SYMREP ) );	--| REFERENCE A PROCEDURE DE LIBRAIRIE
##  include	        DI ( CD_LABEL, DEFN, INTEGER ( PROC_LBL ) );		--| STOCKER L ETIQUETTE
##  include	        DI ( CD_LEVEL, DEFN, 1 );			--| STOCKER LE NIVEAU DE LA PROCEDURE REFERENCEE (1)
##  include	        DI ( CD_PARAM_SIZE, DEFN, 0 );			--| INITIALISER LA TAILLE DU PARAMETRAGE A ZERO )
##  include	        DB ( CD_COMPILED, DEFN, TRUE );			--| INDIQUER QUE L'ON A DEJA TRAITE
##  include	        EMIT ( RFL, PROC_LBL );			--| EMETTRE L ETIQUETTE
##  include	      END;
##  include	    END IF;

##  include	  END IF;
##  include	END;
--|.................................................................................................
//  USED_OBJECT		::=
//	used_char | used_object_id;
//  USED_OBJECT		=>
//	sm_exp_type	: TYPE_SPEC,
//	sm_value	: Value;

##  USED_OBJECT	====>
##	if	used_char
##	call	used_char	USED_OBJECT
##	if	used_object_id
##	call	used_object_id	USED_OBJECT
--|.................................................................................................
//  used_char	=> ;

##  used_char	====>
##	include	null;
--|.................................................................................................
//  used_object_id	=> ;

##  used_object_id	====>
##  include	    NULL;



--|-------------------------------------------------------------------------------------------------
-- Syntax 4.1.B
--  prefix ::= name | function_call
--|-------------------------------------------------------------------------------------------------

prefix	::=
	name
	%%
--|.................................................................................................
--** name includes function_call

//  NAME_VAL		::=
//	function_call;



--|-------------------------------------------------------------------------------------------------
-- 4.1.1  Indexed Components
-- Syntax 4.1.1
--  indexed_component ::= prefix(expression {, expression})
--
--|-------------------------------------------------------------------------------------------------

indexed_component__|__slice	::=
	apply
	%%
--|.................................................................................................


//  exp_s		=>
//	as_list	: Seq Of EXP;
--|.................................................................................................
//  indexed		=>
//	as_exp_s	: exp_s;

##  INDEXED	====>
##  include	DECLARE
##  include	  PROCEDURE INDEX ( EXP_SEQ :SEQ_TYPE ) IS
##  include	    EXP_S : SEQ_TYPE := EXP_SEQ;
##  include	    EXP   : TREE;
##  include	  BEGIN
##  include	    POP ( EXP_S, EXP );
##  call	    EXP	EXP
##  include	    IF IS_EMPTY ( EXP_S ) THEN			--| DERNIER INDICE
##  include	      EMIT ( AR2, "ADRESSE POUR LE DERNIER INDICE (RAPIDE)" );
##  include	    ELSE				--| INDICES INTERMEDIAIRES
##  include	      EMIT ( AR1, "ADRESSE POUR INDICE INTERMEDIAIRE" );
##  include	      EMIT ( DEC, A, 3*INTG_SIZE, "PTR DESCRIPTEUR AU TRIPLET INDICE SUIVANT" );
##  include	      INDEX ( EXP_S );
##  include	      EMIT ( ADD, I, "AJOUTER LE DECALAGE A L ADRESSE DES INDICES PRECEDENTS" );
##  include	    END IF;
##  include	  END INDEX;
      
##  include	BEGIN
##  include	  CODE_OBJECT ( D ( AS_NAME, INDEXED ) );			--| EMPILER L ADRESSE D OBJET
##  include	  EMIT ( DPL, A, "DUP ADRESS OBJET" );				--| DUPLIQUER CETTE ADRESSE
##  include	  EMIT ( IND, A, 0, "CHARGE INDEXE D ADRESSE TABLEAU" );			--| CHARGEMENT DE L ADRESSE DE TABLEAU
##  include	  EMIT ( SWP, A, "ADRESSE OBJET AU TOP" );
##  include	  EMIT ( IND, A, -addr_Size, "CHARGE INDEXE ADRESSE DU DESCRIPTEUR TABLEAU" );
##  include	  EMIT ( DEC, A, INTG_SIZE, "ADRESSE DESCRIPTEUR - TAILLE ENTIER" );
##  include	  DECLARE
##  include	    EXP_SEQ : SEQ_TYPE := LIST ( D ( AS_EXP_S, INDEXED ) );
##  include	  BEGIN
##  include	    IF NOT IS_EMPTY ( EXP_SEQ ) THEN
##  include	     INDEX ( EXP_SEQ );
##  include	    END IF;
##  include	  END;
##  include	  EMIT ( IXA, INTEGER ( 1 ) );
##  include	END;



--|-------------------------------------------------------------------------------------------------
-- 4.1.2  Slices
-- Syntax 4.1.2
--  slice ::= prefix(discrete_range)

--** slice is parsed as an indexed_component__|__slice
--|-------------------------------------------------------------------------------------------------

//  slice		=>
//	as_discrete_range	: DISCRETE_RANGE;

##  slice	====>
##	include	null;


--|-------------------------------------------------------------------------------------------------
-- 4.1.3  Selected Components
-- Syntax 4.1.3
--  selected_component ::=  prefix.selector
--
--  selector ::= simple_name
--     | character_literal | operator_symbol | all
--|-------------------------------------------------------------------------------------------------

selected_component	::=
	  prefix  .  selector			====> $2 selected
	| prefix  .  ALL				====> $1 all
	%%
--|.................................................................................................
selector	::=
	used_id | used_char | operator_symbol
	%%
--|.................................................................................................


//  selected		=>
//	as_designator	: DESIGNATOR;
--|.................................................................................................
//  all		=> ;

##  all	====>
##	include	null;



--|-------------------------------------------------------------------------------------------------
-- 4.1.4  Attributes
-- Syntax 4.1.4
--  attribute ::= prefix'attribute_designator
--
--  attribute_designator ::= simple_name [(universal_static_expression)]
--|-------------------------------------------------------------------------------------------------

attribute	::=
	prefix  '  used_id				====> void $3 attribute
	%%
--|.................................................................................................

--** attribute_call parsed as function call

//  attribute		=>
//	as_used_name_id	: used_name_id,
//	as_exp	: EXP;



--|-------------------------------------------------------------------------------------------------
-- 4.2	Literals
-- Refer to 4.4.C for numeric_literal, string_literal,
-- and null_access.
-- Refer to 4.1 for character_literal


--|-------------------------------------------------------------------------------------------------
-- 4.3	Aggregates
-- Syntax 4.3.A
--  aggregate ::=
--     (component_association {, component_association})

--** Syntax added to not parse ( expression ) as aggregate
--|-------------------------------------------------------------------------------------------------

aggregate	::=
	  ( named_association )			====> list $L general_assoc_s $1 aggregate
	| ( others_association )			====> list $L general_assoc_s $1 aggregate
	| ( component_association,{component_association,} component_association )	====> append $L general_assoc_s $1 aggregate
	| ( component_association,{component_association,} others_association )	====> append $L general_assoc_s $1 aggregate
	%%
--|.................................................................................................


//  aggregate		=>
//	as_general_assoc_s		: general_assoc_s,
//	sm_normalized_comp_s	: general_assoc_s;

##  aggregate	====>
##	include	null;



--|-------------------------------------------------------------------------------------------------
-- Syntax 4.3.B
--  component_association ::=
--     [choice {| choice}	=> ] expression
--|-------------------------------------------------------------------------------------------------

component_association	::=
	expression | named_association
	%%
--|.................................................................................................

named_association	::=
	choice_s  =>  expression			====> exch_1 $2 named
	%%
--|.................................................................................................
others_association	::=
	others_s  =>  expression			====> exch_1 $2 named
	%%
--|.................................................................................................


//  GENERAL_ASSOC		::=
//	NAMED_ASSOC | EXP;
--|.................................................................................................
//  NAMED_ASSOC		::=
//	named;
//  NAMED_ASSOC		=>
//	as_exp	: EXP;
--|.................................................................................................
//  named		=>
//	as_choice_s	: choice_s;



--|-------------------------------------------------------------------------------------------------
-- 4.4	Expressions
-- Syntax 4.4.A
--  expression ::=
--	 relation {and relation}  | relation {and then relation}
--     | relation {or relation}   | relation {or else relation}
--     | relation {xor relation}
--|-------------------------------------------------------------------------------------------------

expression	::=
	relation | relation_and | relation_and_then | relation_or
	| relation_or_else | relation_xor
	%%
--|.................................................................................................
relation_and_then	::=
	  relation  and_then  relation			====> $3 short_circuit
	| relation_and_then  and_then  relation			====> $3 short_circuit
	%%
--|.................................................................................................
and_then	::=
	AND  THEN				====> $0 and_then
	%%
--|.................................................................................................
relation_or_else	::=
	  relation  or_else   relation			====> $3 short_circuit
	| relation_or_else   or_else   relation			====> $3 short_circuit
	%%
--|.................................................................................................
or_else	::=
	OR  ELSE				====> $0 or_else
	%%
--|.................................................................................................
relation_and	::=
	  relation  AND  relation			====> infix "AND"
	| relation_and  AND  relation			====> infix "AND"
	%%
--|.................................................................................................
relation_or	::=
	  relation  OR  relation			====> infix "OR"
	| relation_or   OR  relation			====> infix "OR"
	%%
--|.................................................................................................
relation_xor	::=
	  relation  XOR  relation			====> infix "XOR"
	| relation_xor  XOR  relation			====> infix "XOR"
	%%
--|.................................................................................................


//  EXP_VAL		::=
//	short_circuit;
--|.................................................................................................
//  short_circuit		=>
//	as_exp1	: EXP,
//	as_short_circuit_op	: SHORT_CIRCUIT_OP,
//	as_exp2	: EXP;

##  short_circuit	====>
##	include	null;
--|.................................................................................................
//  SHORT_CIRCUIT_OP	::=
//	and_then | or_else;
--|.................................................................................................
//  and_then	=> ;
--|.................................................................................................
//  or_else	=> ;



--|-------------------------------------------------------------------------------------------------
-- Syntax 4.4.B
--  relation ::=
--	 simple_expression [relational_operator simple_expression]
--     | simple_expression [not] in range
--     | simple_expression [not] in type_mark
--|-------------------------------------------------------------------------------------------------

relation	::=
	simple_expression
	| simple_expression =  simple_expression		====> infix "="
	| simple_expression /= simple_expression		====> infix "/="
	| simple_expression <  simple_expression		====> infix "<"
	| simple_expression <= simple_expression		====> infix "<="
	| simple_expression >  simple_expression		====> infix ">"
	| simple_expression >= simple_expression		====> infix ">="
	| simple_expression  membership_op	range		====> $3 range_membership
	%%
--|.................................................................................................
--** range includes type_mark and range_attribute

membership_op	::=
	  IN				====> $0 in_op
	| NOT IN				====> $0 not_in
	%%
--|.................................................................................................

//  EXP_VAL_EXP		::=
//	MEMBERSHIP;
--|.................................................................................................
//  MEMBERSHIP		::=
//	range_membership | type_membership;
//  MEMBERSHIP		=>
//	as_membership_op	: MEMBERSHIP_OP;

##  MEMBERSHIP	====>
##	if	range_membership
##	call	range_membership	MEMBERSHIP
##	if	type_membership
##	call	type_membership	MEMBERSHIP
--|.................................................................................................
//  range_membership	=>
//	as_range	: RANGE;

##  range_membership	====>
##	include	null;

//  type_membership		=>
//	as_name	: NAME;

##  type_membership	====>
##	include	null;
--|.................................................................................................
//  MEMBERSHIP_OP		::=
//	in_op | not_in;
--|.................................................................................................
//  in_op	=> ;
--|.................................................................................................
//  not_in	=> ;



--|-------------------------------------------------------------------------------------------------
-- Syntax 4.4.C
--  simple_expression ::=
--     [unary_operator] term {binary_adding_operator term}
--
--  term ::= factor {multiplying_operator factor}
--
--  factor ::= primary [** primary] | abs primary | not primary
--|-------------------------------------------------------------------------------------------------

simple_expression		::=
	[unary_operator]term
     |  simple_expression  +  term              ====> infix "+"
     |  simple_expression  -  term              ====> infix "-"
     |  simple_expression  &  term              ====> infix "&"
	%%
--|.................................................................................................
term		::=
	factor
	| term / factor		====> infix "/"
	| term * factor		====> infix "*"
	| term MOD factor		====> infix "MOD"
	| term REM factor		====> infix "REM"
	%%
--|.................................................................................................
factor		::=
	primary
	| primary  **  primary	====> infix "**"
	| ABS primary		====> unary "ABS"
	| NOT primary		====> unary "NOT"
	%%
--|.................................................................................................
[unary_operator]term	::=
	term
	|  +  term		====> unary "+"
	|  -  term		====> unary "-"
	%%
--|.................................................................................................



--|-------------------------------------------------------------------------------------------------
-- Syntax 4.4.D
--  primary ::=
--	 numeric_literal | null | aggregate | string_literal | name | allocator
--     | function_call | type_conversion | qualified_expression | (expression)
--|-------------------------------------------------------------------------------------------------

primary	::=
	  numeric_literal				====> $0 numeric_literal lx_numrep
	| NULL				====> $0 null_access
	| aggregate  |  name  |  allocator
	| qualified_expression
	| (  expression  )				====> $1 parenthesized
	%%
--|.................................................................................................
--** string_literal, function_call and type_conversion are included in name


//  EXP		::=
//	NAME | EXP_EXP;

##  EXP	====>
##	if_class	NAME
##	call	NAME	EXP
##	if_class	EXP_EXP
##	call	EXP_EXP	EXP
--|.................................................................................................
//  EXP_EXP		::=
//	EXP_VAL | AGG_EXP | qualified_allocator | subtype_allocator;
//  EXP_EXP		=>
//	sm_exp_type	: TYPE_SPEC;

##  EXP_EXP	====>
##	if_class	EXP_VAL
##	call	EXP_VAL	EXP_EXP
##	if_class	AGG_EXP
##	call	AGG_EXP	EXP_EXP
##	if	qualified_allocator
##	call	qualified_allocator	EXP_EXP
##	if	subtype_allocator
##	call	subtype_allocator	EXP_EXP
--|.................................................................................................
//  EXP_VAL		::=
//	numeric_literal | null_access | EXP_VAL_EXP;
//  EXP_VAL		=>
//	sm_value	: Value;

##  EXP_VAL	====>
##	if_class	EXP_VAL_EXP
##	call	EXP_VAL_EXP	EXP_VAL
##	if	numeric_literal
##	call	numeric_literal	EXP_VAL
##	if	null_access
##	call	null_access	EXP_VAL
##	if	short_circuit
##	call	short_circuit	EXP_VAL
--|.................................................................................................
//  EXP_VAL_EXP		::=
//	QUAL_CONV | parenthesized;
//  EXP_VAL_EXP		=>
//	as_exp	: EXP;

##  EXP_VAL_EXP	====>
##	if_class	QUAL_CONV
##	call	QUAL_CONV	EXP_VAL_EXP
##	if_class	MEMBERSHIP
##	call	MEMBERSHIP	EXP_VAL_EXP
##	if	parenthesized
##	call	parenthesized	EXP_VAL_EXP
--|.................................................................................................
//  AGG_EXP		::=
//	aggregate | string_literal;
//  AGG_EXP		=>
//	sm_discrete_range	: DISCRETE_RANGE;

##  AGG_EXP	====>
##	if	aggregate
##	call	aggregate	AGG_EXP
##	if	string_literal
##	call	string_literal	AGG_EXP
--|.................................................................................................
//  parenthesized		=> ;

##  parenthesized	====>
##	include	null;
--|.................................................................................................
//  numeric_literal		=>
//	lx_numrep	: Number_Rep;

##  numeric_literal	====>
##	include	null;
--|.................................................................................................
//  string_literal		=>
//	lx_symrep	: symbol_rep;

##  string_literal	====>
##	include	null;
--|.................................................................................................
//  null_access		=> ;

##  null_access	====>
##	include	null;



--|-------------------------------------------------------------------------------------------------
-- 4.5	Operators and Expression Evaluation
-- Syntax 4.5
--  logical_operator ::= and | or | xor
--
--  relational_operator ::=  = | /= | < | <= | > | >=
--
--  adding_operator ::= + | - | &
--
--  unary_operator ::= + | -
--
--  multiplying_operator ::= * | / | mod | rem
--
--  highest_precedence_operator ::= ** | abs | not
--|-------------------------------------------------------------------------------------------------


--|-------------------------------------------------------------------------------------------------
-- 4.6	Type Conversions
-- Syntax 4.6
--  type_conversion ::= type_mark(expression)
--|-------------------------------------------------------------------------------------------------

--** parsed as name
//  QUAL_CONV		::=
//	conversion | qualified;
//  QUAL_CONV		=>
//	as_name	: NAME;

##  QUAL_CONV	====>
##	if	conversion
##	call	conversion	QUAL_CONV
##	if	qualified
##	call	qualified	QUAL_CONV
--|.................................................................................................
//  conversion	=> ;

##  conversion	====>
##	include	null;



--|-------------------------------------------------------------------------------------------------
-- 4.7	Qualified Expressions
-- Syntax 4.7
--  qualified_expression ::=
--     type_mark'(expression) | type_mark'aggregate
--|-------------------------------------------------------------------------------------------------

qualified_expression	::=
	  prefix  '  (  expression  )			====> exch_1 $2 qualified
	| prefix  '  aggregate			====> exch_1 $2 qualified
	%%
--|.................................................................................................

--** The 'prefix' must be a 'type_mark'

//  qualified	=> ;

##  qualified	====>
##	include	null;



--|-------------------------------------------------------------------------------------------------
-- 4.8	Allocators
-- Syntax 4.8
--  allocator ::=
--     new subtype_indication | new qualified_expression
--|-------------------------------------------------------------------------------------------------

allocator	::=
	  NEW  allocator_subtype_indication			====> $1 subtype_allocator
	| NEW  allocator_qualified_expression			====> $1 qualified_allocator
	%%
--|.................................................................................................

--** The only allowed forms of constraint in the subtype indication of
--** an allocator are index and discriminant constraints [RM 4.8/4]

allocator_subtype_indication ::=
	  type_mark
	| type_mark  index_constraint__|__discriminant_constraint		====> exch_1 $2 subtype_indication
	%%
--|.................................................................................................
--** Elsewhere, a qualified_expression begins with prefix to avoid
--** LALR conflict.  Here, type mark can (must) be used.

allocator_qualified_expression	::=
	  type_mark  ' ( expression )			====> exch_1 $2 qualified
	| type_mark  ' aggregate			====> exch_1 $2 qualified
	%%
--|.................................................................................................


//  qualified_allocator	=>
//	as_qualified	: qualified;

##  qualified_allocator	====>
##	include	null;

--|.................................................................................................
//  subtype_allocator	=>
//	as_subtype_indication	: subtype_indication,
//	sm_desig_type		: TYPE_SPEC;

##  subtype_allocator	====>
##	include	null;



--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-- 5.  Statements
--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-- 5.1	Simple and Compound Statements - Sequences of Statements
-- Syntax 5.1.A
--  sequence_of_statements ::= statement {statement}
--|-------------------------------------------------------------------------------------------------

sequence_of_statements	::=
      {stm_pragma} stm_s_tail			====> cat $L stm_s
	%%
--|.................................................................................................
stm_s_tail		::=
	statement  {stm_pragma}		====> insert
	| stm_s_tail  statement  {stm_pragma}		====> insert cat
	%%
--|.................................................................................................
stm_pragma	::=
	pragma			====> $1 stm_pragma
	%%
--|.................................................................................................


//  STM_ELEM	::=
//	STM | stm_pragma;
//  stm_s		=>
//	as_list	: Seq Of STM_ELEM;

##  stm_s	====>
##	repeat_extract	stm_s	stm_elem
##	call	STM_ELEM	stm_elem

##  STM_ELEM	====>
##	if_class	STM
##	call	STM	STM_ELEM
##	if	stm_pragma
##	call	stm_pragma	STM_ELEM

//  stm_pragma		=>
//	as_pragma	: pragma;

##  stm_pragma	====>
##	include	null;



--|-------------------------------------------------------------------------------------------------
-- Syntax 5.1.B
--  statement ::=
--     {label} simple_statement | {label} compound_statement
--|-------------------------------------------------------------------------------------------------

statement		::=
	simple_statement
	| compound_statement
	| label_s  [pragma_s]  simple_statement		====> $3 labeled
	| label_s  [pragma_s]  compound_statement	====> $3 labeled
	%%
--|.................................................................................................


//  STM		::=
//	labeled;

##  STM	====>
##	if	labeled
##	call	labeled	STM
##	if	null_stm
##	call	null_stm	STM
##	if	accept
##	call	accept	STM
##	if	terminate
##	call	terminate	STM
##	if	abort
##	call	abort	STM
##	if_class	CLAUSES_STM
##	call	CLAUSES_STM	STM
##	if_class	BLOCK_LOOP
##	call	BLOCK_LOOP	STM
##	if_class	ENTRY_STM
##	call	ENTRY_STM	STM
##	if_class	STM_WITH_NAME
##	call	STM_WITH_NAME	STM
##	if_class	STM_WITH_EXP
##	call	STM_WITH_EXP	STM
--|.................................................................................................
//  labeled		=>
//	as_source_name_s	: source_name_s,
//	as_pragma_s	: pragma_s,
//	as_stm	: STM;

##  labeled	====>
##	include	null;



--|-------------------------------------------------------------------------------------------------
-- Syntax 5.1.C
--  simple_statement ::= null_statement
--     | assignment_statement | procedure_call_statement
--     | exit_statement       | return_statement
--     | goto_statement       | entry_call_statement
--     | delay_statement      | abort_statement
--     | raise_statement      | code_statement
--|-------------------------------------------------------------------------------------------------

simple_statement		::=
	  null_statement
	| assignment_statement	 |  goto_statement
	| exit_statement		 |  return_statement
	| delay_statement		 |  abort_statement
	| raise_statement		 |  code_statement
	| procedure_call_statement__|__entry_call_statement
	%%
--|.................................................................................................

procedure_call_statement__|__entry_call_statement	::=
	procedure_call_statement
	%%
--|.................................................................................................
--** Semantics required to determine that call is to an entry


//  STM		::=
//	null_stm | abort | STM_WITH_EXP | STM_WITH_NAME;
--|.................................................................................................
//  STM_WITH_EXP		::=
//	return | delay | STM_WITH_EXP_NAME;
//  STM_WITH_EXP		=>
//	as_exp	: EXP;

##  STM_WITH_EXP	====>
##	if	return
##	call	return	STM_WITH_EXP
##	if	delay
##	call	delay	STM_WITH_EXP
##	if	case
##	call	case	STM_WITH_EXP
##	if_class	STM_WITH_EXP_NAME
##	call	STM_WITH_EXP_NAME	STM_WITH_EXP
--|.................................................................................................
//  STM_WITH_EXP_NAME	::=
//	assign | exit | code;
//  STM_WITH_EXP_NAME	=>
//	as_name	: NAME;

##  STM_WITH_EXP_NAME	====>
##	if	code
##	call	code	STM_WITH_EXP_NAME
##	if	assign
##	call	assign	STM_WITH_EXP_NAME
##	if	exit
##	call	exit	STM_WITH_EXP_NAME
--|.................................................................................................
//  STM_WITH_NAME		::=
//	goto | raise;
--|.................................................................................................
//  STM_WITH_NAME		::=
//	CALL_STM;
//  STM_WITH_NAME		=>
//	as_name	: NAME;

##  STM_WITH_NAME	====>
##	if	goto
##	call	goto	STM_WITH_NAME
##	if	raise
##	call	raise	STM_WITH_NAME
##	if_class	CALL_STM
##	call	CALL_STM	STM_WITH_NAME
--|.................................................................................................
//  CALL_STM		::=
//	entry_call | procedure_call;

##  CALL_STM	====>
##	if	procedure_call
##	call	procedure_call	CALL_STM
##	if	entry_call
##	call	entry_call	CALL_STM
--|.................................................................................................



--|-------------------------------------------------------------------------------------------------
-- Syntax 5.1.D
--  compound_statement ::=
--	 if_statement	 | case_statement
--     | loop_statement       | block_statement
--     | accept_statement     | select_statement
--|-------------------------------------------------------------------------------------------------

compound_statement	::=
	  if_statement	| case_statement
	| loop_statement	| block_statement
	| accept_statement	| select_statement
	%%
--|.................................................................................................

//  STM		::=
//	accept | BLOCK_LOOP | ENTRY_STM | CLAUSES_STM;
--|.................................................................................................
//  STM_WITH_EXP		::=
//	case;
--|.................................................................................................
//  CLAUSES_STM		::=
//	if | selective_wait;
//  CLAUSES_STM		=>
//	as_test_clause_elem_s	: test_clause_elem_s,
//	as_stm_s		: stm_s;

##  CLAUSES_STM	====>
##	if	if
##	call	if	CLAUSES_STM
##	if	selective_wait
##	call	selective_wait	CLAUSES_STM



--|-------------------------------------------------------------------------------------------------
-- Syntax 5.1.E
--  label ::= <<label_simple_name>>
--|-------------------------------------------------------------------------------------------------

label_id		::=
	identifier 				====> $0 label_id lx_symrep
	%%
--|.................................................................................................
label		::=
	<<  label_id  >>
	%%
--|.................................................................................................
label_s		::=
	label{label}				====> $L source_name_s
	%%
--|.................................................................................................


//  LABEL_NAME		::=
//	label_id;
//  LABEL_NAME		=>
//	sm_stm	: STM;

##  LABEL_NAME	====>
##	if	label_id
##	call	label_id	LABEL_NAME
##	if	block_loop_id
##	call	block_loop_id	LABEL_NAME
--|.................................................................................................
//  label_id		=>
//	cd_label	: Integer;

##  label_id	====>
##	include	null;



--|-------------------------------------------------------------------------------------------------
-- Syntax 5.1.F
--  null_statement ::= null ;
--|-------------------------------------------------------------------------------------------------

null_statement		::=
	NULL ;				====> $0 null_stm
	%%
--|.................................................................................................


//  null_stm		=> ;

##  null_stm	====>
##	include	null;



--|-------------------------------------------------------------------------------------------------
-- 5.2	Assignment Statement
-- Syntax 5.2
--  assignment_statement ::=
--     variable_name := expression;
--|-------------------------------------------------------------------------------------------------

assignment_statement ::=
	name  :=   expression  ;			====> exch_1 $2 assign
	%%
--|.................................................................................................
##  OBJECT	====>				--| N EST PAS UN ELEMENT SYNTAXIQUE SE RATTACHE A USED_OBJECT_ID CONTEXTUALISE
##  include	  CASE OBJECT.TY IS
##  include	   WHEN DN_VARIABLE_ID =>			--| De classe OBJECT_NAME ; INIT_OBJECT_NAME ; VC_NAME
##  include	      GEN_LOAD_ADDR ( DI (CD_COMP_UNIT, OBJECT ), DI ( CD_LEVEL, OBJECT ), DI ( CD_OFFSET, OBJECT ),
##  include	                  "EMPILE ADRESSE DE VARIABLE" );
         
##  include	   WHEN DN_IN_ID =>				--| De classe OBJECT_NAME ; INIT_OBJECT_NAME ; PARAM_NAME
##  include	     EMIT ( LDA, LEVEL - DI ( CD_LEVEL, OBJECT ), DI ( CD_OFFSET, OBJECT ),
##  include	                  "EMPILE ADRESSE DE PARAM IN" );
         
##  include	   WHEN DN_IN_OUT_ID | DN_OUT_ID =>			--| De classe OBJECT_NAME ; INIT_OBJECT_NAME ; PARAM_NAME ; PARAM_IO_O
##  include	     EMIT ( LDA, LEVEL - DI ( CD_LEVEL, OBJECT ), DI ( CD_VAL_OFFSET, OBJECT ),
##  include	                  "EMPILE ADRESSE PARAM IN_OUT/OUT" );
         
##  include	   WHEN DN_INDEXED =>			--| De classe EXP ; NAME ; NAME_EXP
##  include	     CODE_INDEXED ( OBJECT );
         
##  include	   WHEN DN_USED_OBJECT_ID =>			--| De classe EXP ; NAME ; DESIGNATOR ; USED_OBJECT
##  include	     CODE_OBJECT ( D ( SM_DEFN, OBJECT ) );		--| CHARGER L ADRESSE CONTENUE DANS LA DEFINITION
         
##  include	   WHEN OTHERS =>
##  include	     PUT_LINE ( "!!! LOAD_OBJECT_ADDRESS : OBJECT.TY ILLICITE " & NODE_NAME'IMAGE ( OBJECT.TY ) );
##  include	     RAISE PROGRAM_ERROR;
##  include	  END CASE;
--|.................................................................................................
##  ADRESSE	====>				--| N EST PAS UN ELEMENT SYNTAXIQUE SE RATTACHE AUX ACCESS
##  include	CASE ADRESSE.TY is
##  include	WHEN DN_VARIABLE_ID =>			--| UNE VARIABLE ACCESS DE CLASSE OBJECT_NAME ; INIT_OBJECT_NAME ; VC_NAME
##  include	  GEN_LOAD ( A, DI (CD_COMP_UNIT, ADRESSE ), DI ( CD_LEVEL, ADRESSE ), DI ( CD_OFFSET, ADRESSE ) );
         
##  include	WHEN DN_IN_ID =>				--| UN PARAMETRE ACCESS IN DE CLASSE OBJECT_NAME ; INIT_OBJECT_NAME ; PARAM_NAME
##  include	  GEN_LOAD ( A, 0,  DI ( CD_LEVEL, ADRESSE ), DI ( CD_OFFSET, ADRESSE ) );
         
##  include	WHEN DN_IN_OUT_ID | DN_OUT_ID =>			--| UNPARAMETRE DE CLASSE OBJECT_NAME ; INIT_OBJECT_NAME ; PARAM_NAME ; PARAM_IO_O
##  include	  GEN_LOAD ( A, 0, DI ( CD_LEVEL, ADRESSE ), DI ( CD_VAL_OFFSET, ADRESSE ) );
         
##  include	WHEN DN_INDEXED =>				--| De classe EXP ; NAME ; NAME_EXP
##  include	  CODE_INDEXED ( ADRESSE );
         
##  include	WHEN DN_USED_OBJECT_ID =>			--| De classe EXP ; NAME ; DESIGNATOR ; USED_OBJECT
##  include	  CODE_ADRESSE ( D ( SM_DEFN, ADRESSE ) );
##  include	WHEN OTHERS =>
##  include	PUT_LINE ( "!!! CODE_ADRESSE : OBJECT.TY ILLICITE " & NODE_NAME'IMAGE ( ADRESSE.TY ) );
##  include	  RAISE PROGRAM_ERROR;
##  include	END CASE;

--|.................................................................................................
//  assign		=> ;

##  assign	====>
##  include	DECLARE
##  include	  NAME : TREE := D ( AS_NAME, ASSIGN );			--| RAMENER LE NOM AFFECTE

##  include	  PROCEDURE STORE_VAL ( TYPE_SPEC :TREE ) IS
##  include	  BEGIN
##  include	    CASE TYPE_SPEC.TY IS
##  include	    WHEN DN_ACCESS =>			--| STOCKAGE D UNE VALEUR POINTEUR
##  include	      EMIT ( STO, A );			--| STOCKER L ADRESSE A L ADRESSE DONNEE
                  
##  include	    WHEN DN_ENUMERATION =>			--| STOCKAGE D UNE VALEUR ENUMEREE
##  include	      DECLARE
##  include	        TYPE_SOURCE_NAME : TREE            := D ( XD_SOURCE_NAME, TYPE_SPEC );
##  include	        TYPE_SYMREP      : TREE            := D ( LX_SYMREP, TYPE_SOURCE_NAME );
##  include	        NAME             : CONSTANT STRING := PRINT_NAME ( TYPE_SYMREP );
##  include	      BEGIN
##  include	        IF NAME = "BOOLEAN" THEN EMIT ( STO, B );		--| STOCKER LE BOOLEAN A L ADRESSE DONNEE
##  include	        ELSIF NAME = "CHARACTER" THEN EMIT ( STO, C );		--| STOCKER LE CARACTERE
##  include	        ELSE EMIT ( STO, I );			--| STOCKER L ENTIER
##  include	        END IF;
##  include	      END;
                  
##  include	    WHEN DN_INTEGER =>			--| STOCKAGE D UNE VALEUR ENTIERE
##  include	      EMIT ( STO, I );
               
##  include	    WHEN DN_UNIVERSAL_INTEGER =>
##  include	      DECLARE
##  include	        COMP_UNIT : COMP_UNIT_NBR := DI ( CD_COMP_UNIT, TYPE_SPEC );
##  include	        LVL       : LEVEL_TYPE    := DI ( CD_LEVEL, TYPE_SPEC );
##  include	        OFS       : INTEGER       := DI ( CD_OFFSET, TYPE_SPEC );
##  include	      BEGIN
##  include	        GEN_LOAD_ADDR ( COMP_UNIT, LVL, OFS );
##  include	        EMIT ( CVB );
##  include	        EMIT ( STO, I );
##  include	      END;
               
##  include	    WHEN OTHERS =>
##  include	      PUT_LINE ( "!!! STORE_VAL TYPE_SPEC.TY ILLICITE " & NODE_NAME'IMAGE ( TYPE_SPEC.TY ) );
##  include	      RAISE PROGRAM_ERROR;
##  include	    END CASE;
##  include	  END STORE_VAL;

##  include	BEGIN
##  include	  --|---------------------------------------------------------------------------
##  include	  IF NAME.TY = DN_ALL THEN			--| C EST UNE INDIRECTION QQC.ALL
##  include	    CODE_ADRESSE ( D ( AS_NAME, NAME ) );		--| ADRESSE DE QQC
##  call	EXP	@ AS_EXP	ASSIGN		--| TRAITER L EXPRESSION A AFFECTER
##  include	    STORE_VAL ( D ( SM_EXP_TYPE, NAME ) );		--| STOCKER LA VALEUR D EXPRESSION

##  include	  --|---------------------------------------------------------------------------
##  include	  ELSIF NAME.TY = DN_INDEXED THEN			--| DESTINATION CASE DE TABLEAU
##  include	    CODE_INDEXED ( NAME );			--| ELABORER L ADRESSE DESTINATION PAR CALCUL D INDEX
##  call	EXP	@ AS_EXP	ASSIGN		--| TRAITER L EXPRESSION A AFFECTER
##  include	    STORE_VAL ( D ( SM_EXP_TYPE, NAME ) );		--| STOCKER LA VALEUR D EXPRESSION

##  include	  --|---------------------------------------------------------------------------
##  include	  ELSIF NAME.TY = DN_USED_OBJECT_ID THEN		--| DESTINATION IDENTIFICATEUR D OBJET DEST :=
##  include	    DECLARE
##  include	      NAMEXP    : TREE := D ( SM_EXP_TYPE, NAME );		--| GENRE D OBJET DESTINATION
##  include	      DEFN      : TREE := D ( SM_DEFN, NAME );		--| DEFINITION DE L OBJET A AFFECTER
##  include	      COMP_UNIT : COMP_UNIT_NBR;			--| NUMERO D UNITE POUR LE STOCKAGE
##  include	      LVL       : LEVEL_TYPE;			--| NIVEAU DE STOCKAGE
##  include	      OFS       : OFFSET_TYPE;			--| DECALAGE DE STOCKAGE
##  include	    BEGIN
##  include	      --|-----------------------------------------------------------------------
##  include	      IF NAMEXP.TY = DN_ACCESS THEN			--| L OBJET DESTINATION EST UN ACCES
##  call	EXP	@ AS_EXP	ASSIGN		--| TRAITER L EXPRESSION A AFFECTER
##  include	        EMITS.GET_CLO ( DEFN, COMP_UNIT, LVL, OFS );		--| LIEU DE LA DEFINITION DESTINATION
##  include	        EMITS.GEN_STORE ( A, COMP_UNIT, LVL, OFS );		--| STOCKAGE DANS LA DESTINATION
##  include	      --|-----------------------------------------------------------------------
##  include	      ELSIF NAMEXP.TY = DN_ARRAY THEN			--| L OBJET DESTINATION EST UN TABLEAU
##  include	        CODE_OBJECT ( DEFN );			--| ADRESSE DESTINATION
##  include	        DECLARE
##  include	          EXP : TREE := D ( AS_EXP, ASSIGN );		--| EXPRESSION A DROITE DE L AFFECTATION
##  include	        BEGIN
##  include	          IF EXP.TY = DN_USED_OBJECT_ID THEN		--| IDENTIFICATEUR D OBJET DU GENRE := SRC
##  include	            CODE_OBJECT ( D ( SM_DEFN, EXP ) );		--| CHARGER L ADRESSE CONTENUE DANS LA DEFINITION
##  include	            CODE_OBJECT( EXP );			--| ADRESSE SOURCE
##  include	            EMIT ( LDC, I, NUMBER_OF_DIMENSIONS ( NAMEXP ), COMMENT=>"NB DIM" );
##  include	            EMIT ( CYA );			--| PROCEDURE STANDARD COPY ARRAY
##  include	          ELSE
##  call	EXP	@ AS_EXP	ASSIGN		--| TRAITER L EXPRESSION A AFFECTER
##  include	            EMIT ( LDC, I, NUMBER_OF_DIMENSIONS ( NAMEXP ), COMMENT=>"NB DIM" );
##  include	            EMIT ( PUA );			--| PROCEDURE STANDARD PUSH ARRAY
##  include	          END IF;
##  include	        END;
##  include	      --|-----------------------------------------------------------------------
##  include	      ELSIF NAMEXP.TY = DN_ENUMERATION THEN		--| L OBJET DESTINATION A UN TYPE ENUMERE
##  call	EXP	@ AS_EXP	ASSIGN		--| TRAITER L EXPRESSION A AFFECTER
##  include	        EMITS.GET_CLO ( DEFN, COMP_UNIT, LVL, OFS );		--| LIEU DE LA DEFINITION DESTINATION
##  include	        DECLARE
##  include	          CT : CODE_TYPE := CODE_TYPE_OF ( NAMEXP );		--| CODE BOOL OU CHAR OU INT
##  include	        BEGIN
##  include	          GEN_STORE ( CT, COMP_UNIT, LVL, OFS );		--| EMETTRE STORE EN FONCTION DU CODE TYPE
##  include	        END;
##  include	      --|-----------------------------------------------------------------------
##  include	      ELSIF NAMEXP.TY = DN_INTEGER THEN			--| L OBJET DESTINATION A UN TYPE ENTIER
##  call	EXP	@ AS_EXP	ASSIGN		--| TRAITER L EXPRESSION A AFFECTER
##  include	        IF NAMEXP.TY /= DN_UNIVERSAL_INTEGER THEN		--| UN ENTIER NON STANDARD
##  include	          EMITS.GET_CLO ( NAMEXP, COMP_UNIT, LVL, OFS );		--| LIEU DE LA SOURCE
##  include	          GEN_LOAD_ADDR ( COMP_UNIT, LVL, OFS );		--| ADRESSE DE LA SOURCE
##  include	          EMIT ( CVB );			--| EMPILEMENT DU CONVERTI
##  include	        END IF;
##  include	        EMITS.GET_CLO ( DEFN, COMP_UNIT, LVL, OFS );		--| LIEU DE LA DEFINITION DESTINATION
##  include	        EMITS.GEN_STORE ( I, COMP_UNIT, LVL, OFS );		--| STOCKAGE DU CONVERTI DANS LA DESTINATION

##  include	      END IF;
##  include	    END;
##  include	  END IF;
##  include	END;



--|-------------------------------------------------------------------------------------------------
-- 5.3	If Statements
-- Syntax 5.3.A
--  if_statement ::=
--	if condition then
--	    sequence_of_statements
--     {elsif condition then
--	    sequence_of_statements}
--     [else
--	    sequence_of_statements]
--	end if;
--|-------------------------------------------------------------------------------------------------

if_statement	::=
	  if_clause_s  END IF ;				====> nil $L stm_s $2 if
	| if_clause_s  else_clause  END IF  ; 			====> $2 if
	%%
--|.................................................................................................
if_clause	::=
	IF  condition  THEN  sequence_of_statements		====> $2 cond_clause
	%%
--|.................................................................................................
elsif_clause	::=
	ELSIF  condition  THEN  sequence_of_statements		====> $2 cond_clause
	%%
--|.................................................................................................
if_clause_s	::=
	if_clause{elsif_clause} 			====> $L test_clause_elem_s
	%%
--|.................................................................................................
else_clause	::=
	ELSE  sequence_of_statements
	%%
--|.................................................................................................
condition	::=
	expression
	%%
--|.................................................................................................


//  if		=> ;
--	as_test_clause_elem_s	:test_clause_elem_s
--	as_stm_s	:stm_s
--	lx_srcpos	:Source_Position

##  if	====>
##  include	DECLARE
##  include	  OLD_AFTER_IF_LBL : LABEL_TYPE := EMITS.AFTER_IF_LBL;		--| GARER EN CAS D IMBRICATION DE IF
##  include	BEGIN
##  include	  EMITS.AFTER_IF_LBL := NEXT_LABEL;			--| ALLOUER UNE ETIQUETTE POST FIN DU IF
##  call	test_clause_elem_s	@ as_test_clause_elem_s	if	--| TRAITER LA SEQUENCE DES IF ELSIF ELSE
##  include	  WRITE_LABEL ( EMITS.AFTER_IF_LBL, COMMENT=> "ETIQUETTE END IF" );	--| ECRIRE L ETIQUETTE POST FIN DU IF
##  include	  EMITS.AFTER_IF_LBL := OLD_AFTER_IF_LBL;		--| RESTAURER L EVENTUELLE ETIQUETTE D UN IF ENGLOBANT
##  include	END;
--|.................................................................................................
//  TEST_CLAUSE		::=
//	cond_clause;
//  TEST_CLAUSE		=>
//	as_exp	: EXP,
//	as_stm_s	: stm_s;

##  TEST_CLAUSE	====>
##	if	cond_clause
##	call	cond_clause	TEST_CLAUSE
##	if	select_alternative
##	call	select_alternative	TEST_CLAUSE

--|.................................................................................................
//  cond_clause		=> ;
--	as_exp	:EXP
--	as_stm_s	:stm_s
--	lx_srcpos	:Source_Position

##  cond_clause	====>
--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
##  include	DECLARE
##  include	  EXP : TREE := D ( AS_EXP, COND_CLAUSE );
##  include	  NEXT_CLAUSE_LBL : LABEL_TYPE;
##  include	BEGIN
##  call	exp	exp			--| EXPRESSION CONDITION
##  include	  NEXT_CLAUSE_LBL := NEXT_LABEL;			--| ALLOUER UNE ETIQUETTE POUR LA CONDITION SUIVANTE
##  include	  EMIT ( JMPF, NEXT_CLAUSE_LBL, COMMENT=> "NON CONDITION SAUT CLAUSE SUIVANTE" );
##  call	stm_s	@ as_STM_S	cond_clause		--| INSTRUCTIONS DE L ALTERNATIVE
##  include	  EMIT ( JMP, EMITS.AFTER_IF_LBL, COMMENT=> "SAUT END IF" );	--| SAUT POST IF
##  include	  WRITE_LABEL ( NEXT_CLAUSE_LBL, COMMENT=> "LBL CONDITION SUIVANTE" );
##  include	END;



--|-------------------------------------------------------------------------------------------------
-- Syntax 5.3.B
--  condition ::= expression
--|-------------------------------------------------------------------------------------------------
-- 5.4	Case Statements
-- Syntax 5.4
--  case_statement ::=
--     case expression is
--	case_statement_alternative
--	    {case_statement_alternative}
--     end case;
--
--  case_statement_alternative ::=
--     when choice {| choice }	=>
--	    sequence_of_statements}
--|-------------------------------------------------------------------------------------------------

case_statement	::=
	CASE  expression  IS  alternative_s  END  CASE  ;		====> $2 case
	%%
--|.................................................................................................
alternative_pragma	::=
	pragma				====> $1 alternative_pragma
	%%
--|.................................................................................................
alternative_s	::=
	  {alternative_pragma} {case_sta_alt} case_sta_alt		====> append cat $L alternative_s
	| {alternative_pragma} {case_sta_alt} case_sta_others		====> append cat $L alternative_s
	%%
--|.................................................................................................
case_sta_alt	::=
	WHEN  choice_s  =>  sequence_of_statements		====>  $2 alternative
	%%
--|.................................................................................................
case_sta_others	::=
	WHEN  others_s  =>  sequence_of_statements		====>  $2 alternative
	%%
--|.................................................................................................


//  ALTERNATIVE_ELEM	::=
//	alternative | alternative_pragma;

##  ALTERNATIVE_ELEM	====>
##	if	alternative
##	call	alternative	ALTERNATIVE_ELEM
##	if	alternative_pragma
##	call	alternative_pragma	ALTERNATIVE_ELEM
--|.................................................................................................
//  case		=>
//	as_alternative_s	: alternative_s;

##  case	====>
##	include	null;
--|.................................................................................................
//  alternative_s		=>
//	as_list	: Seq Of ALTERNATIVE_ELEM;

##  alternative_s	====>
##	repeat_extract	alternative_s	alternative_elem
##	call	ALTERNATIVE_ELEM	alternative_elem
--|.................................................................................................
//  alternative		=>
//	as_choice_s	: choice_s,
//	as_stm_s	: stm_s;

##  alternative	====>				--| UNE ALTERNATIVE DE CASE
##  include	DECLARE
##  include	  SKIP_LBL          : LABEL_TYPE := NEXT_LABEL;		--| ALLOUER UNE ETIQUETTE POUR LE SAUT POST ALTERNATIVE
##  include	  HANDLER_BEGIN_LBL : LABEL_TYPE := NEXT_LABEL;		--| ALLOUER UNE ETIQUETTE POUR LE DEBUT DES INSTRUCTIONS DE L ALTERNATIVE
##  include	  CHOICE_S          : TREE       := D ( AS_CHOICE_S, ALTERNATIVE );	--| LISTE DES ELEMENTS CONDITIONANTS
##  include	BEGIN
##  include	  DI ( CD_LABEL, CHOICE_S, INTEGER ( HANDLER_BEGIN_LBL ) );		--| STOCKER L ETIQUETTE DE DEBUT DES INSTRUCTIONS
##  call	choice_s	choice_s			--| TRAITER LES ELEMENTS DE CONDITION
##  include	  IF NOT CHOICE_OTHERS_FLAG THEN			--| SI PAS ALTERNATIVE WHEN OTHERS
##  include	    EMIT ( JMP, SKIP_LBL, COMMENT=> "SKIP ALTERNATIVE SUIVANTE"  );	--| SAUTER A L ALTERNATIVE SUIVANTE
##  include	    WRITE_LABEL ( HANDLER_BEGIN_LBL, COMMENT=> "LABEL DEBUT INSTRUCTIONS" );
##  include	  END IF;
##  call	stm_s	@ as_STM_S	alternative		--| TRAITER LES INSTRUCTIONS DE L ALTERNATIVE
-- ##  include	  PERFORM_RETURN ( ENCLOSING_BODY );			??
##  include	  IF NOT CHOICE_OTHERS_FLAG THEN			--| SI PAS ALTERNATIVE WHEN OTHERS
##  include	    WRITE_LABEL ( SKIP_LBL, COMMENT=> "ALTERNATIVE SUIVANTE" );	--| METTRE L ETIQUETTE D'ALTERNATIVE SUIVANTE
##  include	  END IF;
##  include	END;

--|.................................................................................................
//  alternative_pragma	=>
//	as_pragma	: pragma;

##  alternative_pragma	====>
##	include	null;



--|-------------------------------------------------------------------------------------------------
-- 5.5	Loop Statements
-- Syntax 5.5.A
--  loop_statement ::=
--     [loop_simple_name:]
--	    [iteration_scheme] loop
--		 sequence_of_statements
--	    end loop [loop_simple_name];
--|-------------------------------------------------------------------------------------------------

loop_statement	::=
	  loop  ;				====> void exch_2 exch_1 $V3 loop $DEF block_loop_id
	| identifier  :  loop  identifier  ;			====> check_name $V3 loop $DEF block_loop_id
	%%
--|.................................................................................................
loop	::=
	[iteration_scheme]  LOOP  sequence_of_statements  END  LOOP
	%%
--|.................................................................................................


//  BLOCK_LOOP		::=
//	loop;
//  BLOCK_LOOP		=>
//	as_source_name	: SOURCE_NAME;

##  BLOCK_LOOP	====>
##	if	loop
##	call	loop	BLOCK_LOOP
##	if	block
##	call	block	BLOCK_LOOP
--|.................................................................................................
//  LABEL_NAME		::=
//	block_loop_id;
--|.................................................................................................
//  block_loop_id		=> ;

##  block_loop_id	====>
##	include	null;
--|.................................................................................................

##  ITERATION	====>
##	if_class	FOR_REV
##	call	FOR_REV	ITERATION
##	if	while
##	call	while	ITERATION
--|.................................................................................................
//  loop		=>
//	as_iteration	: ITERATION,
//	as_stm_s	: stm_s
//	cd_level	: Integer
//	cd_after_loop	: Integer;

##  loop	====>				--| BOUCLE SIMPLE
##  include	DECLARE
##  include	  OLD_LOOP_STM_S          : TREE := EMITS.LOOP_STM_S;		--| GARER LA SEQUENCE EN CAS D IMBRICATION
##  include	  OLD_BEFORE_LOOP_LBL : LABEL_TYPE := EMITS.BEFORE_LOOP_LBL;	--| GARER CES ETIQUETTES EN CAS D IMBRICATION DE BOUCLES
##  include	  OLD_AFTER_LOOP_LBL  : LABEL_TYPE := EMITS.AFTER_LOOP_LBL;
##  include	BEGIN
##  include	  LOOP_STM_S := D ( as_STM_S, ADA_LOOP );		--| RAMENER LA SEQUENCE D'INSTRUCTIONS INTERNE A LA BOUCLE
##  include	  EMITS.BEFORE_LOOP_LBL := NEXT_LABEL;			--| ALLOUER UNE ETIQUETTE DE DEBUT DE BOUCLE
##  include	  EMITS.AFTER_LOOP_LBL := NEXT_LABEL;			--| ALLOUER UNE ETIQUETTE POST FIN DE BOUCLE
##  include	  DI ( CD_AFTER_LOOP, ADA_LOOP, INTEGER( after_Loop_Lbl) );		--| PLACER L ETIQUETTE POST BOUCLE DANS LE STM LOOP (ADA_LOOP)
##  include	  DI ( CD_LEVEL, ADA_LOOP, EMITS.LEVEL );		--| PLACER LE NIVEAU ACTUEL EGALEMENT

##  include	  DECLARE
##  include	    ITERATION : TREE := D ( AS_ITERATION, ADA_LOOP );		--| RAMENER LE SCHEMA ITERATIF EVENTUEL
##  include	  BEGIN
##  include	    IF ITERATION = TREE_VOID then			--| S IL N Y EN A PAS (LOOP instructions END LOOP)
##  include	      WRITE_LABEL ( BEFORE_LOOP_LBL );			--| ECRIRE L ETIQUETTE DE DEBUT DE BOUCLE
##  call	stm_s	LOOP_STM_S			--| COMPILER LES INSTRUCTIONS DE LA BOUCLE
##  include	      EMIT ( JMP, BEFORE_LOOP_LBL );			--| ECRIRE LE SAUT DE RETOUR DE BAS DE BOUCLE
##  include	    ELSE				--| S IL Y A UN SCHEMA ITERATIF
##  call	ITERATION	@ as_iteration	ada_loop
##  include	    END IF;
##  include	  END;
##  include	  WRITE_LABEL ( after_Loop_Lbl );			--| ECRIRE L ETIQUETTE POST BOUCLE
##  include	  EMITS.BEFORE_LOOP_LBL := OLD_BEFORE_LOOP_LBL;		--| RESTAURER LES ETIQUETTES D UNE EVENTUELLE BOUCLE EXTERNE
##  include	  EMITS.AFTER_LOOP_LBL := OLD_AFTER_LOOP_LBL;
##  include	  EMITS.LOOP_STM_S := OLD_LOOP_STM_S;
##  include	END;


--|-------------------------------------------------------------------------------------------------
-- Syntax 5.5.B
--  iteration_scheme ::=  while condition
--     | for loop_parameter_specification
--
--  loop_parameter_specification ::=
--     identifier in [reverse] discrete_range
--|-------------------------------------------------------------------------------------------------

iteration_scheme	::=
	  WHILE  condition				====> $1 while
	| FOR  iteration_id  IN  discrete_range			====> $2 for
	| FOR  iteration_id  IN  REVERSE  discrete_range		====> $2 reverse
	%%
--|.................................................................................................
iteration_id	::=
	identifier				====> $0 iteration_id lx_symrep
	%%
--|.................................................................................................


//  ITERATION		::=
//	FOR_REV;
--|.................................................................................................
//  FOR_REV		::=
//	for | reverse;
//  FOR_REV		=>
//	as_source_name	: SOURCE_NAME,
//	as_discrete_range	: DISCRETE_RANGE;

##  FOR_REV	====>				--| BOUCLE FOR OU REVERSE (LES SAUVEGARDES D ETIQUETTES SONT DEJA FAITES PAR LOOP QUI APPELLE)
##  include	DECLARE
##  include	  OLD_LOOP_OP_INC_DEC   : OP_CODE      := EMITS.LOOP_OP_INC_DEC;	--| GARER CELA EN CAS D IMBRICATION DE BOUCLES FOR REV
##  include	  OLD_LOOP_OP_GT_LT     : OP_CODE      := EMITS.LOOP_OP_GT_LT;
##  include	  COUNTER, TEMP         : INTEGER;
##  include	  OLD_OFFSET_ACT        : OFFSET_TYPE  := EMITS.OFFSET_ACT;
##  include	  ITERATION_ID          : TREE         := D ( AS_SOURCE_NAME, FOR_REV );
##  include	  aCT                   : CODE_TYPE    := EMITS.CODE_TYPE_OF ( D ( SM_OBJ_TYPE, ITERATION_ID ) );
##  include	  PROCEDURE LOAD_DSCRT_RANGE ( DSCRT_RANGE : TREE ) IS
##  include	  BEGIN
##  include	    NULL;
##  include	  END;
##  include	BEGIN
##  include	  EMITS.BEFORE_LOOP_LBL := NEXT_LABEL;			--| ALLOUER UNE ETIQUETTE DE DEBUT DE BOUCLE
##  include	  EMITS.AFTER_LOOP_LBL := NEXT_LABEL;			--| ALLOUER UNE ETIQUETTE POST FIN DE BOUCLE
##  if	for
##  call	for	FOR_REV			--| POSITIONNE LES OPERATIONS LOOP_OP INC LE
##  if	reverse
##  call	reverse	FOR_REV			--| POSITIONNE LES OPERATIONS LOOP_OP DEC GE
##  end_if
##  include	  CASE aCT IS				--| SUIVANT LE TYPE DE LA VARIABLE D ITERATION
##  include	  WHEN B =>				--| BOOLEEN (? POUR UNE BOUCLE ?)
##  include	    ALIGN ( Bool_Al );
##  include	    COUNTER := -EMITS.OFFSET_ACT;
##  include	    INC_OFFSET ( Bool_Size);
##  include	    ALIGN ( Bool_Al);
##  include	    TEMP := -EMITS.OFFSET_ACT;
##  include	    INC_OFFSET ( Bool_Size );
##  include	  WHEN C =>				--| CARACTERE
##  include	    ALIGN ( Char_Al );
##  include	    COUNTER := -EMITS.OFFSET_ACT;
##  include	    INC_OFFSET ( Char_Size );
##  include	    ALIGN ( Char_Al);
##  include	    TEMP := -EMITS.OFFSET_ACT;
##  include	    INC_OFFSET ( Char_Size );
##  include	  WHEN I =>				--| ENTIER
##  include	    ALIGN ( INTG_Al );			--| ALIGNER POUR L ENTIER VARIABLE COMPTEUR
##  include	    COUNTER := -EMITS.OFFSET_ACT;			--| OFFSET DU COMPTEUR DE BOUCLE
##  include	    INC_OFFSET ( INTG_SIZE );			--| RESERVER UNE PLACE D ENTIER COMPTEUR
##  include	    ALIGN ( INTG_Al );			--| ALIGNER POUR L ENTIER BORNE DE COMPTAGE
##  include	    TEMP := -EMITS.OFFSET_ACT;			--| OFFSET DE LA BORNE DE COMPTAGE
##  include	    INC_OFFSET ( INTG_SIZE );			--| RESERVER UNE PLACE D ENTIER BORNE
##  include	  WHEN A =>
##  include	    PUT_LINE ( "!!! compile_stm_loop_reverse aCT illicite " & Code_Type'IMAGE ( aCT ) );
##  include	    RAISE PROGRAM_ERROR;
##  include	  END CASE;

##  include	  DI ( CD_LEVEL, ITERATION_ID, EMITS.LEVEL );		--| RANGER LE NIVEAU STATIQUE DU COMPTEUR
##  include	  DI ( CD_OFFSET, ITERATION_ID, COUNTER );		--| RANGER L OFFSET DE COMPTEUR
##  include	  LOAD_DSCRT_RANGE ( D ( as_DISCRETE_RANGE, FOR_REV ) );

##  include	  EMIT ( STR, aCT, 0, TEMP );
##  include	  WRITE_LABEL ( EMITS.BEFORE_LOOP_LBL );		--| ETIQUETTE DE DEBUT DE BOUCLE
##  include	  EMIT ( STR, aCT, 0, COUNTER );			--| STOCKER LE COMPTEUR (IL EST MODIFIE EN FIN DE BOUCLE)
##  include	  EMIT ( LOD, aCT, 0, COUNTER );			--| RECHARGER LE COMPTEUR
##  include	  EMIT ( LOD, aCT, 0, TEMP );			--| CHARGER LA BORNE
##  include	  EMIT ( EMITS.LOOP_OP_GT_LT, aCT );			--| FAIRE LA COMPARAISON SUIVANT LE CAS FOR OU REVERSE
##  include	  EMIT ( JMPT, EMITS.AFTER_LOOP_LBL );			--| LE COMPTEUR DEPASSE LA BORNE SORTIE DE BOUCLE
##  call	stm_s	LOOP_STM_S			--| TRAITER LES INSTRUCTIONS DE BOUCLE
##  include	  EMIT ( LOD, aCT, 0, COUNTER );			--| CHARGER LE COMPTEUR
##  include	  EMIT ( EMITS.LOOP_OP_INC_DEC, aCT, 1 );		--| L INCREMENTER OU DECREMENTER SUIVANT LE TYPE DE BOUCLE
##  include	  EMIT ( JMP, EMITS.BEFORE_LOOP_LBL );			--| FOND DE BOUCLE SAUT AU DEBUT
##  include	  WRITE_LABEL ( EMITS.AFTER_LOOP_LBL );			--| ETIQUETTE POST BOUCLE

##  include	  EMITS.OFFSET_ACT := OLD_OFFSET_ACT;
##  include	  EMITS.LOOP_OP_INC_DEC := OLD_LOOP_OP_INC_DEC;		--| RESTAURER CES OPERATIONS D UNE EVENTUELLE BOUCLE EXTERNE FOR REV
##  include	  EMITS.LOOP_OP_GT_LT := OLD_LOOP_OP_GT_LT;
##  include	END;

--|.................................................................................................
//  for		=> ;

##  for	====>
##  include	LOOP_OP_INC_DEC := INC;			--| UNE BOUCLE FOR NORMALE INCREMENTE SON COMPTEUR
##  include	LOOP_OP_GT_LT := GT;			--| ON L ARRETE QUAND LE COMPTEUR DEPASSE LA BORNE

--|.................................................................................................
//  reverse		=> ;

##  reverse	====>
##  include	LOOP_OP_INC_DEC := DEC;			--| UNE BOUCLE FOR REVERSE DECREMENTE SON COMPTEUR
##  include	LOOP_OP_GT_LT := LT;			--| ON L ARRETE QUAND LE COMPTEUR PASSE SOUS LA BORNE
--|.................................................................................................
//  OBJECT_NAME		::=
//	iteration_id;
--|.................................................................................................
//  iteration_id		=>
//	cd_level	: Integer,
//	cd_offset	: Integer;

##  iteration_id	====>
##	include	null;
--|.................................................................................................
//  ITERATION		::=
//	while;
--|.................................................................................................
//  while		=>
//	as_exp	: EXP;

##  while	====>				--| BOUCLE WHILE (LES SAUVEGARDES D ETIQUETTES SONT DEJA FAITE PAR LOOP QUI APPELLE WHILE)
##  include	BEFORE_LOOP_LBL := NEXT_LABEL;			--| ALLOUER UNE ETIQUETTE DE DEBUT DE BOUCLE
##  include	AFTER_LOOP_LBL := NEXT_LABEL;			--| ALLOUER UNE ETIQUETTE POST FIN DE BOUCLE
##  include	WRITE_LABEL ( BEFORE_LOOP_LBL );			--| ECRIRE L ETIQUETTE ENTREE DE BOUCLE
##  call	EXP	@ as_EXP	ADA_WHILE		--| TRAITER L EXPRESSION CONDITION
##  include	EMIT ( JMPF, AFTER_LOOP_LBL );			--| SAUT POST BOUCLE SI CONDITION FAUSSE
##  call	stm_s	LOOP_STM_S			--| TRAITER LES INSTRUCTIONS DE LA BOUCLE
##  include	EMIT ( JMP, BEFORE_LOOP_LBL );			--| FOND DE BOUCLE SAUT AU DEBUT DE BOUCLE


--|-------------------------------------------------------------------------------------------------
-- 5.6	Block Statements
-- Syntax 5.6
--  block_statement ::=
--     [block_simple_name:]
--	    [declare
--		 declarative_part]
--	    begin
--		 sequence_of_statements
--	    [exception
--		  exception_handler
--		 {exception_handler}]
--	    end [block_simple_name];
--|-------------------------------------------------------------------------------------------------

block_statement	::=
	  block ;				====> void exch_1 $V2 block $DEF block_loop_id
	| identifier  :  block  identifier  ;			====> check_name $V2 block $DEF block_loop_id
	%%
--|.................................................................................................
block	::=
	[DECLARE__declarative_part]  BEGIN  sequence_of_statements
	[EXCEPTION__exception_handler{exception_handler}]  END		====> $3 block_body
	%%
--|.................................................................................................
[DECLARE__declarative_part]	::=
	  empty				====> nil $L item_s
	| DECLARE  declarative_part
	%%
--|.................................................................................................
[EXCEPTION__exception_handler{exception_handler}]  ::=
	  empty				====> nil $L alternative_s
	| EXCEPTION  alternative_s
	%%
--|.................................................................................................


//  BLOCK_LOOP		::=
//	block;
--|.................................................................................................
//  block		=>
//	as_block_body	: block_body;
--	as_source_name	:SOURCE_NAME
--	lx_srcpos	:Source_Position

##  block	====>
##  include	DECLARE
##  include	  AFTER_BLOCK_LBL : LABEL_TYPE := NEXT_LABEL;
##  include	  PROC_LBL        : LABEL_TYPE := NEXT_LABEL;
##  include	BEGIN
##  include	  EMIT ( MST, INTEGER ( 0 ), INTEGER( 0 ), COMMENT=> "POUR BLOC" );
##  include	  EMIT ( CALL, EMITS.RELATIVE_RESULT_OFFSET, PROC_LBL,		--| UN BLOC EST TRAITE COMME UNE PROCEDURE SANS PARAMETRE DONC APPELE
##  include	         COMMENT=> "APPEL DE BLOC" );
##  include	  EMIT ( JMP, AFTER_BLOCK_LBL, COMMENT=> "SAUT POST BLOC" );	--| AU RETOUR DU BLOC SAUTER POST BLOC
##  include	  WRITE_LABEL ( PROC_LBL);			--| ETIQUETTE DEBUT DE BLOC
##  include	  DECLARE
##  include	    OLD_OFFSET_ACT : OFFSET_TYPE := EMITS.OFFSET_ACT;		--| GARER LES OFFSETS ANTERIEURS
##  include	    OLD_OFFSET_MAX : OFFSET_TYPE := EMITS.OFFSET_MAX;
##  include	  BEGIN
##  include	    EMITS.OFFSET_ACT := FIRST_LOCAL_VAR_OFFSET;		--| METTRE LES OFFSETS SUR LA PREMIERE VARIABLE LOCALE
##  include	    EMITS.OFFSET_MAX := FIRST_LOCAL_VAR_OFFSET;
##  include	    INC_LEVEL;				--| UN NIVEAU PLUS PROFOND
##  call	block_body	@ as_block_body	block		--| TRAITER LE CORPS DU BLOC
##  include	    DEC_LEVEL;
##  include	    EMITS.OFFSET_ACT := OLD_OFFSET_ACT;			--| RESTAURER LES OFFSETS D AVANT LE BLOC
##  include	    EMITS.OFFSET_MAX := OLD_OFFSET_MAX;
##  include	  END;
##  include	  WRITE_LABEL ( AFTER_BLOCK_LBL );
##  include	END;
--|.................................................................................................
//  block_body		=>
//	as_item_s	: item_s,
//	as_stm_s	: stm_s,
//	as_alternative_s	: alternative_s,
//	cd_level	: Integer,
//	cd_return_label	: Integer,
//	cd_result_offset	: Integer;

##  block_body	====>

##  include	DECLARE				--| TRAITEMENT DU CORPS DE SOUS PROGRAMME
##  include	  SAVE_ENCLOSING_BODY : TREE := ENCLOSING_BODY;
##  include	  OLD_TOP_ACT         : OFFSET_TYPE := EMITS.TOP_ACT;
##  include	  OLD_TOP_MAX         : OFFSET_TYPE := EMITS.TOP_MAX;
##  include	BEGIN
##  include	  ENCLOSING_BODY := BLOCK_BODY;			--| LE BLOC EN TRAITEMENT DEVIENT L'ENGLOBANT ACTUEL
##  include	  EMITS.TOP_ACT := 0;			--| RAZ DES TOPS PUISQUE ON A UN NOUVEAU CONTEXTE
##  include	  EMITS.TOP_MAX := 0;
##  include	  DI ( CD_LEVEL, BLOCK_BODY, INTEGER ( EMITS.LEVEL ) );		--| PLACER LE NIVEAU COURANT DANS LE CHAMP LEVEL DU BLOC
##  include	  DI ( CD_RETURN_LABEL, BLOCK_BODY, INTEGER ( NEXT_LABEL ) );	--| ALLOUER UNE ETIQUETTE ET LA PLACER DANS LE CHAMP POUR RETOUR
##  include	  DECLARE
##  include	    ENT_1_LBL : LABEL_TYPE := NEXT_LABEL;
##  include	    ENT_2_LBL : LABEL_TYPE := NEXT_LABEL;
##  include	  BEGIN
##  include	    EMIT ( ENT, INTEGER ( 1 ), ENT_1_Lbl );		--| EMETTRE LE MARQUEUR D ENTREE DE BLOC AVEC ETIQUETTE POUR OFFSET_MAX
##  include	    EMIT ( ENT, INTEGER ( 2 ), ENT_2_Lbl );		--| SECOND MARQUEUR POUR TOP + OFFSET MAXIS

##  include	    IF FUNCTION_RESULT /= TREE_VOID THEN		--| S IL Y A UN RESULTAT DE FONCTION
##  include	      IF FUNCTION_RESULT.TY = DN_ARRAY THEN		--| SI C EST UN TABLEAU INITIALISER LE DESCRIPTEUR RESULTAT
##  include	        GEN_LOAD_ADDR ( DI ( CD_COMP_UNIT, FUNCTION_RESULT ),
##  include	                        DI ( CD_LEVEL, FUNCTION_RESULT ),
##  include	                        DI ( CD_OFFSET, FUNCTION_RESULT )
##  include	            );
##  include	        EMIT ( DPL, A );			--| DUPLIQUER L ADRESSE OBTENUE
##  include	        EMIT ( STR, A, 0, FUN_RESULT_OFFSET - EMITS.ADDR_SIZE );	--| LA STOCKER
##  include	        EMIT ( IND, I, 0 );
##  include	        EMIT ( ALO, INTEGER ( -1 ) );
##  include	        EMIT ( STR, A, 0, FUN_RESULT_OFFSET );		--| STOCKER L ADRESSE DE L ALLOCATION
##  include	      END IF;
##  include	    END IF;
##  call	item_s	@ as_ITEM_S	block_body		--| TRAITER LES DECLARATIONS
##  include	    DECLARE
##  include	      EXC_LBL : LABEL_TYPE := NEXT_LABEL;		--| ALLOUER UNE ETIQUETTE POUR LE DEBUT DES HANDLERS EXCEPTION
##  include	    BEGIN
##  include	      EMIT ( EXH, EXC_LBL, COMMENT=> "EXCEPTION HANDLERS" );	--| DECLARER UNE ETIQUETTE POUR LES HANDLERS EXCEPTION (PEUT Y AVOIR DES RAISE DANS LES INSTRUCTIONS SUIVANTES)
##  call	stm_s	@ as_STM_S	block_body		--| TRAITER LES INSTRUCTIONS
##  include	      WRITE_LABEL ( LABEL_TYPE ( DI ( CD_RETURN_LABEL, BLOCK_BODY ) ) );	--| ETIQUETTE DU RETOUR
-- CG_Param.COPY_OUT_PARAMS ( params );				--| COPIER LES PARAMETRES DE SORTIE
##  include	      EMIT ( RET, PARAM_SIZE );			--| EMETTRE L INSTRUCTION RETURN
##  include	      WRITE_LABEL ( EXC_LBL );			--| PLACER L ETIQUETTE DES HANDLERS
##  include	    END;
##  include	    IF NOT IS_EMPTY ( LIST ( D ( AS_ALTERNATIVE_S, BLOCK_BODY ) ) ) THEN	--| S IL Y A UNE LISTE DE HANDLERS
##  call	alternative_s	@ as_ALTERNATIVE_S	block_body		--| TRAITER LES HANDLERS
##  include	    ELSE				--| SINON
##  include	      EMIT ( EEX );				--| SIMPLEMENT EMETTRE UN MARQUEUR DE FIN DES HANDLERS EXCEPTION
##  include	    END IF;
##  include	    GEN_LBL_ASSIGNMENT ( ENT_1_LBL, EMITS.OFFSET_MAX );		--| DONNER LES VALEURS AUX ETIQUETTES DES ENTER BLOCKS
##  include	    GEN_LBL_ASSIGNMENT ( ENT_2_LBL, EMITS.OFFSET_MAX + EMITS.TOP_MAX );
##  include	  END;
##  include	  EMITS.TOP_MAX := OLD_TOP_MAX;			--| RESTAURER LES OFFSETS ANTERIEURS
##  include	  EMITS.TOP_ACT := OLD_TOP_ACT;
##  include	  ENCLOSING_BODY := SAVE_ENCLOSING_BODY;		--| ET L ENGLOBANT PRECEDENT
##  include	END;



--|-------------------------------------------------------------------------------------------------
-- 5.7	Exit Statements
-- Syntax 5.7
--  exit_statement ::=
--     exit [loop_name] [when condition] ;
--|-------------------------------------------------------------------------------------------------

exit_statement	::= 
	EXIT  [expanded_name]  [WHEN__condition]  ;		====> exch_1 $2 exit
	%%
--|.................................................................................................
[WHEN__condition]	::=
	empty				====> void
	| WHEN  expression
	%%
--|.................................................................................................

--|.................................................................................................
//  exit		=>
//	sm_stm	: STM;
--	as_exp	:EXP
--	as_name	:NAME
--	lx_srcpos	:Source_Position

##  exit	====>

##  include	DECLARE
##  include	  LVB_LBL          : LABEL_TYPE;
##  include	  EXP              : TREE := D ( AS_EXP, ada_exit );		--| AMENER L EXPRESSION EVENTUELLE DE CONDITION DE SORTIE
##  include	  LOOP_STM         : TREE := D ( SM_STM, ada_exit );		--| AMENER L INSTRUCTION BOUCLE DONT ON SORT
##  include	  LOOP_LEVEL       : LEVEL_TYPE := DI ( CD_LEVEL, LOOP_STM );	--| LIRE SON NIVEAU STATIQUE
##  include	  AFTER_LOOP_LABEL : LABEL_TYPE := LABEL_TYPE( DI( CD_AFTER_LOOP, LOOP_STM ) );	--| REPRENDRE LE NUMERO D ETIQUETTE DE FIN DE BOUCLE
##  include	BEGIN
##  include	  IF EXP = TREE_VOID THEN			--| PAS D EXPRESSION DONC EXIT SANS CONDITION (SANS WHEN)
##  include	    IF LOOP_LEVEL /= EMITS.LEVEL THEN			--| LE NIVEAU DE LA BOUCLE DIFFERE DU NIVEAU COURANT DE L EXIT (PLUS PROFOND)
##  include	         LVB_LBL := NEXT_LABEL;			--| ALLOUER UNE ETIQUETTE
##  include	         EMIT ( LVB, LVB_LBL, COMMENT=> "NOMBRE DE NIVEAUX REMONTES" );	--| EMETTRE UN LEAVE BLOCK AVEC CETTE ETIQUETTE
##  include	         GEN_LBL_ASSIGNMENT ( LVB_LBL, EMITS.LEVEL - LOOP_LEVEL );	--| QUI A VALEUR LE NOMBRE DE NIVEAUX REMONTES
##  include	    END IF;
##  include	    EMIT ( JMP, AFTER_LOOP_LABEL, COMMENT=> "SORTIE DE BOUCLE" );	--| EMETTRE LE SAUT EN FIN DE BOUCLE

##  include	  ELSE				--| EXIT AVEC CONDITION (AVEC WHEN)
##  call	exp	exp			--| TRAITER L EXPRESSION
##  include	    IF LOOP_LEVEL /= EMITS.LEVEL THEN			--| LE NIVEAU DE LA BOUCLE DIFFERE DU NIVEAU COURANT DE L EXIT (PLUS PROFOND)
##  include	      DECLARE
##  include	        SKIP_LBL : LABEL_TYPE := NEXT_LABEL;		--| ALLOUER UNE ETIQUETTE DE SAUT POUR POURSUITE SI CONDITION FAUSSE
##  include	      BEGIN
##  include	        EMIT ( JMPF, SKIP_LBL, COMMENT=> "PAS D EXIT SI CONDITION FAUSSE" );	--| EMETTRE LE SAUT A CETTE ETIQUETTE
##  include	        LVB_LBL := NEXT_LABEL;			--| ALLOUER UNE ETIQUETTE
##  include	        EMIT ( LVB, LVB_lbl, COMMENT=> "NOMBRE DE NIVEAUX REMONTES" );	--| EMETTRE UN LEAVE BLOCK AVEC CETTE ETIQUETTE
##  include	        GEN_LBL_ASSIGNMENT ( LVB_LBL, EMITS.LEVEL - LOOP_LEVEL );	--| QUI A VALEUR LE NOMBRE DE NIVEAUX REMONTES
##  include	        EMIT ( JMP, AFTER_LOOP_LABEL, COMMENT=> "SORTIE DE BOUCLE" );	--| EMETTRE LE SAUT EN FIN DE BOUCLE
##  include	        WRITE_LABEL ( SKIP_LBL, COMMENT=> "LABEL NO EXIT" );	--| ECRIRE L ETIQUETTE DE CONTOURNEMENT
##  include	      END;
##  include	    ELSE				--| LE NIVEAU DE L EXIT EST CELUI DE LA BOUCLE
##  include	      EMIT ( JMPT, AFTER_LOOP_LABEL );			--| EMETTRE UN SIMPLE SAUT POST FIN DE BOUCLE
##  include	    END IF;
##  include	  END IF;
##  include	END;



--|-------------------------------------------------------------------------------------------------
-- 5.8	Return Statements
-- Syntax 5.8
--  return_statement ::= return [expression] ;
--|-------------------------------------------------------------------------------------------------

return_statement	::=
	RETURN  [expression]  ;			====> $1 return
	%%
--|.................................................................................................


//  return		=> ;

##  return	====>
##  include	DECLARE
##  include	  EXP : TREE := D ( AS_EXP, ADA_RETURN );		--| RAMENER L EXPRESSION RETOURNEE
##  include	BEGIN
##  include	  IF EXP /= TREE_VOID THEN			--| IL Y A UNE EXPRESSION
##  include	STORE_FUNCTION_RESULT:
##  include	    DECLARE
##  include	      ENCLOSING_LEVEL : INTEGER := DI ( CD_LEVEL, EMITS.ENCLOSING_BODY );	--| NIVEAU STATIQUE DE L ENGLOBANT
##  include	      RESULT_OFFSET : INTEGER := DI ( CD_RESULT_OFFSET, EMITS.ENCLOSING_BODY );	--| DECALAGE DU RESULTAT
##  include	      EXPR_TYPE     : TREE := D ( SM_EXP_TYPE, EXP );		--| TYPE DE L EXPRESSION
##  include	    BEGIN
##  include	      IF EXPR_TYPE.TY = DN_ARRAY THEN			--| RETOUR D'UN TABLEAU
##  include	        EMIT ( LDA, EMITS.LEVEL - ENCLOSING_LEVEL, RESULT_OFFSET );
##  call	EXP	exp			--| TRAITER L EXPRESSION
##  include	        EMIT ( LDC, I, EMITS.NUMBER_OF_DIMENSIONS ( EXP ) );	--| EMPILER LE NOMBRE DE DIMENSIONS
##  include	        EMIT ( PUA );			--| APPELER "PUT ARRAY"
                     
##  include	       ELSIF EXPR_TYPE.TY = DN_ENUM_LITERAL_S THEN		--| ENUMERE
##  call	EXP	exp			--| TRAITER L EXPRESSION
##  include	         EMIT ( STR, EMITS.CODE_TYPE_OF ( EXP ), EMITS.LEVEL - ENCLOSING_LEVEL, RESULT_OFFSET );
                     
##  include	       ELSIF EXPR_TYPE.TY = DN_INTEGER THEN
##  call	EXP	exp
##  include	         EMIT ( STR, I, EMITS.LEVEL - ENCLOSING_LEVEL, RESULT_OFFSET );
##  include	       END IF;
##  include	     END STORE_FUNCTION_RESULT;
##  include	   END IF;
##  include	   EMITS.PERFORM_RETURN ( EMITS.ENCLOSING_BODY );		--| EFFECTUER LE RETOUR PROPREMENT DIT
##  include	end;



--|-------------------------------------------------------------------------------------------------
-- 5.9	Goto Statements
-- Syntax 5.9
--  goto_statement ::= goto label_name;
--|-------------------------------------------------------------------------------------------------

goto_statement	::=
	GOTO  expanded_name  ;			====> $1 goto
	%%
--|.................................................................................................


//  goto		=> ;

##  goto	====>
##	include	null;



--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-- 6.  Subprograms
--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-- 6.1	Subprogram Declarations
-- Syntax 6.1.A
--  subprogram_declaration ::= subprogram_specification;
--|-------------------------------------------------------------------------------------------------

subprogram_declaration	::=
	subprogram_specification  ;			====> void $3 subprog_entry_decl
	%%
--|.................................................................................................
proc_id	::=
	identifier				====> $0 procedure_id lx_symrep
	%%
--|.................................................................................................
function_id	::=
	identifier				====> $0 function_id lx_symrep
	%%
--|.................................................................................................
def_op	::=
	string_literal				====> $0 operator_id lx_symrep
	%%
--|.................................................................................................


//  subprog_entry_decl	=>;
--	as_source_name	:SOURCE_NAME
--	as_header	:HEADER
--	as_unit_kind	:UNIT_KIND
--	lx_srcpos	:Source_Position

##  subprog_entry_decl	====>			--| DECLARATION DE SOUS PROGRAMME
##  include	DECLARE
##  include	  OLD_OFFSET_ACT : OFFSET_TYPE := EMITS.OFFSET_ACT;		--| GARER LES OFFSETS DU NIVEAU SUPERIEUR
##  include	  OLD_OFFSET_MAX : OFFSET_TYPE := EMITS.OFFSET_MAX;
##  include	  SOURCE_NAME    : TREE        := D ( AS_SOURCE_NAME, SUBPROG_ENTRY_DECL );	--| RAMENER LE NOEUD NOM DU SOUS PROGRAMME
##  include	  HEADER         : TREE        := D ( AS_HEADER, SUBPROG_ENTRY_DECL );	--| RAMENER L ENTETE DE PARAMETRAGE
##  include	BEGIN
##  include	  EMITS.OFFSET_ACT := EMITS.FIRST_PARAM_OFFSET;		--| OFFSET DU PREMIER PARAMETRE COMME OFFSET DE PILE ACTUEL
##  include	  EMITS.OFFSET_MAX := EMITS.OFFSET_ACT;			--| OFFSET MAX MIS A L OFFSET ACTUEL
##  include	  INC_LEVEL;				--| NIVEAU STATIQUE SUIVANT

##  include	  IF SOURCE_NAME.TY IN CLASS_SUBPROG_NAME THEN
##  include	    DECLARE
##  include	      LBL : LABEL_TYPE := NEXT_LABEL;			--| ALLOUER UNE ETIQUETTE POUR LE SOUS PROGRAMME
##  include	    BEGIN
##  include	      DI ( CD_LABEL, SOURCE_NAME, INTEGER ( LBL ) );		--| INTEGRER CETTE ETIQUETTE AU NOM DU SOUS PROGRAMME
##  include	      DI ( CD_LEVEL, SOURCE_NAME, EMITS.LEVEL );		--| MENTIONNER AUSSI LE NIVEAU STATIQUE
##  include	      DB ( CD_COMPILED, SOURCE_NAME, TRUE );		--| INDIQUER QUE L ON VA AVOIR COMPILE CETTE DECLARATION
##  include	      IF NOT EMITS.GENERATE_CODE THEN			--| SI PAS DE GENERATION DE CODE
##  include	        EMITS.GENERATE_CODE := TRUE;			--| LA METTRE QUAND MEME
##  include	        EMIT ( RFL, LBL );			--| POUR EMETTRE CETTE REFERENCE D ETIQUETTE
##  include	        EMITS.GENERATE_CODE := FALSE;			--| ET REMETTRE COMME AVANT
##  include	      END IF;

##  call	HEADER	@ as_header	subprog_entry_decl		--| TRAITER L ENTETE DE PARAMETRAGE

##  include	      DI ( CD_PARAM_SIZE, SOURCE_NAME, OFFSET_ACT - FIRST_PARAM_OFFSET );	--| APRES TRAITEMENT DE L ENTETE ON A LA TAILLE DU PARAMETRAGE QUE L ON STOCKE
##  include	    END;

##  include	    IF SOURCE_NAME.TY = DN_FUNCTION_ID OR SOURCE_NAME.TY = DN_OPERATOR_ID THEN	--| SI L ON A UNE FONCTION OU UN OPERATEUR (QUI ONT UN RESULTAT)
##  include	      DECLARE
##  include	        USED_OBJECT_ID   : TREE := D ( AS_NAME, HEADER );		--| RAMENER LE CHAMP AS_NAME DE L ENTETE DE PARAMETRAGE
##  include	        RESULT_TYPE_SPEC : TREE := D ( SM_EXP_TYPE, USED_OBJECT_ID );	--| RAMENER SON TYPE
##  include	      BEGIN
##  include	        DI ( CD_RESULT_SIZE, SOURCE_NAME, EMITS.TYPE_SIZE( RESULT_TYPE_SPEC ));	--| STOCKER LA TAILLE DU TYPE RESULTAT
##  include	      END;
##  include	    END IF;
##  include	  END IF;

##  include	  DEC_LEVEL;				--| REVENIR AU NIVEAU STATIQUE PRECEDENT
##  include	  EMITS.OFFSET_MAX := OLD_OFFSET_MAX;			--| REGENERER LES OFFSETS DU NIVEAU PRECEDENT
##  include	  EMITS.OFFSET_ACT := OLD_OFFSET_ACT;
##  include	END;
--|.................................................................................................
//  UNIT_NAME		::=
//	NON_TASK_NAME;
--|.................................................................................................
//  NON_TASK_NAME		::=
//	SUBPROG_PACK_NAME;
//  NON_TASK_NAME		=>
//	sm_spec	: HEADER,
//	xd_stub	: stub,
//	xd_body	: SUBUNIT_BODY;

##  NON_TASK_NAME	====>
##	if	generic_id
##	call	generic_id	NON_TASK_NAME
##	if_class	SUBPROG_PACK_NAME
##	call	SUBPROG_PACK_NAME	NON_TASK_NAME
--|.................................................................................................
//  SUBPROG_PACK_NAME	::=
//	SUBPROG_NAME;
//  SUBPROG_PACK_NAME	=>
//	sm_unit_desc	: UNIT_DESC,
//	sm_address	: EXP,
//	cd_compiled	: BOOLEAN;

##  SUBPROG_PACK_NAME	====>
##	if	package_id
##	call	package_id	SUBPROG_PACK_NAME
##	if_class	SUBPROG_NAME
##	call	SUBPROG_NAME	SUBPROG_PACK_NAME
--|.................................................................................................
//  SUBPROG_NAME		::=
//	procedure_id | function_id | operator_id;
//  SUBPROG_NAME		=>
//	sm_is_inline	: BOOLEAN,
//	sm_interface	: PREDEF_NAME,
//	cd_level	: Integer,
//	cd_label	: Integer,
//	cd_param_size	: Integer;

##  SUBPROG_NAME	====>
##	if	procedure_id
##	call	procedure_id	SUBPROG_NAME
##	if	function_id
##	call	function_id	SUBPROG_NAME
##	if	operator_id
##	call	operator_id	SUBPROG_NAME
--|.................................................................................................
//  UNIT_DESC		::=
//	UNIT_KIND | BODY | implicit_not_eq | derived_subprog;
--|.................................................................................................
//  derived_subprog		=>
//	sm_derivable	: SOURCE_NAME;
--|.................................................................................................
//  implicit_not_eq		=>
//	sm_equal	: SOURCE_NAME;
--|.................................................................................................
//  procedure_id		=> ;

##  procedure_id	====>
##	include	null;
--|.................................................................................................
//  function_id		=>
//	cd_result_size	: Integer;

##  function_id	====>
##	include	null;
--|.................................................................................................
//  operator_id		=>
//	xd_not_equal	: operator_id;			-- "/=" corresponding to "="

##  operator_id	====>
##	include	null;
--|.................................................................................................




--|-------------------------------------------------------------------------------------------------
-- Syntax 6.1.B
--  subprogram_specification ::=
--	 procedure identifier [formal_part]
--     | function designator [formal_part] return type_mark
--
--  designator ::= identifier | operator_symbol
--
--  operator_symbol ::= string_literal
--|-------------------------------------------------------------------------------------------------

subprogram_specification	::=
	  PROCEDURE  proc_id  procedure_header
	| PROCEDURE  proc_id  nil_procedure_header
	| FUNCTION  function_id  function_header
	| FUNCTION  def_op  function_header
	%%
--|.................................................................................................
procedure_header	::=
	param_s				====> $1 procedure_spec
	%%
--|.................................................................................................
nil_procedure_header	::=
	nil_param_s				====> $1 procedure_spec
	%%
--|.................................................................................................
[param_s]	::=
	  nil_param_s
	| param_s
	%%
--|.................................................................................................
--** nil_param_s is used for generic instantiation
nil_param_s	::=
	empty				====> nil $L param_s
	%%
--|.................................................................................................
param_s	::=
	(  parameter_specification{;parameter_specification}  )		====> $L param_s
	%%
--|.................................................................................................
function_header	::=
	[param_s]  RETURN  type_mark			====> $2 function_spec
	%%
--|.................................................................................................
operator_symbol	::=
	used_string
	%%
--|.................................................................................................


//  HEADER		::=
//	SUBP_ENTRY_HEADER;

##  HEADER	====>
##	if_class	SUBP_ENTRY_HEADER
##	call	param_s	@ as_param_s	HEADER
##	call	SUBP_ENTRY_HEADER	HEADER
##	if	package_spec
##	call	package_spec	HEADER
--|.................................................................................................
//  SUBP_ENTRY_HEADER	::=
//	procedure_spec | function_spec;
//  SUBP_ENTRY_HEADER	=>
//	as_param_s	: param_s;

##  SUBP_ENTRY_HEADER	====>
##	if	procedure_spec
##	call	procedure_spec	SUBP_ENTRY_HEADER
##	if	function_spec
##	call	function_spec	SUBP_ENTRY_HEADER
--|.................................................................................................
//  procedure_spec		=> ;
--	as_param_s	:param_s
--	lx_srcpos	:Source_Position

##  procedure_spec	====>
##  include	EMITS.PARAM_SIZE := (EMITS.OFFSET_ACT - EMITS.FIRST_PARAM_OFFSET + EMITS.RELATIVE_RESULT_OFFSET);

--|.................................................................................................
//  function_spec		=>
//	as_name	: NAME;
--	as_param_s	:param_s
--	lx_srcpos	:Source_Position

##  function_spec	====>
##  include	INC_OFFSET ( EMITS.RELATIVE_RESULT_OFFSET );
##  include	EMITS.PARAM_SIZE := ( EMITS.OFFSET_ACT - EMITS.FIRST_PARAM_OFFSET );
-- ##  include	EMITS.RESULT_SIZE := EMITS.TYPE_SIZE ( RESULT_TYPE_SPEC );		--| A VOIR
##  include	DI ( CD_RESULT_SIZE, D ( AS_NAME, FUNCTION_SPEC ), EMITS.RESULT_SIZE );
##  include	INC_OFFSET ( EMITS.RESULT_SIZE );
##  include	ALIGN ( STACK_AL );
##  include	DI ( CD_RESULT_OFFSET, FUNCTION_SPEC, EMITS.OFFSET_ACT );
##  include	EMITS.FUN_RESULT_OFFSET := EMITS.OFFSET_ACT;



--|-------------------------------------------------------------------------------------------------
-- Syntax 6.1.C
--  formal_part ::=
--     (parameter_specification {; parameter_specification})
--
--  parameter_specification ::=
--     identifier_list : mode type_mark [:= expression]
--
--  mode  ::= [in] | in out | out
--|-------------------------------------------------------------------------------------------------
parameter_specification	::=
	  in_specification
	| in_out_specification
	| out_specification
	%%
--|.................................................................................................
in_specification	::=
	  identifier  :  in_definition			====> $DEF in_id lx_default
	| identifier  :  IN  in_definition			====> $DEF in_id not_lx_default
	| identifier  ,  in_specification			====> $DEF in_id
	%%
--|.................................................................................................
in_definition	::=
	subtype_indication  [:=expression]			====> $N3 in
	%%
--|.................................................................................................
in_out_specification	::=
	  identifier  :  IN OUT  in_out_definition		====> $DEF in_out_id
	| identifier  ,  in_out_specification			====> $DEF in_out_id
	%%
--|.................................................................................................
in_out_definition		::=
	subtype_indication				====> void $N3 in_out
	%%
--|.................................................................................................
out_specification	::=
	  identifier  :  OUT  out_definition			====> $DEF out_id
	| identifier  ,  out_specification			====> $DEF out_id
	%%
--|.................................................................................................
out_definition	::=
	subtype_indication				====> void $N3 out
	%%
--|.................................................................................................


//  param_s		=>
//	as_list	: Seq Of PARAM;

##  param_s	====>
##	repeat_extract	param_s	param
##	call	param	param
--|.................................................................................................
//  DSCRMT_PARAM_DECL	::=
//	PARAM;
--|.................................................................................................
//  PARAM		::=
//	in | out | in_out;

##  PARAM	====>
##	if	in
##	call	in	PARAM
##	if	out
##	call	out	PARAM
##	if	in_out
##	call	in_out	PARAM

--|.................................................................................................
//  in		=>
//	lx_default	: BOOLEAN;
--	as_source_name_s	:source_name_s
--	as_name	:NAME
--	as_exp	:EXP
--	lx_srcpos	:Source_Position

##  in	====>
##	include	null;
--|.................................................................................................
//  in_out		=> ;

##  in_out	====>
##	include	null;

//  out		=> ;

##  out	====>
##	include	null;
--|.................................................................................................
//  INIT_OBJECT_NAME	::=
//	PARAM_NAME;

##  INIT_OBJECT_NAME	====>
##	if	number_id
##	call	number_id	INIT_OBJECT_NAME
##	if_class	VC_NAME
##	call	VC_NAME	INIT_OBJECT_NAME
##	if_class	COMP_NAME
##	call	COMP_NAME	INIT_OBJECT_NAME
##	if_class	PARAM_NAME
##	call	PARAM_NAME	INIT_OBJECT_NAME
--|.................................................................................................
//  PARAM_NAME		::=
//	in_id | PARAM_IO_O;
//  PARAM_NAME		=>
//	sm_first	: DEF_NAME,
//	cd_level	: Integer;

##  PARAM_NAME	====>
##	if	in_id
##	call	in_id	PARAM_NAME
##	if_class	PARAM_IO_O
##	call	PARAM_IO_O	PARAM_NAME
--|.................................................................................................
//  PARAM_IO_O		::=
//	in_out_id | out_id;
//  PARAM_IO_O		=>
//	cd_addr_offset	: Integer,
//	cd_val_offset	: Integer;

##  PARAM_IO_O	====>
##	if	in_out_id
##	call	in_out_id	PARAM_IO_O
##	if	out_id
##	call	out_id	PARAM_IO_O
--|.................................................................................................
//  in_id	=>
//	cd_offset	: Integer;

##  in_id	====>
##	include	null;
--|.................................................................................................
//  in_out_id	=> ;

##  in_out_id	====>
##	include	null;
--|.................................................................................................
//  out_id	=> ;

##  out_id	====>
##	include	null;



--|-------------------------------------------------------------------------------------------------
-- 6.3	Subprogram Bodies
-- Syntax 6.3
--  subprogram_body ::=
--	subprogram_specification is
--	    [declarative_part]
--	begin
--	    sequence_of_statements
--     [exception
--	exception_handler
--	    {exception_handler}]
--	end [designator];
--|-------------------------------------------------------------------------------------------------

subprogram_body	::=
	  PROCEDURE  proc_id  procedure_header  subprogram_block		====> exch_1 $3 subprogram_body
	| PROCEDURE  proc_id  nil_procedure_header  subprogram_block	====> exch_1 $3 subprogram_body
	| FUNCTION  function_id  function_header  subprogram_block		====> exch_1 $3 subprogram_body
	| FUNCTION  def_op  function_header  subprogram_block		====> exch_1 $3 subprogram_body
	%%
--|.................................................................................................
subprogram_block	::=
	IS  declarative_part  BEGIN  sequence_of_statements
	[EXCEPTION__exception_handler{exception_handler}]
	END__[designator]  ;			====> $3 block_body
	%%
--|.................................................................................................
END__[designator]	::=
	END
	| END  identifier				====> check_subp_name
	| END  string_literal			====> check_subp_name
	%%
--|.................................................................................................


//  BODY		::=
//	block_body | stub;
##  BODY	====>
##	if	block_body
##	call	block_body	BODY
--|.................................................................................................
//  subprogram_body		=>
//	as_header	: HEADER;
--	as_source_name	:SOURCE_NAME
--	as_body	:BODY
--	lx_srcpos	:Source_Position

##  subprogram_body	====>

##  include	DECLARE
##  include	   OLD_OFFSET_ACT : OFFSET_TYPE := EMITS.OFFSET_ACT;		--| GARER LES DECALAGES DE L ENGLOBANT
##  include	   OLD_OFFSET_MAX : OFFSET_TYPE := EMITS.OFFSET_MAX;
##  include	   SOURCE_NAME    : TREE := D ( AS_SOURCE_NAME, SUBPROGRAM_BODY );	--| RAMENER LE NOM DE SOUS PROGRAMME
##  include	   START_LABEL    : LABEL_TYPE := NEXT_LABEL;		--| ALLOUER UNE ETIQUETTE DE POINT D ENTREE
##  include	BEGIN
##  include	  IF EMITS.ENCLOSING_BODY = TREE_VOID THEN		--| Au niveau externe (pas d'imbrication)
##  include	    EMIT ( PRO, S=> PRINT_NAME ( D ( LX_SYMREP, SOURCE_NAME ) ) );	--| Indiquer la mention "PRO"
##  include	  END IF;
##  include	  EMITS.OFFSET_ACT := EMITS.FIRST_PARAM_OFFSET;		--| LIEU DU PREMIER PARAMETRE COMME DECALAGE ACTUEL
##  include	  EMITS.OFFSET_MAX := EMITS.OFFSET_ACT;			--| ET DECALAGE MAXIMAL ACTUEL
##  include	  INC_LEVEL;				--| NIVEAU STATIQUE SUIVANT
##  include	  DI ( CD_LABEL, SOURCE_NAME, INTEGER ( START_LABEL ) );		--| STOCKER LE NUMERO D ETIQUETTE ENTREE
##  include	  DI ( CD_LEVEL, SOURCE_NAME, EMITS.LEVEL );		--| STOCKER LE NIVEAU STATIQUE
##  include	  WRITE_LABEL ( START_LABEL );			--| EMETTRE L ETIQUETTE ENTREE
##  call	HEADER	@ as_header	subprogram_body		--| TRAITER LES PARAMETRES D APPEL
##  include	  DI ( CD_PARAM_SIZE, SOURCE_NAME, PARAM_SIZE );		--| STOCKER LA TAILLE DU PARAMETRAGE MAINTENANT CONNUE
##  include	  EMITS.OFFSET_ACT := EMITS.FIRST_LOCAL_VAR_OFFSET;		--| REPLACER LES OFFSETS SUR LA PREMIERE VARIABLE LOCALE
##  include	  EMITS.OFFSET_MAX := EMITS.OFFSET_ACT;
##  call	BODY	@ as_BODY	subprogram_body		--| TRAITER LE CORPS DE SOUS PROGRAMME
##  include	  DEC_LEVEL;				--| REVENIR AU NIVEAU PRECEDENT
##  include	  EMITS.OFFSET_MAX := OLD_OFFSET_MAX;			--| RESTAURER LES OFFSETS ANTERIEURS
##  include	  EMITS.OFFSET_ACT := OLD_OFFSET_ACT;
##  include	END;


--|-------------------------------------------------------------------------------------------------
-- 6.4	Subprogram Calls
-- Syntax 6.4
--  procedure_call_statement ::=
--     procedure_name [actual_parameter_part];
--
--  function_call ::=
--     function_name [actual_parameter_part]
--
--  actual_parameter_part ::=
--     (parameter_association {, parameter_association})
--
--  parameter_association ::=
--     [formal_parameter	=>] actual_parameter
--
--  formal_parameter ::= parameter_simple_name
--
--  actual_parameter ::=
--     expression | variable_name | type_mark(variable_name)
--|-------------------------------------------------------------------------------------------------

procedure_call_statement	::=
	used_id  ;				====> nil $L general_assoc_s $2 procedure_call
	| selected_component  ;			====> nil $L general_assoc_s $2 procedure_call
	| name  general_assoc_s  ;			====> $2 procedure_call
	%%
--|.................................................................................................
function_call	::=
	name
	%%
--|.................................................................................................
apply	::=
	name  general_assoc_s			====> $2 function_call
	%%
--|.................................................................................................
general_assoc_s	::=
	(  general_assoc{,general_assoc}  )			====> $L general_assoc_s
	%%
--|.................................................................................................
general_assoc	::=
	argument_association
	| simple_expression  ..  simple_expression		====> $2 range
	| name range_constraint			====> exch_1 $2 subtype_indication
	%%
--|.................................................................................................


//  CALL_STM		=> 
//	as_general_assoc_s		: general_assoc_s,
//	sm_normalized_param_s	: exp_s;
--|.................................................................................................
//  procedure_call		=> ;

##  procedure_call	====>
##	include	null;
--|.................................................................................................
//  function_call		=>
//	as_general_assoc_s		: general_assoc_s,
//	sm_normalized_param_s	: exp_s,
//	lx_prefix		: BOOLEAN;

##  function_call	====>
##	include	null;
--|.................................................................................................
//  NAMED_ASSOC		::=
//	assoc;
--|.................................................................................................
//  assoc		=>
//	as_used_name	: USED_NAME;



--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-- 7.  Packages
--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-- 7.1	Package Structure
-- Syntax 7.1.A
--  package_declaration ::= package_specification;
--|-------------------------------------------------------------------------------------------------

//  package_decl		=> ;
--	as_source_name	:SOURCE_NAME
--	as_header	:HEADER
--	as_unit_kind	:UNIT_KIND
--	lx_srcpos	:Source_Position

##  package_decl	====>
##  include	EMIT ( PKG, S=> PRINT_NAME ( D ( LX_SYMREP, D ( AS_SOURCE_NAME, PACKAGE_DECL ) ) ) );
##  include	WRITE_LABEL ( 1 );
##  include	DECLARE
##  include	  L1 : LABEL_TYPE := NEXT_LABEL;
##  include	  L2 : LABEL_TYPE := NEXT_LABEL;
##  include	BEGIN
##  include	  EMIT ( ENT, Integer( 1 ), L1 );			--| DEUX ENTER LABELS POUR LES VALEURS DE PILE MAX AFFECTEES EN FIN
##  include	  EMIT ( ENT, Integer( 2 ), L2 );
##  include	  EMITS.OFFSET_ACT := 0;			--| RAZ DES OFFSETS
##  include	  EMITS.OFFSET_MAX := 0;
##  call	HEADER	@ as_header	package_decl		--| ACTION HEADER SUR CHAMP AS_HEADER
##  include	  DECLARE
##  include	    EXC_LBL : LABEL_TYPE := NEXT_LABEL;			--| ETIQUETTE DE DEBUT DU HANDLER EXCEPTIONS
##  include	  BEGIN
##  include	    EMIT ( EXH, EXC_LBL, COMMENT=> "ETIQUETTE EXCEPTION HANDLE DU PACKAGE" );
##  include	    EMIT ( RET, RELATIVE_RESULT_OFFSET );
##  include	    WRITE_LABEL ( EXC_LBL );
##  include	  END;
##  include	  EMIT ( EEX );				--| FIN DE HANDLER EXCEPTIONS
##  include	  GEN_LBL_ASSIGNMENT ( L1, OFFSET_MAX );		--| OFFSET MAX ASSIGNE AU LABEL L1
##  include	  GEN_LBL_ASSIGNMENT ( L2, TOP_MAX + OFFSET_MAX );		--| PILE MAX ASSIGNE AU LABEL L2
##  include	END;
--|.................................................................................................
//  SUBPROG_PACK_NAME	::=
//	package_id;
--|.................................................................................................
//  package_id		=> ;

##  package_id	====>
##	include	null;



--|-------------------------------------------------------------------------------------------------
-- Syntax 7.1.B
--  package_specification ::=
--     package identifier is
--	    {basic_declarative_item}
--     [private
--	    {basic_declarative_item}]
--     end [package_simple_name]
--|-------------------------------------------------------------------------------------------------

package_declaration	::=
	PACKAGE  package_id  package_definition  END__[simple_name]  ;	====> void $3 package_decl
	%%
--|.................................................................................................
package_id	::=
	identifier				====> $0 package_id lx_symrep
	%%
--|.................................................................................................
package_definition	::=
	IS  decl_s  [PRIVATE__decl_s]			====> $2 package_spec
	%%
--|.................................................................................................
[PRIVATE__decl_s]	::=
	  empty				====> nil $L decl_s
	| PRIVATE  decl_s
	%%
--|.................................................................................................
decl_s	::=
	{pragma}  {basic_declarative_item{pragma}}		====> cat $L decl_s
	%%
--|.................................................................................................
END__[simple_name]	::=
	  END
	| END  identifier				====> check_name
	%%
--|.................................................................................................


//  package_spec		=>
//	as_decl_s1	: decl_s,
//	as_decl_s2	: decl_s,
//   	xd_body_is_required	: BOOLEAN;

##  package_spec	====>
##	call	decl_s	@ as_decl_s1	package_spec
--|.................................................................................................
//  decl_s		=>
//	as_list	: Seq Of DECL;

##  decl_s	====>
##	repeat_extract	decl_s	decl
##	call	DECL	decl



--|-------------------------------------------------------------------------------------------------
-- Syntax 7.1.C
--  package_body ::=
--	package body package_simple_name is
--	    [declarative_part]
--     [begin
--	 sequence_of_statements
--     [exception
--	exception_handler
--	    {exception_handler}]]
--	end [package_simple_name];
--|-------------------------------------------------------------------------------------------------

package_body	::=
	PACKAGE  BODY  package_id  package_block		====> $2 package_body
	%%
--|.................................................................................................
package_block	::=
	  IS  declarative_part  BEGIN  sequence_of_statements
	  [EXCEPTION__exception_handler{exception_handler}]
	  END__[designator]  ;			====> $3 block_body
	| IS  declarative_part  END__[designator]  ;		====> nil $L stm_s nil $L alternative_s $3 block_body
	%%
--|.................................................................................................


//  package_body		=> ;

##  package_body	====>
##  include	EMIT ( PKB, S=> PRINT_NAME ( D ( LX_SYMREP, D ( AS_SOURCE_NAME, PACKAGE_BODY ) ) ) );
##  include	EMITS.GENERATE_CODE := FALSE;
##  call	package_spec	@ sm_spec @ as_source_name package_body
##  include	EMITS.GENERATE_CODE := TRUE;
##  include	WRITE_LABEL ( 1 );
##  call	BODY	@ as_body  package_body



--|-------------------------------------------------------------------------------------------------
-- 7.4	Private Type and Deferred Constant Declarations
-- Syntax 7.4.A
--  private_type_declaration ::=
--     type identifier [discriminant_part] is [limited] private;
--|-------------------------------------------------------------------------------------------------

private_type_declaration	::=
	  TYPE  identifier	[discriminant_part]__IS  LIMITED  PRIVATE  ;	====> $0 l_private_def $V3 type_decl $DEF l_private_type_id
	| TYPE  identifier	[discriminant_part]__IS  PRIVATE  ;		====> $0 private_def $V3 type_decl $DEF private_type_id
	%%
--|.................................................................................................
[discriminant_part]__IS	::=
	  IS				====> nil $L dscrmt_decl_s
	| discriminant_part  IS
	%%
--|.................................................................................................


//  TYPE_DEF		::=
//	private_def | l_private_def;
--|.................................................................................................
//  private_def		=> ;
--|.................................................................................................
//  l_private_def		=> ;
--|.................................................................................................
//  TYPE_NAME		::=
//	private_type_id | l_private_type_id;
--|.................................................................................................
//  private_type_id		=> ;

##  private_type_id	====>
##	include	null;
--|.................................................................................................
//  l_private_type_id	=> ;

##  l_private_type_id	====>
##	include	null;
--|.................................................................................................
//  PRIVATE_SPEC		::=
//	private | l_private;
//  PRIVATE_SPEC		=>
//	sm_discriminant_s	: dscrmt_decl_s,
//	sm_type_spec	: TYPE_SPEC;
--|.................................................................................................
//  private		=> ;
--|.................................................................................................
//  l_private		=> ;



--|-------------------------------------------------------------------------------------------------
-- Syntax 7.4.B
--  deferred_constant_declaration ::=
--     identifier_list : constant type_mark;
--|-------------------------------------------------------------------------------------------------
--** See 3.2.A

//  deferred_constant_decl	=>
//	as_name	: NAME;

##  deferred_constant_decl	====>
##	include	null;



--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-- 8.  Visibility Rules
--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-- 8.4	Use Clauses
-- Syntax 8.4
--  use_clause ::= use package_name {, package_name};
--|-------------------------------------------------------------------------------------------------

use_clause	::=
	USE  expanded_name{,expanded_name}  ;			====> $L name_s $1 use
	%%
--|.................................................................................................


//  use		=>
//	as_name_s	: name_s;



--|-------------------------------------------------------------------------------------------------
-- 8.5	Renaming Declarations
-- Syntax 8.5
--  renaming_declaration ::=
--	 identifier : type_mark    renames object_name;
--     | identifier : exception    renames exception_name;
--     | package identifier	   renames package_name;
--     | subprogram_specification  renames subprogram_or_entry_name;
--|-------------------------------------------------------------------------------------------------

renaming_declaration ::=
	  identifier  :  renamed_var_definition  ;		====> $DEF variable_id
	| identifier  :  renamed_exception_definition  ;		====> $DEF exception_id
	| PACKAGE  package_id  renames_unit  ;			====> void exch_1 $3 package_decl
	| subprogram_specification  renames_unit  ;		====> $3 subprog_entry_decl
	%%
--|.................................................................................................
--** var_id will be replaced by const_id if necessary

renamed_var_definition	::=
	type_mark  RENAMES  name			====> exch_1 $V3 renames_obj_decl
	%%
--|.................................................................................................
renamed_exception_definition	::=
	EXCEPTION  RENAMES  name			====> $V2 renames_exc_decl
	%%
--|.................................................................................................
renames_unit	::=
	RENAMES  name				====> $1 renames_unit
	%%
--|.................................................................................................


//  ID_DECL		::=
//	SIMPLE_RENAME_DECL;
--|.................................................................................................
//  SIMPLE_RENAME_DECL	::=
//	renames_obj_decl | renames_exc_decl;
//  SIMPLE_RENAME_DECL	=>
//	as_name	: NAME;
--|.................................................................................................
//  renames_obj_decl	=>
//	as_type_mark_name	: NAME;
--|.................................................................................................
//  renames_exc_decl	=> ;
--|.................................................................................................
//  UNIT_KIND		::=
//	RENAME_INSTANT;
--|.................................................................................................
//  RENAME_INSTANT		::=
//	renames_unit;
//  RENAME_INSTANT		=>
//	as_name	: NAME;
--|.................................................................................................
//  renames_unit		=> ;



--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-- 9.  Tasks
--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-- 9.1	Task Specifications and Task Bodies
-- Syntax 9.1.A
--  task_declaration ::= task_specification;
--
--  task_specification ::=
--     task [type] identifier [is
--	    {entry_declaration}
--	    {representation_clause}
--     end [task_simple_name]]
--|-------------------------------------------------------------------------------------------------

task_declaration	::=
	  TASK  TYPE  type_id  task_spec  ;			====> $2 task_decl
	| TASK  variable_id  task_spec  ;			====> $2 task_decl
	%%
--|.................................................................................................
task_spec	::=
	  empty				====> nil $L decl_s
	| IS  entry_list  END__[simple_name]
--** ??? Need to check all the END__[...]'s
	%%
--|.................................................................................................
type_id	::=
	identifier				====> $0 type_id lx_symrep
	%%
--|.................................................................................................
variable_id	::=
	identifier				====> $0 variable_id lx_symrep
	%%
--|.................................................................................................
entry_list	::=
	{pragma}  {entry_declaration{pragma}}  {representation_clause{pragma}}	====> cat cat $L decl_s
	%%
--|.................................................................................................


//  task_decl		=>
//	as_decl_s	: decl_s;

##  task_decl	====>
##	include	null;
--|.................................................................................................
//  task_spec		=>
//	sm_decl_s	: decl_s,
//	sm_body	: BODY,
//	sm_address	: EXP,
//	sm_size	: EXP,
//	sm_storage_size	: EXP,
//	xd_stub	: stub,
//	xd_body	: SUBUNIT_BODY;



--|-------------------------------------------------------------------------------------------------
-- Syntax 9.1.B
--  task_body ::=
--	task body task_simple_name is
--	    [declarative_part]
--	begin
--	    sequence_of_statements
--     [exception
--	exception_handler
--	    {exception_handler}]
--	end [task_simple_name];
--|-------------------------------------------------------------------------------------------------

task_body	::=
	TASK  BODY  task_body_id  subprogram_block		====> $2 task_body
	%%
--|.................................................................................................
task_body_id	::=
	identifier				====> $0 task_body_id lx_symrep
	%%
--|.................................................................................................


//  task_body		=> ;

##  task_body	====>
##	include	null;
--|.................................................................................................
//  UNIT_NAME		::=
//	task_body_id;
--|.................................................................................................
//  task_body_id		=>
//	sm_type_spec	: TYPE_SPEC,
//	sm_body	: BODY;

##  task_body_id	====>
##	include	null;



--|-------------------------------------------------------------------------------------------------
-- 9.4 Task Dependence - Termination of Tasks
--|-------------------------------------------------------------------------------------------------

//  ALL_DECL		::=
//	block_master;
--|.................................................................................................
//  block_master		=>
//	sm_stm	: STM;



--|-------------------------------------------------------------------------------------------------
-- 9.5	Entries, Entry Calls and Accept Statements
-- Syntax 9.5.A
--  entry_declaration ::=
--     entry identifier [(discrete_range)] [formal_part];
--|-------------------------------------------------------------------------------------------------

entry_declaration	::=
	ENTRY  entry_id  entry_header  ;			====> void $3 subprog_entry_decl
	%%
--|.................................................................................................
entry_id	::=
	identifier				====> $0 entry_id lx_symrep
	%%
--|.................................................................................................
entry_header	::=
	  [param_s]				====> void $2 entry
	| (  discrete_range  )  [param_s]			====> exch_1 $2 entry

	%%
--|.................................................................................................


//  SUBP_ENTRY_HEADER	::=
//	entry;
--|.................................................................................................
//  entry		=>
//	as_discrete_range	: DISCRETE_RANGE;
--|.................................................................................................
//  SOURCE_NAME	::=
//	entry_id;
--|.................................................................................................
//  entry_id		=>
//	sm_spec	: HEADER,
//	sm_address	: EXP;

##  entry_id	====>
##	include	null;



--|-------------------------------------------------------------------------------------------------
-- Syntax 9.5.B
--  entry_call_statement ::= entry_name [actual_parameter_part];
--|-------------------------------------------------------------------------------------------------

entry_call_statement	::=
	  used_id  ;				====> nil $L general_assoc_s $2 entry_call
	| selected_component  ;			====> nil $L general_assoc_s $2 entry_call
	| name  general_assoc_s  ;			====> $2 entry_call
	%%
--|.................................................................................................


//  entry_call		=> ;

##  entry_call	====>
##	include	null;



--|-------------------------------------------------------------------------------------------------
-- Syntax 9.5.C
--  accept_statement ::=
--     accept entry_simple_name [(entry_index)] [formal_part] [do
--	    sequence_of_statements
--     end [entry_simple_name]];
--
--  entry_index ::= expression
--|-------------------------------------------------------------------------------------------------

accept_statement	::=
	ACCEPT  accept_name__[param_s]
	[DO__sequence_of_statements__END[entry_simple_name]]  ;		====> $3 accept
	%%
--|.................................................................................................
accept_name__[param_s]	::=
	  used_name_id				====> void
	| used_name_id param_s
	| used_name_id__(entry_index)  [param_s]
	%%
--|.................................................................................................
used_name_id__(entry_index)	::=
	used_name_id  (  expression  )			====> list $L exp_s $2 indexed
	%%
--|.................................................................................................
[DO__sequence_of_statements__END[entry_simple_name]]	::=
	  empty				====> nil $L stm_s
	| DO  sequence_of_statements  END__[entry_simple_name]
	%%
--|.................................................................................................
END__[entry_simple_name]	::=
	  END
	| END  identifier 				====> check_accept_name
	%%
--|.................................................................................................


//  accept		=>
//	as_name	: NAME,
//	as_param_s	: param_s,
//	as_stm_s	: stm_s;

##  accept	====>
##	include	null;



--|-------------------------------------------------------------------------------------------------
-- 9.6	Delay Statements, Duration and Time
-- Syntax 9.6
--  delay_statement ::= delay simple_expression;
--|-------------------------------------------------------------------------------------------------

delay_statement	::=
	DELAY  simple_expression  ;			====> $1 delay
	%%
--|.................................................................................................

//  delay		=> ;

##  delay	====>
##	include	null;



--|-------------------------------------------------------------------------------------------------
-- 9.7	Select Statements
-- Syntax 9.7
--  select_statement ::= selective_wait
--     | conditional_entry_call | timed_entry_call
--|-------------------------------------------------------------------------------------------------

select_statement	::=
	selective_wait | conditional_entry_call | timed_entry_call
	%%



--|-------------------------------------------------------------------------------------------------
-- 9.7.1  Selective Waits
-- Syntax 9.7.1.A
--  selective_wait ::=
--	select
--	    select_alternative
--     {or
--	    select_alternative}
--     [else
--	    sequence_of_statements]
--	end select;
-- select_alt_pragma ::= pragma 		====> $1 select_alt_pragma
--** -- parsed as stm_pragma; must be changed in test_clause_elem_s
--|-------------------------------------------------------------------------------------------------

selective_wait	::=
	SELECT  select_clause_s
	[ELSE__sequence_of_statements]
	END  SELECT  ;				====> $2 selective_wait
	%%
--|.................................................................................................
select_clause_s	::=
	select_alternative_list			====> $L test_clause_elem_s
	%%
--|.................................................................................................
select_alternative_list	::=
	select_alternative				====> list
	| {stm_pragma}  when_select_alternative			====> append
	| select_alternative_list  OR  select_alternative		====> append
	| select_alternative_list  OR  {stm_pragma}  when_select_alternative	====> append cat
	%%
--|.................................................................................................
[ELSE__sequence_of_statements]	::=
	  empty				====> nil $L stm_s
	| ELSE  sequence_of_statements
	%%
--|.................................................................................................


//  selective_wait		=> ;

##  selective_wait	====>
##	include	null;



--|-------------------------------------------------------------------------------------------------
-- Syntax 9.7.1.B
--  selective_alternative ::=
--     [when condition	=>]
--	    selective_wait_alternative
--
--  selective_wait_alternative ::= accept_alternative
--     | delay_alternative | terminate_alternative
--
--  accept_alternative ::= accept_statement [sequence_of_statements]
--
--  delay_alternative ::= delay_statement  [sequence_of_statements]
--
--  terminate_alternative ::= terminate;
--|-------------------------------------------------------------------------------------------------

when_select_alternative	::=
	WHEN  expression  =>  selective_wait_alternative		====> $2 select_alternative
	%%
--|.................................................................................................
select_alternative	::=
	| selective_wait_alternative 			====> $V2 select_alternative
	%%
--|.................................................................................................
selective_wait_alternative	::=
	accept_alternative | delay_alternative | terminate_alternative
	%%
--|.................................................................................................
accept_alternative	::=
	accept_statement[sequence_of_statements]
	%%
--|.................................................................................................
delay_alternative ::= delay_statement[sequence_of_statements]

	%%
--|.................................................................................................
terminate_alternative	::=
	{stm_pragma}  terminate  {stm_pragma}			====> insert cat $L stm_s
	%%
--|.................................................................................................
terminate	::=
	TERMINATE  ;				====> $0 terminate
	%%
--|.................................................................................................
accept_statement[sequence_of_statements]	::=
	  {stm_pragma}  accept_statement  {stm_pragma}  stm_s_tail		====> cat insert cat $L stm_s
	| {stm_pragma}  accept_statement			====> append $L stm_s
	%%
--|.................................................................................................
delay_statement[sequence_of_statements]	::=
	  {stm_pragma}  delay_statement  {stm_pragma}  stm_s_tail		====> cat insert cat $L stm_s
	| {stm_pragma}  delay_statement			====> append $L stm_s
	%%
--|.................................................................................................


//  TEST_CLAUSE_ELEM	::=
//	TEST_CLAUSE | select_alt_pragma;

##  TEST_CLAUSE_ELEM	====>
##	if_class	TEST_CLAUSE
##	call	TEST_CLAUSE	TEST_CLAUSE_ELEM
##	if	select_alt_pragma
##	call	select_alt_pragma	TEST_CLAUSE_ELEM
--|.................................................................................................
//  TEST_CLAUSE		::=
//	select_alternative;

--|.................................................................................................
//  test_clause_elem_s	=>
//	as_list	: Seq Of TEST_CLAUSE_ELEM;

##  test_clause_elem_s	====>
##	repeat_extract	test_clause_elem_s	test_clause_elem
##	call	TEST_CLAUSE_ELEM	test_clause_elem
--|.................................................................................................
//  select_alternative	=> ;

##  select_alternative	====>
##	include	null;
--|.................................................................................................
//  select_alt_pragma	=>
//	as_pragma	: pragma;

##  select_alt_pragma	====>
##	include	null;
--|.................................................................................................
//  STM		::=
//	terminate;
--|.................................................................................................
//  terminate		=> ;

##  terminate	====>
##	include	null;



--|-------------------------------------------------------------------------------------------------
-- 9.7.2  Conditional Entry Calls
-- Syntax 9.7.2
--  conditional_entry_call ::=
--     select
--	entry_call_statement
--	    [sequence_of_statements]
--     else
--	    sequence_of_statements
--     end select;
--|-------------------------------------------------------------------------------------------------

conditional_entry_call	::=
	SELECT  entry_call_statement[sequence_of_statements]
	ELSE  sequence_of_statements  END  SELECT  ;		====> $2 cond_entry
	%%
--|.................................................................................................
entry_call_statement[sequence_of_statements]	::=
	  {stm_pragma}  entry_call_statement  {stm_pragma}  stm_s_tail	====> cat insert cat $L stm_s
	| {stm_pragma}  entry_call_statement			====> append $L stm_s
	%%
--|.................................................................................................


//  ENTRY_STM		::=
//	cond_entry | timed_entry;
//  ENTRY_STM		=>
//	as_stm_s1	: stm_s,
//	as_stm_s2	: stm_s;

##  ENTRY_STM	====>
##	if	cond_entry
##	call	cond_entry	ENTRY_STM
##	if	timed_entry
##	call	timed_entry	ENTRY_STM
--|.................................................................................................
//  cond_entry		=> ;

##  cond_entry	====>
##	include	null;



--|-------------------------------------------------------------------------------------------------
-- 9.7.3  Timed Entry Calls

-- Syntax 9.7.3
--  timed_entry_call ::=
--     select
--	entry_call_statement
--	    [sequence_of_statements]
--     or
--	delay_alternative
--     end select;
--|-------------------------------------------------------------------------------------------------

timed_entry_call	::=
	SELECT  entry_call_statement[sequence_of_statements]
	OR  delay_alternative  END  SELECT  ;			====> $2 timed_entry
	%%
--|.................................................................................................


//  timed_entry		=> ;

##  timed_entry	====>
##	include	null;



--|-------------------------------------------------------------------------------------------------
-- 9.10  Abort Statements
-- Syntax 9.10
--  abort_statement ::= abort task_name {, task_name};
--|-------------------------------------------------------------------------------------------------

abort_statement	::=
	ABORT  name_s  ;				====> $1 abort
	%%
--|.................................................................................................
name_s	::=
	name{,name}				====> $L name_s
	%%
--|.................................................................................................


//  name_s		=>
//	as_list	: Seq Of NAME;

##  name_s	====>
##	repeat_extract	name_s	name
##	call	NAME	name
--|.................................................................................................
//  abort		=>
//	as_name_s	: name_s;

##  abort	====>
##	include	null;


--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-- 10.	Program Structure and Compilation Issues
--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-- 10.1  Compilation Units - Library Units
-- Syntax 10.1.A
--  compilation ::= {compilation_unit}
--|-------------------------------------------------------------------------------------------------

compilation	::=
	  pragma_only_unit  {compilation_unit}			====> insert $L compltn_unit_s $1 compilation
	| {compilation_unit}			====> $L compltn_unit_s $1 compilation
	%%
--|.................................................................................................
pragma_only_unit	::=
	null_context  pragma_s			====> $3 compilation_unit
	%%
--|.................................................................................................
null_context	::=
	empty				====> nil $L context_elem_s void
	%%
--|.................................................................................................
--** pragma_only_unit records pragmas at beginning of compilation
--** pragmas at end of compilation_unit are parsed as part of unit


//  compilation		=>
//	as_compltn_unit_s	: compltn_unit_s;

##  compilation	====>				--| Action sur compilation
##	call	compltn_unit_s	@ as_compltn_unit_s compilation	--| Appliquer l'action compltn_unit_s sur le champ as_compltn_unit_s
--|.................................................................................................
//  compltn_unit_s		=>
//	as_list	: Seq Of compilation_unit;

##  compltn_unit_s	====>				--| ACTION SUR LA LISTE DES UNITES DE COMPILATION
##  repeat_extract	compltn_unit_s	compltn_unit			--| EXTRACTION D UN ELEMENT
##  include	EMITS.OPEN_OUTPUT_FILE ( GET_LIB_PREFIX & PRINT_NAME ( D ( XD_LIB_NAME, COMPLTN_UNIT ) ) );
##  call	compilation_unit	compltn_unit			--| ACTION COMPILATION_UNIT SUR L UNITE EXTRAITE
##  include	EMITS.CLOSE_OUTPUT_FILE;			--| FERMER LE FICHIER



--|-------------------------------------------------------------------------------------------------
-- Syntax 10.1.B
--  compilation_unit ::=
--     context_clause library_unit | context_clause secondary_unit
--
--  library_unit ::=
--	 subprogram_declaration| package_declaration
--     | generic_declaration   | generic_instantiation
--     | subprogram_body
--
--  secondary_unit ::= library_unit_body | subunit
--
--  library_unit_body ::= subprogram_body | package_body
--|-------------------------------------------------------------------------------------------------

compilation_unit	::=
	  context_clause  library_unit  [pragma_s]		====> $3 compilation_unit
	| context_clause  secondary_unit  [pragma_s]		====> $3 compilation_unit
	%%
--|.................................................................................................
library_unit	::=
	  subprogram_declaration	| package_declaration
	| generic_declaration	| generic_instantiation
	| subprogram_body
	%%
--|.................................................................................................
secondary_unit	::=
	library_unit_body | subunit
	%%
--|.................................................................................................
library_unit_body	::=
	subprogram_body__|__package_body
	%%
--|.................................................................................................
subprogram_body__|__package_body	::=
	package_body
	%%
--|.................................................................................................

--|.................................................................................................
//  pragma_s		=>
//	as_list	: Seq Of pragma;
--|.................................................................................................
//  compilation_unit	=>
//	as_context_elem_s	: context_elem_s,
//	as_all_decl	: ALL_DECL,
//	as_pragma_s	: pragma_s,
//	xd_timestamp	: Integer,
//	xd_with_list	: Seq Of trans_with,
//	xd_nbr_pages	: Integer,
//	xd_parent	: compilation_unit,
//	xd_lib_name	: symbol_rep;

##  compilation_unit	====>			--| ACTION SUR compilation_unit
##  include	EMITS.TOP_ACT := 0;				--| HAUT DE PILE A ZERO
##  include	EMITS.TOP_MAX := 0;				--| HAUT MAXIMAL DE PILE AUSSI
##  include	EMITS.OFFSET_ACT := 0;			--| DECALAGE SUR PILE A ZERO
##  include	EMITS.OFFSET_MAX := 0;			--| DECALAGE MAX AUSSI
##  include	EMITS.LEVEL := 0;				--| NIVEAU D IMBRICATION ZERO
##  include	EMITS.GENERATE_CODE := FALSE;			--| NE PAS GENERER ENCORE LE CODE
##  include	EMITS.CUR_COMP_UNIT := 2;			--| UNITE DE COMPILATION NUMERO 2 (STANDARD ET SYSTEM AVANT)
##  include	EMITS.ENCLOSING_BODY := Tree_VOID;			--| PAS D ENGLOBANT
##  call	context_elem_s	@ as_context_elem_s	compilation_unit		--| TRAITER LA LISTE DE CONTEXTE (PRAGMA ET WITH)
##  include	EMITS.CUR_COMP_UNIT := 0;			--| SE REPLACER SUR L UNITE 0 (STANDARD)
##  include	EMITS.GENERATE_CODE := TRUE;			--| GENERER LE CODE
##  call	ALL_DECL	@ as_all_decl	compilation_unit		--| APPLIQUER L ACTION ALL_DECL SUR LE CHAMP as_all_decl
##  include	EMIT ( QUIT );
--|.................................................................................................
//  CONTEXT_ELEM		::=
//	context_pragma;

##  CONTEXT_ELEM	====>
##	if	context_pragma
##	call	context_pragma	CONTEXT_ELEM
##	if	with
##	call	with	CONTEXT_ELEM
--|.................................................................................................
//  context_pragma		=>
//	as_pragma	: pragma;

##  context_pragma	====>
##	include	null;



--|-------------------------------------------------------------------------------------------------
-- Syntax 10.1.1.A
--  context_clause ::= {with_clause {use_clause}}
--|-------------------------------------------------------------------------------------------------

context_clause	::=
	{with_clause}				====> $L context_elem_s
	%%
--|.................................................................................................


//  context_elem_s		=>
//	as_list	: Seq Of CONTEXT_ELEM;

##  context_elem_s	====>
##	repeat_extract	context_elem_s	context_elem
##	call	CONTEXT_ELEM	context_elem



--|-------------------------------------------------------------------------------------------------
-- Syntax 10.1.1.B
--  with_clause ::= with unit_simple_name {, unit_simple_name};
--|-------------------------------------------------------------------------------------------------

with_clause	::=
	WITH  name_s  ;  use_pragma_s			====> $2 with
	%%
--|.................................................................................................
use_pragma_s	::=
	{pragma}  {use_clause{pragma}}			====> cat $L use_pragma_s
	%%
--|.................................................................................................


//  CONTEXT_ELEM		::=
//	with;
--|.................................................................................................
//  with		=>
//	as_name_s	: name_s,
//	as_use_pragma_s	: use_pragma_s;
--	lx_srcpos	:Source_Position

##  with	====>
##	call	name_s	@ as_NAME_S	with
--|.................................................................................................
//  use_pragma_s		=>
//	as_list	: Seq Of USE_PRAGMA;



--|-------------------------------------------------------------------------------------------------
-- 10.2  Subunits of Compilation Units
-- Syntax 10.2.A
--  subunit ::=
--     separate (parent_unit_name) proper_body
--|-------------------------------------------------------------------------------------------------

subunit	::=
	SEPARATE  (  expanded_name  )  proper_body		====> $2 subunit
	%%
--|.................................................................................................


//  subunit		=>
//	as_name	: NAME,
//	as_subunit_body	: SUBUNIT_BODY;

##  subunit	====>
##	include	null;
--|.................................................................................................
//  SUBUNIT_BODY		::=
//	subprogram_body | package_body | task_body;
//  SUBUNIT_BODY		=>
//	as_source_name	: SOURCE_NAME,
//	as_body	: BODY;
--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
##  SUBUNIT_BODY	====>

##  include	DECLARE
##  include	   POST_LBL : LABEL_TYPE;			--| ETIQUETTE EVENTUELLE POUR L APRES CORPS
##  include	BEGIN
##  include	  IF ENCLOSING_BODY /= TREE_VOID THEN			--| S IL Y A UN CORPS ENGLOBANT
##  include	    POST_LBL := NEXT_LABEL;			--| ALLOUER L ETIQUETTE DE FIN DE CORPS SOUS UNITE
##  include	    EMIT ( JMP, POST_LBL, COMMENT=> "CONTOURNEMENT" );		--| Y SAUTER
##  include	  END IF;

##  if	subprogram_body
##  call	subprogram_body	SUBUNIT_BODY

##  if	package_body
##  call	package_body	SUBUNIT_BODY

##  if	task_body
##  call	task_body	SUBUNIT_BODY

##  end_if

##  include	  IF ENCLOSING_BODY /= TREE_VOID THEN
##  include	    WRITE_LABEL ( POST_LBL, COMMENT=> "FIN DE CONTOURNEMENT" );
##  include	  END IF;
##  include	END;
--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


--|-------------------------------------------------------------------------------------------------
-- Syntax 10.2.B
--  body_stub ::=
--	 subprogram_specification is separate;
--     | package body package_simple_name is separate;
--     | task body task_simple_name is separate;
--|-------------------------------------------------------------------------------------------------

body_stub	::=
	  PROCEDURE  proc_id  procedure_header  IS__SEPARATE  ;		====> exch_1 $3 subprogram_body
	| PROCEDURE  proc_id  nil_procedure_header IS__SEPARATE  ;		====> exch_1 $3 subprogram_body
	| FUNCTION  function_id  function_header  IS__SEPARATE  ;		====> exch_1 $3 subprogram_body
	| PACKAGE  BODY  package_id  IS__SEPARATE  ;		====> $2 package_body
	| TASK  BODY  task_body_id  IS__SEPARATE  ;		====> $2 task_body
	%%
--|.................................................................................................
IS__SEPARATE	::=
	IS  SEPARATE				====> $0 stub
	%%
--|.................................................................................................
//  stub		=> ;



--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-- 11.	Exceptions
--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-- 11.1	Exception Declarations
-- Syntax 11.1
--  exception_declaration ::= identifier_list : exception;
--|-------------------------------------------------------------------------------------------------

exception_declaration	::=
	  identifier  :  exception_definition  ;		====> $DEF exception_id
	| identifier  ,  exception_declaration			====> $DEF exception_id
	%%
--|.................................................................................................
exception_definition	::=
	EXCEPTION				====> nil $L source_name_s $1 exception_decl
	%%
--|.................................................................................................


//  exception_decl		=> ;
--	as_source_name_s	:source_name_s
--	lx_srcpos	:Source_Position

##  exception_decl	====>
##	call	source_name_s	@ as_source_name_s	exception_decl
--|.................................................................................................
//  SOURCE_NAME		::=
//	exception_id;
--|.................................................................................................
//  exception_id		=>
//	sm_renames_exc	: NAME,
//	cd_label	: Integer;

##  exception_id	====>				--| DECLARATION D IDENTIFICATEUR D EXCEPTION
##  include	DECLARE
##  include	  LBL : LABEL_TYPE := NEXT_LABEL;			--| ALLOUER UNE ETIQUETTE
##  include	BEGIN
##  include	  DI ( CD_LABEL, EXCEPTION_ID, INTEGER ( LBL ) );		--| LA STOCKER
##  include	  EMIT ( EXL, LBL, S=> PRINT_NAME ( D ( LX_SYMREP, EXCEPTION_ID ) ),
##  include	         COMMENT=> "NUMERO D EXCEPTION SUR DECLARATION" );		--| CAS NORMAL PUISQUE LA DECLARATION DOIT PRECEDER L USAGE
##  include	END;




--|-------------------------------------------------------------------------------------------------
-- 11.2  Exception Handlers
-- Syntax 11.2
--  exception_handler ::=
--     when exception_choice {| exception_choice}	=>
--	    sequence_of_statements
--
--  exception_choice ::= exception_name | others
--|-------------------------------------------------------------------------------------------------
--** Parsed as case statement alternative



--|-------------------------------------------------------------------------------------------------
-- 11.3  Raise Statements
-- Syntax 11.3
--  raise_statement ::= raise [exception_name];
--|-------------------------------------------------------------------------------------------------

raise_statement	::=
	RAISE  [expanded_name]  ;			====> $1 raise
	%%
--|.................................................................................................

//  raise		=> ;

##  raise	====>
##  include	DECLARE
##  include	  NAME : TREE := D ( AS_NAME, ADA_RAISE );		--| AMENER LE NOM DE L EXCEPTION LEVEE
##  include	BEGIN
##  include	  IF NAME = TREE_VOID THEN			--| PAS DE NOM (UN SIMPLE "RAISE")
##  include	    EMIT ( RAI );				--| EMETTRE LE RAISE
##  include	  ELSE				--| IL Y A UN NOM D EXCEPTION
##  include	    DECLARE
##  include	      EXCEPTION_ID : TREE := D ( SM_DEFN, NAME );		--| RAMENER LA DEFINITION DE L EXCEPTION
##  include	      LBL : LABEL_TYPE;			--| ETIQUETTE EVENTUELLE
##  include	    BEGIN
##  include	      IF D ( CD_LABEL, EXCEPTION_ID ).TY /= DN_NUM_VAL THEN		--| PAS DEJA DE VALEUR D ETIQUETTES (PAS DE RAISE ANTERIEUR)
##  include	        LBL := NEXT_LABEL;			--| ALLOUER UNE ETIQUETTE
##  include	        DI ( CD_LABEL, EXCEPTION_ID, INTEGER ( LBL ) );		--| PORTER SON NUMERO DANS L IDENTIFICATEUR
##  include	        EMIT ( EXL, LBL, S=> PRINT_NAME ( D ( LX_SYMREP, NAME ) ),	--| EMETTRE UNE ETIQUETTE EXCEPTION
##  include		COMMENT=> "NUMERO D EXCEPTION EXTERNE SUR RAISE" );	--| ME PARAIT UN CAS IMPOSSIBLE LA DECLARATION DEVANT PRECEDER
##  include	      END IF;
##  include	      EMIT ( RAI, DI ( CD_LABEL, EXCEPTION_ID ) );		--| EMETTRE LE RAISE
##  include	    END;
##  include	  END IF;
##  include	END;


--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-- 12.	Generic Program Units
--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-- 12.1  Generic Declarations
-- Syntax 12.1.A
--  generic_declaration ::= generic_specification;
--
--  generic_specification ::=
--	 generic_formal_part subprogram_specification
--     | generic_formal_part package_specification
--|-------------------------------------------------------------------------------------------------

generic_declaration	::=
	generic_specification  ;
	%%
--|.................................................................................................
generic_specification	::=
	  generic_formal_part  FUNCTION  generic_id  function_header	====> exch_1 exch_2 $3 generic_decl
	| generic_formal_part  PROCEDURE  generic_id  procedure_header	====> exch_1 exch_2 $3 generic_decl
	| generic_formal_part  PROCEDURE  generic_id  nil_procedure_header	====> exch_1 exch_2 $3 generic_decl
	| generic_formal_part  PACKAGE  generic_id
		package_definition  END__[simple_name]		====> exch_1 exch_2 $3 generic_decl
	%%
--|.................................................................................................
generic_id	::=
	identifier				====> $0 generic_id lx_symrep
	%%
--|.................................................................................................


//  HEADER		::=
//	package_spec;

--|.................................................................................................
//  generic_decl		=>
//	as_item_s	: item_s;

##  generic_decl	====>
##	include	null;
--|.................................................................................................
//  NON_TASK_NAME		::=
//	generic_id;
--|.................................................................................................
//  generic_id		=>
//	sm_generic_param_s	: item_s,
//	sm_body	: BODY,
//	sm_is_inline	: BOOLEAN;

##  generic_id	====>
##	include	null;



--|-------------------------------------------------------------------------------------------------
-- Syntax 12.1.B
--  generic_formal_part ::= generic {generic_parameter_declaration}
--|-------------------------------------------------------------------------------------------------

generic_formal_part	::=
	GENERIC  {pragma}  {generic_parameter_declaration{pragma}}		====> cat $L item_s
	%%
--|.................................................................................................



--|-------------------------------------------------------------------------------------------------
-- Syntax 12.1.C
--  generic_parameter_declaration ::=
--	 identifier_list : [in [out]] type_mark [:= expression];
--     | type identifier is generic_type_definition;
--     | private_type_declaration
--     | with subprogram_specification [is name];
--     | with subprogram_specification [is <>];
--|-------------------------------------------------------------------------------------------------

generic_parameter_declaration	::=
	  in_specification  ;
	| in_out_specification  ;
	| TYPE  identifier  empty_discriminant_part__IS  generic_type_definition  ;	====> $V3 type_decl $DEF type_id
	| private_type_declaration
	| WITH  subprogram_specification  formal_subprogram_def  ;		====> $3 subprog_entry_decl
	%%
--|.................................................................................................
empty_discriminant_part__IS	::=
	IS				====> nil $L dscrmt_decl_s
	%%
--|.................................................................................................
formal_subprogram_def	::=
	empty				====> $0 no_default
	| IS  <>				====> $0 box_default
	| IS  name 				====> $1 name_default
	%%
--|.................................................................................................


//  UNIT_KIND		::=
//	GENERIC_PARAM;
--|.................................................................................................
//  GENERIC_PARAM		::=
//	name_default | box_default | no_default;
--|.................................................................................................
//  name_default		=>
//	as_name	: NAME;
--|.................................................................................................
//  box_default		=> ;
--|.................................................................................................
//  no_default		=> ;



--|-------------------------------------------------------------------------------------------------
-- Syntax 12.1.D
--  generic_type_definition ::=
--	 (<>) | range <> | digits <> | delta <>
--     | array_type_definition | access_type_definition
--|-------------------------------------------------------------------------------------------------

generic_type_definition	::=
	  (  <>  )				====> $0 formal_dscrt_def
	| RANGE  <>				====> $0 formal_integer_def
	| DIGITS  <>				====> $0 formal_float_def
	| DELTA  <>				====> $0 formal_fixed_def
	| array_type_definition
	| access_type_definition
	%%
--|.................................................................................................


//  TYPE_DEF		::=
//	formal_dscrt_def | formal_integer_def | formal_fixed_def | formal_float_def;
--|.................................................................................................
//  formal_dscrt_def	=> ;
--|.................................................................................................
//  formal_fixed_def	=> ;
--|.................................................................................................
//  formal_float_def	=> ;
--|.................................................................................................
//  formal_integer_def	=> ;



--|-------------------------------------------------------------------------------------------------
-- 12.3  Generic Instantiation
-- Syntax 12.3.A
--  generic_instantiation ::=
--	 package identifier is
--	 new generic_package_name [generic_actual_part];
--     | procedure identifier is
--	 new generic_procedure_name [generic_actual_part];
--     | function identifier is
--	 new generic_function_name [generic_actual_part];
--
--  generic_actual_part ::=
--     (generic_association {, generic_association})
--|-------------------------------------------------------------------------------------------------

generic_instantiation	::=
	  PACKAGE  package_id  instantiation			====> void exch_1 $3 package_decl
	| PROCEDURE  proc_id  nil_procedure_header  instantiation		====> $3 subprog_entry_decl
	| FUNCTION  function_id  generic_function_header  instantiation	====> $3 subprog_entry_decl
	| FUNCTION  def_op  generic_function_header  instantiation		====> $3 subprog_entry_decl
	%%
--|.................................................................................................
generic_function_header	::=
	nil_param_s				====> void $2 function_spec
	%%
--|.................................................................................................
instantiation	::=
	IS  NEW  expanded_name  generic_assoc_s  ;		====> $2 instantiation
	%%
--|.................................................................................................
generic_assoc_s	::=
	  empty				====> nil $L general_assoc_s
	| (  generic_association{,generic_association}  )		====> $L general_assoc_s
	%%
--|.................................................................................................


//  RENAME_INSTANT		::=
//	instantiation;
--|.................................................................................................
//  instantiation		=>
//	as_general_assoc_s	: general_assoc_s,
//	sm_decl_s	: decl_s;



--|-------------------------------------------------------------------------------------------------
-- Syntax 12.3.B
--  generic_association ::=
--     [generic_formal_parameter	=>] generic_actual_parameter
--
--  generic_formal_parameter ::= parameter_simple_name | operator_symbol
--|-------------------------------------------------------------------------------------------------

generic_association	::=
	  generic_actual_parameter
	| used_id  =>  generic_actual_parameter			====> exch_1 $2 assoc
	| used_string  =>  generic_actual_parameter		====> exch_1 $2 assoc
	%%
--|.................................................................................................



--|-------------------------------------------------------------------------------------------------
-- Syntax 12.3.C
--  generic_actual_parameter ::= expression | variable_name
--     | subprogram_name | entry_name | type_mark
--|-------------------------------------------------------------------------------------------------

generic_actual_parameter	::=
	expression
	%%
--|.................................................................................................


--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-- 13. Representation Clauses and
-- Implementation Dependent Features
--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-- 13.1  Representation Clauses

-- Syntax 13.1
--  representation_clause ::=
--	 type_representation_clause | address_clause
--
--  type_representation_clause ::= length_clause
--     | enumeration_representation_clause | record_representation_clause
--|-------------------------------------------------------------------------------------------------

representation_clause	::=
	type_representation_clause | address_clause
	%%
--|.................................................................................................
type_representation_clause	::=
	length_clause | enumeration_representation_clause | record_representation_clause
	%%
--|.................................................................................................


//  REP		::=
//	NAMED_REP | record_rep;
//  REP		=>
//	as_name	: NAME;
--|.................................................................................................
//  NAMED_REP		=>
//	as_exp	: EXP;



--|-------------------------------------------------------------------------------------------------
-- 13.2 Length Clause
-- Syntax 13.2
--  length_clause ::= for attribute use simple_expression;
--|-------------------------------------------------------------------------------------------------

length_clause	::=
	FOR  attribute  USE  simple_expression  ;		====> $2 length_enum_rep
	%%
--|.................................................................................................



--|-------------------------------------------------------------------------------------------------
-- 13.3 Enumeration Representation Clauses
-- Syntax 13.3
--  enumeration_representation_clause ::=
--	 for type_simple_name use aggregate;
--|-------------------------------------------------------------------------------------------------

enumeration_representation_clause	::=
	FOR  used_id  USE  aggregate  ;			====> $2 length_enum_rep
	%%
--|.................................................................................................


//  NAMED_REP		::=
//	length_enum_rep;
--|.................................................................................................
//  length_enum_rep		=> ;



--|-------------------------------------------------------------------------------------------------
-- 13.4  Record Representation Clauses
-- Syntax 13.4.A
--  record_representation_clause ::=
--     for type_simple_name use
--	    record [alignment_clause]
--		 {component_clause}
--	    end record;
--
--  alignment_clause ::= at mod static_simple_expression;
--|-------------------------------------------------------------------------------------------------

record_representation_clause	::=
	  FOR  used_id  USE  RECORD  null_alignment  comp_rep_s  END  RECORD  ;	====> $3 record_rep
	| FOR  used_id  USE  RECORD  alignment {comp_rep_pragma}comp_rep_s
				END  RECORD  ;	====> $3 record_rep
	%%
--|.................................................................................................
--** Note two definitions to deal with extra {pragma}
--** Leading {pragma} always included in alignment clause even if null

null_alignment		::=
	[pragma_s]				====> void $2 alignment
	%%
--|.................................................................................................
alignment	::=
	[pragma_s]  AT  MOD  simple_expression  ;		====> $2 alignment
	%%
--|.................................................................................................
	

//  ALIGNMENT_CLAUSE	::=
//	alignment;
--|.................................................................................................
//  alignment		=>
//	as_pragma_s	: pragma_s,
//	as_exp	: EXP;
--|.................................................................................................
//  record_rep		=>
//	as_alignment_clause	: ALIGNMENT_CLAUSE,
//	as_comp_rep_s	: comp_rep_s;
--|.................................................................................................



--|-------------------------------------------------------------------------------------------------
-- Syntax 13.4.B
--  component_clause	::=
--     component_simple_name at static_simple_expression range static_range;
--|-------------------------------------------------------------------------------------------------

comp_rep_pragma	::=
	pragma				====> $1 comp_rep_pragma
	%%
--|.................................................................................................
{comp_rep_pragma}comp_rep_s	::=
	{comp_rep_pragma}  {component_clause{comp_rep_pragma}}		====> cat $L comp_rep_s
	%%
--|.................................................................................................
comp_rep_s		::=
	{component_clause{comp_rep_pragma}}			====> $L comp_rep_s
	%%
--|.................................................................................................
component_clause		::=
	used_id  AT  simple_expression  RANGE  range  ;		====> $3 comp_rep
	%%
--|.................................................................................................


//  COMP_REP_ELEM		::=
//	comp_rep | comp_rep_pragma;
--|.................................................................................................
//  comp_rep_s		=>
//	as_list	: Seq Of COMP_REP_ELEM;
--|.................................................................................................
//  comp_rep		=>
//	as_name	: NAME,
//	as_exp	: EXP,
//	as_range	: RANGE;
--|.................................................................................................
//  comp_rep_pragma		=>
//	as_pragma	: pragma;



--|-------------------------------------------------------------------------------------------------
-- 13.5  Address Clauses
-- Syntax 13.5
--  address_clause ::= for simple_name use at simple_expression;
--|-------------------------------------------------------------------------------------------------

address_clause	::=
	FOR  used_id  USE  AT  simple_expression  ;		====> $2 address
	%%
--|.................................................................................................


//  NAMED_REP		::=
//	address;
--|.................................................................................................
//  address		=> ;



--|-------------------------------------------------------------------------------------------------
-- 13.8  Machine Code Insertions
-- Syntax 13.8
--  code_statement ::= type_mark'record_aggregate;
--|-------------------------------------------------------------------------------------------------

code_statement		::=
	prefix  '  aggregate  ;			====> exch_1 $2 code
	%%
--|.................................................................................................


//  code		=> ;

##  code	====>
##	include	null;



--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-- 14.0 Input-Output
--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-- I/O procedure calls are not specially handled. They are
-- represented by procedure or function calls (see 6.4).
--|-------------------------------------------------------------------------------------------------



-- Predefined Diana Environment
-- ============================
--
-- see Appendix   of this manual
--

//  PREDEF_NAME		::=
//	  attribute_id | pragma_id | argument_id | bltn_operator_id;
--|.................................................................................................
//  attribute_id		=>
//	xd_pos	: Integer;			-- Predefined_Attributes'POS
--|.................................................................................................
//  TYPE_SPEC		::=
//	universal_integer | universal_fixed | universal_real;
--|.................................................................................................
//  universal_integer	=> ;
--|.................................................................................................
//  universal_fixed		=> ;
--|.................................................................................................
//  universal_real		=> ;
--|.................................................................................................
//  argument_id		=>
//	xd_pos	: Integer;			-- 'POS in appropriate enum type
--|.................................................................................................
//  bltn_operator_id	=>
//	sm_operator	: Integer;			-- (bltn_operators'POS)
--|.................................................................................................
//  pragma_id		=>
//	sm_argument_id_s	: argument_id,
//	xd_pos	: Integer;			-- Defined_Pragmas'POS
--|.................................................................................................
//  argument_id_s	=>
//	as_list	: Seq Of argument_id;
--|.................................................................................................
//  ALL_SOURCE		::=
//	  DEF_NAME	| ALL_DECL	| TYPE_DEF	| SEQUENCES
//	| STM_ELEM	| GENERAL_ASSOC	| CONSTRAINT	| CHOICE
//	| HEADER	| UNIT_DESC	| TEST_CLAUSE_ELEM
//	| MEMBERSHIP_OP	| SHORT_CIRCUIT_OP	| ITERATION
//	| ALTERNATIVE_ELEM	| COMP_REP_ELEM	| CONTEXT_ELEM
//	| VARIANT_ELEM	| ALIGNMENT_CLAUSE	| VARIANT_PART
//	| comp_list	| compilation	| compilation_unit	| index;
--|.................................................................................................
//  SEQUENCES		::=
//	  alternative_s	| argument_id_s	| choice_s
//	| comp_rep_s	| compltn_unit_s	| context_elem_s
//	| decl_s	| dscrmt_decl_s	| general_assoc_s
//	| discrete_range_s	| enum_literal_s	| exp_s	| item_s
//	| index_s | name_s	| param_s	| pragma_s	| scalar_s
//	| source_name_s	| stm_s	| test_clause_elem_s
//	| use_pragma_s	| variant_s;
--|.................................................................................................
//  ALL_SOURCE		=>
//	lx_srcpos	: Source_Position,
//	lx_comments	: comments;
--|.................................................................................................
//  ALL_DECL		::=
//	ITEM | subunit;

## ALL_DECL	====>				--| Action sur ALL_DECL
##	if_class	ITEM			--| Si dans classe ITEM
##	call	ITEM	ALL_DECL		--| Appliquer l'action sur ITEM au paramètre ALL_DECL
##	if	subunit			--| Si subunit
##	call	subunit	ALL_DECL		--| Appliquer l'action subunit au paramètre ALL_DECL
--|.................................................................................................
//  user_root		=>
//  	xd_sourcename	: txtrep,
//	xd_grammar	: void,
//	xd_statelist	: void,
//	xd_structure	: compilation,
//	xd_timestamp	: Integer,
//	spare_3	: void;
##  user_root	====>				--| Action sur user_root
##	call	compilation	@ xd_structure	user_root	--| Appliquer l'action compilation sur le champ xd_structure
--|.................................................................................................
//  NON_DIANA		::=
//	user_root;
--|.................................................................................................
//  NON_DIANA		::=
//	real_val | trans_with | lib_info;
--|.................................................................................................
//  real_val		=>			-- universal real values
//	xd_numer	: num_val,
//	xd_denom	: num_val;
--|.................................................................................................
//  trans_with		=>
//	tw_filename	: txtrep,
//	tw_comp_unit	: compilation_unit;
--|.................................................................................................
//  lib_info		=>
//	xd_short	: txtrep,
//	xd_primary	: txtrep,
//	xd_secondary	: txtrep;
--|.................................................................................................
//  any_integer     	=> ;
--|.................................................................................................
//  any_real		=> ;
--|.................................................................................................
//  any_access		=> ;
--|.................................................................................................
//  any_composite   	=> ;
--|.................................................................................................
//  any_string		=> ;
--|.................................................................................................
//  any_access_of   	=>
//	xd_item 	: ITEM;
--|.................................................................................................
//  UNSPECIFIED_TYPE	::=
//	any_access | any_composite | any_string | any_access_of | any_integer | any_real;
--|.................................................................................................
//  NON_DIANA		::=
//	def | UNSPECIFIED_TYPE;
--|.................................................................................................
//  def 		=>
//	xd_header	: HEADER,
//	xd_source_name	: SOURCE_NAME,
//	xd_region_def	: def,
//	xd_is_in_spec	: BOOLEAN,
//	xd_lex_level	: Integer,			-- 0 pour la base
//	xd_is_used	: BOOLEAN;
--|.................................................................................................
// implicit_conv    	=>
//	xd_item 	: ITEM,			-- (or type spec)
//	xd_list 	: Seq Of EXP;
--|.................................................................................................
// nullary_call     	=>
//	xd_item 	: ITEM;
--|.................................................................................................
// NON_DIANA		::=
//	implicit_conv | nullary_call;
--|.................................................................................................
// end	--| Fin de specification IDL



--** Definitions of rules for meta-brackets
--** Only rules with "standard" definitions are given here:
--**   [xxx]  is void or has semantics of xxx
--**   {xxx}  is a sequence of 0 or more xxx's
--**   other rules combined with {xxx} extend the sequence

{pragma}	::=
	  empty				====> nil
	| pragma  {pragma} 				====> insert
	%%
--|.................................................................................................
{variant_pragma}	::=
	  empty				====> nil
	| variant_pragma {variant_pragma}			====> insert
	%%
--|.................................................................................................
{stm_pragma}	::=
	  empty				====> nil
	| stm_pragma  {stm_pragma} 			====> insert
	%%
--|.................................................................................................
{alternative_pragma}	::=
	  empty				====> nil
	| alternative_pragma {alternative_pragma}		====> insert
	%%
--|.................................................................................................
{comp_rep_pragma}	::=
	empty				====> nil
	| comp_rep_pragma {comp_rep_pragma}			====> insert
	%%
--|.................................................................................................
argument_association{,argument_association}	::=
	  argument_association			====> list
	| argument_association{,argument_association}  ,  argument_association	====> append
	%%
--|.................................................................................................
[:=expression]	::=
	  empty				====> void
	| :=  expression
	%%
--|.................................................................................................
[expression]	::=
	  empty				====> void
	| expression
	%%
--|.................................................................................................
enumeration_literal{,enumeration_literal}	::=
	enumeration_literal 			====> list
	| enumeration_literal{,enumeration_literal} , enumeration_literal	====> append
	%%
--|.................................................................................................
[constraint]	::=
	  empty				====> void
	| constraint
	%%
--|.................................................................................................
[range_constraint]	::=
	  empty				====> void
	| range_constraint
	%%
--|.................................................................................................
index_subtype_definition{,index_subtype_definition}	::=
	  index_subtype_definition			====> list
	| index_subtype_definition{,index_subtype_definition}
			,  index_subtype_definition	====> append
	%%
--|.................................................................................................
{pragma}{component_declaration{pragma}}	::=
	  {pragma}
	| {pragma}{component_declaration{pragma}}  component_declaration  {pragma}	====> insert cat
	%%
--|.................................................................................................
discriminant_specification{;discriminant_specification}	::=
	  discriminant_specification			====> list
	| discriminant_specification{;discriminant_specification}
			;  discriminant_specification	====> append
	%%
--|.................................................................................................
{variant}	::=
	  empty				====> nil
	| {variant}  variant			====> append
	%%
--|.................................................................................................
choice{|choice}	::=
	  choice				====> list
	| choice{|choice}  '|'  choice			====> append
	%%
--|.................................................................................................
{basic_declarative_item{pragma}}	::=
	  empty				====> nil
	| {basic_declarative_item{pragma}} basic_declarative_item  {pragma}	====> insert cat
	%%
--|.................................................................................................
{later_declarative_item{pragma}}	::=
	  empty				====> nil
	| {later_declarative_item{pragma}} later_declarative_item  {pragma}	====> insert cat
	%%
--|.................................................................................................
component_association,{component_association,}	::=
	  component_association  ,			====> list
	| component_association,{component_association,}  component_association  ,	====> append
	%%
--|.................................................................................................
label{label}	::=
	  label				====> list
	| label{label}  label 			====> append
	%%
--|.................................................................................................
if_clause{elsif_clause}	::=
	  if_clause				====> list
	| if_clause{elsif_clause}  elsif_clause			====> append
	%%
--|.................................................................................................
{case_sta_alt}	::=
	  empty				====> nil
	| {case_sta_alt}  case_sta_alt 			====> append
	%%
--|.................................................................................................
[iteration_scheme]	::=
	  empty				====> void
	| iteration_scheme
	%%
--|.................................................................................................
parameter_specification{;parameter_specification}	::=
	  parameter_specification			====> list
	| parameter_specification{;parameter_specification}  ;  parameter_specification	====> append
	%%
--|.................................................................................................
general_assoc{,general_assoc}	::=
	  general_assoc				====> list
	| general_assoc{,general_assoc}  ,  general_assoc		====> append
	%%
--|.................................................................................................
expanded_name{,expanded_name}	::=
	  expanded_name				====> list
	| expanded_name{,expanded_name}  ,  expanded_name		====> append
	%%
--|.................................................................................................
{representation_clause{pragma}}	::=
	  empty				====> nil
	| representation_clause  {pragma}  {representation_clause{pragma}}	====> cat insert
	%%
--|.................................................................................................
{compilation_unit}	::=
	  empty				====> nil
	| {compilation_unit} compilation_unit			====> append
	%%
--|.................................................................................................
name{,name}	::=
	  name				====> list
	| name{,name} , name			====> append
	%%
--|.................................................................................................
{with_clause}	::=
	empty				====> nil
	| {with_clause}  with_clause			====> append
	%%
--|.................................................................................................
{use_clause{pragma}}	::=
	  empty				====> nil
	| {use_clause{pragma}}  use_clause  {pragma}		====> insert cat
	%%
--|.................................................................................................
[expanded_name]	::=
	  empty				====> void
	| expanded_name
	%%
--|.................................................................................................
{entry_declaration{pragma}}	::=
	  empty				====> nil
	| {entry_declaration{pragma}}  entry_declaration  {pragma}		====> insert cat
	%%
--|.................................................................................................
{generic_parameter_declaration{pragma}}	::=
	  empty				====> nil
	| {generic_parameter_declaration{pragma}} generic_parameter_declaration {pragma} ====> insert cat
	%%
--|.................................................................................................
generic_association{,generic_association}	::=
	  generic_association 			====> list
	| generic_association{,generic_association}  ,  generic_association	====> append
	%%
--|.................................................................................................
{component_clause{comp_rep_pragma}}	::=
	  empty				====> nil
	| {component_clause{comp_rep_pragma}}  component_clause  {comp_rep_pragma}	====> insert cat
	%%
--|.................................................................................................
discrete_range{,discrete_range}	::=
	  discrete_range				====> list
	| discrete_range{,discrete_range}  ,  discrete_range		====> append
	%%
--|.................................................................................................
discriminant_association{,discriminant_association}	::=
	  discriminant_association			====> list
	| discriminant_association{,discriminant_association}
			,  discriminant_association	====> append
	%%
--|.................................................................................................
discriminant_choice{|discriminant_choice}	::=
	  discriminant_choice 			====> list
	| discriminant_choice{|discriminant_choice}  '|'  discriminant_choice	====> append
	%%
--|.................................................................................................

--##################################################################################################
--	FIN !! Eh ben dis donc !!
--##################################################################################################
%end
##  STOP					--| ARRET POUR LE GEN_CODEGEN
