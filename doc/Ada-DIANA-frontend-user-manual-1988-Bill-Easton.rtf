{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1036\deflangfe1036{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f28\froman\fcharset238\fprq2 Times New Roman CE;}{\f29\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f31\froman\fcharset161\fprq2 Times New Roman Greek;}{\f32\froman\fcharset162\fprq2 Times New Roman Tur;}
{\f33\froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\f34\froman\fcharset178\fprq2 Times New Roman (Arabic);}{\f35\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f44\fmodern\fcharset238\fprq1 Courier New CE;}
{\f45\fmodern\fcharset204\fprq1 Courier New Cyr;}{\f47\fmodern\fcharset161\fprq1 Courier New Greek;}{\f48\fmodern\fcharset162\fprq1 Courier New Tur;}{\f49\fmodern\fcharset177\fprq1 Courier New (Hebrew);}
{\f50\fmodern\fcharset178\fprq1 Courier New (Arabic);}{\f51\fmodern\fcharset186\fprq1 Courier New Baltic;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;
\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{
\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1036\langfe1036\cgrid\langnp1036\langfenp1036 \snext0 Normal;}{\*\cs10 \additive Default Paragraph Font;}}{\info{\author x}{\operator x}
{\creatim\yr2006\mo10\dy14\hr14\min45}{\revtim\yr2006\mo10\dy14\hr14\min58}{\version8}{\edmins13}{\nofpages16}{\nofwords4853}{\nofchars27665}{\*\company y}{\nofcharsws33974}{\vern8249}}\margl1417\margr1417\margt1417\margb1417 
\widowctrl\ftnbj\aenddoc\hyphhotz425\noxlattoyen\expshrtn\noultrlspc\dntblnsbdb\nospaceforul\hyphcaps0\horzdoc\dghspace120\dgvspace120\dghorigin1701\dgvorigin1984\dghshow0\dgvshow3\jcompress\viewkind4\viewscale100\nolnhtadjtbl \fet0\sectd 
\linex0\sectdefaultcl {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang
{\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8
\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 \fs24\lang1036\langfe1036\cgrid\langnp1036\langfenp1036 {
\f2\fs20 
\par \tab \tab \tab }{\f2\fs20\lang2057\langfe1036\langnp2057     ADA/DIANA FRONT END
\par 
\par                                USER'S MANUAL
\par 
\par 
\par 
\par \tab \tab \tab \tab  D R A F T
\par \tab \tab \tab        Oct. 6, 1988
\par 
\par 
\par 
\par ****************************************************************************
\par *\tab \tab DISCLAIMER OF WARRANTY AND LIABILITY\tab \tab \tab    *
\par *   \tab \tab \tab \tab \tab \tab \tab \tab \tab    *
\par *  This is experimental prototype software.  It is provided "as is"        *
\par *  without warranty or representation of any kind.  The institute for      *
\par *  Defense Analyses (IDA) does not warrant, guarantee, or make any         *
\par *  representations regarding this software with respect to correctness,    *
\par *  accuracy, reliability, merchantability, fitness for a particular        *
\par *  purpose, or otherwise.\tab \tab \tab \tab \tab \tab    *
\par *\tab \tab \tab \tab \tab \tab \tab \tab \tab    *
\par *  Users assume all risks in using this software.,  Neither IDA nor        *
\par *  anyone else involved in the creation, production or distribution of     *
\par *  this software shall be liable for any damage, injury or loss            *
\par *  resulting from its use, whether such damage, injury or loss is          *
\par *  characterized as direct, indirect, consequential, incidental,           *
\par *  special, or otherwise.\tab \tab \tab \tab \tab \tab    *
\par *\tab \tab \tab \tab \tab \tab \tab \tab \tab    *
\par ****************************************************************************
\par 
\par INTRODUCTION
\par 
\par This document describes an Ada front end, that is a system which
\par translates Ada into Diana, together with associated tools for use of the
\par Diana.
\par 
\par The front end is to be considered a prototype version.\tab It presently
\par converts statically correct Ada to the corresponding Diana representation;
\par there is no guarantee that statically incorrect programs will be diagnosed
\par as such.  (It is the intention to replace this front end with a
\par production-quality version which will also diagnose statically incorrect
\par programs.)
\par 
\par The language accepted is the entire Ada language, including library
\par support, generics, etc., but not (yet) including any of the Chapter 13
\par optional features.  The requirement is that the front end accept the
\par ACVC class A and class C tests.
\par 
\par The implementation of Diana uses a software virtual memory, implemented as
\par a DIRECT_IO file with fixed-size pages.    Diana nodes are represented as
\par pointers into this file; the current implementation of a pointer is a
\par record containing a node type, a page number and a location within a
\par page.  (Of course, it is strongly recommended that the details of the
\par current implementation not be relied upon.)  The definition of the Diana
\par is given in IDL form and matches the Intermetrics 1986 draft definition of
\par Diana (rather than that published in 1983).  Program access to Diana nodes
\par and attributes is given by an Ada packages (actually, three packages) very
\par similar to that given in the 1983 Diana specification.
\par 
\par The system includes utilities for processing the IDL specification of
\par Diana to produce programs and packages required for using Diana.  It also
\par includes a LALR grammar generator (similar in scope to yacc, but
\par implemented in Ada and tailored to the present project).  In addition, a
\par tool for printing the Diana in an indented format is included.
\par 
\par The system consists of about 35,000 lines of Ada source, probably about 15,000
\par Ada statements.  Because of the virtual-memory implementation, there should be
\par no arbitrary small limitations due to main memory table sizes.
\par 
\par 
\par DEFINITION OF DIANA AND THE ADA GRAMMAR
\par 
\par Both the definition of Diana (in IDL form) and the LALR grammar for Ada
\par are contained in the file diana.idl.  The file contains the following
\par kinds of information:
\par 
\par          On lines beginning with "--"
\par \tab       The RM grammar (and other comments), as given in Diana 86.
\par 
\par          On lines not beginning with "--", "@@" or "++"
\par \tab       The LALR grammar actually used.  Adapted from the LALR
\par \tab       grammer given by Fisher and Charles in Ada Letters.  Note
\par \tab       that terminals and non-terminals consist of strings of
\par               printable characters other than ' '; terminals are listed
\par \tab       at the beginning of the grammar and other such symbols are
\par \tab       non-terminals.  The semantic information for each rule is
\par               given, following the rule, beginning with "====>" and
\par \tab       ending with the end of the line.\tab The semantic information
\par \tab       consists of instructions for building an abstract syntax
\par \tab       tree; the details probably do not matter to a user of the
\par \tab       front end.
\par 
\par          On lines beginning with "@@"
\par \tab       The IDL definition of Diana, taken from the Diana 86 draft.
\par 
\par          On lines beginning with "++"
\par \tab       Attributes for nodes which are inherited from classes
\par \tab       containing the node.  (These are machine-generated and are
\par \tab       for the convenience of the human reader.)
\par 
\par Note that the RM grammar and the specification of Diana are from the Diana
\par 86 draft.  They were typed in manually, as a machine-readable copy was not
\par available.  (Does anyone know where there is a machine readable copy of
\par Diana 86?)
\par 
\par There are a few additional attributes and nodes, not taken from Diana 86.
\par The nodes are used in the front end.  Those which are part of the
\par implementation of Diana are given before the "real" diana nodes and are in
\par the class STANDARD_IDL.    Those which are used internally by the front end
\par are given after the "real" diana and are in the class NON_DIANA.    Nodes in
\par the classes ALL_SOURCE and TYPE_SPEC are precisely those in Diana 86.
\par 
\par Additional attributes begin with "xd_" or "tw_"; "real" Diana attributes,
\par as in Diana 86, begin with "lx_", "as_", "sm_" or "cd_".  It is recommended
\par that the additional attributes not be used, as they will probably be
\par eliminated, except in cases of necessity.
\par 
\par 
\par 
\par REPRESENTATION OF DIANA NODES AND ATTRIBUTES
\par 
\par Conceptually, the Diana is represented by means of a record for each node
\par containing, as its fields, the attributes of the node.\tab The present
\par implementation makes use of a large virtual memory implemented in
\par software.  (Large means up to 2**15 pages of 512 bytes, at present; an
\par increase to, say, 2**23 pages is not very difficult.)  Pages of virtual
\par memory are allocated, and then nodes are allocated within them.  A node
\par consists of a 32-bit control word containing the node type and the number
\par of attributes which follow; a pointer to a node consists of a record of
\par type TREE (defined in package USERPK) with three fields, the number of a
\par virtual page (16 bits), the type of the node pointed to (8 bits) and the
\par line number or position within the virtual page.  The page may be thought
\par of as an array, array (1..127) of TREE; the page number is then the
\par subscript corresponding to the array element which holds the node's
\par control word.
\par 
\par Thus, a pointer and the node pointed to have the following structure:
\par 
\par 
\par     |---------|----|----|\tab  |---------|----|----|
\par     | virt-pg |type|line| ---> |  type   |    n    |
\par     }{\f2\fs20 |---------|----|----|\tab  |---------|---------|
\par \tab \tab \tab \tab        |   attribute 1     |
\par \tab   (pointer)\tab \tab        |-------------------|
\par \tab \tab \tab \tab        |   attribute 2     |
\par \tab \tab \tab \tab        }{\f2\fs20\lang2057\langfe1036\langnp2057 |-------------------|
\par \tab \tab \tab \tab  .\tab \tab      .
\par \tab \tab \tab \tab  .\tab \tab      .
\par \tab \tab \tab \tab  |-------------------|
\par \tab \tab \tab \tab  |   attribute n     |
\par \tab \tab \tab \tab  |-------------------|
\par 
\par \tab \tab \tab \tab    (node pointed to)
\par 
\par 
\par Pointers which correspond to types other than TREE or which correspond to
\par nodes with no attributes have special formats:
\par 
\par Pointer to a node with no attributes:
\par 
\par \tab       |---------|----|----|    Page and line both 0
\par \tab       |    0    |type|\tab 0 |    y=type /= num_rep
\par \tab       |---------|----|----|
\par 
\par An integer in the range -32768 .. 32767:
\par 
\par \tab       |---------|----|----|    ** type = num_rep
\par \tab       |  value  | ** |\tab 0 |
\par \tab       |---------|----|----|
\par 
\par An integer outside the range -32768 .. 32767
\par 
\par     |---------|----|----|\tab  |---------|----|----|
\par     | virt-pg | ** |line| ---> |   **    |    n    |\tab  d_1 .. d_2n are
\par     |---------|----|----|      |---------|---------|   10_000'ary digits
\par \tab \tab \tab \tab        |  d_2n   | d_(2n-1)|
\par \tab   (pointer)\tab \tab        |-------------------|\tab  10_000 added to
\par \tab \tab \tab \tab        | d_(2n-2)| d_(2n-3)|\tab      d_2n for negative
\par       ** type = num_rep \tab  |-------------------|
\par \tab \tab \tab \tab  .\tab \tab      .
\par \tab \tab \tab \tab  .\tab \tab      .\tab  (Allows for up to
\par \tab \tab \tab \tab  |-------------------|\tab  500 digits
\par \tab \tab \tab \tab  |   d_2  |   d_1    |\tab      precision.)
\par \tab \tab \tab \tab  |-------------------|
\par 
\par \tab \tab \tab \tab    (node pointed to)
\par 
\par A universal real (i.e. rational) number is represented by a real_val node
\par whose attributes are the numerator and denominator reduced to lowest terms.
\par 
\par     |---------|----|----|\tab  |---------|----|----|
\par     | virt-pg | ** |line| ---> |   **    |    2    |
\par     |---------|----|----|\tab  |---------|---------|
\par \tab \tab \tab \tab        |num_val (numerator)|
\par        ** type = real_val\tab  |-------------------|
\par }{\f2\fs20\lang1043\langfe1036\langnp1043                                |num_val (denomin'r)|
\par \tab \tab \tab \tab        }{\f2\fs20\lang2057\langfe1036\langnp2057 |-------------------|
\par 
\par 
\par Text, as in lx_symrep and lx_numrep attributes, is represented either by a
\par node of type txtrep or a node of type symbol_rep.    A txtrep contains the
\par actual text; a symbol_rep contains a (pointer to a) txtrep and an
\par additional attribute which is a list (of definitions).\tab If two text
\par attributes are represented by symbol_rep's and are textually the same,
\par they are guaranteed to be represented by the same symbol_rep node.
\par (Normally, symbol_rep nodes are used; however, txtrep nodes are used when
\par the Diana is written out into Ada library files and may be used internally
\par when identical representation for identical text is not required.)
\par 
\par     |---------|---------|\tab  |---------|----|----|
\par     |\tab **    |    2\tab |  +-> |  txtrep |    n    | ln is string length
\par     |---------|---------|  |\tab  |---------|---------|
\par     |  symbol_rep pntr\tab |--+\tab  | ln | c1 | c2 | c3 | n*4-4 <= ln < n*4
\par     |-------------------|\tab  |-------------------|
\par     |  head of list     |      | c3 | c4 | c5 | c6 | (0 - 3 null char's
\par     |-------------------|\tab  |-------------------| following text)
\par \tab \tab \tab \tab  \tab    .\tab \tab      .
\par       ** type = symbol_rep\tab    .\tab \tab        .
\par \tab \tab \tab \tab \tab  |-------------------|
\par        (symbol_rep)\tab \tab  |   ...   |c-ln|... |
\par \tab \tab \tab \tab \tab  |-------------------|
\par 
\par \tab \tab \tab \tab       (txtrep)
\par 
\par Lists are represented in one of the following three ways:
\par 
\par     |-------------------|   |-------------------|   |-------------------|
\par     |\tab  0    |nil | 0\tab |   |\tab pntr to head\tab |   |  page   |list|line|
\par     |-------------------|   |-------------------|   |-------------------|
\par \tab \tab \tab \tab \tab \tab \tab    \tab     |
\par \tab ( empty list )\tab \tab ( one member)\tab     |
\par \tab \tab \tab \tab \tab \tab \tab           V
\par \tab \tab \tab \tab \tab \tab \tab     |-------------------|
\par \tab \tab \tab \tab \tab \tab \tab     |\tab list  |    2\tab |
\par \tab        (Note that list with one member  |-------------------|
\par \tab \tab is represented by the member)\tab     |\tab  pntr to head\tab |
\par \tab \tab \tab \tab \tab \tab \tab     |-------------------|
\par \tab        (Node of type list used for\tab     |\tab  pntr to tail\tab |
\par \tab \tab lists of more than one member)    |-------------------|
\par 
\par \tab \tab \tab \tab \tab \tab    ( more than one member)
\par 
\par Source positions are represented by a special pointer which encodes both
\par the line and the column.  (Currently, file is not represented; front end
\par produces messages only for the current file.)
\par 
\par \tab       |---------|----|----|  col is column number;
\par \tab       | -(page) |col |line|  line represented by
\par \tab       |---------|----|----|  sourceline node at
\par \tab \tab \tab \tab      (page,line).
\par 
\par Words in virtual memory file which have not been used are assigned a
\par pattern of all one bits.
\par 
\par lx_comments attributes are not represented.
\par 
\par 
\par REPRESENTATION OF DIANA AS ADA OBJECTS
\par 
\par Diana nodes of (Ada) type TREE are represented as Ada records with the
\par format described above.
\par 
\par Diana nodes of (Ada) type SEQ_TYPE, representing sequences of nodes, are
\par represented as Ada records containing (1) the node as described above for
\par lists in virtual memory and (2) a field containing either (a node of type)
\par nil or a pointer to one of the nodes of type list, usually the last such,
\par in the representation of the sequence in virtual memory.  (This permits
\par appending to objects of type SEQ_TYPE without chasing down the list each
\par time.)
\par 
\par Declarations of TREE and SEQ_TYPE are given in the package USERPK (as in
\par Diana 83).
\par 
\par 
\par 
\par STRING-PROCESSING ROUTINES
\par 
\par The package USERPK also contains some routines for working with
\par varyable-length strings.  Type PNAME represents a variable-length string
\par of maximum length 127; it is a limited private type, so that predefined
\par equality cannot be used.  In the front end, PNAME's are only used as local
\par variables; heap storage is not used.  Generally, Ada type STRING is used
\par except when a string is to be stored temporarily.  The following
\par operations are provided:
\par 
\par     procedure SET (...) -- assignment of STRING's and PNAME's
\par     function LENGTH (...) -- length of a PNAME
\par     function TO_STRING (...) -- convert PNAME to Ada STRING
\par     procedure PUT (...) -- like TEXT_IO, but for PNAME's
\par     procedure PUT_LINE (...) -- likewise
\par     function "&" (...) -- catenation of CHARACTER's, STRING's and PNAME's
\par \tab       -- result is always STRING
\par     function "=" (...) -- for PNAME's
\par     function IS_EQUAL (...) -- comparison of PNAME's and STRING's
\par 
\par The type PNAME is represented as a record containing an 8-bit length
\par followed by 127 characters.  In the Vax implementation, an 8-bit integer
\par field and a STRING(1..127) field are used.  In other implementations, such
\par as Sun/Verdix, a single field of type array(0..127) of character is used,
\par with the length stored as the 'POS of the 0'th character; this is because
\par the appropriate representation clauses do not work.
\par 
\par At some future date, the length field will probably be expanded so that
\par the same code works on all implementations; this should be transparent to
\par users of the front-end.
\par 
\par 
\par ADA INTERFACE TO DIANA
\par 
\par The Ada interface to Diana is patterned on the Ada interface given in
\par Diana 83.  There are differences due to the unavailability of a full Ada
\par compiler at the time the interface was designed.  The major differences
\par are:
\par 
\par \tab  -    The interface is defined in three packages, DIANATTR, DIANA,
\par \tab       and DIANAMAN, instead of only one.  DIANATTR contains an
\par \tab       enumeration type for attributes, DIANA contains an
\par \tab       enumeration type for node names and functions and
\par \tab       procedures which depend on the particular IDL definition of
\par \tab       Diana, and DIANAMAN contains functions and procedures which
\par \tab       are independent of the particular IDL definition.
\par 
\par \tab  -    Instead of providing, for each attribute, a function to
\par \tab       fetch it and a procedure to store it, attributes are
\par \tab       implemented as an enumeration type and one function D and
\par \tab       one procedure D are provided to fetch and store tree-valued
\par \tab       attributes.  (For example, attribute as_name of node nnn is
\par \tab       fetched by the function call D(AS_NAME, NNN) rather than by
\par \tab       the [Diana 83] function call AD_NAME(NNN).
\par 
\par \tab  -    Subtypes of NODE_NAME are provided for Diana classes.
\par 
\par 
\par These are simple syntactic differences.   At some time in the future, an
\par interface more like Diana 83 will be provided in addition to the current
\par one.
\par 
\par A condensed version of the Ada specification for the three packages
\par follows:
\par 
\par     package DIANATTR is
\par 
\par \tab  type ATTRIBUTE_NAME is
\par \tab       ( ...
\par \tab       , AS_NAME
\par \tab       . ... );
\par 
\par     end DIANATTR;
\par 
\par 
\par     package DIANA is
\par 
\par \tab  type NODE_NAME is
\par \tab       ( ...
\par \tab       , DN_USED_NAME_ID
\par \tab       , ... );
\par 
\par \tab  ...\tab   -- subtypes for Diana classes
\par \tab  subtype CLASS_DESIGNATOR is NODE_NAME
\par \tab \tab \tab    range DN_USED_CHAR .. DN_USED_NAME_ID;
\par \tab  ...
\par 
\par \tab  procedure CREATE_DIANA; -- initialize new virtual memory
\par \tab  procedure OPEN_DIANA; -- attach to existing virtual memory
\par 
\par \tab  function MAKE(C: in NODE_NAME) return TREE;\tab -- make a Diana node
\par \tab  -- procedure DESTROY -- not provided
\par \tab  function KIND(T: in TREE) return NODE_NAME;\tab -- get node type
\par 
\par \tab  procedure D (A: ATTRIBUTE_NAME; T: in TREE; V: in TREE);
\par \tab       -- store value of tree-valued attribute
\par \tab  function  D (A: ATTRIBUTE_NAME, T: in TREE) return TREE;
\par \tab       -- fetch value of tree-valued attribute
\par 
\par \tab  procedure DB(A: ATTRIBUTE_NAME; T: in TREE; V: in TREE);
\par \tab       -- store value of boolean-valued attribute
\par \tab  function  DB(A: ATTRIBUTE_NAME, T: in TREE) return TREE;
\par \tab       -- fetch value of boolean-valued attribute
\par 
\par \tab  procedure D (A: ATTRIBUTE_NAME; T: in TREE; V: in TREE);
\par \tab       -- store value of integer-valued attribute
\par \tab  function  D (A: ATTRIBUTE_NAME, T: in TREE) return TREE;
\par \tab       -- fetch value of integer-valued attribute
\par 
\par \tab  function NODE_IMAGE(C: NODE_NAME) return STRING;
\par \tab  function ATTR_IMAGE(A: ATTRIBUTE_NAME) return STRING;
\par               -- similar to 'IMAGE functions
\par 
\par     end DIANA;
\par 
\par 
\par     package DIANAMAN is
\par 
\par \tab  CONST_FALSE:  constant TREE := ...; -- constants for certain
\par \tab  CONST_TRUE:   constant TREE := ...; -- node types with no
\par \tab  CONST_NIL:    constant TREE := ...; -- attributes
\par \tab  CONST_VOID:   constant TREE := ...;
\par \tab  CONST_ROOT:   constant TREE := ...;
\par \tab  CONST_VIRGIN: constant TREE := ...;
\par 
\par \tab  procedure CLOSE_DIANA; -- detach from virtual memory; close file
\par 
\par \tab  -- type ARITIES -- moved to package USERPK
\par \tab  function ARITY (T: IN TREE)  return ARITIES;
\par \tab  function SON1 (T: IN TREE) return TREE;
\par \tab  ...
\par               -- "general" tree walk subprograms from Diana 83 (not too
\par \tab       -- useful, since order of as_ attribures not uniform
\par 
\par \tab  function HEAD ...
\par \tab  function TAIL ...
\par \tab  function MAKE;
\par \tab  function IS_EMPTY ...
\par \tab  function INSERT ...
\par \tab  function APPEND ...
\par \tab       -- list-processing subprograms from Diana 83
\par \tab  function SINGLETON (V: TREE) return SEQ_TYPE;
\par \tab       -- makes list with one element
\par \tab  procedure POP (L: in out SEQ_TYPE; T: out TREE);
\par \tab       -- removes and returns head of list
\par 
\par \tab  procedure LIST (T: in TREE; V: in SEQ_TYPE);
\par \tab  function  LIST (T: in TREE);
\par               -- store/fetch the 'Seq of' attribute of a node
\par 
\par \tab  ... -- various functions and procedures used by only by DIANA
\par 
\par \tab  ... -- functions and procedures for creating and searching for
\par \tab      -- text strings and source positions
\par 
\par \tab  ... -- procedures for recording errors and warnings within the
\par \tab      -- front end
\par 
\par     end DIANAMAN;
\par 
\par 
\par 
\par ADDING NEW NODES AND ATTRIBUTES
\par 
\par New nodes and attributes can be added by inserting them in the file
\par DIANA.IDL and running the Diana tools described below.\tab Because of field
\par sizes, there is a limit of 255 attributes types and 255 node types.
\par 
\par Note that modification of the Diana definition requires recompilation of
\par most of the Ada sources in the system; there is no provision for
\par "refinement" of the IDL specification.
\par 
\par 
\par LIBRARY MANAGEMENT
\par 
\par There is a simple, quick-and-dirty scheme for manageing the Ada library. 
\par It is correct, according to the LRM; just a bit crude.
\par 
\par The file ADA__LIB.CTL is a control file.  It is ASCII text, processed by
\par TEXT_IO.  It contains translations between long unit names and DOS-compatible
\par file names; it also contains a "time stamp" -- an integer in the range 1..32767
\par -- for use in version control.  Entries are as follows:
\par 
\par \tab U <short-name>   \tab \tab \tab -- <short-name>.DCL, .BDY
\par \tab <full-name-of-library-unit>
\par 
\par \tab S <short-name>\tab \tab \tab \tab -- <short-name>.SUB
\par \tab <full-name-of-library-unit>
\par \tab <flul-name-of-subunit>
\par 
\par \tab T <time-stamp>
\par 
\par Library units whose name is at most 8 characters are not indicated in the
\par control file; the unit name is the file name.  Otherwise, a short name
\par is constructed fron the first 4 characters of the unit name, a '$',
\par and a 3 character code constructed from the time stamp.  Library unit
\par declarations, including subprogram bodies which are library units, are
\par represented by .DCL files; secondary units which are not sub units are
\par represented by .BDY files; subunits are represented by .SUB files.
\par 
\par The file representing the compilation unit consists of DIANA compacted
\par into contiguous pages.  Each library file contains (as an attribute of
\par the compilation_unit node) a list of units which it transitively withs.
\par The phase libphase reads withed units and relocates all node pointers 
\par so that the compilation has access to the entire Diana tree of the
\par library units in scope.  Phase writelib compacts the Diana by copying
\par all nodes of each compilation unit to a contiguous set of pages and
\par writing those pages into a file.  The compilation_unit node also contains
\par its own timestamp, which must be greater than that of all transitively 
\par withed units for the unit to be valid.
\par 
\par 
\par INSTALLATION INSTRUCTIONS
\par 
\par Brief installation instructions follow.  Note that, as of this writing,
\par the Diana generation and grammar processing programs not been run only on
\par the Vax; they have no known system dependencies, except for the use of a
\par system-dependent version of USERPK, so there should not be a lot of
\par difficulty in bringing them up.  It is suggested that the front end itself
\par be brought up first, beginning with the running of loadgrmr with the Ascii
\par input files provided.
\par 
\par 1.  Compilation:
\par 
\par Files of the form *.a are Ada sources to be compiled.  It is suggested
\par that files of the form *_.a, which are Ada specifications, be compiled
\par using a compilation order tool, such as the Verdix 'a.make -f *_.a'.
\par Next, evalnum.a and set_dflt.a, which contain Ada subprogram bodies
\par without separate specifications, should be compiled.  Finally, the
\par remaining files *.a can be compiled in any order.  Note that eachfile
\par contains one compilation unit, except for diana_.a, which contains
\par specifications of both DIANATTR and DIANA, and reqgene_.a which contains
\par both the specifications and bodies of generic units.
\par 
\par 2.  Linking:
\par 
\par The following main programs can be linked after the above compilations are
\par complete:
\par 
\par     To generate LALRIDL, "small" IDL used by Diana tools (optional)
\par 
\par \tab  readidl
\par \tab  putladn
\par \tab  putlaidl
\par 
\par     To generate DIANA from specifications
\par 
\par \tab  readdn
\par \tab  putdn
\par \tab  makeidl
\par 
\par     Tools for maintaining and printing IDL specification
\par 
\par \tab  }{\f2\fs20\lang1043\langfe1036\langnp1043 hieridl
\par \tab  fixters
\par 
\par     LALR grammar processing
\par 
\par \tab  readgrmr
\par \tab  optrgrmr
\par \tab  initgrmr
\par \tab  statgrmr
\par \tab  lalrgrmr
\par \tab  }{\f2\fs20\lang2057\langfe1036\langnp2057 chekgrmr
\par 
\par     Printing the states created during grammar processing (useful if
\par     grammar needs to be debugged)
\par 
\par \tab  prntstat
\par 
\par     Loading LALR tables from Ascii grammar file
\par 
\par \tab  loadgrmr
\par 
\par     Phases of the front end
\par 
\par \tab  parphase
\par \tab  libphase
\par \tab  semphase
\par \tab  repphase  ) alternate
\par \tab  errphase  ) versions
\par \tab  writelib
\par 
\par     Tool to print the Diana tree
\par 
\par \tab  prettydi
\par \tab  prntdian  (old version)
\par 
\par     Program to fix up predefined environment
\par 
\par \tab  fixpre
\par 
\par     "Ugly printer" for maintaining source code (optional)
\par 
\par \tab  ugly
\par 
\par 3.  General notes on execution:
\par 
\par Most of the programs make use of a virtual memory file, $$$.TMP (yes,
\par dollar signs and capitals) created at the beginning of a run or retained
\par from a previous run.  Generally file names are all capitals; it was
\par written this way before conversion to Unix.
\par 
\par To avoid system dependencies, fixed file names are used and files are
\par copied (or linked or moved) before and after execution.  Thus, such
\par system-dependent operations as reading the command line are moved to the
\par controlling JCL (or .COM or shell) files.  Generally, $$$PGM.TMP is the
\par input to a program that reads a text file.
\par 
\par The statement that program b "runs after" program a means that program b
\par expects to use the virtual memory file left by the execution of program a.
\par 
\par 4.  Generation of LALRIDL:
\par 
\par (You probably won't need to do this; LALRIDL is a small IDL structure used
\par by the Diana processing programs.  It creates itself; once, long ago, it
\par was bootstrapped with great pain.  The programs are included for
\par completeness.)
\par 
\par \tab  readidl -- reads LALRIDL.TBL
\par \tab  putladn -- creates new LALRIDL package spec
\par \tab  rename created spec to lalridl_.a
\par \tab  putlaidl -- creates new LALRIDL table
\par \tab  rename created table to LALRIDL.TBL
\par 
\par 5.  To generate DIANA from specifications
\par 
\par \tab  readdn -- reads DIANA.IDL (lines starting with @@)
\par \tab  putdn -- makes new package spec DIANA.NEW
\par \tab  rename DIANA.NEW to diana_.a
\par \tab  makeidl -- makes new DIANA table DIANATBL.NEW
\par \tab  rename DIANATBL.NEW to DIANA.TBL
\par 
\par 6.  Tools for maintaining and printing IDL specification
\par 
\par \tab  hieridl -- run after readidl; prints structure of Diana
\par \tab \tab  -- definition
\par 
\par \tab  fixters -- run after readidl (?); reads DIANA.IDL and creates
\par \tab \tab  -- new version with ++ lines regenerated
\par 
\par 7.  LALR grammar processing
\par 
\par \tab  readgrmr -- reads grammar from DIANA.IDL; also reads DIANA.TBL
\par \tab  optrgrmr
\par \tab  initgrmr
\par \tab  statgrmr
\par \tab  lalrgrmr -- (runs a long time -- 3 to 4 min Vax 8600 cpu time)
\par \tab  chekgrmr -- writes PARSE.TBL -- Ascii version of LALR table
\par 
\par 8.  Printing the states created during grammar processing (useful if
\par     grammar needs to be debugged)
\par 
\par \tab  prntstat -- runs after statgrmr or lalrgrmr; prints a lot
\par 
\par 9.  Loading LALR tables from Ascii grammar file
\par 
\par \tab  loadgrmr -- reads DIANA.TBL, PARSE.TBL
\par \tab \tab   -- writes DIANA.BIN, PARSE.BIN -- used in front end
\par \tab  copy $$$.TMP to PARSE.VM -- initial virtual memory for front end
\par 
\par 
\par 10. Translating the predefined environment (used parphase and writelib
\par     from the front end) -- shell script provided: makepre
\par 
\par \tab  copy PARSE.VM to $$$.TMP
\par \tab  copy predef.aa to $$$PGM.TMP
\par \tab  parphase
\par \tab  fixpre
\par \tab  writelib
\par 
\par 11. Running the front end -- shell script provided: front  (Note: ADA__
\par     LIB.TMP may be renamed, but need not be, if earlier errors.)
\par 
\par \tab  copy PARSE.VM to $$$.TMP
\par \tab  copy program to be compiled to $$$PGM.TMP
\par \tab  parphase
\par \tab  libphase -- if no errors, do withing of library files
\par \tab  semphase -- if no errors, do semantic processing
\par \tab  errphase  -- prints error list; use repphase for full source
\par \tab  rename ADA__LIB.TMP to ADA__LIB.CTL
\par \tab  writelib  -- if no errors, write library files
\par 
\par 12. Translating predefined packages.  Predefined packages can now be
\par     compiled as ordinary Ada units.  As of this writing only SYSTEM is
\par     provided; others will be as in RM.
\par 
\par \tab  perform step 11. above on system.aa
\par \tab  (using shell script front, give command:
\par \tab       front system.aa
\par \tab  )
\par 
\par 13. Running tool to print the Diana tree
\par 
\par \tab  prettydi -- runs on output from any front end phase
\par 
\par 14. Running "ugly printer" for maintenance of sources (optional).  Fixes
\par     up upper and lower case; checks for some common syntax errors; throws
\par     away all end's (end;, end if;, etc.) and regenerates them from the
\par     indentation.
\par 
\par \tab  copy source file to $$$PGM.TMP
\par \tab  ugly
\par \tab  save old source file for backup
\par \tab  rename $$$.TMP to be new source file
\par 
\par 
\par INDEX OF FILES
\par 
\par In lieu of more complete documentation, the following list of files
\par provided includes a very brief note as to the content and function of each
\par file.
\par 
\par DIANA.TBL\tab -- Ascii description of DIANA nodes and attributes
\par \tab \tab \tab -- created by putidl
\par \tab \tab \tab -- read by programs (e.g. loadgrmr) which create a
\par \tab \tab \tab --\tab new virtual memory file ($$$.TMP)
\par \tab \tab \tab -- also read by programs which use LALRIDL instead
\par \tab \tab \tab --\tab of Diana, but which need some info on Diana
\par LALRIDL.TBL\tab -- description of nodes and attributes used by LALR/Diana tools
\par \tab \tab \tab -- created by putlaidl
\par \tab \tab \tab -- read by programs (e.g. readidl) which create a
\par \tab \tab \tab --\tab new virtual memory file ($$$.TMP)
\par PARSE.TBL\tab -- Ascii description of LALR parse tables
\par \tab \tab \tab -- created by chekgrmr
\par \tab \tab \tab -- read by loadgrmr
\par _standrd.aa\tab -- Spec of predefined standard
\par ada__lib.ini\tab -- Virgin library control file
\par \tab \tab \tab -- copy to ADA__LIB.CTL to make an empty library
\par aggreso.a\tab -- (in semphase) -- process aggregates
\par aggreso_.a
\par attwalk.a\tab -- (in semphase) -- process attributes
\par attwalk_.a
\par chekgrmr.a\tab -- LALR program -- check LALR condition and write Ascii grmr
\par chkstat.a\tab -- (in semphase) -- test for static subtype, range, etc.
\par chkstat_.a
\par defutil.a       -- (in semphase) -- process 'def' nodes.  A def node records
\par defutil_.a\tab \tab -- declaration of name (outside of normal Diana)
\par defwalk.a\tab -- (in semphase) -- process type definitions
\par defwalk_.a
\par derived.a\tab -- (in semphase) -- create derived subprograms
\par derived_.a
\par diana.a \tab -- packages DIANATTR and DIANA -- created by putdn
\par diana.idl\tab -- definition of Ada LALR grammar and Diana (interleaved)
\par diana_.a\tab -- package body DIANA
\par dianaman.a\tab -- package DIANAMAN -- functions and procedures for Diana
\par dianaman_.a\tab \tab -- any that care about Diana definition are
\par \tab \tab \tab -- called through package DIANA
\par dianatbl_.a\tab -- storage for in core version of DIANA.TBL
\par errphase.a\tab -- phase of front end -- prints errors and lines in error
\par \tab \tab \tab -- repphase is similar, prints all of source
\par evalnum.a\tab -- (in semphase) -- evaluate universal integer or real literal
\par expreso.a\tab -- (in semphase) -- second (top-down) pass of overload
\par expreso_.a\tab \tab -- resolution
\par exptype.a\tab -- (in semphase) -- first (bottom-up) pass of overload
\par exptype_.a\tab \tab -- resolution
\par fixpre.a\tab -- program to fix up predefined environment after parsing
\par fixters.a       -- support program -- puts the '++' lines in diana.idl
\par fixwith.a       -- (in semphase) -- makes 'def' nodes for transitively
\par fixwith_.a\tab \tab -- withed declarations
\par front\tab \tab -- shell script to run the front end
\par gensubs.a\tab -- (in semphase) -- substitution within generic instations
\par gensubs_.a
\par grmrops.a\tab -- (in chekgrmr, parphase) declaration of parse semantic actions
\par grmrops_.a
\par grmrtbl_.a\tab -- (in chekgrmr, parphase) lalr grammar table
\par hieridl.a\tab -- support program -- prints a hierarchical description of Diana
\par homunit.a\tab -- (in semphase) -- searches for unit which is a homograph
\par homunit_.a\tab \tab -- of a given unit (for rename unit, formal subprogram)
\par initgrmr.a\tab -- LALR program -- initializes grammar structure, checks
\par \tab \tab \tab -- grammar (except for LALR conflicts)
\par instant.a\tab -- (in semphase) -- generic instantiations
\par instant_.a
\par lalrgrmr.a\tab -- LALR program -- given states, generates LALR lookahead sets
\par lalridl.a\tab -- package LALRIDL -- small IDL structure used by LALR stuff
\par lalridl.idl\tab -- IDL definition of LALRIDL
\par lalridl_.a
\par libphase.a\tab -- phase of front end -- determine withed units and load them
\par loaddtbl.a\tab -- loads core version of DIANA.TBL
\par loaddtbl_.a\tab \tab -- (used by various support programs)
\par loadgrmr.a\tab -- load Ascii grammar file into empty virtual memory
\par \tab \tab \tab -- $$$.TMP created is copied at start of front end run
\par }{\f2\fs20\lang3082\langfe1036\langnp3082 lscan.a \tab -- Ada lexical scan
\par }{\f2\fs20\lang2057\langfe1036\langnp2057 lscan_.a
\par ltext_io.a\tab -- Used in some support programs (duplicates some things in
\par ltext_io_.a             -- TEXT_IO that weren't there when project started)
\par ltype.a \tab -- Definition of types of lexical tokens (body implements
\par ltype_.a                -- images - 'IMAGE didn't work when project started)
\par makeidl.a\tab -- generate DIANA.TBL from stuff read in by readdn
\par makenod.a\tab -- creates given Diana nodes (generated from the Diana)
\par makenod_.a
\par makepre \tab -- shell script to compile predefined environment
\par makeskel.a\tab -- $$$$ may be deleted--
\par newsnam.a\tab -- (in semphase) -- generate new source name (during
\par newsnam_.a\tab \tab -- substitution for generic instantiation)
\par nodwalk.a\tab -- (in semphase) -- Walks various nodes of Diana, expecially
\par nodwalk_.a\tab \tab -- declaration nodes
\par optrgrmr.a\tab -- LALR program -- decreases size of grammar by eliminating
\par \tab \tab \tab -- certain productions; needed to get < 256 rules
\par pageio_.a\tab -- Direct IO for virtual memory operations
\par pageman.a\tab -- Virtual memory paging operations
\par pageman_.a
\par parphase.a\tab -- phase of front end -- lexical scan and LALR parse
\par prawalk.a\tab -- (in semphase) -- process pragmas
\par prawalk_.a
\par prefcns.a\tab -- (in semphase) -- create predefined operations
\par prefcns_.a
\par prename_.a\tab -- predefined names of attributes, pragmas, etc
\par prettydi.a\tab -- pretty print program for diana
\par printnod.a\tab -- routines to print diana nodes (used by prettydi, debug calls)
\par }{\f2\fs20 printnod.vax\tab -- VAX version
\par }{\f2\fs20\lang2057\langfe1036\langnp2057 printnod_.a
\par prntdian.a\tab -- diana pretty printer (older than prettydi; may work on
\par prntstat.a              -- erroneous trees when prettydi doesn't)
\par putdn.a \tab -- writes diana_.a from data read by readdn
\par putladn.a\tab -- writes lalridl.a from data read by readidl
\par putlaidl.a\tab -- writes LALRIDL.TBL from data read by readidl
\par readdn.a\tab -- reads diana definition into virtual memory for support tools
\par readgrmr.a\tab -- LALR program -- reads grammar and semantics (ignores Diana)
\par readidl.a\tab -- reads LALRIDL definition for support tools
\par redsubp.a\tab -- (in semphase) -- processes subprogram calls, also slices,
\par }{\f2\fs20 redsubp_.a\tab \tab -- conversions, etc.
\par }{\f2\fs20\lang2057\langfe1036\langnp2057 repphase.a\tab -- phase of front end (optional) -- prints source and errors
\par reqgene_.a\tab -- generics used by requtil
\par requtil.a\tab -- reduces sets of declarations and types according to
\par requtil_.a\tab \tab -- RM requirements
\par semglob.a\tab -- (in semphase) -- global data visible to almost everyone
\par semglob_.a
\par semphase.a\tab -- phase of front end -- semantic analysis
\par set_dflt.a\tab -- (in parphase) -- fills in default values of some attributes
\par setutil.a\tab -- process sets of (1) definitions and (2) types used
\par setutil_.a\tab \tab -- in overload resolution
\par statgrmr.a\tab -- LALR program -- creates LR(0) for LALR table
\par stmwalk.a\tab -- (in semphase) -- process statements
\par stmwalk_.a
\par system.aa\tab -- Specification of predefined package SYSTEM
\par termlist.a\tab -- (in LALR programs) utilities for processing lists of
\par termlist_.a\tab \tab -- terminal symbols
\par text2_io_.a\tab -- Stripped down TEXT_IO
\par uarith.a\tab -- universal arithmetic
\par uarith_.a
\par ugly.a          -- an 'ugly printer' -- tool to take correctly-indented Ada
\par                         -- and make end's right (opposite of a pretty printer)
\par univops.a\tab -- universal arithmetic, internal operations called from
\par univops_.a\tab \tab -- uarith
\par userpk.a\tab -- declaration of types used by Diana (see Diana 83)
\par userpk.vax\tab -- VAX version (different def of a varying string)
\par userpk_.a
\par userpk_.vax
\par visutil.a\tab -- (in semphase) -- functions to find visible identifiers
\par visutil_.a
\par writelib.a\tab -- phase of front end -- writes new library file
\par ADA__LIB.CTL\tab -- Ada library control file (copy from ada__lib.ini)
\par 
\par 
\par FUTURE PLANS
\par 
\par The current implementation is a prototype.  It is intended to replace it
\par with a production-quality version over the next 6 to 12 months.  The
\par production-quality version will, of course, pass all of the ACVC's, not
\par just the class A and C tests.  It will be possible to use the current
\par Diana interface; other versions will probably also be supplied.
\par 
\par KNOWN PROBLEMS
\par 
\par In a few cases, the attributes are not as they should be in the Diana bool:
\par 
\par \tab sm_master is not filled in
\par \tab sm_depends_on_discriminant is not filled in
\par \tab for array aggregates and strings,
\par \tab \tab sm_exp_type is the base type, not subtype for aggregate
\par \tab \tab \tab (it is void for subaggregates)
\par \tab \tab sm_discrete_range is not filled in
\par \tab \tab sm_normalized_param_s is not filled in
\par 
\par If someone needs these now, tell me.
\par 
\par Please feel free to call me to report bugs or ask questions.
\par Bill Easton, Peregrine Systems (703)689-1168, easton@ida.org
\par 
\par 
\par }}