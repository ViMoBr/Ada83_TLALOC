//  root	=>	xd_high_page	: num_val,
//		xd_user_root	: user_root,
//		xd_source_list	: Seq Of sourceline,
//		xd_err_count	: num_val,
//		spare_1 	: void;
//  txtrep	=> ;				-- representation of text
//  num_val	=> ;				-- representation of (small) integer
//  BOOLEAN	::=	false | true;
//  false	=> ;				-- used for BOOLEAN
//  true	=> ;
//  nil	=> ;				-- empty list
//  list	=>	xd_head 	: void,		-- list representation
//		xd_tail 	: void;
//  sourceline	=>	xd_number	: num_val,
//		xd_error_list	: Seq Of error;
//  error	=>	xd_srcpos	: Source_Position,
//		xd_text 	: txtrep;
//  symbol_rep	=>	xd_text 	: txtrep,
//		xd_deflist	: Seq Of DEF_NAME;
//  hash	=>	xd_list 	: Seq Of symbol_rep;
//  void	=> ;
// STANDARD_IDL	::=
//	root | txtrep | num_val | BOOLEAN | nil | list | sourceline | error | symbol_rep | hash | void;
//  DEF_NAME	::=	SOURCE_NAME | PREDEF_NAME;
//  DEF_NAME	=>	lx_symrep	: symbol_rep;
//  SOURCE_NAME	::=	OBJECT_NAME | TYPE_NAME | UNIT_NAME | LABEL_NAME;
//  SOURCE_NAME	=>	xd_region	: SOURCE_NAME;
//  OBJECT_NAME	=>	sm_obj_type	: TYPE_SPEC;
//  UNIT_NAME	=>	sm_first	: DEF_NAME;
//  pragma	=>
//	as_used_name_id	: used_name_id,
//	as_general_assoc_s	: general_assoc_s;			-- seq of EXP and/or assoc
//  general_assoc_s	=>
//	as_list	: Seq Of GENERAL_ASSOC;
//  DECL		::=
//	ID_S_DECL | ID_DECL;
//  ID_DECL		::=
//	type_decl | subtype_decl | task_decl | UNIT_DECL;
//  ID_DECL		=>
//	as_source_name	: SOURCE_NAME;
//  ID_S_DECL		::=
//	EXP_DECL | exception_decl | deferred_constant_decl;
//  ID_S_DECL		=>
//	as_source_name_s	: source_name_s;
//  EXP_DECL		::=
//	OBJECT_DECL | number_decl;
//  EXP_DECL		=>
//	as_exp	: EXP;
//  CONSTRAINED_DEF		::=
//	subtype_indication;
//  OBJECT_DECL		::=
//	constant_decl | variable_decl;
//  OBJECT_DECL		=>
//	as_type_def : TYPE_DEF;
//  constant_decl		=> ;			--| Ne fait qu'heriter
//  variable_decl		=> ;
//  OBJECT_NAME		::=
//	INIT_OBJECT_NAME;
//  INIT_OBJECT_NAME	::=			--| Objet var ou cst avec initialisation
//	VC_NAME;
//  INIT_OBJECT_NAME	=>
//	sm_init_exp	: EXP;			--| Attribut expression d'init
//  VC_NAME		::=
//	variable_id | constant_id;			--| Identificateur variable ou constante
//  VC_NAME		=>
//	sm_renames_obj	: BOOLEAN,			--| Indique un renames (pour var)
//	sm_address	: EXP,			--| EXP OU VIDE
//	cd_comp_unit	: Integer,
//	cd_level	: Integer,
//	cd_offset	: Integer,
//	cd_compiled	: BOOLEAN;
//  variable_id		=>
//	sm_is_shared	: BOOLEAN;			--| Si pragma shared applique
//  constant_id		=>
//	sm_first	: DEF_NAME;
//  number_decl		=> ;
//  INIT_OBJECT_NAME	::=    number_id;
//  number_id		=> ;
//  source_name_s	=>	    as_list : Seq Of SOURCE_NAME;
//  type_decl		=>
//	as_dscrmt_decl_s	: dscrmt_decl_s,
//	as_type_def	: TYPE_DEF;
//  TYPE_NAME		::=
//	type_id;
//  TYPE_NAME		=>
//	sm_type_spec	: TYPE_SPEC;
//  type_id		=>
//	sm_first	: DEF_NAME;
//  TYPE_DEF		::=
//	enumeration_def | CONSTRAINED_DEF | ARR_ACC_DER_DEF | record_def;
//  CONSTRAINED_DEF		::=
//	integer_def | float_def | fixed_def;
//  ARR_ACC_DER_DEF		::=
//	constrained_array_def | unconstrained_array_def | access_def | derived_def;
//  ARR_ACC_DER_DEF		=>
//	as_subtype_indication	: subtype_indication;
//  TYPE_SPEC		::=
//	DERIVABLE_SPEC;
//  DERIVABLE_SPEC		::=
//	FULL_TYPE_SPEC | PRIVATE_SPEC;
//  DERIVABLE_SPEC		=>
//	xd_source_name	: SOURCE_NAME,
//	sm_derived	: TYPE_SPEC,
//	sm_is_anonymous	: BOOLEAN;
//  FULL_TYPE_SPEC		::=
//	task_spec | NON_TASK;
//  FULL_TYPE_SPEC		=>
//	cd_comp_unit	: Integer,
//	cd_level	: Integer,
//	cd_compiled	: BOOLEAN;
//  NON_TASK		::=
//	SCALAR | UNCONSTRAINED | CONSTRAINED;
//  NON_TASK		=>
//	sm_base_type	: TYPE_SPEC;
//  SCALAR		::=
//	enumeration | Integer | REAL;
//  SCALAR		=>
//	sm_range	: RANGE,
//	cd_impl_size	: Integer;
//  REAL		::=
//	float | fixed;
//  REAL		=>
//	sm_accuracy	: Value;
//  UNCONSTRAINED		::=
//	UNCONSTRAINED_COMPOSITE | access;
//  UNCONSTRAINED		=>
//	sm_size	: EXP;		-- exp or void
//  UNCONSTRAINED_COMPOSITE	::=
//	array | record;
//  UNCONSTRAINED_COMPOSITE	=>
//	sm_is_limited	: BOOLEAN,
//	sm_is_packed	: BOOLEAN;
//  CONSTRAINED		::=
//	constrained_array | constrained_record | constrained_access;
//  CONSTRAINED		=>
//	sm_depends_on_dscrmt	: BOOLEAN,
//	cd_impl_size		: Integer,
//	cd_alignment		: Integer;
//  subtype_decl		=>
//	as_subtype_indication	: subtype_indication;
//  TYPE_NAME		::=
//	subtype_id;
//  subtype_id		=> ;
//  CONSTRAINED_DEF		=>
//	as_constraint	: CONSTRAINT;
//  subtype_indication	=>
//	as_name	: NAME;
//  CONSTRAINT		::=
//	DISCRETE_RANGE | REAL_CONSTRAINT | index_constraint | dscrmt_constraint;
//  derived_def	=>	   	xd_derived_subprog_list: Seq Of SUBPROG_NAME;
//  DISCRETE_RANGE		::=
//	RANGE | discrete_subtype;
//  RANGE		::=
//	range | range_attribute;
//  RANGE		=>
//	sm_type_spec : TYPE_SPEC;
//  range		=>
//	as_exp1	: EXP,
//	as_exp2	: EXP;
//  range_attribute		=>
//	as_name	: NAME,
//	as_used_name_id	: used_name_id,
//	as_exp	: EXP;			-- EXP or void
//  enumeration_def		=>
//	as_enum_literal_s	: enum_literal_s;
//  enum_literal_s		=>
//	as_list	: Seq Of ENUM_LITERAL,
//	cd_alignment	: Integer,
//	cd_impl_size	: Integer,
//	cd_last	: Integer;
//  enumeration		=>
//	sm_literal_s	: enum_literal_s;
//  OBJECT_NAME		::=
//	ENUM_LITERAL;
//  ENUM_LITERAL		::=
//	enumeration_id | character_id;
//  ENUM_LITERAL		=>
//	sm_pos	: Integer,
//	sm_rep	: Integer;
//  enumeration_id	=> ;
//  character_id	=> ;
//  integer_def	=> ;
//  Integer	=>
//	cd_offset	: Integer,
//	cd_impl_size	: Integer;
//  REAL_CONSTRAINT ::=     float_constraint
//			  | fixed_constraint;
//  REAL_CONSTRAINT	=>	    sm_type_spec : TYPE_SPEC;
//  float_def		=> ;
//  REAL_CONSTRAINT		=>
//	as_exp	: EXP,
//	as_range	: RANGE;
//  float_constraint	=> ;
//  float		=>
//	cd_impl_size	: Integer ;
//  fixed_def	=> ;
//  fixed_constraint	=> ;
//  fixed		=>
//	cd_impl_small	: Value,
//	cd_impl_size	: Integer;
//  constrained_array_def	=>
//	as_constraint	: CONSTRAINT;
//  index_constraint	=>
//	as_discrete_range_s	: discrete_range_s;
//  discrete_range_s	=>
//	as_list	: Seq Of DISCRETE_RANGE;
//  unconstrained_array_def	=>
//	as_index_s	: index_s;
//  scalar_s		=>
//	as_list	: Seq Of SCALAR;
//  array		=>
//	sm_index_s	: index_s,
//	sm_comp_type	: TYPE_SPEC;
//  constrained_array	=>
//	sm_index_subtype_s	: scalar_s,
//	cd_offset	: Integer,
//	cd_dimensions	: Integer;
//  index		=>
//	as_name	: NAME,
//	sm_type_spec	: TYPE_SPEC;
//  index_s		=>
//	as_list	: Seq Of index;
//  discrete_subtype	=>
//	as_subtype_indication	: subtype_indication;
//  record_def		=>
//	as_comp_list	: comp_list;
//  record		=>
//	sm_discriminant_s	: dscrmt_decl_s,
//	sm_comp_list	: comp_list,
//	sm_representation	: REP;			-- REP or void
//	cd_impl_size		: Integer,
//	cd_alignment		: Integer;
//  constrained_record	=>
//	sm_normalized_dscrmt_s	: exp_s;
//  DECL		::=
//	null_comp_decl;
//  null_comp_decl		=> ;
//		    -- (missing from Intermetrics definition)
//  INIT_OBJECT_NAME	::=
//	COMP_NAME;
//  COMP_NAME	::=
//	component_id | discriminant_id;
//  COMP_NAME	=>
//	sm_comp_rep	: COMP_REP_ELEM;
//  component_id		=> ;
//  ITEM		::=
//	DSCRMT_PARAM_DECL;
//  DSCRMT_PARAM_DECL	::=
//	dscrmt_decl;
//  DSCRMT_PARAM_DECL	=>
//	as_source_name_s	: source_name_s,
//	as_name	: NAME,
//	as_exp	: EXP;
//  dscrmt_decl_s		=>
//	as_list	: Seq Of dscrmt_decl;
//  dscrmt_decl		=> ;
//  discriminant_id		=>
//	sm_first	: DEF_NAME;
//  dscrmt_constraint	=>
//	as_general_assoc_s	: general_assoc_s;
//  VARIANT_PART		::=
//	variant_part;
//  variant_part		=>
//	as_name	: NAME,
//	as_variant_s	: variant_s;
//  variant_s		=>
//	as_list	: Seq Of VARIANT_ELEM;
//  VARIANT_ELEM	::=
//	variant | variant_pragma;
//  variant		=>
//	as_choice_s	: choice_s,
//	as_comp_list	: comp_list;
//  choice_s		=>
//	as_list	: Seq Of CHOICE,
//	cd_label	: Integer;
//  comp_list		=>
//	as_decl_s	: decl_s,
//	as_variant_part	: VARIANT_PART,
//	as_pragma_s	: pragma_s;
//  variant_pragma	=>	    as_pragma : pragma;
//  CHOICE		::=
//	choice_exp | choice_range | choice_others;
//  choice_exp		=>
//	as_exp	: EXP;
//  choice_range		=>
//	as_discrete_range	: DISCRETE_RANGE;
//  choice_others		=> ;
//  access_def	=> ;
//  access		=>
//	sm_storage_size	: EXP,			-- EXP or void
//	sm_is_controlled	: BOOLEAN,
//	sm_desig_type	: TYPE_SPEC,
//	sm_master	: ALL_DECL,
//	cd_offset	: Integer,
//	cd_constrained	: BOOLEAN;
//  constrained_access	=>
//	sm_desig_type	: TYPE_SPEC;
//  TYPE_SPEC ::=	    incomplete;
//  incomplete		=>
//	sm_discriminant_s	: dscrmt_decl_s,
//	xd_source_name	: SOURCE_NAME,
//	xd_full_type_spec	: TYPE_SPEC;
//  DECL		::=
//	REP | USE_PRAGMA;
//  USE_PRAGMA	::=
//	use | pragma;
//  ITEM		::=
//	DECL | SUBUNIT_BODY;
//  item_s		=>
//	as_list	: Seq Of ITEM;
//  UNIT_DECL		::=	    generic_decl | NON_GENERIC_DECL;
//  UNIT_DECL		=>
//	as_header	: HEADER;
//  NON_GENERIC_DECL	::=
//	subprog_entry_decl | package_decl;
//  NON_GENERIC_DECL	=>
//	as_unit_kind	: UNIT_KIND;
//  NAME		::=
//	DESIGNATOR | NAME_EXP;
//  NAME_EXP		::=
//	NAME_VAL | indexed | slice | all;
//  NAME_EXP		=>
//	as_name	: NAME,
//	sm_exp_type	: TYPE_SPEC;
//  NAME_VAL		::=
//	attribute | selected;
//  NAME_VAL		=>
//	sm_value	: Value;
//  DESIGNATOR		::=
//	USED_OBJECT | USED_NAME;
//  DESIGNATOR		=>
//	sm_defn	: DEF_NAME,
//	lx_symrep	: symbol_rep;
//  USED_NAME		::=
//	used_op | used_name_id;
//  used_op		=> ;
//  used_name_id		=> ;
//  USED_OBJECT		::=
//	used_char | used_object_id;
//  USED_OBJECT		=>
//	sm_exp_type	: TYPE_SPEC,
//	sm_value	: Value;
//  used_char	=> ;
//  used_object_id	=> ;
//  NAME_VAL		::=
//	function_call;
//  exp_s		=>
//	as_list	: Seq Of EXP;
//  indexed		=>
//	as_exp_s	: exp_s;
//  slice		=>
//	as_discrete_range	: DISCRETE_RANGE;
//  selected		=>
//	as_designator	: DESIGNATOR;
//  all		=> ;
//  attribute		=>
//	as_used_name_id	: used_name_id,
//	as_exp	: EXP;
//  aggregate		=>
//	as_general_assoc_s		: general_assoc_s,
//	sm_normalized_comp_s	: general_assoc_s;
//  GENERAL_ASSOC		::=
//	NAMED_ASSOC | EXP;
//  NAMED_ASSOC		::=
//	named;
//  NAMED_ASSOC		=>
//	as_exp	: EXP;
//  named		=>
//	as_choice_s	: choice_s;
//  EXP_VAL		::=
//	short_circuit;
//  short_circuit		=>
//	as_exp1	: EXP,
//	as_short_circuit_op	: SHORT_CIRCUIT_OP,
//	as_exp2	: EXP;
//  SHORT_CIRCUIT_OP	::=
//	and_then | or_else;
//  and_then	=> ;
//  or_else	=> ;
//  EXP_VAL_EXP		::=
//	MEMBERSHIP;
//  MEMBERSHIP		::=
//	range_membership | type_membership;
//  MEMBERSHIP		=>
//	as_membership_op	: MEMBERSHIP_OP;
//  range_membership	=>
//	as_range	: RANGE;
//  type_membership		=>
//	as_name	: NAME;
//  MEMBERSHIP_OP		::=
//	in_op | not_in;
//  in_op	=> ;
//  not_in	=> ;
//  EXP		::=
//	NAME | EXP_EXP;
//  EXP_EXP		::=
//	EXP_VAL | AGG_EXP | qualified_allocator | subtype_allocator;
//  EXP_EXP		=>
//	sm_exp_type	: TYPE_SPEC;
//  EXP_VAL		::=
//	numeric_literal | null_access | EXP_VAL_EXP;
//  EXP_VAL		=>
//	sm_value	: Value;
//  EXP_VAL_EXP		::=
//	QUAL_CONV | parenthesized;
//  EXP_VAL_EXP		=>
//	as_exp	: EXP;
//  AGG_EXP		::=
//	aggregate | string_literal;
//  AGG_EXP		=>
//	sm_discrete_range	: DISCRETE_RANGE;
//  parenthesized		=> ;
//  numeric_literal		=>
//	lx_numrep	: Number_Rep;
//  string_literal		=>
//	lx_symrep	: symbol_rep;
//  null_access		=> ;
//  QUAL_CONV		::=
//	conversion | qualified;
//  QUAL_CONV		=>
//	as_name	: NAME;
//  conversion	=> ;
//  qualified	=> ;
//  qualified_allocator	=>
//	as_qualified	: qualified;
//  subtype_allocator	=>
//	as_subtype_indication	: subtype_indication,
//	sm_desig_type		: TYPE_SPEC;
//  STM_ELEM	::=
//	STM | stm_pragma;
//  stm_s		=>
//	as_list	: Seq Of STM_ELEM;
//  stm_pragma		=>
//	as_pragma	: pragma;
//  STM		::=
//	labeled;
//  labeled		=>
//	as_source_name_s	: source_name_s,
//	as_pragma_s	: pragma_s,
//	as_stm	: STM;
//  STM		::=
//	null_stm | abort | STM_WITH_EXP | STM_WITH_NAME;
//  STM_WITH_EXP		::=
//	return | delay | STM_WITH_EXP_NAME;
//  STM_WITH_EXP		=>
//	as_exp	: EXP;
//  STM_WITH_EXP_NAME	::=
//	assign | exit | code;
//  STM_WITH_EXP_NAME	=>
//	as_name	: NAME;
//  STM_WITH_NAME		::=
//	goto | raise;
//  STM_WITH_NAME		::=
//	CALL_STM;
//  STM_WITH_NAME		=>
//	as_name	: NAME;
//  CALL_STM		::=
//	entry_call | procedure_call;
//  STM		::=
//	accept | BLOCK_LOOP | ENTRY_STM | CLAUSES_STM;
//  STM_WITH_EXP		::=
//	case;
//  CLAUSES_STM		::=
//	if | selective_wait;
//  CLAUSES_STM		=>
//	as_test_clause_elem_s	: test_clause_elem_s,
//	as_stm_s		: stm_s;
//  LABEL_NAME		::=
//	label_id;
//  LABEL_NAME		=>
//	sm_stm	: STM;
//  label_id		=>
//	cd_label	: Integer;
//  null_stm		=> ;
//  assign		=> ;
//  if		=> ;
//  TEST_CLAUSE		::=
//	cond_clause;
//  TEST_CLAUSE		=>
//	as_exp	: EXP,
//	as_stm_s	: stm_s;
//  cond_clause		=> ;
//  ALTERNATIVE_ELEM	::=
//	alternative | alternative_pragma;
//  case		=>
//	as_alternative_s	: alternative_s;
//  alternative_s		=>
//	as_list	: Seq Of ALTERNATIVE_ELEM;
//  alternative		=>
//	as_choice_s	: choice_s,
//	as_stm_s	: stm_s;
//  alternative_pragma	=>
//	as_pragma	: pragma;
//  BLOCK_LOOP		::=
//	loop;
//  BLOCK_LOOP		=>
//	as_source_name	: SOURCE_NAME;
//  LABEL_NAME		::=
//	block_loop_id;
//  block_loop_id		=> ;
//  loop		=>
//	as_iteration	: ITERATION,
//	as_stm_s	: stm_s
//	cd_level	: Integer
//	cd_after_loop	: Integer;
//  ITERATION		::=
//	FOR_REV;
//  FOR_REV		::=
//	for | reverse;
//  FOR_REV		=>
//	as_source_name	: SOURCE_NAME,
//	as_discrete_range	: DISCRETE_RANGE;
//  for		=> ;
//  reverse		=> ;
//  OBJECT_NAME		::=
//	iteration_id;
//  iteration_id		=>
//	cd_level	: Integer,
//	cd_offset	: Integer;
//  ITERATION		::=
//	while;
//  while		=>
//	as_exp	: EXP;
//  BLOCK_LOOP		::=
//	block;
//  block		=>
//	as_block_body	: block_body;
//  block_body		=>
//	as_item_s	: item_s,
//	as_stm_s	: stm_s,
//	as_alternative_s	: alternative_s,
//	cd_level	: Integer,
//	cd_return_label	: Integer,
//	cd_result_offset	: Integer;
//  exit		=>
//	sm_stm	: STM;
//  return		=> ;
//  goto		=> ;
//  subprog_entry_decl	=>;
//  UNIT_NAME		::=
//	NON_TASK_NAME;
//  NON_TASK_NAME		::=
//	SUBPROG_PACK_NAME;
//  NON_TASK_NAME		=>
//	sm_spec	: HEADER,
//	xd_stub	: stub,
//	xd_body	: SUBUNIT_BODY;
//  SUBPROG_PACK_NAME	::=
//	SUBPROG_NAME;
//  SUBPROG_PACK_NAME	=>
//	sm_unit_desc	: UNIT_DESC,
//	sm_address	: EXP,
//	cd_compiled	: BOOLEAN;
//  SUBPROG_NAME		::=
//	procedure_id | function_id | operator_id;
//  SUBPROG_NAME		=>
//	sm_is_inline	: BOOLEAN,
//	sm_interface	: PREDEF_NAME,
//	cd_level	: Integer,
//	cd_label	: Integer,
//	cd_param_size	: Integer;
//  UNIT_DESC		::=
//	UNIT_KIND | BODY | implicit_not_eq | derived_subprog;
//  derived_subprog		=>
//	sm_derivable	: SOURCE_NAME;
//  implicit_not_eq		=>
//	sm_equal	: SOURCE_NAME;
//  procedure_id		=> ;
//  function_id		=>
//	cd_result_size	: Integer;
//  operator_id		=>
//	xd_not_equal	: operator_id;			-- "/=" corresponding to "="
//  HEADER		::=
//	SUBP_ENTRY_HEADER;
//  SUBP_ENTRY_HEADER	::=
//	procedure_spec | function_spec;
//  SUBP_ENTRY_HEADER	=>
//	as_param_s	: param_s;
//  procedure_spec		=> ;
//  function_spec		=>
//	as_name	: NAME;
//  param_s		=>
//	as_list	: Seq Of PARAM;
//  DSCRMT_PARAM_DECL	::=
//	PARAM;
//  PARAM		::=
//	in | out | in_out;
//  in		=>
//	lx_default	: BOOLEAN;
//  in_out		=> ;
//  out		=> ;
//  INIT_OBJECT_NAME	::=
//	PARAM_NAME;
//  PARAM_NAME		::=
//	in_id | PARAM_IO_O;
//  PARAM_NAME		=>
//	sm_first	: DEF_NAME,
//	cd_level	: Integer;
//  PARAM_IO_O		::=
//	in_out_id | out_id;
//  PARAM_IO_O		=>
//	cd_addr_offset	: Integer,
//	cd_val_offset	: Integer;
//  in_id	=>
//	cd_offset	: Integer;
//  in_out_id	=> ;
//  out_id	=> ;
//  BODY		::=
//	block_body | stub;
//  subprogram_body		=>
//	as_header	: HEADER;
//  CALL_STM		=> 
//	as_general_assoc_s		: general_assoc_s,
//	sm_normalized_param_s	: exp_s;
//  procedure_call		=> ;
//  function_call		=>
//	as_general_assoc_s		: general_assoc_s,
//	sm_normalized_param_s	: exp_s,
//	lx_prefix		: BOOLEAN;
//  NAMED_ASSOC		::=
//	assoc;
//  assoc		=>
//	as_used_name	: USED_NAME;
//  package_decl		=> ;
//  SUBPROG_PACK_NAME	::=
//	package_id;
//  package_id		=> ;
//  package_spec		=>
//	as_decl_s1	: decl_s,
//	as_decl_s2	: decl_s,
//   	xd_body_is_required	: BOOLEAN;
//  decl_s		=>
//	as_list	: Seq Of DECL;
//  package_body		=> ;
//  TYPE_DEF		::=
//	private_def | l_private_def;
//  private_def		=> ;
//  l_private_def		=> ;
//  TYPE_NAME		::=
//	private_type_id | l_private_type_id;
//  private_type_id		=> ;
//  l_private_type_id	=> ;
//  PRIVATE_SPEC		::=
//	private | l_private;
//  PRIVATE_SPEC		=>
//	sm_discriminant_s	: dscrmt_decl_s,
//	sm_type_spec	: TYPE_SPEC;
//  private		=> ;
//  l_private		=> ;
//  deferred_constant_decl	=>
//	as_name	: NAME;
//  use		=>
//	as_name_s	: name_s;
//  ID_DECL		::=
//	SIMPLE_RENAME_DECL;
//  SIMPLE_RENAME_DECL	::=
//	renames_obj_decl | renames_exc_decl;
//  SIMPLE_RENAME_DECL	=>
//	as_name	: NAME;
//  renames_obj_decl	=>
//	as_type_mark_name	: NAME;
//  renames_exc_decl	=> ;
//  UNIT_KIND		::=
//	RENAME_INSTANT;
//  RENAME_INSTANT		::=
//	renames_unit;
//  RENAME_INSTANT		=>
//	as_name	: NAME;
//  renames_unit		=> ;
//  task_decl		=>
//	as_decl_s	: decl_s;
//  task_spec		=>
//	sm_decl_s	: decl_s,
//	sm_body	: BODY,
//	sm_address	: EXP,
//	sm_size	: EXP,
//	sm_storage_size	: EXP,
//	xd_stub	: stub,
//	xd_body	: SUBUNIT_BODY;
//  task_body		=> ;
//  UNIT_NAME		::=
//	task_body_id;
//  task_body_id		=>
//	sm_type_spec	: TYPE_SPEC,
//	sm_body	: BODY;
//  ALL_DECL		::=
//	block_master;
//  block_master		=>
//	sm_stm	: STM;
//  SUBP_ENTRY_HEADER	::=
//	entry;
//  entry		=>
//	as_discrete_range	: DISCRETE_RANGE;
//  SOURCE_NAME	::=
//	entry_id;
//  entry_id		=>
//	sm_spec	: HEADER,
//	sm_address	: EXP;
//  entry_call		=> ;
//  accept		=>
//	as_name	: NAME,
//	as_param_s	: param_s,
//	as_stm_s	: stm_s;
//  delay		=> ;
//  selective_wait		=> ;
//  TEST_CLAUSE_ELEM	::=
//	TEST_CLAUSE | select_alt_pragma;
//  TEST_CLAUSE		::=
//	select_alternative;
//  test_clause_elem_s	=>
//	as_list	: Seq Of TEST_CLAUSE_ELEM;
//  select_alternative	=> ;
//  select_alt_pragma	=>
//	as_pragma	: pragma;
//  STM		::=
//	terminate;
//  terminate		=> ;
//  ENTRY_STM		::=
//	cond_entry | timed_entry;
//  ENTRY_STM		=>
//	as_stm_s1	: stm_s,
//	as_stm_s2	: stm_s;
//  cond_entry		=> ;
//  timed_entry		=> ;
//  name_s		=>
//	as_list	: Seq Of NAME;
//  abort		=>
//	as_name_s	: name_s;
//  compilation		=>
//	as_compltn_unit_s	: compltn_unit_s;
//  compltn_unit_s		=>
//	as_list	: Seq Of compilation_unit;
//  pragma_s		=>
//	as_list	: Seq Of pragma;
//  compilation_unit	=>
//	as_context_elem_s	: context_elem_s,
//	as_all_decl	: ALL_DECL,
//	as_pragma_s	: pragma_s,
//	xd_timestamp	: Integer,
//	xd_with_list	: Seq Of trans_with,
//	xd_nbr_pages	: Integer,
//	xd_parent	: compilation_unit,
//	xd_lib_name	: symbol_rep;
//  CONTEXT_ELEM		::=
//	context_pragma;
//  context_pragma		=>
//	as_pragma	: pragma;
//  context_elem_s		=>
//	as_list	: Seq Of CONTEXT_ELEM;
//  CONTEXT_ELEM		::=
//	with;
//  with		=>
//	as_name_s	: name_s,
//	as_use_pragma_s	: use_pragma_s;
//  use_pragma_s		=>
//	as_list	: Seq Of USE_PRAGMA;
//  subunit		=>
//	as_name	: NAME,
//	as_subunit_body	: SUBUNIT_BODY;
//  SUBUNIT_BODY		::=
//	subprogram_body | package_body | task_body;
//  SUBUNIT_BODY		=>
//	as_source_name	: SOURCE_NAME,
//	as_body	: BODY;
//  stub		=> ;
//  exception_decl		=> ;
//  SOURCE_NAME		::=
//	exception_id;
//  exception_id		=>
//	sm_renames_exc	: NAME,
//	cd_label	: Integer;
//  raise		=> ;
//  HEADER		::=
//	package_spec;
//  generic_decl		=>
//	as_item_s	: item_s;
//  NON_TASK_NAME		::=
//	generic_id;
//  generic_id		=>
//	sm_generic_param_s	: item_s,
//	sm_body	: BODY,
//	sm_is_inline	: BOOLEAN;
//  UNIT_KIND		::=
//	GENERIC_PARAM;
//  GENERIC_PARAM		::=
//	name_default | box_default | no_default;
//  name_default		=>
//	as_name	: NAME;
//  box_default		=> ;
//  no_default		=> ;
//  TYPE_DEF		::=
//	formal_dscrt_def | formal_integer_def | formal_fixed_def | formal_float_def;
//  formal_dscrt_def	=> ;
//  formal_fixed_def	=> ;
//  formal_float_def	=> ;
//  formal_integer_def	=> ;
//  RENAME_INSTANT		::=
//	instantiation;
//  instantiation		=>
//	as_general_assoc_s	: general_assoc_s,
//	sm_decl_s	: decl_s;
//  REP		::=
//	NAMED_REP | record_rep;
//  REP		=>
//	as_name	: NAME;
//  NAMED_REP		=>
//	as_exp	: EXP;
//  NAMED_REP		::=
//	length_enum_rep;
//  length_enum_rep		=> ;
//  ALIGNMENT_CLAUSE	::=
//	alignment;
//  alignment		=>
//	as_pragma_s	: pragma_s,
//	as_exp	: EXP;
//  record_rep		=>
//	as_alignment_clause	: ALIGNMENT_CLAUSE,
//	as_comp_rep_s	: comp_rep_s;
//  COMP_REP_ELEM		::=
//	comp_rep | comp_rep_pragma;
//  comp_rep_s		=>
//	as_list	: Seq Of COMP_REP_ELEM;
//  comp_rep		=>
//	as_name	: NAME,
//	as_exp	: EXP,
//	as_range	: RANGE;
//  comp_rep_pragma		=>
//	as_pragma	: pragma;
//  NAMED_REP		::=
//	address;
//  address		=> ;
//  code		=> ;
//  PREDEF_NAME		::=
//	  attribute_id | pragma_id | argument_id | bltn_operator_id;
//  attribute_id		=>
//	xd_pos	: Integer;			-- Predefined_Attributes'POS
//  TYPE_SPEC		::=
//	universal_integer | universal_fixed | universal_real;
//  universal_integer	=> ;
//  universal_fixed		=> ;
//  universal_real		=> ;
//  argument_id		=>
//	xd_pos	: Integer;			-- 'POS in appropriate enum type
//  bltn_operator_id	=>
//	sm_operator	: Integer;			-- (bltn_operators'POS)
//  pragma_id		=>
//	sm_argument_id_s	: argument_id,
//	xd_pos	: Integer;			-- Defined_Pragmas'POS
//  argument_id_s	=>
//	as_list	: Seq Of argument_id;
//  ALL_SOURCE		::=
//	  DEF_NAME	| ALL_DECL	| TYPE_DEF	| SEQUENCES
//	| STM_ELEM	| GENERAL_ASSOC	| CONSTRAINT	| CHOICE
//	| HEADER	| UNIT_DESC	| TEST_CLAUSE_ELEM
//	| MEMBERSHIP_OP	| SHORT_CIRCUIT_OP	| ITERATION
//	| ALTERNATIVE_ELEM	| COMP_REP_ELEM	| CONTEXT_ELEM
//	| VARIANT_ELEM	| ALIGNMENT_CLAUSE	| VARIANT_PART
//	| comp_list	| compilation	| compilation_unit	| index;
//  SEQUENCES		::=
//	  alternative_s	| argument_id_s	| choice_s
//	| comp_rep_s	| compltn_unit_s	| context_elem_s
//	| decl_s	| dscrmt_decl_s	| general_assoc_s
//	| discrete_range_s	| enum_literal_s	| exp_s	| item_s
//	| index_s | name_s	| param_s	| pragma_s	| scalar_s
//	| source_name_s	| stm_s	| test_clause_elem_s
//	| use_pragma_s	| variant_s;
//  ALL_SOURCE		=>
//	lx_srcpos	: Source_Position,
//	lx_comments	: comments;
//  ALL_DECL		::=
//	ITEM | subunit;
//  user_root		=>
//  	xd_sourcename	: txtrep,
//	xd_grammar	: void,
//	xd_statelist	: void,
//	xd_structure	: compilation,
//	xd_timestamp	: Integer,
//	spare_3	: void;
//  NON_DIANA		::=
//	user_root;
//  NON_DIANA		::=
//	real_val | trans_with | lib_info;
//  real_val		=>			-- universal real values
//	xd_numer	: num_val,
//	xd_denom	: num_val;
//  trans_with		=>
//	tw_filename	: txtrep,
//	tw_comp_unit	: compilation_unit;
//  lib_info		=>
//	xd_short	: txtrep,
//	xd_primary	: txtrep,
//	xd_secondary	: txtrep;
//  any_integer     	=> ;
//  any_real		=> ;
//  any_access		=> ;
//  any_composite   	=> ;
//  any_string		=> ;
//  any_access_of   	=>
//	xd_item 	: ITEM;
//  UNSPECIFIED_TYPE	::=
//	any_access | any_composite | any_string | any_access_of | any_integer | any_real;
//  NON_DIANA		::=
//	def | UNSPECIFIED_TYPE;
//  def 		=>
//	xd_header	: HEADER,
//	xd_source_name	: SOURCE_NAME,
//	xd_region_def	: def,
//	xd_is_in_spec	: BOOLEAN,
//	xd_lex_level	: Integer,			-- 0 pour la base
//	xd_is_used	: BOOLEAN;
// implicit_conv    	=>
//	xd_item 	: ITEM,			-- (or type spec)
//	xd_list 	: Seq Of EXP;
// nullary_call     	=>
//	xd_item 	: ITEM;
// NON_DIANA		::=
//	implicit_conv | nullary_call;
// end	--| Fin de specification IDL
