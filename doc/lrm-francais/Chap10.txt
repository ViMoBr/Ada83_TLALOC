
              10. Structure du programme et problèmes de compilation  

La structure globale des programmes et les installations pour des
compilation sont décrites dans ce chapitre. Un programme est un ensemble de
une ou plusieurs unités de compilation soumises à un compilateur en un ou plusieurs
compilations. Chaque unité de compilation spécifie la compilation séparée de
une construction qui peut être une déclaration ou un corps de sous-programme, un package
déclaration ou corps, une déclaration ou un corps générique, ou un
instanciation. Alternativement, cette construction peut être une sous-unité, dans laquelle
Dans ce cas, il inclut le corps d'un sous-programme, d'un package, d'une unité de tâche ou d'un générique.
unité déclarée dans une autre unité de compilation.

Références : compilation 10.1, unité de compilation 10.1, corps générique 12.2,
déclaration générique 12.1, instanciation générique 12.3, corps du package 7.1,
déclaration du package 7.1, corps du sous-programme 6.3, déclaration du sous-programme 6.1,
sous-unité 10.2, corps de tâche 9.1, unité de tâche 9  

10.1 Unités de compilation - Unités de bibliothèque 

Le texte d'un programme peut être soumis au compilateur en un ou plusieurs
compilations. Chaque compilation est une succession d'unités de compilation.

   compilation ::= {compilation_unit}

   unité_compilation ::=
        clause_contexte bibliothèque_unité | clause_contexte unité_secondaire

   bibliothèque_unité ::=
        déclaration_sous-programme | déclaration_paquet
      | déclaration_générique | générique_instantiation
      | sous-programme_body

   unité_secondaire ::= library_unit_body | sous-unité

   library_unit_body ::= subprogram_body | package_body

Les unités de compilation d'un programme appartiennent à une bibliothèque de programmes.
Une unité de compilation définit soit une unité de bibliothèque, soit une unité secondaire. UN
l'unité secondaire est soit le corps propre d'une bibliothèque, compilé séparément 
unité, ou une sous-unité d’une autre unité de compilation. Le désignateur d'un
un sous-programme compilé séparément (qu'il s'agisse d'une unité de bibliothèque ou d'une sous-unité) doit
être un identifiant. Dans une bibliothèque de programmes, les noms simples de toutes les bibliothèques
les unités doivent être des identifiants distincts.   

L'effet de la compilation d'une unité de bibliothèque est de définir (ou redéfinir) cette unité
comme celui qui appartient à la bibliothèque de programmes. Pour les règles de visibilité, chacun
L'unité de bibliothèque agit comme une déclaration qui se produit immédiatement dans le
forfait STANDARD.

L'effet de la compilation d'une unité secondaire est de définir le corps d'une bibliothèque
unité, ou dans le cas d'une sous-unité, pour définir le corps propre d'un programme
unité déclarée dans une autre unité de compilation.                                                

Un corps de sous-programme donné dans une unité de compilation est interprété comme un corps de sous-programme
unité si la bibliothèque de programmes contient déjà une unité de bibliothèque qui est une
sous-programme du même nom ; il est par ailleurs interprété à la fois comme un
unité de bibliothèque et en tant que corps d'unité de bibliothèque correspondant (c'est-à-dire en tant que
unité secondaire).

Les unités de compilation d'une compilation sont compilées dans l'ordre indiqué. UN
le pragma qui s'applique à l'ensemble d'une compilation doit apparaître avant le
première unité de compilation de cette compilation.

Un sous-programme qui est une unité de bibliothèque peut être utilisé comme programme principal dans le
sens habituel. Chaque programme principal agit comme s'il était appelé par une tâche d'environnement ;
les moyens par lesquels cette exécution est initiée ne sont pas prescrits par le
définition du langage. Une implémentation peut imposer certaines exigences à
les paramètres et sur le résultat, le cas échéant, d'un programme principal (ces
les exigences doivent être indiquées à l’annexe F). En tout cas, chaque
la mise en œuvre est nécessaire pour permettre, au moins, aux principaux programmes qui sont
procédures sans paramètres, et chaque programme principal doit être un sous-programme qui
est une unité de bibliothèque.

Remarques:

Un programme simple peut consister en une seule unité de compilation. Une compilation
il n'est pas nécessaire d'avoir d'unités de compilation ; par exemple, son texte peut consister en
pragmas.

Le désignateur d'une fonction de bibliothèque ne peut pas être un symbole d'opérateur, mais un
La déclaration de renommage est autorisée à renommer une fonction de bibliothèque en tant que
opérateur. Deux sous-programmes de bibliothèque doivent avoir des noms simples distincts et
ils ne peuvent donc pas se surcharger les uns les autres. Cependant, renommer les déclarations est
autorisé à définir des noms surchargés pour de tels sous-programmes, et un local
Le sous-programme déclaré est autorisé à surcharger un sous-programme de bibliothèque. Le
le nom étendu STANDARD.L peut être utilisé pour une unité de bibliothèque L (sauf si le nom
STANDARD est masqué) puisque les unités de bibliothèque agissent comme des déclarations qui se produisent
immédiatement dans le colis STANDARD.

Références : autoriser 1.6, clause contextuelle 10.1.1, déclaration 3.1, désignateur
6.1, environnement 10.4, déclaration générique 12.1, instanciation générique
12.3, masquage 8.3, identifiant 2.3, unité de bibliothèque 10.5, déclaration locale 8.1,
doit 1.6, nom 4.1, apparaître immédiatement dans 8.1, opérateur 4.5, opérateur
symbole 6.1, surcharge 6.6 8.7, corps du colis 7.1, déclaration du colis 7.1,
paramètre d'un sous-programme 6.2, pragma 2.8, procédure 6.1, unité de programme 6,
corps propre 3.9, déclaration de renommage 8.5, nom simple 4.1, standard
package 8.6, sous-programme 6, corps du sous-programme 6.3, déclaration de sous-programme 6.1,
sous-unité 10.2, tâche 9, visibilité 8.3   

10.1.1 Clauses contextuelles - Clauses avec 

Une clause de contexte est utilisée pour spécifier les unités de bibliothèque dont les noms sont
nécessaires au sein d’une unité de compilation.  

   clause_contexte ::= {with_clause {use_clause}}

   with_clause ::= avec unit_simple_name {, unit_simple_name} ;

Les noms qui apparaissent dans une clause contextuelle doivent être les noms simples de
unités de bibliothèque. Le simple nom de n'importe quelle unité de bibliothèque est autorisé dans un
avec clause. Les seuls noms autorisés dans une clause d'utilisation d'une clause de contexte
sont les noms simples des packages de bibliothèque mentionnés par les clauses with précédentes
de la clause contextuelle. Un nom simple déclaré par une déclaration de renommage est
non autorisé dans une clause contextuelle.

Les clauses with et use de la clause contextuelle d'une unité de bibliothèque
s'appliquent à cette unité de bibliothèque ainsi qu'à l'unité secondaire qui définit la
organisme correspondant (qu'une telle clause soit répétée ou non pour cette
unité). De même, les clauses with et use de la clause contextuelle
d'une unité de compilation s'appliquent à cette unité ainsi qu'à ses sous-unités, le cas échéant.                                        

Si une unité de bibliothèque est nommée par une clause with qui s'applique à une compilation
unité, alors cette unité de bibliothèque est directement visible au sein de la compilation
unité, sauf là où elle est cachée ; l'unité de bibliothèque est visible comme si elle était déclarée
immédiatement dans l'emballage STANDARD (voir 8.6).

Les dépendances entre les unités de compilation sont définies par des clauses with ; c'est,
une unité de compilation qui mentionne d'autres unités de bibliothèque dans ses clauses with
dépend de ces unités de bibliothèque. Ces dépendances entre unités sont prises
en compte pour la détermination de l'ordre de compilation autorisé (et
recompilation) des unités de compilation, comme expliqué à la section 10.3, et pour  
la détermination de l'ordre autorisé d'élaboration des unités de compilation,
comme expliqué à la section 10.5.

Remarques:

Une unité de bibliothèque nommée par une clause with d'une unité de compilation est visible
(sauf là où il est caché) dans l'unité de compilation et peut donc être utilisé comme
une unité de programme correspondante. Ainsi au sein de l'unité de compilation, le nom
d'un package de bibliothèque peut être donné dans des clauses d'utilisation et peut être utilisé pour former
noms étendus ; un sous-programme de bibliothèque peut être appelé ; et des cas de
l’unité générique de la bibliothèque peut être déclarée.

Les règles données pour les clauses with sont telles que l'on obtient le même effet
si le nom d'une unité de bibliothèque est mentionné une ou plusieurs fois par
les clauses with applicables, ou même dans une clause with donnée.

Exemple 1 : Un programme principal :

Ce qui suit est un exemple de programme principal composé d'un seul
unité de compilation : une procédure pour imprimer les racines réelles d'un quadratique
équation. Le package prédéfini TEXT_IO et un package défini par l'utilisateur
REAL_OPERATIONS (contenant la définition du type REAL et du
packages REAL_IO et REAL_FUNCTIONS) sont supposés être déjà présents dans
la bibliothèque de programmes. De tels packages peuvent être utilisés par d'autres programmes principaux.

   avec TEXT_IO, REAL_OPERATIONS ; utilisez REAL_OPERATIONS ;
   la procédure QUADRATIC_EQUATION est
      A, B, C, D : RÉEL ;
      utilisez REAL_IO, -- obtient une visibilité directe de GET et PUT
                               pour de vrai
          TEXT_IO, -- obtient une visibilité directe de PUT pour les chaînes
                               et de NEW_LINE
          REAL_FUNCTIONS ; -- obtient une visibilité directe de SQRT
   commencer
      OBTENIR UN); OBTENIR(B); OBTENIR(C);
      D := B**2 - 4,0*A*C;
      si D < 0,0 alors
         PUT("Racines Imaginaires.");
      autre
         PUT("Racines réelles : X1 = ");
         METTRE((-B - SQRT(D))/(2.0*A)); METTRE(" X2 = ");
         PUT((-B + SQRT(D))/(2.0*A));
      fin si;
      NOUVELLE LIGNE;
   fin QUADRATIC_EQUATION ;   

Notes sur l'exemple :

Les clauses with d'une unité de compilation doivent uniquement mentionner les noms de ceux
sous-programmes et packages de bibliothèque dont la visibilité est réellement nécessaire
au sein de l’unité. Ils n'ont pas besoin (et ne devraient pas) mentionner une autre bibliothèque
des unités qui sont utilisées à leur tour par certaines des unités nommées dans les clauses with,
à moins que ces autres unités de bibliothèque ne soient également utilisées directement par l'actuel
unité de compilation. Par exemple, le corps du package REAL_OPERATIONS peut
besoin d'opérations élémentaires fournies par d'autres packages. Ces derniers forfaits
ne doit pas être nommé par la clause with de QUADRATIC_EQUATION puisque ces
les opérations élémentaires ne sont pas directement appelées au sein de son corps.                                             

Références : autoriser 1.6, unité de compilation 10.1, visibilité directe 8.3,
élaboration 3.9, corps générique 12.2, unité générique 12.1, masquage 8.3, instance
12.3, unité de bibliothèque 10.1, programme principal 10.1, doit 1.6, nom 4.1, package 7,
corps du package 7.1, déclaration du package 7.1, procédure 6.1, unité de programme 6,
unité secondaire 10.1, nom simple 4.1, package standard prédéfini 8.6,
corps du sous-programme 6.3, déclaration du sous-programme 6.1, sous-unité 10.2, type 3.3,
utiliser la clause 8.4, visibilité 8.3  

10.1.2 Exemples d'unités de compilation 

Une unité de compilation peut être divisée en plusieurs unités de compilation. Pour
Par exemple, considérons le programme suivant.

   procédure PROCESSEUR est

      PETIT : constante := 20;
      TOTAL : ENTIER := 0;

      Le STOCK du colis est
         LIMITE : constante := 1
         TABLE : tableau (1 .. LIMIT) de INTEGER ;  
         procédure RESTART ;
      fin du STOCK ;

      Le STOCK du corps du colis est
         la procédure RESTART est
         commencer
            pour N en 1 .. boucle LIMIT
               TABLEAU(N) := N;
            terminer la boucle ;
         fin;
      commencer
         REDÉMARRAGE;
      fin du STOCK ;

      la procédure UPDATE(X : INTEGER) est
         utilisez du STOCK ;
      commencer
         ...
         TABLEAU(X) := TABLEAU(X) + PETIT;
         ...
      terminer la MISE À JOUR ;

   commencer
      ...
      STOCK.RESTART ; -- réinitialise TABLE
      ...
   terminer le PROCESSEUR ;

Les trois unités de compilation suivantes définissent un programme avec un effet
équivalent à l'exemple ci-dessus (les lignes discontinues entre les unités de compilation
servir à rappeler au lecteur que ces unités ne doivent pas nécessairement être des textes contigus).         

Exemple 2 : Plusieurs unités de compilation : 

   Le STOCK du colis est
      LIMITE : constante := 1
      TABLE : tableau (1 .. LIMIT) de INTEGER ;
      procédure RESTART ;
   fin du STOCK ;

   -------------------------------------------------

   Le STOCK du corps du colis est
      la procédure RESTART est
      commencer
         pour N en 1 .. boucle LIMIT
            TABLEAU(N) := N;
         terminer la boucle ;
      fin;
   commencer
      REDÉMARRAGE;
   fin du STOCK ;

   -------------------------------------------------

   avec STOCK ;
   procédure PROCESSEUR est
      PETIT : constante := 20;
      TOTAL : ENTIER := 0;

      la procédure UPDATE(X : INTEGER) est
         utilisez du STOCK ;
      commencer
         ...
         TABLEAU(X) := TABLEAU(X) + PETIT;
         ...
      terminer la MISE À JOUR ;
   commencer
      ...
      STOCK.RESTART ; -- réinitialise TABLE
      ...
   terminer le PROCESSEUR ;

A noter que dans cette dernière version, le package STOCK n'a aucune visibilité sur 
des identifiants externes autres que les identifiants prédéfinis (du package
STANDARD). En particulier, STOCK n'utilise aucun identifiant déclaré dans
PROCESSEUR tel que PETIT ou TOTAL ; sinon le STOCK n'aurait pas pu être
extrait du PROCESSEUR de la manière ci-dessus. La procédure PROCESSEUR, sur
par contre, dépend du STOCK et mentionne ce package dans un avec
clause. Cela permet les occurrences internes de STOCK dans le nom développé
STOCK.RESTART et dans la clause d'utilisation.

Ces trois unités de compilation peuvent être présentées en une ou plusieurs compilations.
Par exemple, il est possible de soumettre la spécification du package et le
corps du package ensemble et dans cet ordre dans une seule compilation. 

Références : unité de compilation 10.1, déclaration 3.1, identifiant 2.3,
package 7, corps du package 7.1, spécification du package 7.1, programme 10,
package standard 8.6, utiliser la clause 8.4, visibilité 8.3, avec la clause 10.1.1                                                     

10.2 Sous-unités des unités de compilation 

Une sous-unité est utilisée pour la compilation séparée du corps propre d'un
unité de programme déclarée dans une autre unité de compilation. Cette méthode de
la division d'un programme permet le développement hiérarchique du programme.

   corps_stub ::=
        subprogram_specification est distinct ;
      | le corps du package package_simple_name est séparé ;
      | le corps de la tâche task_simple_name est distinct ;

   sous-unité ::=
        séparé (nom_unité_parent) corps_propre

Un stub de corps n'est autorisé qu'en tant que corps d'une unité de programme (un sous-programme, un
package, une unité de tâches ou une unité générique) si le stub de corps se produit 
immédiatement dans la spécification d'un package de bibliothèque ou dans le
partie déclarative d’une autre unité de compilation.

Si le corps d'une unité de programme est un stub de corps, une sous-unité compilée séparément
contenant le corps approprié correspondant est requis. Dans le cas d'un
sous-programme, les spécifications du sous-programme données dans le corps approprié et dans
le talon de carrosserie doit être conforme (voir 6.3.1).

Chaque sous-unité mentionne le nom de son unité parent, c'est-à-dire la compilation
unité où le talon de corps correspondant est donné. Si l'unité parents est un
unité de bibliothèque, elle est appelée unité de bibliothèque ancêtre. Si l'unité parents
est elle-même une sous-unité, le nom de l'unité parent doit être donné au complet sous forme de
nom développé, commençant par le nom simple de l'unité de bibliothèque ancêtre.
Les noms simples de toutes les sous-unités qui ont la même unité de bibliothèque ancêtre
doivent être des identifiants distincts.

La visibilité au sein du corps propre d'une sous-unité est la visibilité qui serait
être obtenu à l'endroit du talon de corps correspondant (au sein du parent
unité) si les clauses with et les clauses use de la sous-unité étaient annexées à
la clause contextuelle de l’unité parent. Si l'unité parents est elle-même un
sous-unité, alors la même règle est utilisée pour définir la visibilité au sein de la
corps propre de l’unité parents.

L’effet de l’élaboration d’un stub de corps est d’élaborer le bon
corps de la sous-unité.

Remarques:

Deux sous-unités d'unités de bibliothèque différentes dans la même bibliothèque de programmes ont besoin
n'ont pas d'identifiants distincts. Dans tous les cas, leurs noms complets développés sont
distincts, puisque les noms simples des unités de bibliothèque sont distincts et que
les noms simples de toutes les sous-unités qui ont une unité de bibliothèque donnée comme ancêtre
l'unité est également distincte. En renommant les déclarations, surchargées
des noms de sous-programmes qui renomment des sous-unités (distinctes) peuvent être introduits.

Une unité de bibliothèque nommée par la clause with d'une sous-unité peut être masquée
par une déclaration (avec le même identifiant) donnée dans le corps propre du
sous-unité. De plus, une telle unité de bibliothèque peut même être masquée par une déclaration 
donné dans une unité parent puisqu'une unité de bibliothèque agit comme si elle était déclarée dans
STANDARD; cela n'affecte cependant pas l'interprétation du avec
clauses elles-mêmes, puisque seuls les noms d'unités de bibliothèque peuvent apparaître avec
clauses.                                                                          

Références : unité de compilation 10.1, conforme 6.3.1, clause contextuelle 10.1.1,
déclaration 3.1, partie déclarative 3.9, visibilité directe 8.3, élaboration
3.9, nom étendu 4.1.3, corps générique 12.2, unité générique 12, caché
déclaration 8.3, identifiant 2.3, unité de bibliothèque 10.1, déclaration locale 8.1,
nom 4.1, apparaît immédiatement dans 8.1, surcharge 8.3, package 7, package
corps 7.1, spécification du package 7.1, programme 10, unité de programme 6, proprement dit
corps 3.9, déclaration de renommage 8.5, compilation séparée 10.1, nom simple
4.1, sous-programme 6, corps du sous-programme 6.3, spécification du sous-programme 6.1, tâche
9, corps de tâche 9.1, unité de tâche 9.1, utiliser la clause 8.4, visibilité 8.3, avec
clause 10.1.1  

10.2.1 Exemples de sous-unités 

La procédure TOP est d'abord écrite comme une unité de compilation sans sous-unités.

   avec TEXT_IO ;
   la procédure TOP est

      le type REAL correspond aux chiffres 10 ;
      R, S : RÉEL := 1,0 ;

      Le forfait FACILITY est
         PI : constante := 3.14159_26536;
         la fonction F(X : REAL) renvoie REAL ;
         procédure G(Y, Z : RÉEL);
      fin de l'INSTALLATION ;

      Le corps du colis FACILITY est
         -- quelques déclarations locales suivies de 

         fonction F(X : REAL) retour REAL est
         commencer
            -- séquence d'énoncés de F
            ...
         fin F;
         la procédure G(Y, Z : REAL) est
            -- procédures locales utilisant TEXT_IO
            ...
         commencer
            -- séquence d'énoncés de G
            ...
         fin G;
      fin de l'INSTALLATION ;

      la procédure TRANSFORM(U : in out REAL) est
         utiliser l'INSTALLATION ;
      commencer
         U := F(U);
         ...
      fin de TRANSFORMATION ;
   commencer -- HAUT 
      TRANSFORMER(R);
      ...
      INSTALLATION.G(R, S);
   fin HAUT ;                                                                         

Le corps du package FACILITY et celui de la procédure TRANSFORM peuvent être
transformés en sous-unités distinctes de TOP. De même, le corps de la procédure G
peut être transformé en une sous-unité de FACILITY comme suit.

Exemple 3 :

   la procédure TOP est

      le type REAL correspond aux chiffres 10 ;
      R, S : RÉEL := 1,0 ;

      Le forfait FACILITY est
         PI : constante := 3.14159_26536;
         la fonction F(X : REAL) renvoie REAL ;
         procédure G(Y, Z : RÉEL);
      fin de l'INSTALLATION ;

    le corps du package FACILITY est séparé ; -- stub de INSTALLATION
    la procédure TRANSFORM(U : in out REAL) est séparée ; -- stub de TRANSFORMER

   commencer -- HAUT
      TRANSFORMER(R);
      ...
      INSTALLATION.G(R, S);
   fin HAUT ;

   -------------------------------------------------

   séparé (HAUT)
   la procédure TRANSFORM(U : in out REAL) est
      utiliser l'INSTALLATION ;
   commencer
      U := F(U);
      ...  
   fin de TRANSFORMATION ;

   -------------------------------------------------

   séparé (HAUT)
   Le corps du colis FACILITY est
      -- quelques déclarations locales suivies de

      fonction F(X : REAL) retour REAL est
      commencer
         -- séquence d'énoncés de F
         ...
      fin F;

      la procédure G(Y, Z : REAL) est distincte ; -- stub de G
   fin de l'INSTALLATION ;                                                                     

   -------------------------------------------------

   avec TEXT_IO ;
   séparé (TOP.FACILITY) -- nom complet de l'INSTALLATION
   la procédure G(Y, Z : REAL) est
      -- procédures locales utilisant TEXT_IO
      ...
   commencer
      -- séquence d'énoncés de G
      ...
   fin G;

Dans l'exemple ci-dessus, TRANSFORM et FACILITY sont des sous-unités de TOP, et G est un
sous-unité de FACILITY. La visibilité dans la version divisée est la même que dans
la version initiale à un changement près : puisque TEXT_IO n'est utilisé que
dans G, la clause with correspondante est écrite pour G au lieu de for
HAUT. Hormis ce changement, les mêmes identifiants sont visibles à
points de programme correspondants dans les deux versions. Par exemple, tous les
Les éléments suivants sont (directement) visibles dans le corps propre de la sous-unité G :
la procédure TOP, le type REAL, les variables R et S, le package
FACILITY et le numéro nommé PI et les sous-programmes F et G qu'il contient.

Références : body stub 10.2, unité de compilation 10.1, identifiant 2.3, local
déclaration 8.1, nommée numéro 3.2, package 7, corps du package 7.1, procédure
6, corps de procédure 6.3, corps propre 3.9, sous-programme 6, type 3.3, variable
3.2.1, visibilité 8.3, avec clause 10.1.1  

10.3 Ordre de compilation 

Les règles définissant l'ordre dans lequel les unités peuvent être compilées sont directes
conséquences des règles de visibilité et, notamment, du fait que
toute unité de bibliothèque mentionnée par la clause de contexte d'une compilation
L'unité est visible dans l'unité de compilation.

Une unité de compilation doit être compilée après toutes les unités de bibliothèque nommées par son
clause de contexte. Une unité secondaire qui est un sous-programme ou un corps de package doit
être compilé après l’unité de bibliothèque correspondante. Toute sous-unité d'un parent
l'unité de compilation doit être compilée après l'unité de compilation parent.

Si une erreur est détectée lors de la tentative de compilation d'une unité de compilation,
alors la tentative de compilation est rejetée et elle n'a aucun effet
sur la bibliothèque de programmes ; il en va de même pour les recompilations (pas de compilation
l'unité peut devenir obsolète à cause d'une telle recompilation).

L'ordre dans lequel les unités de compilation d'un programme sont compilées doit être
cohérent avec l’ordre partiel défini par les règles ci-dessus.

Des règles similaires s'appliquent pour les recompilations. Une unité de compilation est potentiellement
affecté par un changement dans une unité de bibliothèque nommée par sa clause de contexte. UN
l'unité secondaire est potentiellement affectée par un changement dans le
unité de bibliothèque. Les sous-unités d'une unité de compilation parent sont potentiellement 
affecté par un changement de l'unité de compilation mère. Si une unité de compilation
est recompilé avec succès, les unités de compilation potentiellement affectées par
ces changements sont obsolètes et doivent être recompilés sauf s'ils ne sont plus
nécessaire. Une implémentation peut être en mesure de réduire les coûts de compilation si
on peut en déduire que certaines des unités potentiellement affectées ne le sont pas réellement
affectés par le changement.                                                  

Les sous-unités d'une unité peuvent être recompilées sans affecter l'unité elle-même.
De même, les modifications apportées à un sous-programme ou au corps d'un package n'affectent pas les autres
unités de compilation (en dehors des sous-unités du corps) puisque celles-ci
les unités de compilation n'ont accès qu'au sous-programme ou au package
spécification. Une implémentation est uniquement autorisée à déroger à cette règle
pour les inclusions en ligne, pour certaines optimisations du compilateur et pour certaines
implémentations d'unités de programme génériques, comme décrit ci-dessous.

 - Si un pragma INLINE est appliqué à une déclaration de sous-programme donnée dans un
    spécification du package, l'inclusion en ligne ne sera réalisée que si le
    le corps du package est compilé avant les unités appelant le sous-programme. Dans un tel
    Dans ce cas, l'inclusion en ligne crée une dépendance de l'unité appelante vis-à-vis de
    le corps du package, et le compilateur doit reconnaître cette dépendance
    au moment de décider de la nécessité d’une recompilation. Si une unité appelante est
    compilé avant le corps du package, le pragma peut être ignoré par le
    compilateur pour de tels appels (un avertissement indiquant que l'inclusion en ligne n'a pas été
    obtenus peuvent être délivrés). Des considérations similaires s’appliquent à un
    sous-programme compilé pour lequel un pragma INLINE est spécifié.

 - À des fins d'optimisation, une implémentation peut compiler plusieurs unités
    d'une compilation donnée d'une manière qui crée des dépendances supplémentaires entre
    ces unités de compilation. Le compilateur doit alors prendre ces
    dépendances en compte au moment de décider de la nécessité de recompilations.

 - Une implémentation peut nécessiter qu'une déclaration générique et le
    corps propre correspondant fasse partie de la même compilation, que le
    l'unité générique est elle-même compilée séparément ou est locale à une autre
    unité de compilation. Une implémentation peut également exiger que les sous-unités de
    une unité générique fasse partie de la même compilation.

Exemples d'ordre de compilation :

(a) Dans l'exemple 1 (voir 10.1.1) : La procédure QUADRATIC_EQUATION doit être
    compilé après les packages de bibliothèque TEXT_IO et REAL_OPERATIONS depuis
    ils apparaissent dans sa clause with.

(b) Dans l'exemple 2 (voir 10.1.2) : Le corps du colis STOCK doit être compilé
    après la spécification du package correspondant.

(c) Dans l'exemple 2 (voir 10.1.2) : La spécification du colis STOCK
    doit être compilé avant la procédure PROCESSEUR. D'autre part,
    la procédure PROCESSOR peut être compilée avant ou après la
    corps de colis STOCK.

(d) Dans l'exemple 3 (voir 10.2.1) : La procédure G doit être compilée après la
    package TEXT_IO puisque ce package est nommé par la clause with de G.
    D'un autre côté, TEXT_IO peut être compilé avant ou après TOP.

(e) Dans l'exemple 3 (voir 10.2.1) : Les sous-unités TRANSFORM et FACILITY doivent
    être compilé après le programme principal TOP. De même, la sous-unité G doit
    être compilé après son unité parent FACILITY.

Remarques:   

Pour les packages de bibliothèques, il résulte des règles de recompilation qu'un
Le corps du paquet est rendu obsolète par la recompilation du fichier correspondant.
spécification. Si la nouvelle spécification du package est telle qu'un package
body n’est pas obligatoire (c’est-à-dire si la spécification du package ne le précise pas).
contient la déclaration d'une unité de programme), puis la recompilation d'un
Le corps de ce package n’est pas requis. Dans tous les cas, le package obsolète
body ne doit pas être utilisé et peut donc être supprimé du programme
bibliothèque.                                                                          

Références : compilation 10.1, unité de compilation 10.1, clause contextuelle
10.1.1, élaboration 3.9, corps générique 12.2, déclaration générique 12.1,
unité générique 12, unité de bibliothèque 10.1, déclaration locale 8.1, nom 4.1,
package 7, corps du package 7.1, spécification du package 7.1, unité parent 10.2,
pragma inline 6.3.2, procédure 6.1, corps de procédure 6.3, corps propre 3.9,
unité secondaire 10.1, corps du sous-programme 6.3, déclaration du sous-programme 6.1,
spécification de sous-programme 6.1, sous-unité 10.2, type 3.3, variable 3.2.1,
visibilité 8.3, avec clause 10.1.1                                       

10.4 La bibliothèque de programmes 

Les compilateurs sont tenus d'appliquer les règles linguistiques de la même manière pour
un programme composé de plusieurs unités (et sous-unités) de compilation comme pour un
programme présenté en une seule compilation. Par conséquent, un fichier de bibliothèque
contenant des informations sur les unités de compilation de la bibliothèque de programmes doit
être maintenu par le compilateur ou l'environnement de compilation. Cette information
peut inclure des tables de symboles et d'autres informations relatives à l'ordre des
compilations précédentes.

Une soumission normale au compilateur comprend la ou les unités de compilation et
le fichier bibliothèque. Ce dernier sert aux contrôles et est mis à jour à chaque
unité de compilation compilée avec succès.

Remarques:

Une seule bibliothèque de programmes est implicite pour les unités de compilation d'un
compilation. L'existence possible de différentes bibliothèques de programmes et la
les moyens par lesquels ils sont nommés ne relèvent pas de la définition du langage ;
ce sont des préoccupations liées à l’environnement de programmation.

Il devrait y avoir des commandes pour créer la bibliothèque de programmes d'un
programme ou d’une famille de programmes donnée. Ces commandes peuvent permettre au
réutilisation d'unités d'autres bibliothèques de programmes. Enfin, il devrait y avoir
commandes pour interroger l’état des unités d’une bibliothèque de programmes.
La forme de ces commandes n'est pas spécifiée par la définition du langage.

Références : unité de compilation 10.1, clause contextuelle 10.1.1, ordre de
compilation 10.3, programme 10.1, bibliothèque de programmes 10.1, sous-unité 10.2, utilisation
clause 8.4, avec clause 10.1.1  

10.5 Élaboration des unités de bibliothèque 

Avant l'exécution d'un programme principal, toutes les unités de bibliothèque nécessaires au
le programme principal est élaboré, ainsi que l'unité de bibliothèque correspondante
corps, le cas échéant. Les unités de bibliothèque nécessaires au programme principal sont : celles
nommé par avec les clauses applicables au programme principal, à son corps et à
ses sous-unités ; ceux nommés par avec les clauses applicables à ces bibliothèques
unités elles-mêmes, aux corps d'unités de bibliothèque correspondants et à leurs
sous-unités ; et ainsi de suite, de manière transitive.

L'élaboration de ces unités de bibliothèque et de la bibliothèque correspondante
les corps unitaires sont exécutés dans un ordre cohérent avec l'ordre partiel
défini par les clauses with (voir 10.3). De plus, un module bibliothèque
mentionnée par la clause de contexte d'une sous-unité doit être élaborée avant le
corps de l’unité de bibliothèque ancêtre de la sous-unité.

Un ordre d’élaboration cohérent avec cet ordre partiel ne
pas toujours garantir que chaque corps d'unité de bibliothèque soit élaboré avant toute
autre unité de compilation dont l'élaboration nécessite que l'unité de bibliothèque
corps soit déjà élaboré. Si l'élaboration préalable de l'unité de bibliothèque 
des corps sont nécessaires, cela peut être demandé par un pragma ELABORATE. La forme de
ce pragma est le suivant :

   pragma ELABORATE (library_unit_simple_name {, library_unit_simple_name});         

Ces pragmas ne sont autorisés qu'immédiatement après la clause de contexte d'un
unité de compilation (avant l'unité de bibliothèque ou l'unité secondaire suivante). 
Chaque argument d'un tel pragma doit être le simple nom d'une unité de bibliothèque
mentionné par la clause de contexte, et cette unité de bibliothèque doit avoir une bibliothèque
corps unitaire. Un tel pragma précise que le corps de l'unité de bibliothèque doit être
élaboré avant l’unité de compilation donnée. Si la compilation donnée
l'unité est une sous-unité, le corps de l'unité de bibliothèque doit être élaboré avant le corps
de l'unité de bibliothèque ancêtre de la sous-unité.                                           

Le programme est illégal si aucun ordre cohérent ne peut être trouvé (c'est-à-dire si un
la circularité existe). L'élaboration des unités de compilation du
le programme est exécuté dans un ordre qui n'est pas autrement défini par le
langue.

Références : allow 1.6, argument d'un pragma 2.8, unité de compilation 10.1,
clause de contexte 10.1.1, dépendance entre les unités de compilation 10.3,
élaboration 3.9, illégal 1.6, dans un certain ordre 1.6, unité de bibliothèque 10.1, nom
4.1, programme principal 10.1, pragma 2.8, unité secondaire 10.1, séparé
compilation 10.1, nom simple 4.1, sous-unité 10.2, avec clause 10.1.1   

10.6 Optimisation du programme 

Optimisation de l’élaboration des déclarations et de l’exécution des
les instructions peuvent être exécutées par les compilateurs. En particulier, un compilateur peut être
capable d'optimiser un programme en évaluant certaines expressions, en plus
à ceux qui sont des expressions statiques. Si l'une de ces expressions,
qu'il soit statique ou non, soit tel qu'une exception soit levée par son
évaluation, alors le code dans ce chemin du programme peut être remplacé par
code pour déclencher l'exception ; il en va de même pour les exceptions soulevées par le
évaluation de noms et d'expressions simples. (Voir également la section 11.6.)   

Un compilateur peut constater que certaines instructions ou sous-programmes ne seront jamais
exécutés, par exemple, si leur exécution dépend d'une condition connue de
être FAUX. Le code machine objet correspondant peut alors être omis. Ce
La règle autorise l’effet de compilation conditionnelle dans le langage.

Note:

Une expression dont l'évaluation est connue pour déclencher une exception n'a pas besoin d'être
représente une erreur si elle se produit dans une instruction ou un sous-programme qui n'est jamais
réalisé. Le compilateur peut avertir le programmeur d'une erreur potentielle.

Références : condition 5.3, déclaration 3.1, élaboration 3.9, évaluation
4.5, exception 11, expression 4.4, fausse valeur booléenne 3.5.3, programme 10,
levée d'exceptions 11.3, instruction 5, expression statique 4.9, sous-programme 6 
