                        4. Noms et expressions  

Les règles applicables aux différentes formes de nom et d'expression, ainsi qu'aux
leur évaluation, sont données dans ce chapitre.  

4.1 Noms 

Les noms peuvent désigner des entités déclarées, qu'elles soient déclarées explicitement ou
implicitement (voir 3.1). Les noms peuvent également désigner des objets désignés par accès
valeurs; sous-composants et tranches d'objets et de valeurs ; entrées uniques,
familles d'entrées et entrées dans des familles d'entrées. Enfin, les noms peuvent
désignent les attributs de l’un des éléments précédents.

   nom ::= nom_simple
      | caractère_littéral | symbole_opérateur
      | composant_indexé | tranche
      | composant_sélectionné | attribut

   simple_name ::= identifiant

   préfixe ::= nom | appel_fonction

Un nom simple pour une entité est soit l'identifiant associé à l'entité
entité par sa déclaration, ou un autre identifiant associé à l'entité
par une déclaration de changement de nom.

Certaines formes de nom (composants indexés et sélectionnés, tranches et
attributs) incluent un préfixe qui est soit un nom, soit un appel de fonction. Si
le type d'un préfixe est un type d'accès, alors le préfixe ne doit pas être un nom
qui désigne un paramètre formel du mode out ou un sous-composant de celui-ci.

Si le préfixe d'un nom est un appel de fonction, alors le nom désigne un
composant, une tranche, un attribut, une entrée ou une famille d'entrées,
le résultat de l'appel de fonction, ou (si le résultat est une valeur d'accès) de
l'objet désigné par le résultat.

Un préfixe est dit approprié pour un type dans l’un des cas suivants
cas :

 - Le type du préfixe est le type considéré.

 - Le type du préfixe est un type d'accès dont le type désigné est le
    type considéré.   

L'évaluation d'un nom détermine l'entité désignée par le nom. Ce
l'évaluation n'a aucun autre effet pour un nom qui est un nom simple, un
un caractère littéral ou un symbole d'opérateur.

L'évaluation d'un nom comportant un préfixe inclut l'évaluation du
préfixe, c'est-à-dire du nom ou de l'appel de fonction correspondant. Si le type
du préfixe est un type d'accès, l'évaluation du préfixe inclut le
détermination de l'objet désigné par la valeur d'accès correspondante ;
l'exception CONSTRAINT_ERROR est levée si la valeur du préfixe est un
valeur d'accès nulle, sauf dans le cas du préfixe d'une représentation
attribut (voir 13.7.2).                                             

Exemples de noms simples :

   PI -- le nom simple d'un nombre (voir 3.2.2)
   LIMIT -- le nom simple d'une constante (voir 3.2.1)
   COUNT -- le nom simple d'une variable scalaire (voir 3.2.1)
   BOARD -- le nom simple d'une variable de tableau (voir 3.6.1)
   MATRIX -- le nom simple d'un type (voir 3.6)
   RANDOM -- le nom simple d'une fonction (voir 6.1)
   ERROR -- le nom simple d'une exception (voir 11.1)

Références : type d'accès 3.8, valeur d'accès 3.8, attribut 4.1.4, appartiennent à
un type 3.3, caractère littéral 2.5, composant 3.3, constraint_error
exception 11.1, déclaration 3.1, désignation 3.8, type désigné 3.8, entité
3.1, entrée 9.5, famille d'entrées 9.5, évaluation 4.5, paramètre formel 6.1,
appel de fonction 6.4, identifiant 2.3, composant indexé 4.1.1, mode 6.1, null
valeur d'accès 3.8, objet 3.2.1, symbole d'opérateur 6.1, levée d'exceptions  
11, renommer les déclarations 8.5, composant sélectionné 4.1.3, tranche 4.1.2,
sous-composant 3.3, type 3.3   

4.1.1 Composants indexés 

Un composant indexé désigne soit un composant d'un tableau, soit une entrée dans
une famille d'entrées.

   composant_indexé ::= préfixe (expression {, expression})

Dans le cas d'un composant d'un tableau, le préfixe doit être approprié pour
un type de tableau. Les expressions spécifient les valeurs d'index du composant ;
il doit y avoir une telle expression pour chaque position d'index du tableau
taper. Dans le cas d'une entrée dans une famille d'entrées, le préfixe doit être un
nom qui désigne une famille d'entrées d'un objet tâche, et l'expression
(il doit y en avoir exactement un) spécifie la valeur d'index pour l'individu
entrée.

Chaque expression doit être du type de l'index correspondant. Pour le
évaluation d'un composant indexé, le préfixe et les expressions sont
évalués dans un ordre qui n’est pas défini par le langage. L'éxéption
CONSTRAINT_ERROR est déclenché si une valeur d'index n'appartient pas à la plage
de l'index correspondant du tableau de préfixes ou de la famille d'entrées.

Exemples de composants indexés :

 MY_SCHEDULE(SAT) -- un composant d'un tableau unidimensionnel (voir 3.6.1)
 PAGE(10) -- un composant d'un tableau unidimensionnel (voir 3.6)
 BOARD(M, J + 1) -- un composant d'un tableau à deux dimensions (voir 3.6.1)
 PAGE(10)(20) -- un composant d'un composant (voir 3.6)
 REQUEST(MEDIUM) -- une entrée dans une famille d'entrées (voir 9.5)
 NEXT_FRAME(L)(M, N) -- un composant d'un appel de fonction (voir 6.1)

Notes sur les exemples :  

Des notations distinctes sont utilisées pour les composants de tableaux multidimensionnels (tels que
comme BOARD) et des tableaux de tableaux (tels que PAGE). Les composants d'un tableau
des tableaux sont des tableaux et peuvent donc être indexés. Ainsi PAGE(10)(20)
désigne le 20ème composant de PAGE(10). Dans le dernier exemple NEXT_FRAME(L)
est un appel de fonction renvoyant une valeur d'accès qui désigne un
tableau à deux dimensions.

Références : approprié pour un type 4.1, un type de tableau 3.6, un composant 3.3,
composant d'un tableau 3.6, exception constraint_error 11.1, dimension 3.6,
entrée 9.5, famille d'entrées 9.5, évaluation 4.5, expression 4.4, appel de fonction
6.4, dans un certain ordre 1.6, index 3.6, nom 4.1, préfixe 4.1, élévation de
exceptions 11, valeur renvoyée 5,8 6,5, objet tâche 9,2                                            

4.1.2 Tranches 

Une tranche désigne un tableau unidimensionnel formé par une séquence de
composants d’un tableau unidimensionnel. Une tranche d'une variable est un
variable; une tranche d'une constante est une constante ; une tranche d'une valeur est un
valeur.

   tranche ::= préfixe (discrete_range)

Le préfixe d'une tranche doit être approprié pour un type de tableau unidimensionnel.
Le type de la tranche est le type de base de ce type de tableau. Les limites de
les plages discrètes définissent celles de la tranche et doivent être du type des
indice; la tranche est une tranche nulle désignant un tableau nul si le discret
range est une plage nulle.

Pour l'évaluation d'un nom qui est une tranche, le préfixe et le discret
range sont évalués dans un ordre qui n’est pas défini par le langage. Le
l'exception CONSTRAINT_ERROR est déclenchée par l'évaluation d'une tranche, d'autres
qu'une tranche nulle, si l'une des limites de la plage discrète ne correspond pas
appartiennent à la plage d’index du tableau de préfixes. (Les limites d'un nul
slice n'a pas besoin d'appartenir au sous-type de l'index.)

Exemples de tranches :

 STARS(1 .. 15) -- une tranche de 15 caractères (voir 3.6.3)
 PAGE(10 .. 10 + SIZE) -- une tranche de composants 1 + SIZE (voir 3.6 et 3.2.1)
 PAGE(L)(A .. B) -- une tranche du tableau PAGE(L) (voir 3.6)
 STARS(1 .. 0) -- une tranche nulle (voir 3.6.3)
 MY_SCHEDULE(WEEKDAY) -- limites données par sous-type (voir 3.6 et 3.5.1)
 STARS(5 .. 15)(K) -- identique à STARS(K) (voir 3.6.3)
                       -- à condition que K soit dans 5 .. 15

Remarques:

Pour un tableau unidimensionnel A, le nom A(N .. N) est une tranche d'un
composant; son type est le type de base de A. Par contre, A(N) est un
composant du tableau A et a le type de composant correspondant.

Références : convient pour un type 4.1, un tableau 3.6, un tableau de type 3.6, un tableau
valeur 3.8, type de base 3.3, appartiennent à un sous-type 3.3, lié à un discret
plage 3.6.1, composant 3.3, type de composant 3.3, constante 3.2.1, contrainte
3.3, exception constraint_error 11.1, dimension 3.6, plage discrète 3.6,
évaluation 4.5, index 3.6, plage d'index 3.6, nom 4.1, tableau nul 3.6.1,
plage nulle 3.5, préfixe 4.1, levée d'exceptions 11, type 3.3, variable
3.2.1  

4.1.3 Composants sélectionnés 

Les composants sélectionnés sont utilisés pour désigner les composants d'enregistrement, les entrées, les entrées
les familles et les objets désignés par des valeurs d'accès ; ils sont également utilisés comme
noms développés comme décrit ci-dessous. 

   selected_component ::= préfixe.selector

   sélecteur ::= simple_name
      | caractère_littéral | symbole_opérateur | tous                                                    

Les quatre formes suivantes de composants sélectionnés sont utilisées pour désigner un
discriminant, un élément d'enregistrement, une entrée ou un objet désigné par un
valeur d'accès :

(a) Un discriminant :

    Le sélecteur doit être un nom simple désignant un discriminant d'un
    objet ou valeur. Le préfixe doit être approprié au type de ceci
    objet ou valeur.

(b) Un élément d'un dossier :

    Le sélecteur doit être un nom simple désignant un composant d'un enregistrement
    objet ou valeur. Le préfixe doit être approprié au type de ceci
    objet ou valeur.

    Pour un composant d'une variante, on vérifie que les valeurs des
    les discriminants sont tels que le dossier comporte cette composante. Le
    l'exception CONSTRAINT_ERROR est levée si cette vérification échoue.

(c) Une entrée unique ou une famille d'entrées d'une tâche :

    Le sélecteur doit être un nom simple désignant une seule entrée ou une entrée
    famille d'une tâche. Le préfixe doit être approprié au type de ceci
    tâche.

(d) Un objet désigné par une valeur d'accès :

    Le sélecteur doit être le mot réservé all. La valeur du préfixe
    doit appartenir à un type d’accès.

Un composant sélectionné de l'une des deux formes restantes est appelé un
nom développé. Dans chaque cas, le sélecteur doit être soit un simple nom, soit un
un caractère littéral ou un symbole d'opérateur. Un appel de fonction n'est pas autorisé
comme préfixe d'un nom développé. Un nom développé peut désigner :

(e) Une entité déclarée dans la partie visible d'un package :

    Le préfixe doit désigner le package. Le sélecteur doit être le simple
    nom, caractère littéral ou symbole d'opérateur de l'entité.

(f) Une entité dont la déclaration a lieu immédiatement dans un
    construction:

    Le préfixe doit désigner une construction qui est soit une unité de programme, soit une
    une instruction block, une instruction de boucle ou une instruction accept. Dans le 
    Dans le cas d'une instruction accept, le préfixe doit être soit le simple nom
    de l'entrée ou de la famille d'entrées, ou un nom étendu se terminant par un tel
    nom simple (c'est-à-dire qu'aucun index n'est autorisé). Le sélecteur doit être le
    nom simple, caractère littéral ou symbole d'opérateur d'une entité dont
    La déclaration se produit immédiatement dans la construction.

    Cette forme de nom développé n'est autorisée que dans la construction elle-même
    (y compris le corps et les éventuelles sous-unités, dans le cas d'une unité de programme).
    Un nom déclaré par une déclaration de renommage n'est pas autorisé car le 
    préfixe. Si le préfixe est le nom d'un sous-programme ou d'une instruction accept
    et s'il y a plus d'un sous-programme visible ou accepter
    déclaration de ce nom, le nom développé est ambigu, indépendamment
    du sélecteur.

Si, selon les règles de visibilité, il existe au moins un
interprétation du préfixe d'un composant sélectionné comme nom d'un
englobant le sous-programme ou l'instruction accept, alors les seules interprétations
considérés sont ceux de la règle (f), comme noms développés (aucune interprétation de
le préfixe comme appel de fonction sont alors considérés).                                              

L'évaluation d'un nom qui est un composant sélectionné inclut le
évaluation du préfixe.

Exemples de composants sélectionnés :

 TOMORROW.MONTH -- un composant d'enregistrement (voir 3.7)
 NEXT_CAR.OWNER -- un composant d'enregistrement (voir 3.8.1)
 NEXT_CAR.OWNER.AGE -- un composant d'enregistrement (voir 3.8.1)
 WRITER.UNIT -- un composant d'enregistrement (un discriminant) (voir 3.7.3)
 MIN_CELL(H).VALUE -- un composant d'enregistrement du résultat (voir 6.1 et 3.8.1)
                    -- de l'appel de fonction MIN_CELL(H)
 CONTROL.SEIZE -- une entrée de la tâche CONTROL (voir 9.1 et 9.2)
 POOL(K).WRITE -- une entrée de la tâche POOL(K) (voir 9.1 et 9.2)

 NEXT_CAR.all -- l'objet désigné par
                    -- la variable d'accès NEXT_CAR (voir 3.8.1)

Exemples de noms développés :

 TABLE_MANAGER.INSERT -- une procédure de la partie visible d'un package
                          (voir 7.5)
 KEY_MANAGER."<" -- un opérateur de la partie visible d'un package
                          (voir 7.4.2)
 DOT_PRODUCT.SUM -- une variable déclarée dans un corps de procédure (voir 6.5)
 BUFFER.POOL -- une variable déclarée dans une unité de tâche (voir 9.12)
 BUFFER.READ -- une entrée d'une unité de tâche (voir 9.12)
 SWAP.TEMP -- une variable déclarée dans une instruction block (voir 5.6)
 STANDARD.BOOLEAN -- le nom d'un type prédéfini (voir 8.6 et C)

Note:

Pour un enregistrement dont les composants sont d'autres enregistrements, les règles ci-dessus impliquent
que le nom simple doit être donné à chaque niveau pour le nom d'un
sous-composant. Par exemple, le nom NEXT_CAR.OWNER.BIRTH.MONTH ne peut pas être
raccourci (NEXT_CAR.OWNER.MONTH n’est pas autorisé).

Références : accept instruction 9.5, type d'accès 3.8, valeur d'accès 3.8,
approprié pour un type 4.1, instruction de bloc 5.6, corps d'une unité de programme
3.9, littéral de caractère 2.5, composant d'un enregistrement 3.7, constraint_error
exception 11.1, déclaration 3.1, désigner 3.8, discriminant 3.3, entité
3.1, entrée 9.5, famille d'entrées 9.5, appel de fonction 6.4, index 3.6, boucle
l'instruction 5.5, objet 3.2.1, apparaît immédiatement dans 8.1, opérateur 4.5,
symbole d'opérateur 6.1, surcharge 8.3, package 7, type C prédéfini, préfixe
4.1, corps de procédure 6.3, unité de programme 6, levée d'exceptions 11, enregistrement
3.7, composant d'enregistrement 3.7, déclaration de renommage 8.5, mot réservé 2.9,
nom simple 4.1, sous-programme 6, sous-unité 10.2, tâche 9, objet de tâche 9.2, tâche
unité 9, variable 3.7.3, variante 3.7.3, visibilité 8.3, partie visible 3.7.3  

4.1.4 Attributs 

Un attribut désigne une opération de base d'une entité donnée par un préfixe.  

   attribut ::= préfixe'attribute_designator

   attribut_designator ::= simple_name [(universal_static_expression)]

Les désignateurs d'attribut applicables dépendent du préfixe. Un attribut
peut être une opération de base délivrant une valeur ; alternativement, cela peut être un
fonction, un type ou une plage. La signification du préfixe d'un attribut
doit être déterminable indépendamment du désignateur d'attribut et
indépendamment du fait qu'il s'agisse du préfixe d'un attribut.                                               

Les attributs définis par le langage sont résumés dans l'Annexe A. Dans
De plus, une implémentation peut fournir des attributs définis par l'implémentation ;
leur description doit être donnée en Annexe F. L'indicateur d'attribut de
tout attribut défini par l'implémentation ne doit pas être le même que celui d'un autre
attribut défini par la langue.

L'évaluation d'un nom qui est un attribut consiste en l'évaluation de
le préfixe.

Remarques:

Les désignateurs d'attribut DIGITS, DELTA et RANGE ont le même identifiant
comme mot réservé. Cependant, aucune confusion n'est possible puisqu'un attribut 
le désignateur est toujours précédé d’une apostrophe. Le seul prédéfini
les désignateurs d'attributs qui ont une expression universelle sont ceux pour
certaines opérations de types tableaux (voir 3.6.2).

Exemples d'attributs :

 COLOR'FIRST -- valeur minimale du type d'énumération COLOR
                       (voir 3.3.1 et 3.5)
 RAINBOW'BASE'FIRST -- identique à COLOR'FIRST (voir 3.3.2 et 3.3.3)
 REAL'DIGITS -- précision de type REAL (voir 3.5.7 et 3.5.8)
 BOARD'LAST(2) -- limite supérieure de la deuxième dimension de BOARD
                       (voir 3.6.1 et 3.6.2)
 BOARD'RANGE(1) -- plage d'index de la première dimension de BOARD
                       (voir 3.6.1 et 3.6.2)
 POOL(K)'TERMINATED -- TRUE si la tâche POOL(K) est terminée (voir 9.2 et 9.9)
 DATE'SIZE -- nombre de bits pour les enregistrements de type DATE
                       (voir 3.7 et 13.7.2)
 MESSAGE'ADDRESS -- adresse de la variable d'enregistrement MESSAGE
                       (voir 3.7.2 et 13.7.2)

Références : convient pour un type 4.1, opération de base 3.3.3, déclaré
entité 3.1, nom 4.1, préfixe 4.1, mot réservé 2.9, nom simple 4.1,
expression statique 4.9, type 3.3, expression universelle 4.1O  

4.2 Littéraux 

Un littéral est soit un littéral numérique, un littéral d'énumération, le littéral
null ou une chaîne littérale. L'évaluation d'un littéral donne le
valeur correspondante.

Les littéraux numériques sont les littéraux des types universal_integer et
universal_real. Les littéraux d'énumération incluent les littéraux de caractères et le rendement
valeurs des types d’énumération correspondants. La valeur nulle littérale donne un
valeur d'accès nulle qui ne désigne aucun objet.

Un littéral de chaîne est une opération de base qui combine une séquence de
caractères dans une valeur d'un tableau unidimensionnel d'un type de caractère ;
les limites de ce tableau sont déterminées selon les règles de
agrégats de tableaux positionnels (voir 4.3.2). Pour un littéral de chaîne nulle, le
la limite supérieure est le prédécesseur, tel que donné par l'attribut PRED, du
borne inférieure. L'évaluation d'une chaîne littérale nulle déclenche l'exception
CONSTRAINT_ERROR si la borne inférieure n'a pas de prédécesseur (voir
3.5.5).  

Le type d'une chaîne littérale ainsi que le type du littéral null doivent
être déterminable uniquement à partir du contexte dans lequel ce littéral apparaît,
en excluant le littéral lui-même, mais en utilisant le fait que le littéral nul est un
valeur d'un type d'accès, et de même qu'une chaîne littérale est une valeur de
un type de tableau unidimensionnel dont le type de composant est un type de caractère.

Les caractères littéraux correspondant aux caractères graphiques contenus
dans une chaîne littérale doit être visible à la place de la chaîne littérale
(bien que ces caractères eux-mêmes ne soient pas utilisés pour déterminer le type de
la chaîne littérale).                                              

Exemples:

   3.14159_26536 -- un vrai littéral
   1_345 -- un littéral entier
   CLUBS -- un littéral d'énumération
   'A' : un caractère littéral
   "SOME TEXT" -- une chaîne littérale

Références : type d'accès 3.8, agrégat 4.3, tableau 3.6, tableau lié 3.6,
type de tableau 3.6, littéral de caractère 2.5, type de caractère 3.5.2, type de composant
3.3, exception constraint_error 11.1, désigner 3.8, dimension 3.6,
littéral d'énumération 3.5.1, caractère graphique 2.1, littéral entier 2.4, null
valeur d'accès 3.8, littéral nul 3.8, littéral numérique 2.4, objet 3.2.1, réel 
littéral 2.4, littéral de chaîne 2.6, type 3.3, type universal_integer 3.5.4,
universal_real type 3.5.6, visibilité 8.3  

4.3 Agrégats 

Un agrégat est une opération de base qui combine les valeurs des composants dans un
valeur composite d'un type d'enregistrement ou de tableau.

   agrégat ::=
      (association_composant {, association_composant})

   association_composant ::=
      [choix {| choix} => ] expression

Chaque association de composants associe une expression à des composants
(peut-être aucun). Une association de composants est dite nommée si le
les composants sont spécifiés explicitement par des choix ; on dit autrement que c'est
positionnel. Pour une association positionnelle, le (unique) composant est
implicitement spécifié par position, dans l'ordre des correspondants
déclarations de composants pour les composants d'enregistrement, dans l'ordre d'index pour le tableau
Composants.

Les associations nommées peuvent être données dans n'importe quel ordre (sauf pour le choix
autres), mais si les associations positionnelles et nommées sont utilisées dans le même
globalement, alors les associations de position doivent se produire en premier, à leur
position. Ainsi, une fois qu'une association nommée est utilisée, le reste du
l'agrégat doit utiliser uniquement des associations nommées. Agrégats contenant un seul
L'association de composants doit toujours être donnée en notation nommée. Spécifique
des règles concernant les associations de composants existent pour les agrégats d'enregistrements et
agrégats de tableaux.

Les choix dans les associations de composants ont la même syntaxe que dans les pièces variantes
(voir 3.7.3). Un choix qui est un simple nom de composant n'est autorisé que dans un
enregistrer l’agrégat. Pour une association de composants, un choix simple
l'expression ou une plage discrète n'est autorisée que dans un agrégat de tableau ; un
choix qui est une expression simple spécifie le composant au
valeur d'indice correspondante ; de même, une plage discrète spécifie le
composants aux valeurs d’index dans la plage. Le choix des autres est seulement
autorisé dans une association de composants si l'association apparaît en dernier et a 
ce choix unique ; il spécifie tous les composants restants, le cas échéant.

Chaque composante de la valeur définie par un agrégat doit être représentée
une et une seule fois au total. Chaque agrégat doit donc être complet
et un composant donné ne peut pas être spécifié par plus d'un
choix.

Le type d'un agrégat doit être déterminable uniquement à partir du contexte dans lequel il se trouve.
lequel apparaît l'agrégat, à l'exclusion de l'agrégat lui-même, mais en utilisant le
fait que ce type doit être composite et non limité. Le type d'un
l'agrégat détermine à son tour le type requis pour chacun de ses composants.                                             

Remarques:

La règle ci-dessus implique que la détermination du type d'un agrégat
ne peut utiliser aucune information provenant de l’agrégat. En particulier, ceci
la détermination ne peut pas utiliser le type de l'expression d'un composant
association, ou la forme ou le type d'un choix. Un agrégat peut toujours
être distingué d'une expression entre parenthèses : il s'agit d'un
conséquence du fait qu'une notation nommée est requise pour un agrégat
avec un seul composant.

Références : agrégat de tableau 4.3.2, type de tableau 3.6, opération de base 3.3.3,
choix 3.7.3, composante 3.3, type composite 3.3, valeur composite 3.3,
plage discrète 3.6, expression 4.4, indice 3.6, type limité 7.4.4, primaire
4.4, agrégat d'enregistrements 4.3.1, type d'enregistrement 3.7, expression simple 4.4, simple
nom 4.1, type 3.3, variante partie 3.7.3   

4.3.1 Agrégats d'enregistrements 

Si le type d'un agrégat est un type d'enregistrement, les noms de composants donnés comme
les choix doivent désigner les composants (y compris les discriminants) du dossier
taper. Si le choix autres est donné comme choix d'un agrégat d'enregistrement, il
doit représenter au moins un composant. Une association de composants avec le
choix d'autres ou avec plus d'un choix n'est autorisé que si le
les composants représentés sont tous du même type. L'expression d'un
l'association de composants doit avoir le type de l'enregistrement associé
Composants.

La valeur spécifiée pour un discriminant qui régit une pièce variante doit être
donné par une expression statique (notez que cette valeur détermine quel
les composants dépendants doivent apparaître dans la valeur d'enregistrement).

Pour l'évaluation d'un agrégat d'enregistrements, les expressions données dans le
les associations de composants sont évaluées dans un ordre qui n'est pas défini par
la langue. L'expression d'une association nommée est évaluée une fois pour
chaque composant associé. On vérifie que la valeur de chaque
La sous-composante de l'agrégat appartient au sous-type de cette sous-composante.

L'exception CONSTRAINT_ERROR est levée si cette vérification échoue.

Exemple d'agrégat d'enregistrements avec associations de position :

   (4 JUILLET 1776) -- voir 3.7

Exemples d'agrégats d'enregistrements avec des associations nommées :

   (JOUR => 4, MOIS => JUILLET, ANNÉE => 1776)
   (MOIS => JUILLET, JOUR => 4, ANNÉE => 1776)

   (DISQUE, FERMÉ, VOIE => 5, CYLINDRE => 12) -- voir 3.7.3
   (UNITÉ => DISQUE, ÉTAT => FERMÉ, CYLINDRE => 9, PISTE => 1)

Exemple d'association de composants avec plusieurs choix :  

   (VALUE => 0, SUCC|PRED => new CELL'(0, null, null)) -- voir 3.8.1

   -- L'allocateur est évalué deux fois : SUCC et PRED désignent
       différentes cellules

Note:   

Pour un agrégat avec associations positionnelles, des valeurs discriminantes apparaissent
en premier puisque la partie discriminante est donnée en premier dans le type d'enregistrement
déclaration; ils doivent être dans le même ordre que dans la partie discriminante.                                                

Références : agrégat 4.3, allocateur 4.8, choix 3.7.3, composant
association 4.3, nom du composant 3.7, contrainte 3.3, constraint_error
exception 11.1, dépendent d'un discriminant 3.7.1, discriminant 3.3,
partie discriminante 3.7.1, évaluer 4.5, expression 4.4, dans un certain ordre 1.6,
programme 10, levée d'exceptions 11, composant d'enregistrement 3.7, type d'enregistrement
3.7, satisfont 3.3, expression statique 4.9, sous-composant 3.3, sous-type 3.3.2,
type 3.3, variante partie 3.7.3  

4.3.2 Agrégats de tableaux 

Si le type d'un agrégat est un type tableau unidimensionnel, alors chaque
le choix doit spécifier les valeurs du type d’index et l’expression de chacun
L'association de composants doit être du type composant.

Si le type d'un agrégat est un type tableau multidimensionnel, un
L'agrégat à n dimensions s'écrit comme un agrégat à une dimension, dans lequel
l'expression spécifiée pour chaque association de composants s'écrit elle-même
en tant qu'agrégat à (n-1) dimensions appelé sous-agrégat ; le
Le sous-type d'index de l'agrégat unidimensionnel est donné par le premier index
position du type de tableau. La même règle est utilisée pour écrire un sous-agrégat
s'il est à nouveau multidimensionnel, en utilisant des positions d'index successives. UN
le littéral de chaîne est autorisé dans un agrégat multidimensionnel à la place d'un
tableau unidimensionnel d’un type de caractère. Dans ce qui suit, les règles
concernant les agrégats de tableaux sont formulés en termes de dimensions unidimensionnelles
agrégats.

Hormis une association de composants finaux avec les autres à choix unique, le
le reste (le cas échéant) des associations de composants d'un agrégat de tableau doit être
soit tous positionnels, soit tous nommés. Une association nommée d'un tableau
l'agrégat n'a que le droit d'avoir un choix qui n'est pas statique, ou de même
un choix qui est une plage nulle, si l'agrégat comprend un seul composant
association et cette association de composants a un seul choix. Un autre
le choix est statique si la contrainte d’index applicable est statique.

Les limites d'un agrégat de tableau qui a un autre choix sont déterminées
par la contrainte d'index applicable. Un autre choix n'est autorisé que si
l'agrégat apparaît dans l'un des contextes suivants (qui définit le
contrainte d'index applicable) :

(a) L'agrégat est un paramètre réel, un paramètre réel générique, le
    expression de résultat d’une fonction, ou l’expression qui suit un
    délimiteur composé d’affectation. De plus, le sous-type du
    paramètre formel correspondant, paramètre formel générique, fonction
    résultat, ou l'objet est un sous-type de tableau contraint.

    Pour un agrégat qui apparaît dans un tel contexte et contient un
    association avec un autre choix, les associations nommées sont autorisées pour
    autres associations uniquement dans le cas d'un paramètre réel (non générique)
    ou résultat de la fonction. Si l'agrégat est un tableau multidimensionnel,
    cette restriction s'applique également à chacun de ses sous-agrégats.   

(b) L'agrégat est l'opérande d'une expression qualifiée dont la marque de type
    désigne un sous-type de tableau contraint.

(c) L'agrégat est l'expression de l'association composante d'un  
    agrégat englobant (tableau ou enregistrement). De plus, si cette enveloppe
    l'agrégat est un agrégat de tableau multidimensionnel alors il est lui-même dans
    l'un de ces trois contextes.

Les limites d'un agrégat de tableau qui n'a pas d'autre choix sont
déterminé comme suit. Pour un agrégat qui a nommé des associations, le
les limites sont déterminées par les choix les plus petits et les plus grands proposés. Pour un
agrégat de position, la limite inférieure est déterminée par l'indice applicable
contrainte si l'agrégat apparaît dans l'un des contextes (a) à (c) ;
sinon, la borne inférieure est donnée par S'FIRST où S est l'indice
sous-type ; dans les deux cas, la limite supérieure est déterminée par le nombre de
Composants.                                                                      

L'évaluation d'un agrégat de tableau qui n'est pas un sous-agrégat se déroule en
deux étapes. Premièrement, les choix de cet agrégat et de ses sous-agrégats,
le cas échéant, sont évalués dans un ordre qui n'est pas défini par le langage.
Deuxièmement, les expressions des associations de composants du tableau
les agrégats sont évalués dans un ordre qui n'est pas défini par le langage ;
l'expression d'une association nommée est évaluée une fois pour chaque association associée
composant. L'évaluation d'un sous-agrégat comprend cette deuxième étape
(la première étape est omise puisque les choix ont déjà été évalués).

Pour l'évaluation d'un agrégat qui n'est pas un tableau nul, une vérification est
fait que les valeurs d'index définies par les choix appartiennent aux valeurs correspondantes
sous-types d'index, et également que la valeur de chaque sous-composant du
l'agrégat appartient au sous-type de ce sous-composant. Pour un
agrégat multidimensionnel à n dimensions, on vérifie que tous 
Les sous-agrégats dimensionnels (n-1) ont les mêmes limites. L'éxéption
CONSTRAINT_ERROR est déclenché si l'une de ces vérifications échoue.

Note:

Les contextes autorisés pour un agrégat de tableau incluant un autre choix sont
de telle sorte que les limites d'un tel agrégat soient toujours connues
contexte.

Exemples d'agrégats de tableaux avec associations de position :

   (7, 9, 5, 1, 3, 2, 4, 8, 6, 0)
   TABLE'(5, 8, 4, 1, autres => 0) -- voir 3.6

Exemples d'agrégats de tableaux avec des associations nommées :

   (1 .. 5 => (1 .. 8 => 0,0)) -- bidimensionnel
   (1 .. N => new CELL) -- N nouvelles cellules, notamment pour N = 0

   TABLE'(2 | 4 | 10 => 1, autres => 0)
   SCHEDULE'(MON .. FRI => TRUE, autres => FALSE) -- voir 3.6
   HORAIRE'(MER | DIM => FAUX, autres => VRAI)

Exemples d'agrégats de tableaux bidimensionnels :

   -- Trois agrégats pour une même valeur de type MATRIX (voir 3.6) :

   ((1.1, 1.2, 1.3), (2.1, 2.2, 2.3))
   (1 => (1.1, 1.2, 1.3), 2 => (2.1, 2.2, 2.3))
   (1 => (1 => 1,1, 2 => 1,2, 3 => 1,3), 2 => (1 => 2,1, 2 => 2,2, 3 => 2,3))

Exemples d'agrégats comme valeurs initiales :

 A : TABLEAU := (7, 9, 5, 1, 3, 2, 4, 8, 6, 0); -- UNE(1)=7, UNE(10)= 8
 B : TABLE := TABLE'(2 | 4 | 10 => 1, autres => 0); --B(1)=0, B(10)=1
 C : constante MATRICE := (1 .. 5 => (1 .. 8 => 0.0));
                                                -- C'PREMIER(1)=1, C'DERNIER(2)=8

 D : BIT_VECTOR(M .. N) := (M .. N => VRAI); -- voir 3.6
 E : BIT_VECTOR(M .. N) := (autres => VRAI);
 F : STRING(1 .. 1) := (1 => 'F'); -- un agrégat à un composant : idem "F"

Références : paramètre réel 6.4.1, agrégat 4.3, type de tableau 3.6,
affectation délimiteur composé 5.2, choix 3.7.3, composant 3.3, composant
association 4.3, type de composant 3.3, sous-type de tableau contraint 3.6,  
contrainte 3.3, exception constraint_error 11.1, dimension 3.6, évaluer
4.5, expression 4.4, paramètre formel 6.1, fonction 6.5, dans un certain ordre 1.6,
contrainte d'index 3.6.1, plage d'index 3.6, sous-type d'index 3.6, type d'index 3.6,
association de composants nommés 4.3, tableau nul 3.6.1, objet 3.2, positionnel
association de composants 4.3, expression qualifiée 4.7, levée d'exceptions
11, expression statique 4.9, sous-composant 3.3, type 3.3                                               

4.4Expressions 

Une expression est une formule qui définit le calcul d'une valeur.

   expression ::=
        relation {et relation} | relation {puis relation}
      | relation {ou relation} | relation {ou bien relation}
      | relation {relation xor}

   rapport ::=
        expression_simple [opérateur_relationnel expression_simple]
      | expression_simple [pas] dans la plage
      | simple_expression [pas] dans type_mark

   expression_simple ::= [unary_adding_operator]
                         terme {binary_adding_operator term}

   terme ::= facteur {facteur multiplying_operator}

   facteur ::= primaire [** primaire] | abs primaire | pas primaire

   primaire ::=
      numérique_littéral | nul | agrégat | chaîne_littérale | nom | répartiteur
    | appel_fonction | type_conversion | expression_qualifiée | (expression)

Chaque primaire a une valeur et un type. Les seuls noms autorisés comme primaires
sont des nombres nommés ; des attributs qui génèrent des valeurs ; et des noms désignant
objets (la valeur d'un tel primaire est la valeur de l'objet) ou
désignant des valeurs. Les noms qui désignent les paramètres formels du mode out ne sont pas
autorisés comme primaires; les noms de leurs sous-composants ne sont autorisés que dans le
case of discriminants. 

Le type d'une expression dépend uniquement du type de ses constituants et
sur les opérateurs appliqués ; pour un constituant ou un opérateur surchargé, le
détermination du type de constituant, ou identification du
opérateur approprié, dépend du contexte. Pour chaque prédéfini
opérateur, les types d’opérande et de résultat sont donnés à la section 4.5.

Exemples de primaires :

   4.0 -- vrai littéral
   PI – numéro nommé
   (1 .. 10 => 0) -- agrégat de tableau
   SOMME -- variable
   INTEGER'LAST -- attribut
   SINE(X) -- appel de fonction
   COULEUR'(BLEU) -- expression qualifiée
   RÉEL(M*N) -- conversion
   (LINE_COUNT + 10) -- expression entre parenthèses

Exemples d'expressions :

   VOLUME -- primaire
   non DÉTRUIT -- facteur
   2*LINE_COUNT – terme 
   -4.0 -- expression simple
   -4,0 + A -- expression simple
   B**2 - 4,0*A*C -- expression simple
   MOT DE PASSE(1 .. 3) = "BWV" -- relation
   COUNT dans SMALL_INT - relation
   COUNT ne fait pas partie de la relation SMALL_INT
   INDEX = 0 ou ITEM_HIT -- expression
   (FROID et ENSOLEILLÉ) ou CHAUD -- expression (les parenthèses sont obligatoires)
   A**(B**C) -- expression (les parenthèses sont obligatoires)                                               

Références : agrégat 4.3, allocateur 4.8, agrégat de tableau 4.3.2, attribut
4.1.4, opérateur d'addition binaire 4.5 4.5.3, contexte de résolution de surcharge 
8.7, opérateur exponentiel 4.5 4.5.6, appel de fonction 6.4, multiplication
opérateur 4.5 4.5.5, nom 4.1, numéro nommé 3.2, littéral nul 3.8, numérique
littéral 2.4, objet 3.2, opérateur 4.5, surcharge 8.3, surcharge d'un
opérateur 6.7, expression qualifiée 4.7, plage 3.5, littéral réel 2.4,
relation 4.5.1, opérateur relationnel 4.5 4.5.2, type de résultat 6.1, chaîne
littéral 2.6, type 3.3, conversion de type 4.6, marque de type 3.3.2, ajout unaire
opérateur 4.5 4.5.4, variable 3.2.1  

4.5 Opérateurs et évaluation d'expression 

Le langage définit les six classes d'opérateurs suivantes. Le
les symboles d'opérateur correspondants (sauf /=), et uniquement ceux-là, peuvent être utilisés comme
désignateurs dans les déclarations de fonctions pour les opérateurs définis par l'utilisateur. Ils
sont donnés par ordre de priorité croissante.

   opérateur_logique ::= et | ou | xor
   opérateur_relationnel ::= = | /= | < | <= | > | >=
   opérateur_adding_binaire ::= + | - | &
   unary_adding_operator ::= + | -
   opérateur_multiplicateur ::= * | / | module | Rem
   high_precedence_operator ::= ** | abdos | pas

Les formes de contrôle de court-circuit et puis et ou bien ont les mêmes
priorité en tant qu’opérateurs logiques. Les tests d'adhésion dans et non dans have
la même priorité que les opérateurs relationnels.

Pour un terme, une expression simple, une relation ou une expression, des opérateurs de niveau supérieur
la priorité sont associées à leurs opérandes avant les opérateurs de niveau inférieur
priorité. Dans ce cas, pour une séquence d’opérateurs de même
niveau de priorité, les opérateurs sont associés dans l'ordre textuel de gauche
à droite; les parenthèses peuvent être utilisées pour imposer des associations spécifiques.

Les opérandes d'un facteur, d'un terme, d'une expression simple ou d'un
relation, et les opérandes d'une expression qui ne contient pas de
formulaire de contrôle des courts-circuits, sont évalués dans un ordre qui n'est pas défini
par la langue (mais avant application de l'opérateur correspondant).
L'opérande droit d'un formulaire de contrôle de court-circuit est évalué si et seulement
si l'opérande de gauche a une certaine valeur (voir 4.5.1).

Pour chaque forme de déclaration de type, certains des opérateurs ci-dessus sont
prédéfinis, c'est-à-dire qu'ils sont implicitement déclarés par la déclaration de type.
Pour chacune de ces déclarations d'opérateur implicites, les noms des paramètres
sont GAUCHE et DROITE pour les opérateurs binaires ; le seul paramètre est appelé
DROITE pour les opérateurs d'addition unaire et pour les opérateurs unaires abs et non.
L'effet des opérateurs prédéfinis est expliqué dans les sous-sections 4.5.1 
à 4.5.7.

Les opérations prédéfinies sur les types entiers donnent soit le résultat mathématique
corriger le résultat ou déclencher l'exception NUMERIC_ERROR. Un prédéfini
opération qui fournit un résultat de type entier (autre que
universal_integer) ne peut déclencher l'exception NUMERIC_ERROR que si le
le résultat mathématique n’est pas une valeur du type. Les opérations prédéfinies
sur des types réels donnent des résultats dont la précision est définie dans la section 4.5.7. UN
opération prédéfinie qui délivre un résultat de type réel (autre que
universal_real) ne peut déclencher l'exception NUMERIC_ERROR que si le résultat est
pas dans la plage des numéros de sécurité du type, comme expliqué dans
paragraphe 4.5.7.                                                                     

Exemples de priorité :

   ni ENSOLEILLÉ ni CHAUD - identique à (pas ENSOLEILLÉ) ou CHAUD
   X > 4,0 et Y > 0,0 -- identique à (X > 4,0) et (Y > 0,0)   

   -4.0*A**2 -- identique à -(4.0 * (A**2))
   abs(1 + A) + B -- identique à (abs (1 + A)) + B
   Y**(-3) -- les parenthèses sont nécessaires
   A / B * C -- identique à (A/B)*C
   A + (B + C) -- évaluez B + C avant de l'ajouter à A

Références : désignateur 6.1, expression 4.4, facteur 4.4, implicite
déclaration 3.1, dans un certain ordre 1.6, type entier 3.5.4, test d'appartenance
4.5.2, nom 4.1, exception numeric_error 11.1, surcharge 6.6 8.7, augmentation
d'une exception 11, plage 3.5, type réel 3.5.6, relation 4.4, numéro de sécurité
3.5.6, formulaire de contrôle des courts-circuits 4.5 4.5.1, expression simple 4.4, terme
4.4, type 3.3, déclaration de type 3.3.1, type universal_integer 3.5.4,
type universel_réel 3.5.6  

4.5.1 Opérateurs logiques et formulaires de contrôle des courts-circuits 

Les opérateurs logiques suivants sont prédéfinis pour tout type booléen et tout
type tableau unidimensionnel dont les composants sont de type booléen ; dans
dans tous les cas, les deux opérandes ont le même type.

Opérateur Opération Type d’opérande Type de résultat

et conjonction de n'importe quel type booléen même type booléen
                              tableau de composants booléens du même type de tableau
ou disjonction inclusive tout type booléen même type booléen
                              tableau de composants booléens du même type de tableau
disjonction exclusive xor tout type booléen même type booléen
                              tableau de composants booléens du même type de tableau

Les opérations sur les tableaux sont effectuées composant par composant sur
composants correspondants, le cas échéant (comme pour l'égalité, voir 4.5.2). Les limites de
le tableau résultant est celui de l'opérande de gauche. On vérifie que
pour chaque composant de l'opérande de gauche, il existe un composant correspondant du
opérande droit, et vice versa. L'exception CONSTRAINT_ERROR est levée si
cette vérification échoue.

Les formes de contrôle de court-circuit puis et ou bien sont définies pour deux
opérandes de type booléen et délivrent un résultat du même type. La gauche
L'opérande d'un formulaire de contrôle de court-circuit est toujours évalué en premier. Si la
opérande gauche d'une expression avec le formulaire de contrôle, puis évalué à
FALSE, l'opérande de droite n'est pas évalué et la valeur de l'expression
c'est faux. Si l'opérande gauche d'une expression avec la forme de contrôle ou
sinon est évalué à TRUE, l'opérande de droite n'est pas évalué et la valeur de
l'expression est VRAIE. Si les deux opérandes sont évalués, puis délivrent
le même résultat que et, et ou bien donne le même résultat que ou. 

Note:

La signification conventionnelle des opérateurs logiques est donnée par la formule suivante.
table de vérité suivante :

   A B (A et B) (A ou B) (A xor B)

   VRAI VRAI VRAI VRAI FAUX
   VRAI FAUX FAUX VRAI VRAI
   FAUX VRAI FAUX VRAI VRAI
   FAUX FAUX FAUX FAUX FAUX                                               

Exemples d'opérateurs logiques :

   ENSOLEILLE ou CHAUD
   FILTRE(1 .. 10) et FILTRE(15 .. 24) -- voir 3.6.1

Exemples de formulaires de contrôle de court-circuit :

   NEXT_CAR.OWNER /= null puis NEXT_CAR.OWNER.AGE > 25 -- voir 3.8.1
   N = 0 ou bien A(N) = HIT_VALUE

Références : type de tableau 3.6, type booléen 3.5.3, limite d'une plage d'index
3.6.1, composant d'un tableau 3.6, exception constraint_error 11.1,  
dimension 3.6, fausse valeur booléenne 3.5.3, sous-type d'index 3.6, correspondance
composants des tableaux 4.5.2, tableau nul 3.6.1, opération 3.3, opérateur 4.5,
opérateur prédéfini 4.5, levée d'exceptions 11, vraie valeur booléenne
3.5.3, tapez 3.3  

4.5.2 Opérateurs relationnels et tests d'appartenance 

Les opérateurs d'égalité et d'inégalité sont prédéfinis pour tout type
pas limité. Les autres opérateurs relationnels sont les opérateurs d'ordonnancement <
(inférieur à), <= (inférieur ou égal), > (supérieur à) et >= (supérieur
supérieur ou égal). Les opérateurs de commande sont prédéfinis pour tout scalaire
type, et pour tout type de tableau discret, c'est-à-dire un tableau unidimensionnel
type dont les composants sont de type discret. Les opérandes de chacun
Les opérateurs relationnels prédéfinis ont le même type. Le type de résultat est le
type prédéfini BOOLEAN.

Les opérateurs relationnels ont leur signification conventionnelle : le résultat est
égal à TRUE si la relation correspondante est satisfaite ; le résultat est
FAUX sinon. L’opérateur d’inégalité donne le résultat complémentaire à
l'opérateur d'égalité : FALSE si égal, TRUE si non égal.

   Opérateur Opération Type d’opérande Type de résultat

   = /= égalité et inégalité de tout type BOOLÉEN

   < <= > >= test pour commander n'importe quel type scalaire BOOLEAN
                                         type de tableau discret BOOLÉEN

L'égalité pour les types discrets est l'égalité des valeurs. Pour de vrai
opérandes dont les valeurs sont presque égales, les résultats des
les opérateurs relationnels sont donnés à la section 4.5.7. Deux valeurs d'accès sont
égaux soit s'ils désignent le même objet, soit si tous deux sont égaux au
valeur nulle du type d'accès.

Pour deux valeurs de tableau ou deux valeurs d'enregistrement du même type, la gauche
l’opérande est égal à l’opérande de droite si et seulement si pour chaque composante de
l'opérande de gauche il y a une composante correspondante de l'opérande de droite et
vice versa; et les valeurs des composants correspondants sont égales, comme indiqué par
l'opérateur d'égalité prédéfini pour le type de composant. En particulier,
deux tableaux nuls du même type sont toujours égaux ; deux enregistrements nuls du 
le même type est toujours égal.

Pour comparer deux enregistrements du même type, les composants correspondants sont ceux
qui ont le même identifiant de composant.

Pour comparer deux tableaux unidimensionnels du même type, correspondant
les composants sont ceux (le cas échéant) dont les valeurs d'index correspondent dans les éléments suivants
sens : les limites inférieures des plages d'index sont définies pour correspondre, et les
les successeurs des indices correspondants sont définis pour correspondre. Pour comparer deux
tableaux multidimensionnels, les composants correspondants sont ceux dont les valeurs d'index
correspondre dans les positions successives de l’index.                                             

Si l'égalité est explicitement définie pour un type limité, elle ne s'étend pas à
types composites ayant des sous-composants du type limité (explicite
la définition de l’égalité est autorisée pour de tels types composites).

Les opérateurs de classement <, <=, > et >= définis pour les tableaux discrets
les types correspondent à l'ordre lexicographique en utilisant la relation d'ordre prédéfinie
du type de composant. Un tableau nul est lexicographiquement inférieur à n'importe quel tableau
tableau ayant au moins un composant. Dans le cas de tableaux non nuls, le
l'opérande de gauche est lexicographiquement inférieur à l'opérande de droite si le premier
la composante de l'opérande gauche est inférieure à celle de droite ; sinon
l'opérande de gauche est lexicographiquement inférieur à l'opérande de droite seulement si  
leurs premières composantes sont égales et la queue de l'opérande de gauche est
lexicographiquement inférieur à celui de droite (la queue est constituée du
composants restants au-delà du premier et peuvent être nuls).

Les tests d'appartenance à et non à sont prédéfinis pour tous les types. Le
Le type de résultat est le type prédéfini BOOLEAN. Pour un test d'adhésion avec un
plage, l'expression simple et les limites de la plage doivent être du type
même type scalaire ; pour un test d'appartenance avec une marque de type, le type du
l'expression simple doit être le type de base de la marque de type. L'évaluation
du test d'appartenance à donne le résultat VRAI si la valeur du simple
l'expression est dans la plage donnée, ou si cette valeur appartient à la
sous-type désigné par la marque de type donnée ; sinon cette évaluation donne
le résultat FAUX (pour une valeur de type réel, voir 4.5.7). L'adhésion
test not in donne le résultat complémentaire au test d'appartenance à.

Exemples:

   X /= Oui

   "" < "A" et "A" < "AA" -- VRAI
   "AA" < "B" et "A" < "A" -- VRAI

   MY_CAR = null -- vrai si MY_CAR a été défini sur null
                                 (voir 3.8.1)
   MY_CAR = YOUR_CAR -- vrai si nous partageons tous les deux la même voiture
   MY_CAR.all = YOUR_CAR.all -- vrai si les deux voitures sont identiques

   N pas dans 1 .. 10 -- test d'appartenance à la plage
   AUJOURD'HUI en LUN .. VEN -- test d'appartenance à la gamme
   AUJOURD'HUI en SEMAINE -- test d'appartenance au sous-type (voir 3.5.1)
   ARCHIVE dans DISK_UNIT -- test d'appartenance au sous-type (voir 3.7.3)

Remarques:

Aucune exception n'est jamais levée par un opérateur relationnel prédéfini ou par un
test d'adhésion, mais une exception peut être soulevée par l'évaluation du
opérandes.

Si un type d'enregistrement comporte des composants qui dépendent de discriminants, deux valeurs de
ce type a des composants correspondants si et seulement si leurs discriminants sont
égal. Deux tableaux non nuls ont des composants correspondants si et seulement si le
la valeur de l'attribut LENGTH(N) pour chaque position d'index N est la même pour
les deux.   

Références : valeur d'accès 3.8, type de tableau 3.6, type de base 3.3, appartiennent à un
sous-type 3.3, type booléen prédéfini 3.5.3, limite d'une plage 3.5, composant
3.3, identifiant de composant 3.7, type de composant 3.3, type composite 3.3,
désigner 3.8, dimension 3.6, type discret 3.5, évaluation 4.5, exception
11, index 3.6, plage d'index 3.6, type limité 7.4.4, valeur d'accès nulle 3.8,
tableau nul 3.6.1, enregistrement nul 3.7, objet 3.2.1, opération 3.3, opérateur
4.5, opérateur prédéfini 4.5, levée d'exceptions 11, plage 3.5, enregistrement
type 3.7, type scalaire 3.5, expression simple 4.4, sous-composant 3.3,
successeur 3.5.5, type 3.3, marque de type 3.3.2                                               

4.5.3 Opérateurs d'ajout binaire 

Les opérateurs d'addition binaire + et - sont prédéfinis pour tout type numérique
et ont leur sens conventionnel. Les opérateurs de caténation & sont
prédéfini pour tout type de tableau unidimensionnel qui n'est pas limité.

Opérateur Opération Type d’opérande gauche Type d’opérande droite Type de résultat

 + ajout de tout type numérique même type numérique même type numérique

 - soustraction de tout type numérique même type numérique même type numérique

 & caténation tout type de tableau même type de tableau même type de tableau
                  n'importe quel type de tableau le type de composant même type de tableau
                  le type de composant n'importe quel type de tableau même type de tableau
                  le type de composant le type de composant n'importe quel type de tableau

Pour les types réels, la précision du résultat est déterminée par l'opérande
type (voir 4.5.7).

Si les deux opérandes sont des tableaux unidimensionnels, le résultat de la caténation
est un tableau unidimensionnel dont la longueur est la somme des longueurs de ses
opérandes, et dont les composants comprennent les composants de l'opérande de gauche
suivi des composantes de l’opérande de droite. La limite inférieure de ceci
le résultat est la limite inférieure de l'opérande de gauche, sauf si l'opérande de gauche est un
tableau nul, auquel cas le résultat de la caténation est le bon
opérande.

Si l’un ou l’autre des opérandes est du type composant d’un type tableau, le résultat de
la caténation est donnée par les règles ci-dessus, en utilisant à la place de cet opérande
un tableau ayant cet opérande comme seul composant et ayant le plus petit
limite du sous-type d'index du type tableau comme limite inférieure.

L'exception CONSTRAINT_ERROR est levée par caténation si la borne supérieure
du résultat dépasse la plage du sous-type d'index, sauf si le résultat est
un tableau nul. Cette exception est également levée si un opérande est de l'ordre
type de composant mais a une valeur qui n’appartient pas au composant
sous-type.

Exemples:

   Z + 0,1 -- Z doit être d'un type réel

   "A" et "BCD" -- caténation de deux chaînes littérales
   'A' & 'BCD' -- caténation d'un caractère littéral et d'une chaîne littérale
   'A' et 'A' -- caténation de deux caractères littéraux

Références : type de tableau 3.6, littéral de caractères 2.5, type de composant 3.3,
exception constraint_error 11.1, dimension 3.6, sous-type d'index 3.6, longueur
d'un tableau 3.6.2, type limité 7.4.4, tableau nul 3.6.1, type numérique 3.5,
opération 3.3, opérateur 4.5, opérateur prédéfini 4.5, levée d'exceptions
11, plage d'un sous-type d'index 3.6.1, type réel 3.5.6, chaîne littérale 2.6,
tapez 3.3  

4.5.4 Opérateurs d'ajout unaire  

Les opérateurs d'addition unaire + et - sont prédéfinis pour tout type numérique et
ont leur sens conventionnel. Pour chacun de ces opérateurs, l'opérande
et le résultat a le même type.                                                  

   Opérateur Opération Type d’opérande Type de résultat

   + identité tout type numérique même type numérique

   - négation de tout type numérique du même type numérique

Références : type numérique 3.5, opération 3.3, opérateur 4.5, prédéfini
opérateur 4.5, type 3.3  

4.5.5 Opérateurs multiplicateurs 

Les opérateurs * et / sont prédéfinis pour tout entier et toute virgule flottante
taper et avoir leur signification conventionnelle ; les opérateurs mod et rem sont
prédéfini pour tout type entier. Pour chacun de ces opérateurs, les opérandes
et le résultat a le même type de base. Pour les types à virgule flottante, le
la précision du résultat est déterminée par le type d'opérande (voir 4.5.7).

 Opérateur Opération Type d’opérande Type de résultat

  * multiplication de tout type entier même type entier
                                n'importe quelle virgule flottante même virgule flottante
                                tapez tapez
  / division entière tout type entier même type entier
             division flottante n'importe quelle virgule flottante même virgule flottante
                                tapez tapez
 module mod tout type entier même type entier
 rem reste tout type entier même type entier

La division entière et le reste sont définis par la relation

   A = (A/B)*B + (A rem B)

où (A rem B) a le signe de A et une valeur absolue inférieure à la
valeur absolue de B. La division entière satisfait l'identité

   (-A)/B = -(A/B) = A/(-B)

Le résultat de l’opération de module est tel que (A mod B) a le signe de
B et une valeur absolue inférieure à la valeur absolue de B ; en outre,
pour une valeur entière N, ce résultat doit satisfaire la relation

   A = B*N + (A mod B)

Pour chaque type de virgule fixe, les multiplications et divisions suivantes
les opérateurs, avec un opérande de type prédéfini INTEGER, sont prédéfinis.

 Opérateur Opération Opérande gauche Opérande droite Type de résultat
                       tapez tapez

  * multipliez n'importe quel point fixe ENTIER comme à gauche
                       taper

                       ENTIER n'importe quel point fixe identique à droite
                                         taper

  / division n'importe quel point fixe ENTIER identique à gauche                        
                       taper

La multiplication entière de valeurs à virgule fixe équivaut à une répétition
ajout. La division d'une valeur à virgule fixe par un nombre entier n'implique pas de
changement de type mais est approximatif (voir 4.5.7).

Enfin, les opérateurs de multiplication et de division suivants sont déclarés
dans le package prédéfini STANDARD. Ces deux opérateurs spéciaux s'appliquent à
opérandes de tous les types de virgules fixes (c'est une conséquence d'autres règles qui
ils ne peuvent pas être renommés ou donnés comme paramètres réels génériques).

Opérateur Opération Opérande gauche Opérande droite Type de résultat
                    tapez type

 * multiplier n'importe quel point fixe n'importe quel point fixe universal_fixed
                    tapez type

 / diviser n'importe quel point fixe n'importe quel point fixe universal_fixed
                    tapez type

La multiplication d'opérandes du même type ou de types de virgule fixe différents est
exact et fournit un résultat du type virgule fixe prédéfini anonyme
universal_fixed dont le delta est arbitrairement petit. Le résultat d'un tel
la multiplication doit toujours être explicitement convertie en un type numérique.
Cela garantit un contrôle explicite de la précision du calcul. Le même
Ces considérations s'appliquent à la division d'une valeur à virgule fixe par une autre valeur à virgule fixe.
valeur en points. Aucun autre opérateur n'est défini pour le type universal_fixed.

L'exception NUMERIC_ERROR est déclenchée par une division entière, rem et mod si
l'opérande de droite est zéro. 

Exemples:

   I : ENTIER := 1;
   J : ENTIER := 2;
   K : ENTIER := 3;

   X : CHIFFRES RÉELS 6 := 1,0 ; -- voir 3.5.7
   Y : CHIFFRES RÉELS 6 := 2,0 ;

   F : FRACTION delta 0,0001 := 0,1; -- voir 3.5.9
   G : FRACTION delta 0,0001 := 0,1;

   Type de résultat de valeur d'expression

   I*J 2 identique à I et J, c'est-à-dire INTEGER
   K/J 1 identique à K et J, c'est-à-dire INTEGER
   K mod J 1 identique à K et J, c'est-à-dire INTEGER

   X/Y 0,5 identique à X et Y, c'est-à-dire REAL
   F/2 0,05 identique à F, c'est-à-dire FRACTION

   3*F 0,3 identique à F, c'est-à-dire FRACTION
   F*G 0.01 universal_fixed, conversion nécessaire
   FRACTION(F*G) 0,01 FRACTION, comme indiqué par la conversion
   REAL(J)*Y 4.0 REAL, le type des deux opérandes après
                               conversion de J                                         

Remarques:

Pour A et B positifs, A/B est le quotient et A rem B est le reste lorsque
A est divisé par B. Les relations suivantes sont satisfaites par le rem  
opérateur:

   Un rem (-B) = Un rem B
   (-A) rem B = -(A rem B)

Pour tout entier K, l’identité suivante est vraie :

     A mod B = (A + K*B) mod B

Les relations entre la division entière, le reste et le module sont
illustré par le tableau suivant : 

  A B A/B A rem B A mod B A B A/B A rem B A mod B

  10 5 2 0 0 -10 5 -2 0 0
  11 5 2 1 1 -11 5 -2 -1 4
  12 5 2 2 2 -12 5 -2 -2 3
  13 5 2 3 3 -13 5 -2 -3 2
  14 5 2 4 4 -14 5 -2 -4 1

  10 -5 -2 0 0 -10 -5 2 0 8
  11 -5 -2 1 -4 -11 -5 2 -1 -1
  12 -5 -2 2 -3 -12 -5 2 -2 -2
  13 -5 -2 3 -2 -13 -5 2 -3 -3
  14 -5 -2 4 -1 -14 -5 2 -4 -4

Références : paramètre réel 6.4.1, type de base 3.3, déclaration 3.1, delta
d'un type à virgule fixe 3.5.9, de type à virgule fixe 3.5.9, de type à virgule flottante
3.5.7, sous-programme formel générique 12.1, type entier 3.5.4, type numérique
3.5, exception numeric_error 11.1, opérateur prédéfini 4.5, augmentation de
exceptions 11, déclaration de renommage 8.5, package prédéfini standard 8.6,
conversion de types 4.6  

4.5.6 Opérateurs de priorité la plus élevée 

L'opérateur unaire abs de priorité la plus élevée est prédéfini pour tout nombre numérique.
taper. L'opérateur unaire de priorité la plus élevée n'est pas prédéfini pour tout
type booléen et tout type de tableau unidimensionnel dont les composants ont un
type booléen.

 Opérateur Opération Type d’opérande Type de résultat

 abs valeur absolue tout type numérique même type numérique

 pas de négation logique, aucun type booléen même type booléen
                             tableau de composants booléens du même type de tableau

L'opérateur not qui s'applique à un tableau unidimensionnel de valeurs booléennes
composants donne un tableau booléen unidimensionnel avec les mêmes limites ;
chaque composante du résultat est obtenue par négation logique du
composant correspondant de l'opérande (c'est-à-dire le composant qui a le
même valeur d'indice).                                                   

L'opérateur exponentiant de priorité la plus élevée ** est prédéfini pour chaque
type entier et pour chaque type à virgule flottante. Dans les deux cas, le droit
L'opérande, appelé exposant, est du type prédéfini INTEGER.

 Opérateur Opération Opérande gauche Opérande droite Type de résultat
                         tapez tapez

  ** exponentiation de tout type entier INTEGER identique à gauche
                         n'importe quel nombre entier à virgule flottante identique à gauche
                         taper

L'exponentiation avec un exposant positif équivaut à une répétition
multiplication de l'opérande de gauche par lui-même, comme indiqué par l'exposant
et de gauche à droite. Pour un opérande de type virgule flottante, le
L'exposant peut être négatif, auquel cas la valeur est l'inverse de la
valeur avec l’exposant positif. Exponentiation par un exposant nul
offre la valeur. Exponentiation d'une valeur d'une virgule flottante
le type est approximatif (voir 4.5.7). L'exponentiation d'un entier augmente le 
exception CONSTRAINT_ERROR pour un exposant négatif.

Références : type de tableau 3.6, type booléen 3.5.3, limite d'un tableau 3.6.1,
composant d'un tableau 3.6, exception constraint_error 11.1, dimensionnalité
3.6, type à virgule flottante 3.5.9, index 3.6, type entier 3.5.4,
opération de multiplication 4.5.5, opérateur prédéfini 4.5, élévation de
exceptions 11  

4.5.7 Précision des opérations avec des opérandes réels 

Un sous-type réel spécifie un ensemble de numéros de modèle. La précision
requis par toute opération basique ou prédéfinie donnant un résultat réel, et
le résultat de toute relation prédéfinie entre opérandes réels est défini dans
termes de ces numéros de modèle.

Un intervalle modèle d'un sous-type est tout intervalle dont les limites sont des modèles
numéros du sous-type. L'intervalle de modèle associé à une valeur qui
appartient à un sous-type réel est le plus petit intervalle de modèle (du sous-type)
cela inclut la valeur. (L'intervalle de modèle associé à un modèle
Le numéro d'un sous-type est constitué uniquement de ce numéro.)

Pour toute opération de base ou opérateur prédéfini qui donne un résultat d'un
sous-type réel, les limites requises sur le résultat sont données par un modèle
intervalle défini comme suit :

 - L'intervalle de modèle résultat est le plus petit intervalle de modèle (des
    sous-type de résultat) qui inclut le minimum et le maximum de tous les
    valeurs obtenues en appliquant l’opération mathématique (exacte), lorsque
    chaque opérande reçoit n'importe quelle valeur de l'intervalle modèle (de l'opérande
    sous-type) défini pour l'opérande.

 - L'intervalle modèle d'un opérande qui est lui-même le résultat d'un
    l'opération, autre qu'une conversion implicite, est le modèle de résultat
    intervalle de cette opération.   

 - L'intervalle modèle d'un opérande dont la valeur est obtenue par implicite  
    la conversion d'une expression universelle est l'intervalle de modèle associé
    avec cette valeur dans le sous-type d'opérande.

L'intervalle du modèle de résultat n'est pas défini si la valeur absolue de l'un des
les résultats mathématiques ci-dessus dépassent le plus grand nombre sûr du résultat
taper. Chaque fois que l'intervalle du modèle de résultat n'est pas défini, il est hautement
souhaitable que l'exception NUMERIC_ERROR soit levée si l'implémentation
ne peut pas produire un résultat réel se situant dans la plage des nombres sûrs. Ce
n'est cependant pas exigé par les règles linguistiques, compte tenu du fait
que certaines machines cibles ne permettent pas une détection aisée des débordements
situations. La valeur de l'attribut MACHINE_OVERFLOWS indique si
la machine cible lève l'exception NUMERIC_ERROR en cas de débordement
situations (voir 13.7.3).                                                           

Les nombres sûrs d'un type réel sont définis (voir 3.5.6) comme un surensemble de
les numéros de modèle, pour lesquels les limites d'erreur suivent les mêmes règles que pour
numéros de modèle. Toute définition donnée dans cette section en termes de modèle
les intervalles peuvent donc être étendus à des intervalles sûrs de nombres sûrs. UN
La conséquence de cette extension est qu'une implémentation n'est pas autorisée à
déclencher l'exception NUMERIC_ERROR lorsque l'intervalle de résultat est sûr
intervalle.

Pour le résultat de l'exponentiation, l'intervalle de modèle définissant les limites sur
le résultat est obtenu en appliquant les règles ci-dessus à la séquence de
multiplications définies par l'exposant, et à la division finale dans le
cas d’un exposant négatif.

Pour le résultat d’une relation entre deux opérandes réels, considérons pour chacun
opérande l'intervalle de modèle (du sous-type d'opérande) défini pour le
opérande ; le résultat peut être n'importe quelle valeur obtenue en appliquant la méthode mathématique
comparaison avec des valeurs arbitrairement choisies dans le modèle d'opérande correspondant
intervalles. Si l'un ou les deux intervalles du modèle d'opérande ne sont pas définis
(et si aucune des évaluations d'opérande ne génère d'exception) alors le
Le résultat de la comparaison peut être n'importe quelle valeur possible (c'est-à-dire
soit VRAI soit FAUX).

Le résultat d'un test d'appartenance est défini en termes de comparaisons des
valeur d'opérande avec les limites inférieure et supérieure de la plage ou du type donné
marque (les règles habituelles s’appliquent à ces comparaisons).

Note:

Pour un type à virgule flottante, les nombres 15,0, 3,0 et 5,0 sont toujours des modèles
Nombres. Par conséquent, X/Y où X est égal à 15,0 et Y est égal à 3,0 donne exactement 5,0.
selon les règles ci-dessus. Dans le cas général, la division ne donne pas
numéros de modèle et par conséquent on ne peut pas supposer que (1,0/X)*X = 1,0.

Références : attribut 4.1.4, opération de base 3.3.3, limite d'une plage 3.5,
limite d'erreur 3.5.6, opération d'exponentiation 4.5.6, fausse valeur booléenne
3.5.3, type à virgule flottante 3.5.9, attribut machine_overflows 13.7.1,
test d'adhésion 4.5.2, numéro de modèle 3.5.6, opération de multiplication 4.5.5,
exception numeric_error 11.1, opération prédéfinie 3.3.3, élévation de
exceptions 11, plage 3.5, type réel 3.5.6, relation 4.4, relationnelle
opérateur 4.5.2 4.5, numéro de sécurité 3.5.6, sous-type 3.3, vraie valeur booléenne
3.5.3, conversion de type 4.6, marque de type 3.3.2, expression universelle 4.1 4 

4.6 Conversions de types 

L'évaluation d'une conversion de type explicite évalue l'expression
donné comme opérande et convertit la valeur résultante en une valeur spécifiée
type de cible. Les conversions de type explicites sont autorisées entre des
types tels que définis ci-dessous.

   type_conversion ::= type_mark(expression)   

Le type cible d'une conversion de type est le type de base de la marque de type.
Le type de l'opérande d'une conversion de type doit être déterminable
indépendamment du contexte (notamment indépendamment de la cible)
taper). De plus, l'opérande d'une conversion de type ne peut pas être
un littéral nul, un allocateur, un agrégat ou une chaîne littérale ; un
l'expression entre parenthèses est autorisée comme opérande d'un type
conversion uniquement si l'expression seule est autorisée.

Une conversion vers un sous-type consiste en une conversion vers le type cible
suivi d'une vérification que le résultat de la conversion appartient au
sous-type. Une conversion d'un opérande d'un type donné vers le type lui-même est
autorisé.                                                                                  

Les autres conversions de type explicites autorisées correspondent aux éléments suivants
trois cas :

(a) Types numériques

    L'opérande peut être de n'importe quel type numérique ; la valeur de l'opérande est
    converti en type cible qui doit également être un type numérique. Pour
    conversions impliquant des types réels, le résultat est dans la précision de
    le sous-type spécifié (voir 4.5.7). La conversion d'une valeur réelle en
    un type entier arrondit à l'entier le plus proche ; si l'opérande est
    à mi-chemin entre deux nombres entiers (dans la limite de la précision du sous-type réel)
    l'arrondi peut être soit vers le haut, soit vers le bas.

(b) Types dérivés

    La conversion est autorisée si l'un du type cible et de l'opérande
    type est dérivé de l’autre, directement ou indirectement, ou s’il existe
    existe un troisième type dont les deux types dérivent, directement ou
    indirectement.

(c) Types de tableaux 

    La conversion est autorisée si le type d'opérande et le type de cible sont
    types de tableaux qui satisfont aux conditions suivantes : les deux types doivent
    avoir la même dimensionnalité ; pour chaque position d'index, les types d'index
    doivent être identiques ou convertibles l'un à l'autre ; le
    les types de composants doivent être les mêmes ; enfin, si le type de composant est un
    type avec des discriminants ou un type d'accès, les sous-types de composants doivent
    être à la fois contraints ou non contraints. Si la marque de type
    désigne un type de tableau sans contrainte, puis, pour chaque position d'index,
    les limites du résultat sont obtenues en convertissant les limites du
    opérande au type d’index correspondant du type cible. Si la
    la marque de type désigne un sous-type de tableau contraint, puis les limites du
    résultat sont ceux imposés par la marque de type. Dans les deux cas, la valeur
    de chaque composante du résultat est celle de la composante correspondante de
    l'opérande (voir 4.5.2).

Dans le cas de conversions de types numériques et de types dérivés, le
l'exception CONSTRAINT_ERROR est déclenchée par l'évaluation d'une conversion de type
si le résultat de la conversion ne satisfait pas à une contrainte imposée par
la marque de type.

Dans le cas des types tableaux, on vérifie que toute contrainte sur le
le sous-type du composant est le même pour le type de tableau d'opérandes que pour la cible
type de tableau. Si la marque de type désigne un type de tableau sans contrainte et si
l'opérande n'est pas un tableau nul, alors, pour chaque position d'index, une vérification est
fait que les bornes du résultat appartiennent à l'index correspondant
sous-type du type cible. Si la marque de type désigne un tableau contraint
sous-type, on vérifie que pour chaque composante de l'opérande il existe un
composant correspondant du sous-type cible, et vice versa. L'éxéption
CONSTRAINT_ERROR est déclenché si l'une de ces vérifications échoue. 

Si une conversion est autorisée d'un type à un autre, la conversion inverse
est également autorisé. Cette conversion inverse est utilisée lorsqu'un paramètre réel
de mode in out ou out a la forme d'une conversion de type d'une (variable) 
nom comme expliqué à la section 6.4.1.

Hormis les conversions de types explicites, la seule forme de type autorisée
la conversion est la conversion implicite d'une valeur du type
universal_integer ou universal_real dans un autre type numérique. Un implicite
conversion d'un opérande de type universal_integer vers un autre type entier,
ou d'un opérande de type universal_real à un autre type réel, ne peut être que
appliqué si l'opérande est soit un littéral numérique, un nombre nommé ou un
attribut; un tel opérande est appelé opérande universel convertible dans
cette section. Une conversion implicite d'un opérande universel convertible est
appliqué si et seulement si le contexte complet le plus interne (voir 8.7) détermine
un type de cible (numérique) unique pour la conversion implicite, et il n'y a pas
interprétation juridique de ce contexte sans cette conversion.                                           

Remarques:

Les règles pour les conversions implicites impliquent qu'aucune conversion implicite n'est
jamais appliqué à l’opérande d’une conversion de type explicite. De la même manière,
les conversions implicites ne sont pas appliquées si les deux opérandes d'un élément prédéfini
Les opérateurs relationnels sont des opérandes universels convertibles.

Le langage permet des conversions de sous-types implicites dans le cas de types tableau
(voir 5.2.1). Une conversion de type explicite peut avoir pour effet un changement
de représentation (voir notamment 13.6). Les conversions explicites sont également 
utilisé pour les paramètres réels (voir 6.4).

Exemples de conversion de type numérique :

   REAL(2*J) -- la valeur est convertie en virgule flottante
   ENTIER (1,6) -- la valeur est 2
   ENTIER (-0,4) -- la valeur est 0

Exemple de conversion entre types dérivés :

   le type A_FORM est le nouveau B_FORM ;

   X : A_FORM ;
   Y : B_FORM;

   X := A_FORM(Y);
   Y := B_FORM(X); -- la conversion inverse

Exemples de conversions entre types de tableaux :

   le type SEQUENCE est un tableau (plage INTEGER <>) de INTEGER ;
   le sous-type DOZEN est SEQUENCE(1 .. 12);
   LEDGER : tableau (1 .. 100) de INTEGER ;

   SEQUENCE(LEDGER) -- les limites sont celles de LEDGER
   SEQUENCE(LEDGER(31 .. 42)) -- les limites sont 31 et 42
   DOZEN(LEDGER(31 .. 42)) -- les limites sont celles de DOZEN

Exemples de conversions implicites :

   X : ENTIER := 2;

   X + 1 + 2 -- conversion implicite de chaque littéral entier
   1 + 2 + X -- conversion implicite de chaque littéral entier
   X + (1 + 2) -- conversion implicite de chaque littéral entier

   2 = (1 + 1) -- pas de conversion implicite : le type est uni-
                             versal_entier
   A'LENGTH = B'LENGTH -- pas de conversion implicite : le type est uni-
                             versal_entier
   C : constante := 3 + 2; -- pas de conversion implicite : le type est uni-
                             versal_entier

   X = 3 et 1 = 2 -- conversion implicite de 3, mais pas de 1 et 2

Références : paramètre réel 6.4.1, type de tableau 3.6, attribut 4.1.4, base
type 3.3, appartiennent à un sous-type 3.3, composant 3.3, sous-type de tableau contraint
3.6, exception constraint_error 11.1, type dérivé 3.4, dimension 3.6, 
expression 4.4, type à virgule flottante 3.5.7, index 3.6, sous-type d'index 3.6,
type d'index 3.6, type entier 3.5.4, composant correspondant 4.5.2, mode 6.1,  
nom 4.1, numéro nommé 3.2, tableau nul 3.6.1, littéral numérique 2.4, numérique
type 3.5, levée d'exceptions 11, type réel 3.5.6, représentation 13.1,
instruction 5, sous-type 3.3, type 3.3, marque de type 3.3.2, tableau sans contrainte
type 3.6, type universal_integer 3.5.4, type universal_real 3.5.6, variable
3.2.1                                                                                     

4.7 Expressions qualifiées 

Une expression qualifiée est utilisée pour indiquer explicitement le type, et éventuellement
le sous-type d'un opérande qui est l'expression ou l'agrégat donné.

   expression_qualifiée ::=
      type_mark'(expression) | type_mark'agrégat

L'opérande doit avoir le même type que le type de base de la marque de type. Le
la valeur d'une expression qualifiée est la valeur de l'opérande. Le
L'évaluation d'une expression qualifiée évalue l'opérande et vérifie que
sa valeur appartient au sous-type désigné par la marque de type. L'éxéption
CONSTRAINT_ERROR est déclenché si cette vérification échoue.

Exemples:

   le type MASK est (FIX, DEC, EXP, SIGNIF) ;
   tapez CODE est (FIX, CLA, DEC, TNZ, SUB) ;

   IMPRIMER (MASQUE'(DEC)); -- DEC est de type MASQUE
   IMPRIMER (CODE'(DEC)); -- DEC est de type CODE

   pour J dans CODE'(FIX) .. Boucle CODE'(DEC) ... -- qualification nécessaire pour
                                                 soit FIX ou DEC
   pour J dans la plage CODE FIX .. Boucle DEC ... -- qualification inutile
   pour J dans CODE'(FIX) .. Boucle DEC ... -- qualification inutile
                                                 pour décembre

   DOUZAINE'(1 | 3 | 5 | 7 => 2, autres => 0) -- voir 4.6

Remarques:

Chaque fois que le type d'un littéral ou d'un agrégat d'énumération n'est pas connu à partir de
le contexte, une expression qualifiée peut être utilisée pour indiquer le type 
explicitement. Par exemple, un littéral d'énumération surchargé doit être
qualifié dans les cas suivants : lorsqu'il est donné en paramètre dans un
appel de sous-programme à un sous-programme surchargé qui ne peut pas être autrement
identifié sur la base des types de paramètres ou de résultats restants, dans un
expression relationnelle où les deux opérandes sont une énumération surchargée
littéraux, ou dans une plage de paramètres de tableau ou de boucle où les deux limites sont
littéraux d'énumération surchargés. Une qualification explicite est également utilisée pour
spécifier laquelle d'un ensemble de fonctions sans paramètre surchargées est concernée,
ou pour contraindre une valeur à un sous-type donné.

Références : agrégat 4.3, tableau 3.6, type de base 3.3, limite d'une plage 3.5,
exception constraint_error 11.1, contexte de résolution de surcharge 8.7,
littéral d'énumération 3.5.1, expression 4.4, fonction 6.5, paramètre de boucle
5.5, surcharge 8.5, levée d'exceptions 11, plage 3.3, relation 4.4,
sous-programme 6, appel de sous-programme 6.4, sous-type 3.3, type 3.3, marque de type 3.3.2  

4.8 Répartiteurs    

L'évaluation d'un allocateur crée un objet et génère une valeur d'accès
qui désigne l'objet.

   allocateur ::=
      nouveau sous-type_indication | nouvelle expression_qualifiée                                                   

Le type de l'objet créé par un allocateur est le type de base du type
marque donnée soit dans l'indication de sous-type, soit dans l'expression qualifiée.
Pour un allocateur avec une expression qualifiée, cette expression définit le
valeur initiale de l'objet créé. Le type de la valeur d'accès renvoyée 
par un allocateur doit être déterminable uniquement à partir du contexte, mais en utilisant le
fait que la valeur renvoyée est d'un type d'accès ayant le nom
type désigné.

Les seules formes de contrainte autorisées dans l'indication de sous-type d'un
l'allocateur sont des contraintes d'index et de discrimination. Si un répartiteur inclut
une indication de sous-type et si le type de l'objet créé est un type tableau
ou un type avec des discriminants qui n'ont pas d'expressions par défaut, alors le
L'indication de sous-type doit soit désigner un sous-type contraint, soit inclure un
indice explicite ou contrainte discriminante.

Si le type de l'objet créé est un type tableau ou un type avec
discriminants, alors l’objet créé est toujours contraint. Si la
l'allocateur inclut une indication de sous-type, l'objet créé est contraint
soit par le sous-type, soit par les valeurs discriminantes par défaut. Si la
l'allocateur inclut une expression qualifiée, l'objet créé est
contraint par les limites ou les discriminants de la valeur initiale. Pour les autres
types, le sous-type de l'objet créé est le sous-type défini par le
indication de sous-type de la définition du type d’accès.

Pour l'évaluation d'un allocateur, l'élaboration du sous-type
l'indication ou l'évaluation de l'expression qualifiée est effectuée
d'abord. Le nouvel objet est alors créé. Des initialisations sont ensuite effectuées
comme pour un objet déclaré (voir 3.2.1) ; l'initialisation est considérée
explicite dans le cas d'une expression qualifiée ; toutes les initialisations sont
implicite dans le cas d’une indication de sous-type. Enfin, une valeur d'accès
qui désigne l'objet créé est renvoyé.

Une implémentation doit garantir que tout objet créé par l'évaluation
d'un allocateur reste alloué aussi longtemps que cet objet ou l'un de ses
sous-composants est accessible directement ou indirectement, c'est-à-dire à condition qu'il
peut être désigné par un nom. De plus, si un objet ou l'un de ses
sous-composants appartient à un type de tâche, elle est considérée comme accessible
tant que la tâche n'est pas terminée. Une implémentation peut (mais pas nécessairement)
récupérer le stockage occupé par un objet créé par un allocateur, une fois
cet objet est devenu inaccessible.

Lorsqu'une application a besoin d'un contrôle plus étroit sur l'allocation de stockage pour
objets désignés par des valeurs d'un type d'accès, ce contrôle peut être
obtenu par un ou plusieurs des moyens suivants :

(a) La quantité totale de stockage disponible pour la collecte d'objets de
    un type d'accès peut être défini au moyen d'une clause de longueur (voir 13.2).

(b) Le pragma CONTROLLED informe l'implémentation que le
    la récupération du stockage ne doit pas être effectuée pour les objets désignés par
    valeurs du type d'accès, sauf à la sortie du bloc le plus intérieur
    instruction, corps de sous-programme ou corps de tâche qui contient le type d'accès
    déclaration, ou après avoir quitté le programme principal.   

       pragma CONTROLLED (access_type_simple_name);

    Un pragma CONTROLLED pour un type d'accès donné est autorisé en même temps
    places comme clause de représentation pour le type (voir 13.1). Ce
    pragma n'est pas autorisé pour un type dérivé.

(c) La désallocation explicite de l'objet désigné par une valeur d'accès
    peut être réalisé en appelant une procédure obtenue par instanciation de
    la procédure de bibliothèque générique prédéfinie UNCHECKED_DEALLOCATION (voir
    13.10.1).

L'exception STORAGE_ERROR est levée par un allocateur s'il n'y a pas
suffisamment de stockage. Notez également que l'exception CONSTRAINT_ERROR peut être
soulevées par l'évaluation de l'expression nuancée, par l'élaboration de
l'indication de sous-type, ou par l'initialisation.                                          

Exemples (pour les types d'accès déclarés à la section 3.8) : 

 new CELL'(0, null, null) -- initialisé explicitement
 new CELL'(VALUE => 0, SUCC => null, PRED => null) -- initialisé explicitement
 nouvelle CELLULE -- non initialisée

 new MATRIX(1 .. 10, 1 .. 20) -- seules les limites sont données
 new MATRIX'(1 .. 10 => (1 .. 20 => 0.0)) -- initialisé explicitement

 new BUFFER(100) -- seul le discriminant est donné

 nouveau BUFFER'(TAILLE => 80, POS => 0, VALEUR => (1 .. 80 => 'A'))
                                              -- initialisé explicitement

Références : type d'accès 3.8, définition du type d'accès 3.8, valeur d'accès 3.8,
type de tableau 3.6, instruction de bloc 5.6, limite d'un tableau 3.6.1, collection
3.8, sous-type contraint 3.3, contrainte 3.3, exception constraint_error
11.1, contexte de résolution de surcharge 8.7, type dérivé 3.4, désigner 3.8,
discriminant 3.3, contrainte discriminante 3.7.2, élaboration 3.9,
évaluation d'une expression qualifiée 4.7, procédure générique 12.1, index
contrainte 3.6.1, valeur initiale 3.2.1, initialisation 3.2.1, instanciation
12.3, clause de longueur 13.2, unité de bibliothèque 10.1, programme principal 10.1, nom 4.1,
objet 3.2.1, déclaration d'objet 3.2.1, pragma 2.8, procédure 6, qualifié
expression 4.7, levée d'exceptions 11, clause de représentation 13.1,
nom simple 4.1, exception storage_error 11.1, sous-composant 3.3, sous-programme
corps 6.3, sous-type 3.3, indication de sous-type 3.3.2, corps de tâche 9.1, type de tâche
9.2, tâche terminée 9.4, type 3.3, déclaration de type 3.3.1, marque de type 3.3.2
taper avec des discriminants 3.3  

4.9 Expressions statiques et sous-types statiques    

Certaines expressions de type scalaire sont dites statiques. De la même manière,
certaines gammes discrètes sont dites statiques, et les marques de type de
certains sous-types scalaires sont censés désigner des sous-types statiques.

Une expression de type scalaire est dite statique si et seulement si chaque
primaire est l'un de ceux répertoriés de (a) à (h) ci-dessous, chaque opérateur
désigne un opérateur prédéfini, et l'évaluation de l'expression
délivre une valeur (c'est-à-dire qu'elle ne déclenche pas d'exception) :

(a) Un littéral d'énumération (y compris un littéral de caractère).

(b) Un littéral numérique.

(c) Un numéro nommé.

(d) Une constante explicitement déclarée par une déclaration de constante avec un static
    sous-type et initialisé avec une expression statique.

(e) Un appel de fonction dont le nom de fonction est un symbole d'opérateur qui désigne
    un opérateur prédéfini, comprenant un nom de fonction qui est un nom développé
    nom; chaque paramètre réel doit également être une expression statique. 

(f) Un attribut défini par le langage d'un sous-type statique ; pour un attribut
    c'est une fonction, le paramètre réel doit également être un paramètre statique
    expression.                                                     

(g) Une expression qualifiée dont la marque de type désigne un sous-type statique et
    dont l'opérande est une expression statique.

(h) Une expression statique entre parenthèses.

Une plage statique est une plage dont les limites sont des expressions statiques. Un statique
la contrainte de plage est une contrainte de plage dont la plage est statique. Un statique
le sous-type est soit un type de base scalaire, autre qu'un type formel générique ; ou
un sous-type scalaire formé en imposant à un sous-type statique soit un sous-type statique
contrainte de plage, ou une contrainte à virgule flottante ou fixe dont la plage
la contrainte, le cas échéant, est statique. Une plage discrète statique est soit une plage statique
sous-type ou une plage statique. Une contrainte d'index statique est un index
contrainte pour laquelle chaque sous-type d'index du type de tableau correspondant est
statique, et dans lequel chaque plage discrète est statique. Un discriminant statique
contrainte est une contrainte discriminante pour laquelle le sous-type de chaque
le discriminant est statique, et dans lequel chaque expression est statique.

Remarques:

La précision de l'évaluation d'une expression statique ayant un type réel est
défini par les règles données à la section 4.5.7. Si le résultat n'est pas un modèle
numéro (ou un numéro sûr) du type, la valeur obtenue par ce
l'évaluation au moment de la compilation ne doit pas nécessairement être la même que la valeur qui serait
être obtenu par une évaluation au moment de l’exécution.

Les attributs de tableau ne sont pas statiques : en particulier, l'attribut RANGE n'est pas
statique.

Références : paramètre réel 6.4.1, attribut 4.1.4, type de base 3.3, lié
d'une plage 3,5, caractère littéral 2,5, constante 3.2.1, déclaration constante
3.2.1, plage discrète 3.6, type discret 3.5, littéral d'énumération 3.5.1,
exception 11, expression 4.4, fonction 6.5, paramètre générique réel 12.3,
type formel générique 12.1.2, déclaration implicite 3.1, initialisation 3.2.1,
numéro de modèle 3.5.6, nommé numéro 3.2, littéral numérique 2.4, prédéfini
opérateur 4.5, expression qualifiée 4.7, levée d'exceptions 11, plage
contrainte 3.5, nombre sûr 3.5.6, type scalaire 3.5, sous-type 3.3, marque de type
3.3.2  

4.10 Expressions universelles 

Une expression_universelle est soit une expression qui fournit un résultat de
tapez universal_integer ou celui qui fournit un résultat de type
universal_real.  

Les mêmes opérations sont prédéfinies pour le type universal_integer comme pour
n’importe quel type entier. Les mêmes opérations sont prédéfinies pour le type
universal_real comme pour tout type à virgule flottante. De plus, ces
les opérations incluent les opérateurs de multiplication et de division suivants :

Opérateur Opération Opérande gauche Opérande droite Type de résultat
                    tapez tapez

  * multiplier universal_real universal_integer universal_real
                    universal_integer universal_real universal_real

  / diviser universal_real universal_integer universal_real

La précision de l'évaluation d'une expression universelle de type
universal_real est au moins aussi bon que celui du prédéfini le plus précis
type à virgule flottante pris en charge par l'implémentation, à l'exception
universal_real lui-même. De plus, si une expression universelle est une expression statique
expression, alors l’évaluation doit être exacte.                                              

Pour l'évaluation d'une opération d'une expression universelle non statique, un
l'implémentation est autorisée à déclencher l'exception NUMERIC_ERROR uniquement si le
Le résultat de l'opération est une valeur réelle dont la valeur absolue dépasse la
le plus grand nombre sûr du type à virgule flottante prédéfini le plus précis
(hors universal_real), ou une valeur entière supérieure à SYSTEM.MAX_INT
ou inférieur à SYSTEM.MIN_INT.

Note:

C'est une conséquence des règles ci-dessus que le type d'un système universel
L'expression est universal_integer si chaque primaire contenue dans le  
l'expression est de ce type (à l'exclusion des paramètres réels des attributs qui
sont des fonctions, et excluant les opérandes droits des opérateurs d'exponentiation)
et que sinon le type est universal_real.

Exemples:

   1 + 1 -- 2
   abs(-10)*3 -- 30

   KILO : constante := 1000;
   MÉGA : constante := KILO*KILO; -- 1_000_000
   LONG : constante := FLOAT'DIGITS*2;

   HALF_PI : constante := PI/2; -- voir 3.2.2
   DEG_TO_RAD : constante := HALF_PI/90;
   RAD_TO_DEG : constante := 1.0/DEG_TO_RAD; -- équivalent à
                                               1.0/((3.14159_26536/2)/90)

Références : paramètre actuel 6.4.1, attribut 4.1.4, évaluation d'un
expression 4.5, type à virgule flottante 3.5.9, fonction 6.5, type entier
3.5.4, opérateur multiplicateur 4.5 4.5.5, opération prédéfinie 3.3.3, primaire
4.4, type réel 3.5.6, numéro de sécurité 3.5.6, system.max_int 13.7,
system.min_int 13.7, type 3.3, universal_integer type 3.5.4, universal_real
tapez 3.5.6            
