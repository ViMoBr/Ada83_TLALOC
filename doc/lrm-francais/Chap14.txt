
                            14. Entrée-Sortie  

Les entrées-sorties sont fournies dans le langage au moyen de packages prédéfinis.
Les packages génériques SEQUENTIAL_IO et DIRECT_IO définissent les entrées-sorties
opérations applicables aux fichiers contenant des éléments d’un type donné.
Des opérations supplémentaires pour l'entrée-sortie de texte sont fournies dans le package
TEXTE_IO. Le package IO_EXCEPTIONS définit les exceptions nécessaires au
au-dessus de trois paquets. Enfin, un package LOW_LEVEL_IO est fourni pour
contrôle direct des périphériques.

Références : package direct_io 14.2 14.2.4, package io_exceptions 14.5,
paquet low_level_io 14.6, paquet sequential_io 14.2 14.2.2, text_io
paquet 14.3  

14.1 Fichiers externes et objets fichier 

Valeurs entrées depuis l'environnement externe du programme ou sorties vers le
environnement, sont considérés comme occupant des fichiers externes. Un fichier externe peut
être quelque chose d'extérieur au programme qui peut produire une valeur à lire ou
recevoir une valeur à écrire. Un fichier externe est identifié par une chaîne
(le nom). Une deuxième chaîne (le formulaire) donne d'autres informations dépendant du système
caractéristiques pouvant être associées au fichier, telles que l'état physique
organisation ou droits d’accès. Les conventions régissant le
l’interprétation de ces chaînes doit être documentée à l’annexe F.

Les opérations d'entrée et de sortie sont exprimées comme des opérations sur des objets de certains
type de fichier, plutôt que directement en termes de fichiers externes. Dans le
Dans le reste de ce chapitre, le terme fichier est toujours utilisé pour désigner un fichier
objet; le terme fichier externe est utilisé autrement. Les valeurs transférées
pour un fichier donné doivent tous être du même type.

Les entrées-sorties pour les fichiers séquentiels de valeurs d'un seul type d'élément sont
défini au moyen du package générique SEQUENTIAL_IO. Le squelette de
ce package est donné ci-dessous.

   avec IO_EXCEPTIONS ;
   générique  
      le type ELEMENT_TYPE est privé ;
   le package SEQUENTIAL_IO est
      le type FILE_TYPE est limité en privé ;

      tapez FILE_MODE est (IN_FILE, OUT_FILE) ;
      ...
      procédure OPEN (FILE : in out FILE_TYPE; ...);
      ... 
      procédure READ (FILE : dans FILE_TYPE ; ITEM : sortie ELEMENT_TYPE) ;
      procédure WRITE(FILE : dans FILE_TYPE; ITEM : dans ELEMENT_TYPE);
      ...
   terminer SEQUENTIAL_IO ;

Afin de définir des entrées-sorties séquentielles pour un type d'élément donné, un
instanciation de cette unité générique, avec le type donné comme réel
paramètre, doit être déclaré. Le package résultant contient le
déclaration d'un type de fichier (appelé FILE_TYPE) pour les fichiers de tels éléments,
ainsi que les opérations applicables à ces fichiers, comme l'OPEN,
Procédures LIRE et ÉCRIRE.                                                          

Les entrées-sorties pour les fichiers en accès direct sont également définies par un
package appelé DIRECT_IO. Les entrées-sorties sous une forme lisible par l'homme sont définies
par le package (non générique) TEXT_IO.

Avant que des opérations d'entrée ou de sortie puissent être effectuées sur un fichier, le fichier doit
être d'abord associé à un fichier externe. Même si une telle association existe
effet, le fichier est dit ouvert, et sinon le fichier est dit
fermé.

Le langage ne définit pas ce qui arrive aux fichiers externes après le
l'achèvement du programme principal (en particulier si les fichiers correspondants ont
pas été fermé). L'effet des entrées-sorties pour les types d'accès est
dépendant de la mise en œuvre.

Un fichier ouvert a un mode courant, qui est une valeur de l'une des valeurs de l'énumération
les types  

 tapez FILE_MODE est (IN_FILE, INOUT_FILE, OUT_FILE) ; -- pour DIRECT_IO
 tapez FILE_MODE est (IN_FILE, OUT_FILE) ; -- pour SEQUENTIAL_IO et TEXT_IO

Ces valeurs correspondent respectivement aux cas où seule la lecture, tant
la lecture et l'écriture, ou seulement l'écriture, doivent être effectuées. Le mode d'un
le fichier peut être modifié.

Plusieurs opérations de gestion de fichiers sont communes aux trois entrées-sorties
paquets. Ces opérations sont décrites dans la section 14.2.1 pour les
et fichiers directs. Les éventuels effets supplémentaires concernant les entrées-sorties de texte sont
décrit à la section 14.3.1.

Les exceptions pouvant être levées par un appel d'un sous-programme d'entrées-sorties
sont tous définis dans le package IO_EXCEPTIONS ; les situations dans lesquelles
ils peuvent être élevés sont décrits, soit à la suite de la description du
sous-programme (et à la section 14.4), ou à l'annexe F en cas d'erreur
situations qui dépendent de la mise en œuvre.

Remarques:

Chaque instanciation des packages génériques SEQUENTIAL_IO et DIRECT_IO
déclare un type différent FILE_TYPE ; dans le cas de TEXT_IO, le type
FILE_TYPE est unique.

Un périphérique bidirectionnel peut souvent être modélisé comme deux fichiers séquentiels
associé à l'appareil, un du mode IN_FILE et un du mode OUT_FILE.
Une implémentation peut restreindre le nombre de fichiers pouvant être associés
avec un fichier externe donné. L'effet du partage d'un fichier externe dans ce
manière par plusieurs objets fichier dépend de l’implémentation.

Références : créer une procédure 14.2.1, index actuel 14.2, taille actuelle
14.2, procédure de suppression 14.2.1, accès direct 14.2, procédure de fichier direct
14.2, package direct_io 14.1 14.2, type d'énumération 3.5.1, exception 11,
mode fichier 14.2.3, instanciation générique 12.3, index 14.2, fichier d'entrée
14.2.2, package io_exceptions 14.5, fichier ouvert 14.1, procédure ouverte 14.2.1,  
fichier de sortie 14.2.2, procédure de lecture 14.2.4, accès séquentiel 14.2,
fichier séquentiel 14.2, entrée-sortie séquentielle 14.2.2, package sequential_io
14.2 14.2.2, chaîne 3.6.3, package text_io 14.3, procédure d'écriture 14.2.4 

14.2 Fichiers séquentiels et directs 

Deux types d'accès aux fichiers externes sont définis : l'accès séquentiel et
accès direct. Les types de fichiers correspondants et les opérations associées
sont fournis par les packages génériques SEQUENTIAL_IO et DIRECT_IO. Un fichier
l'objet à utiliser pour l'accès séquentiel est appelé un fichier séquentiel, et
celui à utiliser pour l’accès direct est appelé fichier direct.

Pour un accès séquentiel, le fichier est considéré comme une séquence de valeurs qui sont
transférés dans l’ordre de leur apparition (tel que produit par le programme ou
par l'environnement). Lorsque le fichier est ouvert, le transfert démarre à partir du
début du fichier.                                                               

Pour un accès direct, le fichier est visualisé comme un ensemble d'éléments occupant
positions consécutives dans un ordre linéaire ; une valeur peut être transférée à ou
à partir d'un élément du fichier à n'importe quelle position sélectionnée. La position d'un
L'élément est spécifié par son index, qui est un nombre supérieur à zéro de
le type entier défini par l'implémentation COUNT. Le premier élément, le cas échéant,
a l'indice un ; l'index du dernier élément, le cas échéant, est appelé le
la taille actuelle; la taille actuelle est nulle s'il n'y a aucun élément. Le
la taille actuelle est une propriété du fichier externe.

Un fichier direct ouvert a un index actuel, qui est l'index qui sera
utilisé par la prochaine opération de lecture ou d’écriture. Lorsqu'un fichier direct est ouvert,  
l'index actuel est défini sur un. L'index actuel d'un fichier direct est un
propriété d'un objet fichier, pas d'un fichier externe.

Les trois modes de fichier sont autorisés pour les fichiers directs. Les seuls modes autorisés
pour les fichiers séquentiels sont les modes IN_FILE et OUT_FILE.

Références : type de comptage 14.3, mode fichier 14.1, in_file 14.1, out_file 14.1  

14.2.1 Gestion des fichiers 

Les procédures et fonctions décrites dans cette section prévoient le
contrôle des fichiers externes; leurs déclarations sont répétées dans chacun des
trois packages pour les entrées-sorties séquentielles, directes et textuelles. Pour le texte
entrées-sorties, les procédures CREATE, OPEN et RESET ont des
effets décrits à la section 14.3.1.

   procédure CREATE(FILE : entrée sortie FILE_TYPE;
                    MODE : dans FILE_MODE := default_mode;
                    NOM : dans STRING := "";
                    FORMULAIRE : dans CHAÎNE := "");

         Crée un nouveau fichier externe, avec le nom et la forme donnés,
         et associe ce fichier externe au fichier donné. Le donné
         le fichier reste ouvert. Le mode actuel du fichier donné est défini sur
         le mode d'accès donné. Le mode d'accès par défaut est le mode
         OUT_FILE pour les entrées-sorties séquentielles et textuelles ; c'est le mode
         INOUT_FILE pour entrée-sortie directe. Pour un accès direct, la taille
         du fichier créé dépend de l’implémentation. Une chaîne nulle
         pour NAME spécifie un fichier externe qui n'est pas accessible après
         l'achèvement du programme principal (un fichier temporaire). Un nul
         chaîne pour FORM spécifie l'utilisation des options par défaut du
         implémentation pour le fichier externe.

         L'exception STATUS_ERROR est levée si le fichier donné est déjà
         ouvrir. L'exception NAME_ERROR est levée si la chaîne donnée comme
         NOM ne permet pas l'identification d'un fichier externe. Le
         L'exception USE_ERROR est levée si, pour le mode spécifié, le
         l'environnement ne prend pas en charge la création d'un fichier externe avec
         le prénom (en l'absence de NAME_ERROR) et la forme.   

   procédure OPEN(FILE : entrée sortie FILE_TYPE;
                  MODE : dans FILE_MODE;
                  NOM : en CHAÎNE ;
                  FORMULAIRE : dans CHAÎNE := "");

         Associe le fichier donné à un fichier externe existant ayant
         le nom et la forme donnés, et définit le mode actuel du donné
         fichier dans le mode donné. Le fichier donné reste ouvert.                                                         

         L'exception STATUS_ERROR est levée si le fichier donné est déjà
         ouvrir. L'exception NAME_ERROR est levée si la chaîne donnée comme
         NOM ne permet pas l'identification d'un fichier externe ; dans
         En particulier, cette exception est levée si aucun fichier externe avec le
         le prénom existe. L'exception USE_ERROR est levée si, pour le
         mode spécifié, l'environnement ne prend pas en charge l'ouverture pour un
         fichier externe portant le nom donné (en l'absence de NAME_ERROR)
         et la forme. 

   procédure CLOSE(FILE : entrée sortie FILE_TYPE);

         Coupe l'association entre le fichier donné et son associé
         fichier externe. Le fichier donné est laissé fermé.

         L'exception STATUS_ERROR est levée si le fichier donné n'est pas
         ouvrir. 

   procédure DELETE(FILE : entrée sortie FILE_TYPE);

         Supprime le fichier externe associé au fichier donné. Le
         le fichier donné est fermé et le fichier externe cesse d'exister.

         L'exception STATUS_ERROR est levée si le fichier donné n'est pas
         ouvrir. L'exception USE_ERROR est levée si (comme entièrement défini dans
         Annexe F) la suppression du fichier externe n'est pas prise en charge par le
         environnement. 

   procédure RESET(FILE : entrée sortie FILE_TYPE; MODE : entrée FILE_MODE);
   procédure RESET(FILE : entrée sortie FILE_TYPE);

         Réinitialise le fichier donné afin que la lecture ou l'écriture dans son
         les éléments peuvent être redémarrés depuis le début du fichier ; dans
         en particulier, pour un accès direct, cela signifie que l'index actuel
         est défini sur un. Si un paramètre MODE est fourni, le mode actuel
         du fichier donné est défini sur le mode donné.

         L'exception STATUS_ERROR est levée si le fichier n'est pas ouvert.
         L'exception USE_ERROR est levée si l'environnement ne le fait pas.
         prend en charge la réinitialisation du fichier externe et, également, si le
         l'environnement ne prend pas en charge la réinitialisation au mode spécifié pour
         le fichier externe. 

   fonction MODE(FILE : dans FILE_TYPE) renvoie FILE_MODE ;

         Renvoie le mode actuel du fichier donné.

         L'exception STATUS_ERROR est levée si le fichier n'est pas ouvert. 

   fonction NOM(FILE : dans FILE_TYPE) renvoie STRING ;  

         Renvoie une chaîne qui identifie de manière unique le fichier externe
         actuellement associé au fichier donné (et peut donc être utilisé dans
         une opération OUVERT). Si un environnement permet une alternative
         spécifications du nom (par exemple, abréviations), le
         la chaîne renvoyée par la fonction doit correspondre à un
         spécification du nom.

         L'exception STATUS_ERROR est levée si le fichier donné n'est pas
         ouvrir.                                                                        

   fonction FORM(FILE : dans FILE_TYPE) return STRING ;

         Renvoie la chaîne de formulaire pour le fichier externe actuellement
         associé au fichier donné. Si un environnement le permet
         spécifications alternatives du formulaire (par exemple,
         abréviations utilisant les options par défaut), la chaîne renvoyée par le
         la fonction doit correspondre à une spécification complète (c'est-à-dire qu'elle
         doit indiquer explicitement toutes les options sélectionnées, y compris
         options par défaut).

         L'exception STATUS_ERROR est levée si le fichier donné n'est pas
         ouvrir. 

   la fonction IS_OPEN(FILE : dans FILE_TYPE) renvoie BOOLEAN ;

         Renvoie VRAI si le fichier est ouvert (c'est-à-dire s'il est associé
         avec un fichier externe), sinon renvoie FALSE.

Références : mode actuel 14.1, taille actuelle 14.1, fichier fermé 14.1, direct
accès 14.2, fichier externe 14.1, fichier 14.1, type file_mode 14.1, file_type
tapez 14.1, chaîne de formulaire 14.1, inout_file 14.2.4, mode 14.1, chaîne de nom
14.1, exception name_error 14.4, fichier ouvert 14.1, out_file 14.1,
exception status_error 14.4, exception use_error 14.4  

14.2.2 Entrées-sorties séquentielles 

Les opérations disponibles pour les entrées et sorties séquentielles sont décrites dans
cette section. L'exception STATUS_ERROR est levée si l'un de ces éléments
des opérations sont tentées pour un fichier qui n’est pas ouvert. 

   procédure READ(FILE : dans FILE_TYPE; ITEM : out ELEMENT_TYPE); 

         Opère sur un fichier de mode IN_FILE. Lit un élément du
         fichier donné, et renvoie la valeur de cet élément dans le ITEM
         paramètre.

         L'exception MODE_ERROR est levée si le mode n'est pas IN_FILE.
         L'exception END_ERROR est levée si aucun élément supplémentaire ne peut être lu
         à partir du fichier donné. L'exception DATA_ERROR est levée si le
         l'élément lu ne peut pas être interprété comme une valeur du type
         ELEMENT_TYPE ; cependant, une implémentation est autorisée à omettre cela
         vérifiez si effectuer la vérification est trop complexe. 

   procédure WRITE(FILE : dans FILE_TYPE; ITEM : dans ELEMENT_TYPE);

         Opère sur un fichier de mode OUT_FILE. Écrit la valeur de ITEM dans
         le fichier donné.  

         L'exception MODE_ERROR est levée si le mode n'est pas OUT_FILE.
         L'exception USE_ERROR est levée si la capacité du serveur externe
         fichier est dépassé. 

   la fonction END_OF_FILE(FILE : dans FILE_TYPE) renvoie BOOLEAN ;

         Opère sur un fichier de mode IN_FILE. Renvoie VRAI si rien de plus
         les éléments peuvent être lus à partir du fichier donné ; sinon revient
         FAUX.

         L'exception MODE_ERROR est levée si le mode n'est pas IN_FILE.

Références : exception data_error 14.4, élément 14.1, element_type 14.1,
exception end_error 14.4, fichier externe 14.1, fichier 14.1, mode fichier 14.1,
file_type 14.1, in_file 14.1, exception mode_error 14.4, out_file 14.1,
exception status_error 14.4, exception use_error 14.4                                                             

14.2.3 Spécification du package Sequential_IO    

   avec IO_EXCEPTIONS ;
   générique
      le type ELEMENT_TYPE est privé ;
   le package SEQUENTIAL_IO est

      le type FILE_TYPE est limité en privé ;

      tapez FILE_MODE est (IN_FILE, OUT_FILE) ; 

      -- Gestion de fichiers

      procédure CREATE(FILE : entrée sortie FILE_TYPE;
                       MODE : dans FILE_MODE := OUT_FILE;
                       NOM : dans STRING := "";
                       FORMULAIRE : dans CHAÎNE := "");

      procédure OPEN (FILE : in out FILE_TYPE;
                       MODE : dans FILE_MODE;
                       NOM : en CHAÎNE ;
                       FORMULAIRE : dans CHAÎNE := "");

      procédure FERMETURE (FILE : entrée sortie FILE_TYPE) ;
      procédure DELETE(FILE : entrée sortie FILE_TYPE);
      procédure RESET (FILE : in out FILE_TYPE; MODE : in FILE_MODE) ;
      procédure RESET (FILE : in out FILE_TYPE) ;

      la fonction MODE (FILE : dans FILE_TYPE) renvoie FILE_MODE ;
      fonction NOM (FILE : dans FILE_TYPE) renvoie STRING ;
      fonction FORM (FILE : dans FILE_TYPE) renvoie STRING ;

      la fonction IS_OPEN(FILE : dans FILE_TYPE) renvoie BOOLEAN ;

      -- Opérations d'entrée et de sortie

      procédure READ (FILE : dans FILE_TYPE ; ITEM : sortie ELEMENT_TYPE) ;
      procédure WRITE (FILE : dans FILE_TYPE ; ITEM : dans ELEMENT_TYPE) ;

      la fonction END_OF_FILE(FILE : dans FILE_TYPE) renvoie BOOLEAN ;

      -- Des exceptions

      STATUS_ERROR : l'exception renomme IO_EXCEPTIONS.STATUS_ERROR ;
      MODE_ERROR : l'exception renomme IO_EXCEPTIONS.MODE_ERROR ;
      NAME_ERROR : l'exception renomme IO_EXCEPTIONS.NAME_ERROR ;
      USE_ERROR : l'exception renomme IO_EXCEPTIONS.USE_ERROR ;
      DEVICE_ERROR : l'exception renomme IO_EXCEPTIONS.DEVICE_ERROR ;
      END_ERROR : l'exception renomme IO_EXCEPTIONS.END_ERROR ;
      DATA_ERROR : l'exception renomme IO_EXCEPTIONS.DATA_ERROR ;   

   privé
      -- dépendant de la mise en œuvre
   terminer SEQUENTIAL_IO ;                                                            

Références : fermer la procédure 14.2.1, créer la procédure 14.2.1, data_error
exception 14.4, procédure de suppression 14.2.1, exception device_error 14.4,
exception end_error 14.4, fonction end_of_file 14.2.2, file_mode 14.1,
file_type 14.1, fonction de formulaire 14.2.1, in_file 14.1, io_exceptions 14.4,
Fonction is_open 14.2.1, fonction mode 14.2.1, exception mode_error 14.4,
fonction de nom 14.2.1, exception name_error 14.4, procédure ouverte 14.2.1,
out_file 14.1, procédure de lecture 14.2.2, procédure de réinitialisation 14.2.1, sequential_io
package 14.2 14.2.2, exception status_error 14.4, exception use_error 14.4,
écrire la procédure 14.2.2,   

14.2.4 Entrée-Sortie directe 

Les opérations disponibles pour l'entrée et la sortie directes sont décrites dans ce
section. L'exception STATUS_ERROR est levée si l'une de ces opérations
est tenté pour un fichier qui n'est pas ouvert.

   procédure READ(FILE : dans FILE_TYPE; ITEM : sortie ELEMENT_TYPE;
                                       FROM : dans POSITIVE_COUNT );
   procédure READ(FILE : dans FILE_TYPE; ITEM : out ELEMENT_TYPE);

         Opère sur un fichier de mode IN_FILE ou INOUT_FILE. Dans le cas d
         la première forme, définit l'index actuel du fichier donné sur le
         valeur d'index donnée par le paramètre FROM. Puis (pour les deux formulaires)
         renvoie, dans le paramètre ITEM, la valeur de l'élément dont
         la position dans le fichier donné est spécifiée par l'index actuel de
         le fichier; enfin, augmente l'indice actuel de un.   

         L'exception MODE_ERROR est levée si le mode du fichier donné
         est OUT_FILE. L'exception END_ERROR est levée si l'index à
         être utilisé dépasse la taille du fichier externe. L'éxéption
         DATA_ERROR est déclenché si l'élément lu ne peut pas être interprété comme
         une valeur de type ELEMENT_TYPE ; cependant, une implémentation est
         autorisé à omettre cette vérification si l'exécution de la vérification est trop
         complexe. 

   procédure WRITE(FILE : dans FILE_TYPE; ITEM : dans ELEMENT_TYPE;
                                        À : dans POSITIVE_COUNT );
   procédure WRITE(FILE : dans FILE_TYPE; ITEM : dans ELEMENT_TYPE);

         Opère sur un fichier de mode INOUT_FILE ou OUT_FILE. Dans le cas
         de la première forme, définit l'index du fichier donné sur l'index
         valeur donnée par le paramètre TO. Puis (pour les deux formes) donne le
         valeur du paramètre ITEM à l'élément dont la position dans le
         le fichier donné est spécifié par l'index actuel du fichier ;
         enfin, augmente l'indice actuel de un.

         L'exception MODE_ERROR est levée si le mode du fichier donné
         est IN_FILE. L'exception USE_ERROR est levée si la capacité de
         le fichier externe est dépassé.  

   procédure SET_INDEX(FILE : dans FILE_TYPE; TO : dans POSITIVE_COUNT);

         Fonctionne sur un fichier de n'importe quel mode. Définit l'index actuel du
         fichier donné à la valeur d'index donnée (qui peut dépasser la valeur actuelle
         taille du fichier). 

   la fonction INDEX(FILE : dans FILE_TYPE) renvoie POSITIVE_COUNT ;

         Fonctionne sur un fichier de n’importe quel mode. Renvoie l'index actuel du
         fichier donné.                                                              

   la fonction SIZE(FILE : dans FILE_TYPE) renvoie COUNT ;

         Fonctionne sur un fichier de n’importe quel mode. Renvoie la taille actuelle du
         fichier externe associé au fichier donné.

   la fonction END_OF_FILE(FILE : dans FILE_TYPE) renvoie BOOLEAN ;

         Opère sur un fichier de mode IN_FILE ou INOUT_FILE. Renvoie VRAI
         si l'index actuel dépasse la taille du fichier externe ;
         sinon, renvoie FALSE.

         L'exception MODE_ERROR est levée si le mode du fichier donné
         est OUT_FILE.

Références : type de comptage 14.2, index actuel 14.2, taille actuelle 14.2,
exception data_error 14.4, élément 14.1, element_type 14.1, end_error
exception 14.4, fichier externe 14.1, fichier 14.1, mode fichier 14.1, type_fichier
14.1, in_file 14.1, index 14.2, inout_file 14.1, exception mode_error 14.4,
fichier ouvert 14.1, positive_count 14.3, exception status_error 14.4, use_error
exception 14.4   

14.2.5 Spécification du package Direct_IO  

   avec IO_EXCEPTIONS ;
   générique
      le type ELEMENT_TYPE est privé ;
   le package DIRECT_IO est

      le type FILE_TYPE est limité en privé ;

      tapez FILE_MODE est (IN_FILE, INOUT_FILE, OUT_FILE) ;
      le type COUNT est la plage 0 .. implémentation définie ;
      le sous-type POSITIVE_COUNT est la plage COUNT 1 .. COUNT'LAST ; 

      -- Gestion de fichiers

      procédure CREATE(FILE : entrée sortie FILE_TYPE;
                       MODE : dans FILE_MODE := INOUT_FILE;
                       NOM : dans STRING := "";
                       FORMULAIRE : dans CHAÎNE := "");

      procédure OPEN (FILE : in out FILE_TYPE;
                       MODE : dans FILE_MODE;
                       NOM : en CHAÎNE ;
                       FORMULAIRE : dans CHAÎNE := "");   

      procédure FERMETURE (FILE : entrée sortie FILE_TYPE) ;
      procédure DELETE(FILE : entrée sortie FILE_TYPE); 
      procédure RESET (FILE : in out FILE_TYPE; MODE : in FILE_MODE) ;
      procédure RESET (FILE : in out FILE_TYPE) ;

      la fonction MODE (FILE : dans FILE_TYPE) renvoie FILE_MODE ;
      fonction NOM (FILE : dans FILE_TYPE) renvoie STRING ;
      fonction FORM (FILE : dans FILE_TYPE) renvoie STRING ;

      la fonction IS_OPEN(FILE : dans FILE_TYPE) renvoie BOOLEAN ;                                                

      -- Opérations d'entrée et de sortie

      procédure READ (FILE : dans FILE_TYPE; ITEM : sortie ELEMENT_TYPE; FROM :
       POSITIVE_COUNT );
      procédure READ (FILE : dans FILE_TYPE ; ITEM : sortie ELEMENT_TYPE) ;

      procédure WRITE(FILE : dans FILE_TYPE; ITEM : dans ELEMENT_TYPE; TO :
       POSITIVE_COUNT );
      procédure WRITE(FILE : dans FILE_TYPE; ITEM : dans ELEMENT_TYPE);

      procédure SET_INDEX(FILE : dans FILE_TYPE; TO : dans POSITIVE_COUNT);

      la fonction INDEX(FILE : dans FILE_TYPE) renvoie POSITIVE_COUNT ;
      la fonction SIZE (FILE : dans FILE_TYPE) renvoie COUNT ;

      la fonction END_OF_FILE(FILE : dans FILE_TYPE) renvoie BOOLEAN ;

      -- Des exceptions

      STATUS_ERROR : l'exception renomme IO_EXCEPTIONS.STATUS_ERROR ;
      MODE_ERROR : l'exception renomme IO_EXCEPTIONS.MODE_ERROR ;
      NAME_ERROR : l'exception renomme IO_EXCEPTIONS.NAME_ERROR ;
      USE_ERROR : l'exception renomme IO_EXCEPTIONS.USE_ERROR ;
      DEVICE_ERROR : l'exception renomme IO_EXCEPTIONS.DEVICE_ERROR ;
      END_ERROR : l'exception renomme IO_EXCEPTIONS.END_ERROR ;
      DATA_ERROR : l'exception renomme IO_EXCEPTIONS.DATA_ERROR ;   

   privé
      -- dépendant de la mise en œuvre
   terminer DIRECT_IO ; 

Références fermer la procédure 14.2.1, type de comptage 14.2, créer une procédure
14.2.1, exception data_error 14.4, default_mode 14.2.5, procédure de suppression
14.2.1, exception device_error 14.4, element_type 14.2.4, end_error
exception 14.4, fonction end_of_file 14.2.4, file_mode 14.2.5, file_type
14.2.4, fonction de formulaire 14.2.1, in_file 14.2.4, fonction d'index 14.2.4,
inout_file 14.2.4 14.2.1, package io_exceptions 14.4, fonction is_open
14.2.1, fonction mode 14.2.1, exception mode_error 14.4, fonction nom
14.2.1, exception name_error 14.4, procédure ouverte 14.2.1, out_file 14.2.1,
procédure de lecture 14.2.4, procédure set_index 14.2.4, fonction size 14.2.4,
exception status_error 14.4, exception use_error 14.4, procédure d'écriture
14.2.4 14.2.1   

14.3 Entrée-Sortie de texte 

Cette section décrit le package TEXT_IO, qui fournit des fonctionnalités pour
entrée et sortie sous une forme lisible par l’homme. Chaque fichier est lu ou écrit
séquentiellement, comme une séquence de caractères regroupés en lignes, et comme un
séquence de lignes regroupées en pages. La spécification du package est
indiquées ci-dessous à la section 14.3.10.   

Les fonctionnalités de gestion de fichiers indiquées ci-dessus, dans les sections 14.2.1 et
14.2.2, sont disponibles pour l'entrée-sortie de texte. Au lieu de LIRE et ÉCRIRE,
cependant, il existe des procédures GET et PUT qui saisissent des valeurs appropriées.
types à partir de fichiers texte et y afficher des valeurs. Ces valeurs sont
fourni aux procédures PUT, et renvoyé par les procédures GET, dans un
paramètre ARTICLE. Il existe plusieurs procédures surchargées portant ces noms, par exemple
différents types d'ARTICLE. Ces procédures GET analysent les séquences d'entrée
de caractères comme éléments lexicaux (voir chapitre 2) et renvoie le  
valeurs correspondantes ; les procédures PUT génèrent les valeurs données sous la forme
éléments lexicaux appropriés. Les procédures GET et PUT sont également disponibles
qui saisissent et extraient des caractères individuels traités comme des valeurs de caractères
plutôt que comme éléments lexicaux.                                                 

En plus des procédures GET et PUT pour les types numériques et énumération
de ITEM qui opèrent sur des fichiers texte, des procédures analogues sont fournies pour
lire et écrire dans un paramètre de type STRING. Ces procédures
effectuer la même analyse et la même composition de séquences de caractères que leur
homologues qui ont un paramètre de fichier.

Pour toutes les procédures GET et PUT qui opèrent sur des fichiers texte, et pour de nombreuses
d'autres sous-programmes, il existe des formulaires avec et sans paramètre de fichier. Chaque
une telle procédure GET opère sur un fichier d'entrée, et chacune de ces procédures PUT
opère sur un fichier de sortie. Si aucun fichier n'est spécifié, un fichier d'entrée par défaut
ou un fichier de sortie par défaut est utilisé.

Au début de l'exécution du programme, les fichiers d'entrée et de sortie par défaut
sont ce qu'on appelle le fichier d'entrée standard et le fichier de sortie standard. Ces
les fichiers sont ouverts, ont respectivement les modes courants IN_FILE et OUT_FILE,
et sont associés à deux fichiers externes définis par l'implémentation.
Des procédures sont fournies pour modifier le fichier d'entrée par défaut actuel et le
fichier de sortie par défaut actuel.

D'un point de vue logique, un fichier texte est une séquence de pages, une page est
une séquence de lignes, et une ligne est une séquence de caractères ; la fin d'un
la ligne est marquée par un terminateur de ligne ; la fin d'une page est marquée par le
combinaison d'un terminateur de ligne immédiatement suivi d'un terminateur de page ;
et la fin d'un fichier est marquée par la combinaison d'un terminateur de ligne
immédiatement suivi d'un terminateur de page puis d'un terminateur de fichier.
Les terminateurs sont générés pendant la sortie ; soit par appels de procédures
prévu expressément à cet effet ; ou implicitement dans le cadre d'autres
opérations, par exemple, lorsqu'une longueur de ligne limitée, une longueur de page limitée,
ou les deux, ont été spécifiés pour un fichier.

La nature réelle des terminateurs n'est pas définie par le langage et donc
dépend de la mise en œuvre. Bien que les terminateurs soient reconnus ou
générés par certaines des procédures qui suivent, ils ne sont pas
nécessairement implémentés sous forme de caractères ou de séquences de caractères.
Qu'il s'agisse de personnages (et si oui lesquels) dans un domaine particulier
la mise en œuvre ne doit pas nécessairement concerner un utilisateur qui ne produit ni explicitement ni
entre explicitement des caractères de contrôle. L'effet de l'entrée ou de la sortie de
les caractères de contrôle (autres que la tabulation horizontale) ne sont pas définis par le
langue.

Les caractères d'une ligne sont numérotés à partir de un ; le numéro d'un
Le caractère est appelé son numéro de colonne. Pour un terminateur de ligne, une colonne
nombre est également défini : il est un de plus que le nombre de caractères dans
la ligne. Les lignes d'une page et les pages d'un fichier sont de la même manière
numéroté. Le numéro de colonne actuel est le numéro de colonne du prochain
caractère ou terminateur de ligne à transférer. Le numéro de ligne actuel est
le numéro de la ligne en cours. Le numéro de page actuel est le nombre de
la page actuelle. Ces nombres sont des valeurs du sous-type POSITIVE_COUNT
du type COUNT (par convention, on utilise la valeur zéro du type COUNT
pour indiquer des conditions particulières).

   le type COUNT est la plage 0 .. mise en œuvre_définie ;
   le sous-type POSITIVE_COUNT est la plage COUNT 1 .. COUNT'LAST ;   

Pour un fichier de sortie, une longueur de ligne maximale peut être spécifiée et une longueur maximale
la longueur de la page peut être spécifiée. Si une valeur à sortir ne peut pas tenir sur le
ligne actuelle, pour une longueur de ligne maximale spécifiée, alors une nouvelle ligne est
automatiquement démarré avant la sortie de la valeur ; si, en outre, ce nouveau
la ligne ne peut pas tenir sur la page actuelle, pour une longueur de page maximale spécifiée,
puis une nouvelle page est automatiquement démarrée avant que la valeur ne soit affichée.
Des fonctions sont fournies pour déterminer la longueur maximale de la ligne et le maximum
longueur des pages. Lorsqu'un fichier est ouvert avec le mode OUT_FILE, les deux valeurs sont
zéro : par convention, cela signifie que les longueurs de lignes et les longueurs de pages sont
sans bornes. (Par conséquent, la sortie consiste en une seule ligne si le
les sous-programmes pour le contrôle explicite de la structure des lignes et des pages ne sont pas utilisés.)
La constante UNBOUNDED est prévue à cet effet.

Références : type de comptage 14.3.10, fichier d'entrée actuel par défaut 14.3.2, par défaut
fichier de sortie actuel 14.3.2, fichier externe 14.1, fichier 14.1, procédure d'obtention
14.3.5, in_file 14.1, out_file 14.1, mettre la procédure 14.3.5, lire 14.2.2,
accès séquentiel 14.1, fichier d'entrée standard 14.3.2, fichier de sortie standard
14.3.2                                      

14.3.1 Gestion des fichiers 

Les seuls modes de fichier autorisés pour les fichiers texte sont les modes IN_FILE et
OUT_FILE. Les sous-programmes donnés à la section 14.2.1 pour le contrôle des
fichiers externes, et la fonction END_OF_FILE donnée dans la section 14.2.2 pour
entrées-sorties séquentielles, sont également disponibles pour les fichiers texte. Il y a aussi
une version de END_OF_FILE qui fait référence au fichier d'entrée par défaut actuel.
Pour les fichiers texte, les procédures ont les effets supplémentaires suivants : 

 - Pour les procédures CREATE et OPEN : Après ouverture d'un fichier avec le mode
    OUT_FILE, la longueur de la page et la longueur de la ligne sont illimitées (les deux ont le
    valeur conventionnelle zéro). Après avoir ouvert un fichier avec le mode IN_FILE ou
    OUT_FILE, la colonne actuelle, la ligne actuelle et les numéros de page actuels
    sont mis à un.

 - Pour la procédure FERMETURE : Si le fichier a le mode courant OUT_FILE,
    a pour effet d'appeler NEW_PAGE, sauf si la page courante est déjà
    terminé; puis génère un terminateur de fichier.

 - Pour la procédure RESET : Si le fichier a le mode courant OUT_FILE,
    a pour effet d'appeler NEW_PAGE, sauf si la page courante est déjà
    terminé; puis génère un terminateur de fichier. Si le nouveau mode de fichier est
    OUT_FILE, les longueurs de page et de ligne sont illimitées. Pour tous les modes, le
    Les numéros de colonne, de ligne et de page actuels sont définis sur un.

L'exception MODE_ERROR est levée par la procédure RESET lors d'une tentative
pour changer le mode d'un fichier qui est soit le fichier d'entrée par défaut actuel,
ou le fichier de sortie par défaut actuel.

Références : créer une procédure 14.2.1, numéro de colonne actuel 14.3, actuel
fichier d'entrée par défaut 14.3, numéro de ligne actuel 14.3, numéro de page actuel
14.3, fin_du_fichier 14.3, fichier externe 14.1, fichier 14.1, mode fichier 14.1, fichier
terminateur 14.3, in_file 14.1, longueur de ligne 14.3, exception mode_error 14.4,
procédure d'ouverture 14.2.1, out_file 14.1, longueur de page 14.3, procédure de réinitialisation
14.2.1  

14.3.2 Fichiers d'entrée et de sortie par défaut 

Les sous-programmes suivants assurent le contrôle de la valeur par défaut particulière
fichiers utilisés lorsqu'un paramètre de fichier est omis d'un GET, PUT ou
autre opération d'entrée-sortie de texte décrite ci-dessous. 

   procédure SET_INPUT(FILE : dans FILE_TYPE);

         Opère sur un fichier de mode IN_FILE. Définit la valeur par défaut actuelle
         fichier d’entrée dans FILE.   

         L'exception STATUS_ERROR est levée si le fichier donné n'est pas
         ouvrir. L'exception MODE_ERROR est levée si le mode du
         le fichier donné n'est pas IN_FILE. 

   procédure SET_OUTPUT(FILE : dans FILE_TYPE);

         Opère sur un fichier de mode OUT_FILE. Définit la valeur par défaut actuelle
         fichier de sortie dans FILE.

         L'exception STATUS_ERROR est levée si le fichier donné n'est pas
         ouvrir. L'exception MODE_ERROR est levée si le mode du
         le fichier donné n'est pas OUT_FILE.                                               

   la fonction STANDARD_INPUT renvoie FILE_TYPE ;

         Renvoie le fichier d'entrée standard (voir 14.3). 

   la fonction STANDARD_OUTPUT renvoie FILE_TYPE ;

         Renvoie le fichier de sortie standard (voir 14.3). 

   la fonction CURRENT_INPUT renvoie FILE_TYPE ;

         Renvoie le fichier d'entrée par défaut actuel. 

   la fonction CURRENT_OUTPUT renvoie FILE_TYPE ;

         Renvoie le fichier de sortie par défaut actuel.

Note:

Les fichiers d'entrée standard et les fichiers de sortie standard ne peuvent pas être ouverts, fermés,
réinitialisé, ou supprimé, car le paramètre FILE du correspondant
les procédures ont le mode in out.

Références : fichier par défaut actuel 14.3, fichier par défaut 14.3, file_type 14.1,
obtenir la procédure 14.3.5, l'exception mode_error 14.4, mettre la procédure 14.3.5,
exception status_error 14.4  

14.3.3 Spécification des longueurs de ligne et de page 

Les sous-programmes décrits dans cette section concernent la ligne et
structure des pages d'un fichier de mode OUT_FILE. Ils opèrent soit sur dossier
donné comme premier paramètre, ou, en l'absence d'un tel paramètre de fichier,
sur le fichier de sortie par défaut actuel. Ils permettent la sortie de texte avec un
longueur de ligne ou longueur de page maximale spécifiée. Dans ces cas, la ligne et
les terminateurs de page sont générés implicitement et automatiquement en cas de besoin. Quand
les longueurs de ligne et de page sont illimitées (c'est-à-dire lorsqu'elles ont la
valeur conventionnelle zéro), comme dans le cas d'un fichier nouvellement ouvert, de nouvelles lignes
et les nouvelles pages ne sont démarrées que lorsqu'elles sont explicitement requises.

Dans tous les cas, l'exception STATUS_ERROR est levée si le fichier à utiliser
n'est pas ouvert ; l'exception MODE_ERROR est levée si le mode du fichier est
pas OUT_FILE. 

   procédure SET_LINE_LENGTH(FILE : dans FILE_TYPE; TO : dans COUNT);
   procédure SET_LINE_LENGTH(TO : dans COUNT);   

         Définit la longueur de ligne maximale du fichier de sortie spécifié sur la valeur
         nombre de caractères spécifié par TO. La valeur zéro pour TO
         spécifie une longueur de ligne illimitée.

         L'exception USE_ERROR est levée si la longueur de ligne spécifiée est
         inapproprié pour le fichier externe associé.                                                  

   procédure SET_PAGE_LENGTH(FILE : dans FILE_TYPE; TO : dans COUNT);
   procédure SET_PAGE_LENGTH(TO : dans COUNT);

         Définit la longueur maximale de page du fichier de sortie spécifié sur la
         nombre de lignes spécifié par TO. La valeur zéro pour TO spécifie
         une longueur de page illimitée.

         L'exception USE_ERROR est levée si la longueur de page spécifiée est
         inapproprié pour le fichier externe associé.  

   la fonction LINE_LENGTH(FILE : dans FILE_TYPE) renvoie COUNT ;
   la fonction LINE_LENGTH renvoie COUNT ;

         Renvoie la longueur de ligne maximale actuellement définie pour le spécifié
         fichier de sortie, ou zéro si la longueur de la ligne est illimitée. 

   la fonction PAGE_LENGTH(FILE : dans FILE_TYPE) renvoie COUNT ;
   la fonction PAGE_LENGTH renvoie COUNT ;

         Renvoie la longueur de page maximale actuellement définie pour le fichier spécifié.
         fichier de sortie, ou zéro si la longueur de la page est illimitée. 

Références : type de comptage 14.3, fichier de sortie par défaut actuel 14.3, externe
fichier 14.1, fichier 14.1, file_type 14.1, ligne 14.3, longueur de ligne 14.3, ligne
terminateur 14.3, longueur de ligne maximale 14.3, longueur de page maximale 14.3,
exception mode_error 14.4, fichier ouvert 14.1, out_file 14.1, page 14.3, page
longueur 14.3, terminateur de page 14.3, exception status_error 14.4, illimité
longueur de page 14.3, exception use_error 14.4  

14.3.4 Opérations sur les colonnes, les lignes et les pages 

Les sous-programmes décrits dans cette section permettent un contrôle explicite de
structure des lignes et des pages ; ils opèrent soit sur le fichier donné comme
premier paramètre, ou, en l'absence d'un tel paramètre de fichier, sur le
fichier par défaut actuel approprié (entrée ou sortie). L'éxéption
STATUS_ERROR est déclenché par l'un de ces sous-programmes si le fichier à utiliser
n'est pas ouvert. 

   procédure NEW_LINE(FILE : dans FILE_TYPE; SPACING : dans POSITIVE_COUNT := 1);
   procédure NEW_LINE(SPACING : dans POSITIVE_COUNT := 1);

         Opère sur un fichier de mode OUT_FILE.

         Pour un ESPACEMENT de un : génère un terminateur de ligne et définit le
         numéro de colonne actuel à un. Puis incrémente la ligne actuelle
         numéro par un, sauf dans le cas où le numéro de ligne actuel est
         déjà supérieure ou égale à la longueur maximale de la page, pour une 
         longueur de page limitée ; dans ce cas, un terminateur de page est affiché, 
         le numéro de page actuel est incrémenté de un et le numéro de page actuel
         le numéro de ligne est défini sur un.

         Pour un SPACING supérieur à un, les actions ci-dessus sont effectuées
         Temps d'ESPACEMENT.

         L'exception MODE_ERROR est levée si le mode n'est pas OUT_FILE.                                                   

 procédure SKIP_LINE(FILE : dans FILE_TYPE; SPACING : dans POSITIVE_COUNT := 1);
 procédure SKIP_LINE(SPACING : dans POSITIVE_COUNT := 1);

         Opère sur un fichier de mode IN_FILE.

         Pour un ESPACEMENT de un : lit et supprime tous les caractères jusqu'à ce qu'un
         le terminateur de ligne a été lu, puis définit la colonne actuelle
         nombre à un. Si la terminaison de ligne n'est pas immédiatement
         suivi d'un terminateur de page, le numéro de ligne actuel est
         incrémenté de un. Sinon, si la terminaison de ligne est
         immédiatement suivi d'un terminateur de page, puis de la page
         Le terminateur est ignoré, le numéro de page actuel est incrémenté de
         un, et le numéro de ligne actuel est défini sur un.

         Pour un SPACING supérieur à un, les actions ci-dessus sont effectuées
         Temps d'ESPACEMENT.

         L'exception MODE_ERROR est levée si le mode n'est pas IN_FILE.
         L'exception END_ERROR est levée si une tentative de lecture d'un
         terminateur de fichier.   

   la fonction END_OF_LINE(FILE : dans FILE_TYPE) renvoie BOOLEAN ;
   la fonction END_OF_LINE renvoie BOOLEAN ;   

         Opère sur un fichier de mode IN_FILE. Renvoie VRAI si une ligne
         le terminateur ou un terminateur de fichier est le suivant ; sinon revient
         FAUX.

         L'exception MODE_ERROR est levée si le mode n'est pas IN_FILE. 

   procédure NEW_PAGE(FILE : dans FILE_TYPE);
   procédure NEW_PAGE ;

         Opère sur un fichier de mode OUT_FILE. Produit un terminateur de ligne
         si la ligne en cours n'est pas terminée, ou si la page en cours est
         vide (c'est-à-dire si les numéros de colonne et de ligne actuels sont tous deux
         égal à un). Génère ensuite un terminateur de page, qui termine
         la page actuelle. Ajoute un au numéro de page actuel et définit
         les numéros de colonne et de ligne actuels à un.

         L'exception MODE_ERROR est levée si le mode n'est pas OUT_FILE. 

   procédure SKIP_PAGE(FILE : dans FILE_TYPE);
   procédure SKIP_PAGE ;

         Opère sur un fichier de mode IN_FILE. Lit et rejette tout
         caractères et terminateurs de ligne jusqu'à ce qu'un terminateur de page ait été
         lire. Ajoute ensuite un au numéro de page actuel et définit le
         Les numéros de colonne et de ligne actuels sont ramenés à un.   

         L'exception MODE_ERROR est levée si le mode n'est pas IN_FILE.
         L'exception END_ERROR est levée si une tentative de lecture d'un
         terminateur de fichier.                                                        

   la fonction END_OF_PAGE(FILE : dans FILE_TYPE) renvoie BOOLEAN ;
   la fonction END_OF_PAGE renvoie BOOLEAN ;

         Opère sur un fichier de mode IN_FILE. Renvoie VRAI si le
         la combinaison d'un terminateur de ligne et d'un terminateur de page est la suivante,
         ou si un terminateur de fichier est le suivant ; sinon, renvoie FALSE.

         L'exception MODE_ERROR est levée si le mode n'est pas IN_FILE. 

   la fonction END_OF_FILE(FILE : dans FILE_TYPE) renvoie BOOLEAN ;
   la fonction END_OF_FILE renvoie BOOLEAN ;

         Opère sur un fichier de mode IN_FILE. Renvoie VRAI si un fichier
         le terminateur est le suivant, ou si la combinaison d'une ligne, d'une page et
         un terminateur de fichier vient ensuite ; sinon, renvoie FALSE.

         L'exception MODE_ERROR est levée si le mode n'est pas IN_FILE. 

Les sous-programmes suivants assurent le contrôle de la position actuelle
de lire ou d'écrire dans un fichier. Dans tous les cas, le fichier par défaut est le
fichier de sortie actuel.

   procédure SET_COL(FILE : dans FILE_TYPE; TO : dans POSITIVE_COUNT);
   procédure SET_COL(TO : dans POSITIVE_COUNT);

         Si le mode fichier est OUT_FILE :

              Si la valeur spécifiée par TO est supérieure à la valeur actuelle
              numéro de colonne, génère des espaces, en ajoutant un au courant
              numéro de colonne après chaque espace, jusqu'à ce que la colonne actuelle
              Le nombre est égal à la valeur spécifiée. Si la valeur spécifiée
              par TO est égal au numéro de colonne actuel, il n'y a pas
              effet. Si la valeur spécifiée par TO est inférieure à la
              numéro de colonne actuel, a pour effet d'appeler NEW_LINE
              (avec un espacement de un), puis génère (TO - 1) espaces, et
              définit le numéro de colonne actuel sur la valeur spécifiée.

              L'exception LAYOUT_ERROR est levée si la valeur spécifiée
              par TO dépasse LINE_LENGTH lorsque la longueur de la ligne est délimitée
              (c'est-à-dire lorsqu'il n'a pas la valeur conventionnelle
              zéro). 

         Si le mode fichier est IN_FILE :   

              Lit (et rejette) les caractères individuels, la ligne
              terminateurs et terminateurs de page, jusqu'au caractère suivant
              à lire a un numéro de colonne qui est égal à la valeur
              précisé par TO ; il n'y a aucun effet si la colonne actuelle
              le nombre est déjà égal à cette valeur. Chaque transfert d'un
              Le caractère ou le terminateur conserve la colonne, la ligne,
              et les numéros de pages de la même manière qu'une procédure GET (voir 
              14.3.5). (Les lignes courtes seront ignorées jusqu'à ce qu'une ligne soit
              atteint qui a un caractère dans la colonne spécifiée
              position.)

              L'exception END_ERROR est déclenchée si une tentative est effectuée
              lire un terminateur de fichier.                                                  

   procédure SET_LINE(FILE : dans FILE_TYPE; TO : dans POSITIVE_COUNT);
   procédure SET_LINE(TO : dans POSITIVE_COUNT); 

         Si le mode fichier est OUT_FILE :

              Si la valeur spécifiée par TO est supérieure à la valeur actuelle
              numéro de ligne, a pour effet d'appeler à plusieurs reprises NEW_LINE
              (avec un espacement de un), jusqu'à ce que le numéro de ligne actuel
              est égal à la valeur spécifiée. Si la valeur spécifiée par TO est
              égal au numéro de ligne actuel, il n'y a aucun effet. Si
              la valeur spécifiée par TO est inférieure à la ligne courante
              numéro, a pour effet d'appeler NEW_PAGE suivi d'un
              appel de NEW_LINE avec un espacement égal à (TO - 1).   

              L'exception LAYOUT_ERROR est levée si la valeur spécifiée
              par TO dépasse PAGE_LENGTH lorsque la longueur de la page est délimitée
              (c'est-à-dire lorsqu'il n'a pas la valeur conventionnelle
              zéro). 

         Si le mode est IN_FILE :

              A pour effet d'appeler SKIP_LINE à plusieurs reprises (avec un
              espacement de un), jusqu'à ce que le numéro de ligne actuel soit égal au
              valeur spécifiée par TO ; il n'y a aucun effet si le courant
              le numéro de ligne est déjà égal à cette valeur. (De courtes pages seront
              ignoré jusqu'à ce qu'une page contenant une ligne en début de page soit atteinte.
              position de ligne spécifiée.)

              L'exception END_ERROR est déclenchée si une tentative est effectuée
              lire un terminateur de fichier. 

   la fonction COL(FILE : dans FILE_TYPE) renvoie POSITIVE_COUNT ;
   la fonction COL renvoie POSITIVE_COUNT ;

         Renvoie le numéro de colonne actuel.

         L'exception LAYOUT_ERROR est levée si ce nombre dépasse
         COMPTE'DERNIER. 

   la fonction LINE(FILE : dans FILE_TYPE) renvoie POSITIVE_COUNT ;
   la fonction LINE renvoie POSITIVE_COUNT ;

         Renvoie le numéro de ligne actuel.

         L'exception LAYOUT_ERROR est levée si ce nombre dépasse
         COMPTE'DERNIER. 

   la fonction PAGE(FILE : dans FILE_TYPE) renvoie POSITIVE_COUNT ;
   la fonction PAGE renvoie POSITIVE_COUNT ;  

         Renvoie le numéro de page actuel.

         L'exception LAYOUT_ERROR est levée si ce nombre dépasse
         COMPTE'DERNIER. 

Le numéro de colonne, le numéro de ligne ou le numéro de page peuvent dépasser
COUNT'LAST (en conséquence de l'entrée ou de la sortie d'un nombre suffisant
caractères, lignes ou pages). Ces événements ne provoquent aucune exception à 
être élevé. Cependant, un appel de COL, LINE ou PAGE déclenche l'exception
LAYOUT_ERROR si le nombre correspondant dépasse COUNT'LAST.                                             

Note:

Un terminateur de page est toujours ignoré chaque fois que le terminateur de ligne précédent
est ignoré. Une implémentation peut représenter la combinaison de ces éléments
terminateurs par un seul caractère, à condition qu'il soit correctement reconnu
en entrée.

Références : numéro de colonne actuel 14.3, fichier par défaut actuel 14.3, actuel
numéro de ligne 14.3, numéro de page actuelle 14.3, exception end_error 14.4, fichier
14.1, terminateur de fichier 14.3, procédure d'obtention 14.3.5, in_file 14.1,
exception layout_error 14.4, ligne 14.3, numéro de ligne 14.3, terminateur de ligne
14.3, longueur maximale de page 14.3, exception mode_error 14.4, fichier ouvert 14.1,
page 14.3, longueur de page 14.3, fin de page 14.3, nombre positif 14.3,
exception status_error 14.4  

14.3.5 Procédures d'obtention et de mise 

Les procédures GET et PUT pour les rubriques de types CHARACTER, STRING,
les types numériques et les types d’énumération sont décrits dans les sections suivantes.
Les caractéristiques de ces procédures qui sont communes à la plupart de ces types sont
décrit dans cette section. Les procédures GET et PUT pour les éléments de type
CHARACTER et STRING traitent des valeurs de caractères individuelles ; le GET et
Les procédures PUT pour les types numériques et énumérations traitent les éléments comme lexicaux
éléments.

Toutes les procédures GET et PUT ont des formulaires avec un paramètre de fichier, écrit en premier.
Lorsque ce paramètre est omis, le courant approprié (d'entrée ou de sortie)
Le fichier par défaut est censé être spécifié. Chaque procédure GET opère sur
un fichier de mode IN_FILE. Chaque procédure PUT opère sur un fichier de mode  
OUT_FILE.

Toutes les procédures GET et PUT conservent la colonne, la ligne et la page actuelles.
numéros du fichier spécifié : l'effet de chacune de ces procédures sur
ces chiffres sont la résultante des effets des transferts individuels de
caractères et de sortie individuelle ou de saut de terminateurs. Chaque
le transfert d'un caractère en ajoute un au numéro de colonne actuel. Chaque sortie
d'un terminateur de ligne définit le numéro de colonne actuel sur un et en ajoute un à
le numéro de ligne actuel. Chaque sortie d'un terminateur de page définit le
les numéros de colonne et de ligne actuels à un et en ajoute un à la page actuelle
nombre. Pour la saisie, chaque saut d'un terminateur de ligne définit le courant
numéro de colonne à un et ajoute un au numéro de ligne actuel ; chaque
le fait de sauter un terminateur de page définit les numéros de colonne et de ligne actuels sur
un et en ajoute un au numéro de page actuel. Des considérations similaires s’appliquent
aux procédures GET_LINE, PUT_LINE et SET_COL.

Plusieurs procédures GET et PUT, pour les types numériques et énumérations, ont
des paramètres de format qui spécifient les longueurs de champ ; ces paramètres sont du
sous-type non négatif FIELD de type INTEGER.

Les entrées-sorties des valeurs d'énumération utilisent la syntaxe des
éléments lexicaux. Toute procédure GET pour un type d'énumération commence par
sauter les blancs de début ou les terminateurs de ligne ou de page ; un être vide 
défini comme un espace ou un caractère de tabulation horizontale. Ensuite, les personnages
sont entrés uniquement tant que l'entrée de séquence est une séquence initiale d'un
identifiant ou d'un littéral de caractère (en particulier, la saisie cesse lorsqu'un
une terminaison de ligne est rencontrée). Le caractère ou le terminateur de ligne qui
provoque l’arrêt de la saisie et reste disponible pour une saisie ultérieure.

Pour un type numérique, les procédures GET ont un paramètre de format appelé  
LARGEUR. Si la valeur donnée pour ce paramètre est nulle, la procédure GET
procède de la même manière que pour les types énumération, mais en utilisant la syntaxe
de littéraux numériques au lieu de celui des littéraux d'énumération. Si un différent de zéro
la valeur est donnée, alors exactement les caractères WIDTH sont saisis, ou les caractères
jusqu'à un terminateur de ligne, selon la première éventualité ; tous les espaces de début sautés
sont inclus dans le décompte. La syntaxe utilisée pour les littéraux numériques est une
syntaxe étendue qui autorise un signe initial (mais pas d'espaces intermédiaires, ou
terminateurs de ligne ou de page).                                                        

Toute procédure PUT, pour un élément de type numérique ou énumération, génère
la valeur de l'élément sous forme de littéral numérique, d'identifiant ou de caractère
littéral, selon le cas. Ceci est précédé d'espaces de début si requis par
les paramètres de format WIDTH ou FORE (comme décrit dans les sections suivantes), et
puis un signe moins pour une valeur négative ; pour un type d'énumération, le
les espaces suivent au lieu de commencer. Le format donné pour une procédure PUT est
annulé s’il n’est pas suffisamment large.

Deux autres cas se présentent pour les procédures PUT pour les opérations numériques et d'énumération.
types, si la longueur de ligne du fichier de sortie spécifié est limitée (c'est-à-dire
s'il n'a pas la valeur conventionnelle zéro). Si le nombre de
caractères à afficher ne dépasse pas la longueur de ligne maximale, mais est
de sorte qu'ils ne peuvent pas tenir sur la ligne actuelle, à partir de la ligne actuelle
colonne, alors (en fait) NEW_LINE est appelé (avec un espacement de un) avant
sortie de l'article. Sinon, si le nombre de caractères dépasse le
longueur de ligne maximale, alors l'exception LAYOUT_ERROR est levée et aucun
les caractères sont sortis.

L'exception STATUS_ERROR est déclenchée par l'une des procédures GET,
GET_LINE, PUT et PUT_LINE si le fichier à utiliser n'est pas ouvert. Le
L'exception MODE_ERROR est levée par les procédures GET et GET_LINE si la
le mode du fichier à utiliser n'est pas IN_FILE ; et par les procédures PUT et
PUT_LINE, si le mode n'est pas OUT_FILE.

L'exception END_ERROR est levée par une procédure GET si une tentative est effectuée
pour ignorer un terminateur de fichier. L'exception DATA_ERROR est levée par un GET
procédure si la séquence finalement saisie n'est pas un élément lexical
correspondant au type, notamment si aucun caractère n'a été saisi ; pour
dans ce test, les blancs en début de page sont ignorés ; pour un élément de type numérique, lorsque
un signe est saisi, cette règle s'applique au littéral numérique suivant. Le
L'exception LAYOUT_ERROR est déclenchée par une procédure PUT qui renvoie vers un
paramètre de type STRING, si la longueur de la chaîne réelle est
insuffisant pour la sortie de l'article.

Exemples:

Dans les exemples, ici et dans les sections 14.3.7 et 14.3.8, la chaîne est entre guillemets
et la lettre minuscule b ne sont pas transférées : elles sont affichées uniquement à
dévoiler l'agencement et les espaces.

   N : ENTIER ;
      ...
   OBTENIR(N);

   -- Caractères en entrée Entrée de séquence Valeur de N

   --bb-12535b-12535-12535
   --bb12_535E1b 12_535E1 125350
   --bb12_535E; 12_535E (aucun) DATA_ERROR déclenché

Exemple de paramètre de largeur remplacé :

   PUT(ITEM => -23, LARGEUR => 2); -- "-23"   

Références : blanc 14.3.9, numéro de colonne 14.3, fichier par défaut actuel 14.3,
exception data_error 14.4, exception end_error 14.4, fichier 14.1, avant
14.3.8, récupérez la procédure 14.3.6 14.3.7 14.3.8 14.3.9, in_file 14.1,
exception layout_error 14.4, numéro de ligne 14.1, terminateur de ligne 14.1,
longueur de ligne maximale 14.3, mode 14.1, exception mode_error 14.4, new_file
procédure 14.3.4, out_file 14.1, numéro de page 14.1, terminateur de page 14.1,
mettre la procédure 14.3.6 14.3.7 14.3.8 14.3.9, sauter 14.3.7 14.3.8 14.3.9,
exception status_error 14.4, largeur 14.3.5 14.3.7 14.3.9                                                

14.3.6 Entrée-sortie de caractères et de chaînes 

Pour un élément de type CARACTÈRE, les procédures suivantes sont fournies :

   procédure GET(FILE : in FILE_TYPE; ITEM : out CHARACTER);
   procédure GET(ITEM : out CHARACTER);

         Après avoir ignoré les terminateurs de ligne et les terminateurs de page,
         lit le caractère suivant du fichier d'entrée spécifié et
         renvoie la valeur de ce caractère dans le paramètre de sortie ITEM.

         L'exception END_ERROR est déclenchée si une tentative est faite pour ignorer un
         terminateur de fichier. 

   procédure PUT(FILE : dans FILE_TYPE; ITEM : dans CHARACTER);
   procédure PUT(ITEM : en CARACTÈRE);

         Si la longueur de ligne du fichier de sortie spécifié est limitée (cela
         est, n'a pas la valeur conventionnelle zéro), et le courant
         le nombre de colonnes le dépasse, a pour effet d'appeler NEW_LINE avec
         un espacement de un. Ensuite, ou autrement, affiche le résultat donné
         caractère au fichier. 

Pour un élément de type STRING, les procédures suivantes sont fournies :

   procédure GET(FILE : dans FILE_TYPE; ITEM : out STRING);
   procédure GET(ITEM : out STRING);

         Détermine la longueur de la chaîne donnée et tente de la faire
         nombre d'opérations GET pour les caractères successifs de la chaîne
         (en particulier, aucune opération n'est effectuée si la chaîne est nulle). 

   procédure PUT(FILE : dans FILE_TYPE; ITEM : dans STRING);
   procédure PUT(ITEM : dans STRING);

         Détermine la longueur de la chaîne donnée et tente de la faire
         nombre d'opérations PUT pour les caractères successifs de la chaîne
         (en particulier, aucune opération n'est effectuée si la chaîne est nulle). 

procédure GET_LINE(FILE : in FILE_TYPE; ITEM : out STRING; LAST : out NATURAL);
procédure GET_LINE(ITEM : sortie STRING; LAST : sortie NATURAL);

         Remplace les caractères successifs de la chaîne spécifiée par
         caractères successifs lus à partir du fichier d’entrée spécifié.
         La lecture s'arrête si la fin de la ligne est atteinte, auquel cas le
         la procédure SKIP_LINE est alors appelée (en effet) avec un espacement de
         un; la lecture s'arrête également si la fin de la chaîne est atteinte.
         Les caractères non remplacés restent indéfinis.   

         Si des caractères sont lus, renvoie en LAST la valeur de l'index telle que
         ITEM(LAST) est le dernier caractère remplacé (l'index du premier
         le caractère remplacé est ITEM'FIRST). Si aucun caractère n'est lu,
         renvoie dans LAST une valeur d'index inférieure d'une unité à ITEM'FIRST.
         L'exception END_ERROR est déclenchée si une tentative est faite pour ignorer un
         terminateur de fichier.                                                      

   procédure PUT_LINE(FILE : dans FILE_TYPE; ITEM : dans STRING);
   procédure PUT_LINE(ITEM : dans STRING);   

         Appelle la procédure PUT pour la chaîne donnée, puis la
         procédure NEW_LINE avec un espacement de un.

Remarques:

Dans un paramètre de chaîne littérale de PUT, le crochet de chaîne englobant
les caractères ne sont pas émis. Chaque caractère de crochet de chaîne doublé dans le
La chaîne ci-jointe est sortie sous la forme d'un seul caractère de crochet de chaîne, sous la forme d'un
conséquence de la règle pour les chaînes littérales (voir 2.6).

Une chaîne lue par GET ou écrite par PUT peut s'étendre sur plusieurs lignes.

Références : numéro de colonne actuel 14.3, exception end_error 14.4, fichier
14.1, terminateur de fichier 14.3, procédure d'obtention 14.3.5, ligne 14.3, longueur de ligne
14.3, procédure new_line 14.3.4, terminateur de page 14.3, procédure put
14.3.4, sauter 14.3.5   

14.3.7 Entrée-sortie pour les types entiers 

Les procédures suivantes sont définies dans le package générique INTEGER_IO.
Cela doit être instancié pour le type entier approprié (indiqué par
NUM dans la spécification).

Les valeurs sont affichées sous forme de décimaux ou de littéraux basés, sans soulignement
caractères ou exposant, et précédé d'un signe moins s'il est négatif. Le
le format (qui inclut les espaces de début et le signe moins) peut être spécifié
par un paramètre facultatif de largeur de champ. Valeurs des largeurs des champs en sortie
les formats sont du sous-type entier non négatif FIELD. Les valeurs des bases sont
du sous-type entier NUMBER_BASE.

   le sous-type NUMBER_BASE est la plage INTEGER 2 .. 16 ;

La largeur et la base du champ par défaut à utiliser par les procédures de sortie sont
défini par les variables suivantes déclarées dans le package générique
ENTIER_IO :

   DEFAULT_WIDTH : FIELD := NUM'WIDTH;
   DEFAULT_BASE : NUMBER_BASE := 10;

Les procédures suivantes sont fournies :

  procédure GET(FILE : in FILE_TYPE; ITEM : out NUM; WIDTH : in FIELD := 0);
  procédure GET(ITEM : out NUM; WIDTH : in FIELD := 0);

         Si la valeur du paramètre WIDTH est nulle, ignore tout interligne
         des blancs, des terminateurs de ligne ou des terminateurs de page, puis lit un plus
         ou un signe moins s'il est présent, se lit alors selon la syntaxe de
         un littéral entier (qui peut être un littéral basé). Si un différent de zéro 
         la valeur de WIDTH est fournie, alors exactement les caractères WIDTH sont
         entrée, ou les caractères (éventuellement aucun) jusqu'à un terminateur de ligne,
         peu importe lequel vient en premier; tous les blancs de début ignorés sont inclus
         dans le décompte.

         Renvoie, dans le paramètre ITEM, la valeur de type NUM qui
         correspond à l’entrée séquence.

         L'exception DATA_ERROR est levée si l'entrée de séquence ne fonctionne pas
         ont la syntaxe requise ou si la valeur obtenue n'est pas de la
         sous-type NUM.                                                           

   procédure PUT(FILE : dans FILE_TYPE;
                 ARTICLE : en NUM;
                 LARGEUR : dans CHAMP := DEFAULT_WIDTH;
                 BASE : dans NUMBER_BASE := DEFAULT_BASE);

   procédure PUT(ITEM : en NUM;
                 LARGEUR : dans CHAMP := DEFAULT_WIDTH;
                 BASE : dans NUMBER_BASE := DEFAULT_BASE);

         Affiche la valeur du paramètre ITEM sous forme de littéral entier,
         sans soulignement, sans exposant et sans zéros non significatifs (mais un
         zéro unique pour la valeur zéro), et un signe moins précédent pour un
         valeur négative.

         Si la séquence de caractères résultante à imprimer comporte moins de caractères
         que les caractères WIDTH, les espaces de début sont d'abord affichés dans 
         combler la différence.

         Utilise la syntaxe du littéral décimal si le paramètre BASE a la
         valeur dix (soit explicitement, soit via DEFAULT_BASE) ;
         sinon, utilise la syntaxe du littéral basé, avec toutes les lettres dans
         haut de casse. 

   procédure GET(FROM : dans STRING; ITEM : sortie NUM; LAST : sortie POSITIF);

         Lit une valeur entière depuis le début de la chaîne donnée,
         suivant les mêmes règles que la procédure GET qui lit un
         valeur entière d'un fichier, mais en traitant la fin de la chaîne comme
         un terminateur de fichier. Renvoie, dans le paramètre ITEM, la valeur de
         tapez NUM qui correspond à l’entrée de séquence. Retours en DERNIER
         la valeur d'index telle que FROM(LAST) est le dernier caractère lu.

         L'exception DATA_ERROR est levée si l'entrée de séquence ne fonctionne pas
         ont la syntaxe requise ou si la valeur obtenue n'est pas de la
         sous-type NUM. 

   procédure PUT(TO : out STRING;
                 ARTICLE : en NUM;
                 BASE : dans NUMBER_BASE := DEFAULT_BASE);

         Affiche la valeur du paramètre ITEM dans la chaîne donnée,
         en suivant la même règle que pour la sortie dans un fichier, en utilisant la longueur
         de la chaîne donnée comme valeur pour WIDTH. 

Exemples:

   le package INT_IO est le nouveau INTEGER_IO(SMALL_INT); utilisez INT_IO ;
   -- format par défaut utilisé à l'instanciation,
        DEFAULT_WIDTH = 4, DEFAULT_BASE = 10

   METTRE(126); -- "b126"
   METTRE(-126, 7); -- "bbb-126"
   PUT(126, LARGEUR => 13, BASE => 2); -- "bbb2#1111110#" 

Références : littéral basé 2.4.2, blanc 14.3.5, exception data_error 14.4,
littéral décimal 2.4.1, sous-type de champ 14.3.5, type_fichier 14.1, procédure d'obtention  
14.3.5, paquet entier_io 14.3.10, littéral entier 2.4, layout_error
exception 14.4, terminateur de ligne 14.3, procédure put 14.3.5, saut
14.3.5, largeur 14.3.5                                                               

14.3.8 Entrées-sorties pour les types réels 

Les procédures suivantes sont définies dans les packages génériques FLOAT_IO et
FIXED_IO, qui doit être instancié pour la virgule flottante appropriée ou
type à virgule fixe respectivement (indiqué par NUM dans les spécifications).

Les valeurs sont affichées sous forme de littéraux décimaux sans caractères soulignés. Le
Le format de chaque sortie de valeur se compose d'un champ FORE, d'un point décimal, d'un
champ AFT, et (si un paramètre EXP différent de zéro est fourni) la lettre E et un
Champ EXP. Les deux formats possibles correspondent donc à :

   AVANT . ARRIÈRE

et à:

   AVANT . AFT E EXP

sans aucun espace entre ces champs. Le champ FORE peut inclure
des espaces de début et un signe moins pour les valeurs négatives. Le domaine AFT
comprend uniquement des chiffres décimaux (éventuellement avec des zéros à droite). Le champ EXP
comprend le signe (plus ou moins) et l'exposant (éventuellement précédé de
des zéros).

Pour les types à virgule flottante, les longueurs par défaut de ces champs sont définies
par les variables suivantes déclarées dans le package générique
FLOAT_IO :

   DEFAULT_FORE : CHAMP := 2;
   DEFAULT_AFT : FIELD := NUM'DIGITS-1;
   DEFAULT_EXP : CHAMP := 3;

Pour les types à virgule fixe, les longueurs par défaut de ces champs sont définies par
les variables suivantes déclarées dans le package générique FIXED_IO : 

   DEFAULT_FORE : FIELD := NUM'FORE;
   DEFAULT_AFT : FIELD := NUM'AFT;
   DEFAULT_EXP : CHAMP := 0; 

Les procédures suivantes sont fournies :

   procédure GET(FILE : in FILE_TYPE; ITEM : out NUM; WIDTH : in FIELD := 0);
   procédure GET(ITEM : out NUM; WIDTH : in FIELD := 0);

         Si la valeur du paramètre WIDTH est nulle, ignore tout interligne
         des blancs, des terminateurs de ligne ou des terminateurs de page, puis lit un plus
         ou un signe moins s'il est présent, se lit alors selon la syntaxe de
         un vrai littéral (qui peut être un littéral basé). Si un différent de zéro
         la valeur de WIDTH est fournie, alors exactement les caractères WIDTH sont
         entrée, ou les caractères (éventuellement aucun) jusqu'à un terminateur de ligne,
         peu importe lequel vient en premier; tous les blancs de début ignorés sont inclus
         dans le décompte.   

         Renvoie, dans le paramètre ITEM, la valeur de type NUM qui
         correspond à l’entrée séquence.

         L'exception DATA_ERROR est levée si l'entrée de séquence ne fonctionne pas
         ont la syntaxe requise ou si la valeur obtenue n'est pas de la
         sous-type NUM.                                                            

   procédure PUT(FILE : dans FILE_TYPE;
                 ARTICLE : en NUM;
                 AVANT : dans CHAMP := DEFAULT_FORE;
                 AFT : dans CHAMP := DEFAULT_AFT;
                 EXP : dans CHAMP := DEFAULT_EXP);

   procédure PUT(ITEM : en NUM;
                 AVANT : dans CHAMP := DEFAULT_FORE;
                 AFT : dans CHAMP := DEFAULT_AFT;
                 EXP : dans CHAMP := DEFAULT_EXP);

         Affiche la valeur du paramètre ITEM sous forme de littéral décimal avec  
         le format défini par FORE, AFT et EXP. Si la valeur est
         négatif, un signe moins est inclus dans la partie entière. Si EXP
         a la valeur zéro, alors la partie entière à sortir a comme
         autant de chiffres que nécessaire pour représenter la partie entière du
         valeur de ITEM, en remplaçant FORE si nécessaire, ou se compose de la
         chiffre zéro si la valeur de ITEM n’a pas de partie entière.

         Si EXP a une valeur supérieure à zéro, alors la partie entière à
         la sortie a un seul chiffre, qui est différent de zéro, sauf pour la valeur
         0,0 de l'ARTICLE.

         Cependant, dans les deux cas, si la partie entière à sortir a
         moins de caractères FORE, y compris tout signe moins, puis
         les espaces de début sont les premiers affichés pour combler la différence. Le
         le nombre de chiffres de la partie fractionnaire est donné par AFT, ou est
         un si AFT est égal à zéro. La valeur est arrondie ; une valeur de
         exactement la moitié à la dernière place peut être arrondie soit à l'unité supérieure, soit à l'unité supérieure.
         vers le bas.

         Si EXP a la valeur zéro, il n’y a pas de partie exposant. Si EXP a
         une valeur supérieure à zéro, alors la partie exposant à sortir
         a autant de chiffres que nécessaire pour représenter la partie exposant
         de la valeur de ITEM (pour laquelle une partie entière à un chiffre est
         utilisé), et comporte un signe initial (plus ou moins). Si la
         la partie exposant à sortir contient moins de caractères EXP,
         y compris le signe, puis les zéros non significatifs précèdent les chiffres, pour
         combler la différence. Pour la valeur 0,0 de ITEM, l'exposant
         a la valeur zéro. 

   procédure GET(FROM : dans STRING; ITEM : sortie NUM; LAST : sortie POSITIF);

         Lit une valeur réelle depuis le début de la chaîne donnée,
         suivant la même règle que la procédure GET qui lit un réel
         valeur d'un fichier, mais en traitant la fin de la chaîne comme un fichier
         terminateur. Renvoie, dans le paramètre ITEM, la valeur de type
         NUM qui correspond à l'entrée de la séquence. Renvoie en DERNIER le
         valeur d'index telle que FROM(LAST) soit le dernier caractère lu.

         L'exception DATA_ERROR est levée si l'entrée de séquence ne fonctionne pas
         ont la syntaxe requise, ou si la valeur obtenue n'est pas de la
         sous-type NUM. 

   procédure PUT(TO : out STRING;
                 ARTICLE : en NUM;
                 AFT : dans CHAMP := DEFAULT_AFT;
                 EXP : en ENTIER := DEFAULT_EXP);

         Affiche la valeur du paramètre ITEM dans la chaîne donnée,
         en suivant la même règle que pour la sortie dans un fichier, en utilisant une valeur
         pour FORE tel que la séquence de caractères soit exactement
         remplit la chaîne, y compris les espaces de début.                                              

Exemples:

   le package REAL_IO est le nouveau FLOAT_IO(REAL); utilisez REAL_IO ;
   -- format par défaut utilisé à l'instanciation, DEFAULT_EXP = 3

   X : RÉEL := -123.4567; -- chiffres 8 (voir 3.5.7)

   METTRE(X); --format par défaut "-1.2345670E+02"
   PUT(X, AVANT => 5, ARRIÈRE => 3, EXP => 2); -- "bbb-1.235E+2"
   METTRE(X, 5, 3, 0); -- "b-123.457"

Note:

Pour un élément avec une valeur positive, si la sortie vers une chaîne remplit exactement le
chaîne sans espaces de début, puis sortie du négatif correspondant
la valeur augmentera LAYOUT_ERROR.  

Références : attribut arrière 3.5.10, littéral basé sur 2.4.2, vide 14.3.5,
exception data_error 14.3.5, littéral décimal 2.4.1, sous-type de champ 14.3.5,
file_type 14.1, paquet fixe_io 14.3.10, paquet flottant_io 14.3.10, avant
attribut 3.5.10, procédure d'obtention 14.3.5, layout_error 14.3.5, ligne
terminateur 14.3.5, procédure put 14.3.5, vrai littéral 2.4, sauter 14.3.5,
largeur 14.3.5   

14.3.9 Entrées-sorties pour les types d'énumération 

Les procédures suivantes sont définies dans le package générique ENUMERATION_IO,
qui doit être instancié pour le type d'énumération approprié (indiqué
par ENUM dans la spécification).

Les valeurs sont affichées en utilisant des lettres majuscules ou minuscules pour les identifiants.
Ceci est spécifié par le paramètre SET, qui est du type énumération
COMPOSER.

   tapez TYPE_SET est (LOWER_CASE, UPPER_CASE) ;

Le format (qui inclut les espaces de fin) peut être spécifié par un
paramètre facultatif de largeur de champ. La largeur du champ et la casse des lettres par défaut
sont définis par les variables suivantes qui sont déclarées dans le générique
paquet ENUMERATION_IO :

   DEFAULT_WIDTH : CHAMP := 0;
   DEFAULT_SETTING : TYPE_SET := UPPER_CASE;

Les procédures suivantes sont fournies :

   procédure GET(FILE : dans FILE_TYPE; ITEM : hors ENUM);
   procédure GET(ITEM : sortie ENUM);

         Après avoir ignoré les espaces de début, les terminateurs de ligne ou les pages
         terminateurs, lit un identifiant selon la syntaxe de ce 
         élément lexical (les minuscules et les majuscules étant considérées
         équivalent), ou un caractère littéral selon la syntaxe de
         cet élément lexical (y compris les apostrophes). Retourne, dans
         le paramètre ITEM, la valeur de type ENUM qui correspond à
         l’entrée de séquence.   

         L'exception DATA_ERROR est levée si l'entrée de séquence ne fonctionne pas
         avoir la syntaxe requise, ou si l'identifiant ou le caractère
         littéral ne correspond pas à une valeur du sous-type ENUM.                                               

   procédure PUT(FILE : dans FILE_TYPE;
                 ARTICLE : en ENUM;
                 LARGEUR : dans CHAMP := DEFAULT_WIDTH;
                 SET : dans TYPE_SET := DEFAULT_SETTING);

   procédure PUT(ITEM : dans ENUM;
                 LARGEUR : dans CHAMP := DEFAULT_WIDTH;
                 SET : dans TYPE_SET := DEFAULT_SETTING);

         Affiche la valeur du paramètre ITEM sous forme de littéral d'énumération
         (soit un identifiant, soit un caractère littéral). L'optionnel
         le paramètre SET indique si l'on utilise des minuscules ou des majuscules
         pour les identifiants ; cela n'a aucun effet sur les caractères littéraux. Si
         la séquence de caractères produite a moins de WIDTH
         caractères, puis les espaces de fin sont finalement affichés pour compenser
         la différence. 

   procédure GET(FROM : dans STRING; ITEM : sortie ENUM; LAST : sortie POSITIVE);

         Lit une valeur d'énumération à partir du début de la valeur donnée
         chaîne, suivant la même règle que la procédure GET qui lit
         une valeur d'énumération à partir d'un fichier, mais en traitant la fin du
         chaîne comme terminateur de fichier. Renvoie, dans le paramètre ITEM, le
         valeur de type ENUM qui correspond à l’entrée de séquence.
         Renvoie dans LAST la valeur de l'index telle que FROM(LAST) soit le dernier
         caractère lu.

         L'exception DATA_ERROR est levée si l'entrée de séquence ne fonctionne pas 
         avoir la syntaxe requise, ou si l'identifiant ou le caractère
         littéral ne correspond pas à une valeur du sous-type ENUM. 

   procédure PUT(TO : out STRING;
                 ARTICLE : en ENUM;
                 SET : dans TYPE_SET := DEFAULT_SETTING);

         Affiche la valeur du paramètre ITEM dans la chaîne donnée,
         en suivant la même règle que pour la sortie dans un fichier, en utilisant la longueur
         de la chaîne donnée comme valeur pour WIDTH. 

Bien que la spécification du package ENUMERATION_IO permettrait
instanciation pour un type entier, ce n'est pas le but prévu de ce
package générique, et l’effet de telles instanciations n’est pas défini par
la langue.

Remarques:

Il y a une différence entre PUT défini pour les caractères et pour
valeurs d'énumération. Ainsi

   TEXT_IO.PUT('A'); -- affiche le caractère A   

   le package CHAR_IO est nouveau TEXT_IO.ENUMERATION_IO(CHARACTER);
   CHAR_IO.PUT('A'); -- affiche le caractère 'A', entre guillemets simples

Le type BOOLEAN est un type énumération, donc ENUMERATION_IO peut être
instancié pour ce type.

Références : blank 14.3.5, data_error 14.3.5, package enumeration_io
14.3.10, sous-type de champ 14.3.5, type_fichier 14.1, procédure d'obtention 14.3.5, ligne
terminateur 14.3.5, procédure de mise 14.3.5, sauter 14.3.5, largeur 14.3.5                                               

14.3.10 Spécification du package Text_IO  

   avec IO_EXCEPTIONS ;
   le package TEXT_IO est

      le type FILE_TYPE est limité en privé ;

      tapez FILE_MODE est (IN_FILE, OUT_FILE) ; 

      le type COUNT est la plage 0 .. implémentation définie ;
      le sous-type POSITIVE_COUNT est la plage COUNT 1 .. COUNT'LAST ;
      ILLIMITÉ : constante COUNT := 0 ; -- longueur de ligne et de page

      le sous-type FIELD est une plage INTEGER 0 .. implémentation définie ;
      le sous-type NUMBER_BASE est la plage INTEGER 2 .. 16 ;

      tapez TYPE_SET est (LOWER_CASE, UPPER_CASE) ;

      -- Gestion de fichiers

      procédure CREATE (FILE : entrée sortie FILE_TYPE;
                        MODE : dans FILE_MODE := OUT_FILE;
                        NOM : dans STRING := "";
                        FORMULAIRE : dans CHAÎNE := "");

      procédure OPEN (FILE : in out FILE_TYPE;
                        MODE : dans FILE_MODE;
                        NOM : en CHAÎNE ;
                        FORMULAIRE : dans CHAÎNE := "");

      procédure FERMETURE (FILE : entrée sortie FILE_TYPE) ;
      procédure DELETE (FILE : entrée sortie FILE_TYPE) ;
      procédure RESET (FILE : in out FILE_TYPE; MODE : in FILE_MODE) ;
      procédure RESET (FILE : in out FILE_TYPE) ;

      la fonction MODE (FILE : dans FILE_TYPE) renvoie FILE_MODE ;
      fonction NOM (FILE : dans FILE_TYPE) renvoie STRING ;
      fonction FORM (FILE : dans FILE_TYPE) renvoie STRING ;

      la fonction IS_OPEN(FILE : dans FILE_TYPE) renvoie BOOLEAN ;

      - Contrôle des fichiers d'entrée et de sortie par défaut

      procédure SET_INPUT (FILE : dans FILE_TYPE) ;
      procédure SET_OUTPUT(FILE : dans FILE_TYPE); 

      la fonction STANDARD_INPUT renvoie FILE_TYPE ;
      la fonction STANDARD_OUTPUT renvoie FILE_TYPE ;

      la fonction CURRENT_INPUT renvoie FILE_TYPE ;
      la fonction CURRENT_OUTPUT renvoie FILE_TYPE ;                                    

      -- Spécification des longueurs de ligne et de page

      procédure SET_LINE_LENGTH(FILE : dans FILE_TYPE; TO : dans COUNT);
      procédure SET_LINE_LENGTH(TO : dans COUNT); 

      procédure SET_PAGE_LENGTH(FILE : dans FILE_TYPE; TO : dans COUNT);
      procédure SET_PAGE_LENGTH(TO : dans COUNT);

      la fonction LINE_LENGTH(FILE : dans FILE_TYPE) renvoie COUNT ;
      la fonction LINE_LENGTH renvoie COUNT ;

      la fonction PAGE_LENGTH(FILE : dans FILE_TYPE) renvoie COUNT ;
      la fonction PAGE_LENGTH renvoie COUNT ;

      - Contrôle de colonne, de ligne et de page

 procédure NEW_LINE (FILE : dans FILE_TYPE; SPACING : dans POSITIVE_COUNT := 1);
 procédure NEW_LINE (SPACING : dans POSITIVE_COUNT := 1) ;

 procédure SKIP_LINE (FILE : dans FILE_TYPE; SPACING : dans POSITIVE_COUNT := 1);
 procédure SKIP_LINE (SPACING : dans POSITIVE_COUNT := 1) ;

      la fonction END_OF_LINE(FILE : dans FILE_TYPE) renvoie BOOLEAN ;
      la fonction END_OF_LINE renvoie BOOLEAN ;

      procédure NEW_PAGE (FILE : dans FILE_TYPE) ;
      procédure NEW_PAGE ;

      procédure SKIP_PAGE (FILE : dans FILE_TYPE) ;
      procédure SKIP_PAGE ;

      la fonction END_OF_PAGE(FILE : dans FILE_TYPE) renvoie BOOLEAN ;
      la fonction END_OF_PAGE renvoie BOOLEAN ;

      la fonction END_OF_FILE(FILE : dans FILE_TYPE) renvoie BOOLEAN ;
      la fonction END_OF_FILE renvoie BOOLEAN ; 

      procédure SET_COL (FILE : dans FILE_TYPE ; TO : dans POSITIVE_COUNT) ;
      procédure SET_COL (TO : dans POSITIVE_COUNT) ;

      procédure SET_LINE(FILE : dans FILE_TYPE; TO : dans POSITIVE_COUNT);
      procédure SET_LINE(TO : dans POSITIVE_COUNT); 

      la fonction COL (FILE : dans FILE_TYPE) renvoie POSITIVE_COUNT ;
      la fonction COL renvoie POSITIVE_COUNT ;

      la fonction LINE(FILE : dans FILE_TYPE) renvoie POSITIVE_COUNT ;
      la fonction LINE renvoie POSITIVE_COUNT ;

      la fonction PAGE(FILE : dans FILE_TYPE) renvoie POSITIVE_COUNT ;
      la fonction PAGE renvoie POSITIVE_COUNT ;                                          

      -- Entrée-sortie de caractères   

      procédure GET(FILE : in FILE_TYPE; ITEM : out CHARACTER);
      procédure GET(ITEM : out CHARACTER);
      procédure PUT(FILE : dans FILE_TYPE; ITEM : dans CHARACTER);
      procédure PUT(ITEM : en CARACTÈRE);

      -- Chaîne d'entrée-sortie

      procédure GET(FILE : dans FILE_TYPE; ITEM : out STRING);
      procédure GET(ITEM : out STRING);
      procédure PUT(FILE : dans FILE_TYPE; ITEM : dans STRING);
      procédure PUT(ITEM : dans STRING);

      procédure GET_LINE(FILE : dans FILE_TYPE; ITEM : sortie STRING; LAST :
        hors NATUREL);
      procédure GET_LINE(ITEM : sortie STRING; LAST : sortie NATURAL);
      procédure PUT_LINE(FILE : dans FILE_TYPE; ITEM : dans STRING);
      procédure PUT_LINE(ITEM : dans STRING);

      -- Package générique pour les entrées-sorties de types entiers

      générique
         tapez NUM est la plage <> ;
      le package INTEGER_IO est

         DEFAULT_WIDTH : FIELD := NUM'WIDTH;
         DEFAULT_BASE : NUMBER_BASE := 10;

  procédure GET(FILE : in FILE_TYPE; ITEM : out NUM; WIDTH : in FIELD := 0);
         procédure GET(ITEM : out NUM; WIDTH : in FIELD := 0);

         procédure PUT(FILE : dans FILE_TYPE;
                       ARTICLE : en NUM;
                       LARGEUR : dans CHAMP := DEFAULT_WIDTH;
                       BASE : dans NUMBER_BASE := DEFAULT_BASE);
         procédure PUT(ITEM : en NUM;
                       LARGEUR : dans CHAMP := DEFAULT_WIDTH;
                       BASE : dans NUMBER_BASE := DEFAULT_BASE);
      procédure GET(FROM : dans STRING; ITEM : sortie NUM; LAST : sortie POSITIF);
      procédure PUT(TO : out STRING;
                       ARTICLE : en NUM;
                       BASE : dans NUMBER_BASE := DEFAULT_BASE);

    terminer INTEGER_IO ;                                                                     

      -- Packages génériques pour les entrées-sorties de types réels

      générique
         tapez NUM est composé de chiffres <> ;
      le paquet FLOAT_IO est

         DEFAULT_FORE : CHAMP := 2;
         DEFAULT_AFT : FIELD := NUM'DIGITS-1;
         DEFAULT_EXP : CHAMP := 3;

   procédure GET(FILE : in FILE_TYPE; ITEM : out NUM; WIDTH : in FIELD := 0);
         procédure GET(ITEM : out NUM; WIDTH : in FIELD := 0);

         procédure PUT(FILE : dans FILE_TYPE;
                       ARTICLE : en NUM;
                       AVANT : dans CHAMP := DEFAULT_FORE;
                       AFT : dans CHAMP := DEFAULT_AFT;
                       EXP : dans CHAMP := DEFAULT_EXP);
         procédure PUT(ITEM : en NUM;
                       AVANT : dans CHAMP := DEFAULT_FORE;
                       AFT : dans CHAMP := DEFAULT_AFT;
                       EXP : dans CHAMP := DEFAULT_EXP);

        procédure GET(FROM : dans STRING; ITEM : sortie NUM; LAST : sortie POSITIF);
          procédure PUT(TO : out STRING;
                       ARTICLE : en NUM;
                       AFT : dans CHAMP := DEFAULT_AFT;
                       EXP : dans CHAMP := DEFAULT_EXP);
      terminer FLOAT_IO ;

      générique
         tapez NUM est delta <> ;
      le package FIXED_IO est

         DEFAULT_FORE : FIELD := NUM'FORE;
         DEFAULT_AFT : FIELD := NUM'AFT;
         DEFAULT_EXP : CHAMP := 0;

   procédure GET(FILE : in FILE_TYPE; ITEM : out NUM; WIDTH : in FIELD := 0);
         procédure GET(ITEM : out NUM; WIDTH : in FIELD := 0);

         procédure PUT(FILE : dans FILE_TYPE;
                       ARTICLE : en NUM;
                       AVANT : dans CHAMP := DEFAULT_FORE;
                       AFT : dans CHAMP := DEFAULT_AFT;
                       EXP : dans CHAMP := DEFAULT_EXP);
         procédure PUT(ITEM : en NUM;
                       AVANT : dans CHAMP := DEFAULT_FORE;  
                       AFT : dans CHAMP := DEFAULT_AFT;
                       EXP : dans CHAMP := DEFAULT_EXP);

       procédure GET(FROM : dans STRING; ITEM : sortie NUM; LAST : sortie POSITIF);
         procédure PUT(TO : out STRING;
                       ARTICLE : en NUM;
                       AFT : dans CHAMP := DEFAULT_AFT; 
                       EXP : dans CHAMP := DEFAULT_EXP);
      terminer FIXED_IO ;                                                               

      -- Package générique pour les entrées-sorties des types d'énumération

      générique
         tapez ENUM est (<>);
      le package ENUMERATION_IO est

         DEFAULT_WIDTH : CHAMP := 0;
         DEFAULT_SETTING : TYPE_SET := UPPER_CASE;

         procédure GET(FILE : dans FILE_TYPE; ITEM : hors ENUM);
         procédure GET(ITEM : sortie ENUM);

         procédure PUT(FILE : dans FILE_TYPE;
                       ARTICLE : en ENUM;
                       LARGEUR : dans CHAMP := DEFAULT_WIDTH;
                       SET : dans TYPE_SET := DEFAULT_SETTING);
         procédure PUT(ITEM : dans ENUM;
                       LARGEUR : dans CHAMP := DEFAULT_WIDTH;
                       SET : dans TYPE_SET := DEFAULT_SETTING);

     procédure GET(FROM : dans STRING; ITEM : sortie ENUM; LAST : sortie POSITIVE);
         procédure PUT(TO : out STRING;
                       ARTICLE : en ENUM;
                       SET : dans TYPE_SET := DEFAULT_SETTING);
      terminer ENUMERATION_IO ;

   -- Des exceptions

      STATUS_ERROR : l'exception renomme IO_EXCEPTIONS.STATUS_ERROR ;
      MODE_ERROR : l'exception renomme IO_EXCEPTIONS.MODE_ERROR ;
      NAME_ERROR : l'exception renomme IO_EXCEPTIONS.NAME_ERROR ;
      USE_ERROR : l'exception renomme IO_EXCEPTIONS.USE_ERROR ;
      DEVICE_ERROR : l'exception renomme IO_EXCEPTIONS.DEVICE_ERROR ;
      END_ERROR : l'exception renomme IO_EXCEPTIONS.END_ERROR ;
      DATA_ERROR : l'exception renomme IO_EXCEPTIONS.DATA_ERROR ;
      LAYOUT_ERROR : l'exception renomme IO_EXCEPTIONS.LAYOUT_ERROR ;

   privé
      -- dépendant de la mise en œuvre
   terminer TEXT_IO ;   

14.4 Exceptions en entrée-sortie 

Les exceptions suivantes peuvent être déclenchées par des opérations d'entrée-sortie. Ils
sont déclarées dans le package IO_EXCEPTIONS, défini à la section 14.5 ; ce
package est nommé dans la clause de contexte pour chacune des trois entrées-sorties
paquets. Seules les descriptions sommaires sont données des conditions sous
quels NAME_ERROR, USE_ERROR et DEVICE_ERROR sont déclenchés ; pour tous les détails
voir l'Annexe F. S'il existe plusieurs conditions d'erreur, la
L'exception qui apparaît en premier dans la liste suivante est celle qui est
soulevé. 

L'exception STATUS_ERROR est déclenchée par une tentative d'opération sur un fichier
qui n'est pas ouvert, et par une tentative d'ouverture d'un fichier déjà ouvert.                                                      

L'exception MODE_ERROR est déclenchée par une tentative de lecture ou de test de
la fin d'un fichier dont le mode courant est OUT_FILE, et également par une tentative
pour écrire dans un fichier dont le mode actuel est IN_FILE. Dans le cas de TEXT_IO,
l'exception MODE_ERROR est également levée en spécifiant un fichier dont le
le mode est OUT_FILE dans un appel de SET_INPUT, SKIP_LINE, END_OF_LINE, SKIP_PAGE,
ou END_OF_PAGE ; et en spécifiant un fichier dont le mode courant est IN_FILE dans
un appel de SET_OUTPUT, SET_LINE_LENGTH, SET_PAGE_LENGTH, LINE_LENGTH,
PAGE_LENGTH, NEW_LINE ou NEW_PAGE.

L'exception NAME_ERROR est levée par un appel de CREATE ou OPEN si le
La chaîne donnée pour le paramètre NOM ne permet pas l'identification d'un
fichier externe. Par exemple, cette exception est levée si la chaîne est
incorrect, ou, alternativement, si aucun ou plusieurs fichiers externes
correspond à la chaîne.

L'exception USE_ERROR est levée si une opération tentée n'est pas
possible pour des raisons qui dépendent des caractéristiques du fichier externe.
Par exemple, cette exception est levée par la procédure CREATE, entre autres
circonstances, si le mode donné est OUT_FILE mais que le formulaire spécifie un
périphérique d'entrée uniquement, si le paramètre FORM spécifie des droits d'accès invalides,
ou si un fichier externe portant le nom donné existe déjà et qu'il écrase
n'est pas autorisé.

L'exception DEVICE_ERROR est levée si une opération d'entrée-sortie ne peut pas être
terminé en raison d’un dysfonctionnement du système sous-jacent.

L'exception END_ERROR est déclenchée par une tentative de sauter (lire au-delà) la fin
d'un dossier.

L'exception DATA_ERROR peut être levée par la procédure READ si l'élément
read ne peut pas être interprété comme une valeur du type requis. Cette exception
est également déclenché par une procédure GET (définie dans le package TEXT_IO) si le
la séquence de caractères d'entrée ne satisfait pas à la syntaxe requise, ou si la
la valeur saisie n'appartient pas à la plage du type ou du sous-type requis.

L'exception LAYOUT_ERROR est levée (en entrée-sortie de texte) par COL, LINE,
ou PAGE si la valeur renvoyée dépasse COUNT'LAST. L'éxéption
LAYOUT_ERROR est également déclenché lors de la sortie par une tentative de définition d'une colonne ou d'une ligne
nombres dépassant respectivement la longueur maximale spécifiée des lignes ou des pages
(à l'exclusion des cas illimités). Elle est également soulevée par une tentative de METTRE
trop de caractères dans une chaîne.

Références : fonction col 14.3.4, procédure de création 14.2.1, end_of_line
fonction 14.3.4, fonction end_of_page 14.3.4, fichier externe 14.1, fichier
14.1, chaîne de formulaire 14.1, procédure d'obtention 14.3.5, in_file 14.1, io_exceptions
package 14.5, fonction line 14.3.4, fonction line_length 14.3.4, nom
chaîne 14.1, procédure new_line 14.3.4, procédure new_page 14.3.4, open
procédure 14.2.1, out_file 14.1, fonction page 14.3.4, fonction page_length
14.3.4, procédure put 14.3.5, procédure lecture 14.2.2 14.2.3, set_input
procédure 14.3.2, set_line_length 14.3.3, set_page_length 14.3.3,
set_output 14.3.2, procédure skip_line 14.3.4, procédure skip_page 14.3.4,
paquet text_io 14.3                                                            

14.5 Spécification du package IO_Exceptions 

Ce package définit les exceptions nécessaires aux packages SEQUENTIAL_IO,
DIRECT_IO et TEXT_IO.

   le package IO_EXCEPTIONS est

      STATUS_ERROR : exception ;
      MODE_ERROR : exception ;
      NAME_ERROR : exception ;
      USE_ERROR : exception ;
      DEVICE_ERROR : exception ;
      END_ERROR : exception ;
      DATA_ERROR : exception ;
      LAYOUT_ERROR : exception ;

   fin de IO_EXCEPTIONS ;   

14.6 Entrée-sortie de bas niveau 

Une opération d'entrée-sortie de bas niveau est une opération agissant sur un
appareil. Une telle opération est gérée en utilisant l'un des (surchargés)
procédures prédéfinies SEND_CONTROL et RECEIVE_CONTROL.

Une procédure SEND_CONTROL peut être utilisée pour envoyer des informations de contrôle à un
dispositif physique. Une procédure RECEIVE_CONTROL peut être utilisée pour surveiller le  
exécution d'une opération d'entrée-sortie en demandant des informations au
dispositif physique.

De telles procédures sont déclarées dans le package standard LOW_LEVEL_IO et ont
deux paramètres identifiant l'appareil et les données. Cependant, les types et
Les formats des informations de contrôle dépendront de l'environnement physique.
caractéristiques de la machine et de l'appareil. Par conséquent, les types de
les paramètres sont définis par l’implémentation. Des définitions surchargées de ces éléments
des procédures doivent être fournies pour les appareils pris en charge.

La partie visible du package définissant ces procédures est décrite comme
suit :

 le package LOW_LEVEL_IO est
   -- déclarations des types possibles pour DEVICE et DATA ;
   -- déclarations de procédures surchargées pour ces types :
   procédure SEND_CONTROL (DEVICE : type_appareil ; DATA : entrée sortie type_données);
   procédure RECEIVE_CONTROL (DEVICE : type_appareil ; DATA : entrée sortie type_données) ;
 fin;

Les corps des procédures SEND_CONTROL et RECEIVE_CONTROL pour diverses
les appareils peuvent être fournis dans le corps du package LOW_LEVEL_IO. Ces
les corps de procédure peuvent être écrits avec des instructions de code.  

14.7 Exemple d'entrée-sortie 

L'exemple suivant montre l'utilisation de certains éléments d'entrée-sortie de texte
installations dans un dialogue avec un utilisateur au niveau d'un terminal. L'utilisateur est invité
pour taper une couleur, et le programme répond en donnant le nombre d'éléments de
cette couleur disponible en stock, selon un inventaire. Le défaut
des fichiers d'entrée et de sortie sont utilisés. Pour simplifier, tous les éléments requis
les instanciations sont données dans un sous-programme ; en pratique, un colis,
distincte de la procédure, serait utilisée.

   avec TEXT_IO ; utilisez TEXT_IO ;
   la procédure DIALOGUE est
      le type COULEUR est (BLANC, ROUGE, ORANGE, JAUNE, VERT, BLEU, MARRON) ;
      le package COLOR_IO est nouveau ENUMERATION_IO(ENUM => COLOR);
      le package NUMBER_IO est nouveau INTEGER_IO(INTEGER);
      utilisez COLOR_IO, NUMBER_IO ;

      INVENTAIRE : tableau (COULEUR) de INTEGER := (20, 17, 43, 10, 28, 173, 87);
      CHOIX : COULEUR;

      la procédure ENTER_COLOR (SELECTION : out COLOR) est
      commencer
         boucle
            commencer
               PUT("Couleur sélectionnée : "); -- invite l'utilisateur
               OBTENIR(SÉLECTION); -- accepte la couleur saisie ou déclenche une exception
               retour;
            exception
               quand DATA_ERROR =>
                  PUT("Couleur invalide, réessayez. "); -- l'utilisateur a tapé
                  NEW_LINE(2); -- nouvelle ligne
                  -- termine l'exécution de l'instruction block
            fin;
         terminer la boucle ; -- répète l'instruction block jusqu'à ce que la couleur soit acceptée
      fin;
   commencer -- déclarations de DIALOGUE ;

      NUMBER_IO.DEFAULT_WIDTH := 5 ;

      boucle

         ENTER_COLOR(CHOIX); -- l'utilisateur tape la couleur et la nouvelle ligne

         SET_COL(5); METTRE(CHOIX); PUT(" éléments disponibles :");
         SET_COL(40); METTRE(INVENTAIRE(CHOIX)); -- la largeur par défaut est de 5
         NOUVELLE LIGNE;
      terminer la boucle ;
   mettre fin au DIALOGUE ;

Exemple d'interaction (les caractères saisis par l'utilisateur sont en italique) :

   Couleur sélectionnée : Noir
   Couleur invalide, réessayez.  

   Couleur sélectionnée : Bleu
       Articles BLEU disponibles : 173
   Couleur sélectionnée : Jaune
       JAUNE articles disponibles : 10

