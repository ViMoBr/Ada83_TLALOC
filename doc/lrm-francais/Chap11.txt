
                             11. Exceptions  

Ce chapitre définit les fonctionnalités permettant de traiter les erreurs ou autres
situations exceptionnelles qui surviennent lors de l'exécution du programme. Tel que
la situation est appelée une exception. Lever une exception, c'est abandonner
exécution normale du programme afin d'attirer l'attention sur le fait que le
une situation correspondante s’est produite. Exécuter certaines actions, en réponse à
la survenance d’une exception s’appelle la gestion de l’exception.

Une déclaration d'exception déclare un nom pour une exception. Une exception
peut être déclenché par une instruction raise, ou il peut être déclenché par un autre
instruction ou opération qui propage l’exception. Lorsqu'une exception
se produit, le contrôle peut être transféré à un gestionnaire d'exceptions fourni par l'utilisateur à
à la fin d'une instruction de bloc ou à la fin du corps d'un sous-programme,
package ou unité de tâches.

Références : instruction de bloc 5.6, situation d'erreur 1.6, gestionnaire d'exceptions
11.2, nom 4.1, corps du package 7.1, propagation d'une exception 11.4.1
11.4.2, instruction raise 11.3, corps de sous-programme 6.3, corps de tâche 9.1   

11.1 Déclarations d'exception 

Une déclaration d'exception déclare un nom pour une exception. Le nom d'un
l'exception ne peut être utilisée que dans les instructions raise, les gestionnaires d'exceptions et
renommer les déclarations.

   exception_declaration ::= identifier_list : exception;

Une déclaration d'exception avec plusieurs identifiants équivaut à un
séquence de déclarations d’exception uniques, comme expliqué dans la section 3.2.
Chaque déclaration d'exception déclare un nom pour un autre
exception. En particulier, si une unité générique comporte une exception
déclaration, les déclarations d'exception générées implicitement par différents
les instanciations de l'unité générique renvoient à des exceptions distinctes (mais toutes
ont le même identifiant). L'exception particulière désignée par un
le nom de l'exception est déterminé au moment de la compilation et est le même peu importe
du nombre de fois où la déclaration d'exception est élaborée. Par conséquent, si un
La déclaration d'exception se produit dans un sous-programme récursif, le nom de l'exception
désigne la même exception pour tous les appels du sous-programme récursif.

Les exceptions suivantes sont prédéfinies dans le langage : ils sont élevés
lorsque les situations décrites sont détectées.   

CONSTRAINT_ERROR Cette exception est déclenchée dans l'un des cas suivants
                 situations : lors d'une tentative de violation d'une plage
                 contrainte, une contrainte d'index ou un discriminant
                 contrainte; lors d'une tentative d'utilisation d'un composant d'enregistrement
                 cela n'existe pas pour les valeurs discriminantes actuelles ;
                 et lors d'une tentative d'utilisation d'un composant sélectionné, un
                 composant indexé, une tranche ou un attribut d'un objet
                 désigné par une valeur d'accès, si l'objet ne
                 exister car la valeur d'accès est nulle.                                               

  NUMERIC_ERROR Cette exception est déclenchée par l'exécution d'un
                 opération numérique qui ne peut pas fournir un résultat correct
                 (dans la limite de la précision déclarée pour les types réels) ; ce
                 inclut le cas où une implémentation utilise un
                 opération numérique prédéfinie pour l'exécution,  
                 évaluation ou élaboration d’un concept. Les règles
                 données à la section 4.5.7 définissent les cas dans lesquels un
                 la mise en œuvre n’est pas nécessaire pour lever cette exception
                 lorsqu'une telle situation d'erreur survient ; voir aussi la rubrique
                 11.6.

  PROGRAM_ERROR Cette exception est déclenchée lors d'une tentative d'appel d'un
                 sous-programme, pour activer une tâche, ou pour élaborer un générique
                 instanciation, si le corps de l'unité correspondante a
                 pas encore été élaboré. Cette exception est également soulevée
                 si la fin d'une fonction est atteinte (voir 6.5) ; ou pendant
                 l'exécution d'une attente sélective qui n'a aucune autre part,
                 si cette exécution détermine que toutes les alternatives sont
                 fermé (voir 9.7.1). Enfin, selon le
                 mise en œuvre, cette exception peut être levée sur demande
                 tenter d'exécuter une action erronée, et pour
                 dépendances d'ordre incorrectes (voir 1.6).

  STORAGE_ERROR Cette exception est déclenchée dans l'un des cas suivants
                 situations : lorsque le stockage dynamique alloué à une tâche
                 est dépassé; lors de l'évaluation d'un allocateur, si
                 l'espace disponible pour la collecte des objets attribués
                 les objets sont épuisés ; ou lors de l'élaboration d'un
                 élément déclaratif, ou lors de l'exécution d'un sous-programme
                 appelez si le stockage n'est pas suffisant.

  TASKING_ERROR Cette exception est déclenchée lorsque des exceptions surviennent au cours
                 communication intertâches (voir 9 et 11.5).

Note:

Les situations décrites ci-dessus peuvent survenir sans que les 
exceptions, si le pragma SUPPRESS a été utilisé pour autoriser l'omission
les contrôles correspondants (voir 11.7).

Exemples de déclarations d'exception définies par l'utilisateur :

   SINGULIER : exception;
   ERREUR : exception ;
   DÉBORDEMENT, SOUS-PLEIN : exception ;

Références : valeur d'accès 3.8, collection 3.8, déclaration 3.1, exception
11, gestionnaire d'exceptions 11.2, corps générique 12.2, instanciation générique 12.3,
unité générique 12, identifiant 2.3, déclaration implicite 12.3, instanciation
12.3, nom 4.1, objet 3.2, instruction raise 11.3, type réel 3.5.6, enregistrement
composant 3.7, instruction return 5.8, sous-programme 6, corps du sous-programme 6.3,
tâche 9, corps de tâche 9.1

Contextes d'exception Constraint_error : agrégat 4.3.1 4.3.2, allocateur 4.8,
instruction d'affectation 5.2 5.2.1, contrainte 3.3.2, attribut de type discret 
3.5.5, contrainte discriminante 3.7.2, élaboration d'un formel générique
paramètre 12.3.1 12.3.2 12.3.4 12.3.5, indice d'entrée 9.5, exponentiation
opérateur 4.5.6, contrainte d'index 3.6.1, composant indexé 4.1.1, logique
opérateur 4.5.1, valeur d'accès nulle 3.8, déclaration d'objet 3.2.1, paramètre
association 6.4.1, expression qualifiée 4.7, contrainte de plage 3.5, sélectionnée
composant 4.1.3, tranche 4.1.2, indication de sous-type 3.3.2, conversion de type 4.6

Contextes d'exception Numeric_error : attribut de type discret 3.5.5, implicite
conversion 3.5.4 3.5.6 4.6, opération numérique 3.5.5 3.5.8 3.5.10, opérateur
de type numérique 4.5 4.5.7

Contextes d'exception Program_error : collection 3.8, élaboration 3.9,
contrôle d'élaboration 3,9 7,3 9,3 12,2, erroné 1,6, ordre incorrect
dépendance 1.6, sortie d'une fonction 6.5, attente sélective 9.7.1                                           

Contextes d'exception Storage_error : allocateur 4.8

Contextes d'exception d'erreur de tâche : instruction d'abandon 9.10, appel d'entrée 9.5
9.7.2 9.7.3, exceptions lors de la communication de tâche 11.5, activation de tâche 9.3   

11.2 Gestionnaires d'exceptions 

La réponse à une ou plusieurs exceptions est spécifiée par une exception
gestionnaire.

   exception_handler ::=
      quand exception_choice {| exception_choice} =>
         séquence_of_statements
   exception_choice ::= exception_name | autres

Un gestionnaire d'exceptions se produit dans une construction qui est soit une instruction de bloc
ou le corps d'un sous-programme, d'un package, d'une unité de tâche ou d'une unité générique. Tel que
La construction sera appelée un cadre dans ce chapitre. Dans chaque cas, la syntaxe
d'un cadre doté de gestionnaires d'exceptions comprend la partie suivante :

   commencer
       séquence_of_statements
   exception
       exception_handler
      {exception_handler}
   fin

Les exceptions indiquées par les noms d'exception donnés comme choix d'exception de
un cadre doit tous être distincts. Le choix d'exception autres n'est autorisé que
pour le dernier gestionnaire d'exceptions d'une trame et comme seul choix d'exception ;
il représente toutes les exceptions non répertoriées dans les gestionnaires précédents du cadre,
y compris les exceptions dont les noms ne sont pas visibles sur le lieu du
gestionnaire d'exceptions.

Les gestionnaires d'exceptions d'un cadre gèrent les exceptions déclenchées par le
exécution de la séquence d'instructions de la trame. Les exceptions
gérés par un gestionnaire d'exceptions donné sont ceux nommés par le correspondant
choix d’exceptions.

Exemple:

   commencer
      -- séquence d'instructions
   exception
      quand SINGULIER | NUMÉRIQUE_ERREUR =>
         PUT(" LA MATRICE EST SINGULIÈRE ");
      quand les autres =>
         PUT(" ERREUR FATALE ");
         augmenter l'ERREUR ;
   fin;   

Note:

Les mêmes types d'instructions sont autorisés dans la séquence d'instructions de
chaque gestionnaire d'exceptions tel qu'autorisé dans la séquence d'instructions du
cadre. Par exemple, une instruction return est autorisée dans un gestionnaire au sein d'un
corps fonctionnel.                                                                            

Références : instruction de bloc 5.6, partie déclarative 3.9, exception 11,
gestion des exceptions 11.4, corps de fonction 6.3, corps générique 12.2, unité générique
12.1, nom 4.1, corps du package 7.1, instruction raise 11.3, instruction return
5.8, séquence d'instructions 5.1, instruction 5, corps du sous-programme 6.3, tâche
corps 9.1, unité opérationnelle 9 9.1, visibilité 8.3   

11.3 Déclarations de relance 

Une instruction raise déclenche une exception.

   raise_statement ::= raise [exception_name];

Pour l'exécution d'une instruction raise avec un nom d'exception, le nom
une exception est levée. Une instruction raise sans nom d'exception est uniquement
autorisé dans un gestionnaire d'exceptions (mais pas dans la séquence de
instructions d'un sous-programme, d'un package, d'une unité de tâche ou d'une unité générique, jointes
par le gestionnaire); il soulève à nouveau l'exception qui a provoqué le transfert vers le
gestionnaire englobant le plus intérieur.

Exemples:

   lever SINGULIER ;
   augmenter NUMERIC_ERROR ; -- soulevant explicitement une exception prédéfinie

   augmenter; -- uniquement dans un gestionnaire d'exceptions

Références : exception 11, unité générique 12, nom 4.1, package 7, séquence
des instructions 5.1, sous-programme 6, unité de tâche 9   

11.4 Gestion des exceptions 

Lorsqu'une exception est levée, l'exécution normale du programme est abandonnée et 
le contrôle est transféré à un gestionnaire d’exceptions. La sélection de ceci
Le gestionnaire dépend du fait que l'exception soit levée ou non lors de l'exécution de
déclarations ou lors de l’élaboration des déclarations.

Références : déclaration 3.1, élaboration 3.1 3.9, exception 11, exception
gestionnaire 11.2, levée d'exceptions 11.3, instruction 5   

11.4.1 Exceptions soulevées lors de l'exécution des déclarations    

La gestion d'une exception déclenchée par l'exécution d'une séquence de
les déclarations dépendent du cadre le plus interne ou de l'instruction d'acceptation qui
contient la séquence d'instructions et constitue un cadre ou une instruction d'acceptation. Le
Le cas où une instruction accept est la plus interne est décrit dans la section 11.5.
Le cas où un cadre est le plus intérieur est présenté ici.                                                   

Différentes actions ont lieu, selon que ce cadre possède ou non un
gestionnaire de l'exception et si l'exception est déclenchée dans le
séquence d’instructions de la frame ou dans celle d’un gestionnaire d’exceptions.

Si une exception est levée dans la séquence d'instructions d'une trame qui a
un gestionnaire d'exception, exécution de la séquence d'instructions du
la trame est abandonnée et le contrôle est transféré au gestionnaire d’exceptions.
L'exécution de la séquence d'instructions du gestionnaire complète le
l'exécution de la trame (ou son élaboration si la trame est un corps de package).

Si une exception est déclenchée dans la séquence d'instructions d'une trame qui
n'a pas de gestionnaire pour l'exception, l'exécution de cette séquence de
les déclarations sont abandonnées. L'action suivante dépend de la nature du
cadre:

(a) Pour un corps de sous-programme, la même exception est à nouveau levée au point
    d'appel du sous-programme, sauf si le sous-programme est le programme principal
    lui-même, auquel cas l'exécution du programme principal est abandonnée.

(b) Pour une instruction de bloc, la même exception est à nouveau levée immédiatement
    après l'instruction block (c'est-à-dire dans l'enceinte la plus interne
    cadre ou accepter la déclaration).

(c) Pour un corps de package qui est un élément déclaratif, la même exception est
    à nouveau immédiatement après ce point déclaratif (dans le délai
    joignant la partie déclarative). Si le corps du package est celui d'une sous-unité,
    l'exception est à nouveau levée à la place de l'organisme correspondant
    bout. Si le package est une unité de bibliothèque, exécution du programme principal
    est abandonné.

(d) Pour un corps de tâche, la tâche est terminée.

Une exception qui est à nouveau levée (comme dans les cas ci-dessus (a), (b) et (c))
est dit se propager, soit par l'exécution du sous-programme, soit par le
l'exécution de l'instruction de bloc ou l'élaboration du corps du package.
Aucune propagation n'a lieu dans le cas d'un corps de tâche. Si le cadre est un
sous-programme ou une instruction de bloc et s'il a des tâches dépendantes, le
la propagation d'une exception n'a lieu qu'après la fin du
tâches dépendantes.

Enfin, si une exception est levée dans la séquence d'instructions d'un
gestionnaire d'exceptions, l'exécution de cette séquence d'instructions est abandonnée.
Les actions ultérieures (y compris la propagation, le cas échéant) sont comme dans les cas (a)
à (d) ci-dessus, selon la nature du cadre.

Exemple:

   fonction FACTORIAL (N : POSITIF) retour FLOAT est
   commencer
      si N = 1 alors
         renvoyer 1,0 ;
      autre
         retourner FLOAT(N) * FACTORIAL(N-1);
      fin si;
   exception  
      quand NUMERIC_ERROR => renvoie FLOAT'SAFE_LARGE ;
   fin FACTORIEL ;

Si la multiplication génère NUMERIC_ERROR, alors FLOAT'SAFE_LARGE est
restitué par le gestionnaire. Cette valeur entraînera d'autres NUMERIC_ERROR
exceptions à lever par l’évaluation de l’expression dans chacun des
appels restants de la fonction, de sorte que pour de grandes valeurs de N, le
La fonction renverra finalement la valeur FLOAT'SAFE_LARGE.                                                

Exemple:

   la procédure P est
      ERREUR : exception ;
      procédure R ;

      la procédure Q est
      commencer
         R ;
         ... -- situation d'erreur (2)
      exception
         ...
         quand ERREUR => -- gestionnaire E2
         ...
      fin Q;

      la procédure R est
      commencer
         ... -- situation d'erreur (3)
      fin R;

   commencer
      ... -- situation d'erreur (1)
      Q ;
      ...
   exception
      ...
      quand ERREUR => -- gestionnaire E1
      ...
   fin P;

Les situations suivantes peuvent se présenter :

(1) Si l'exception ERROR est déclenchée dans la séquence d'instructions du
    procédure externe P, le gestionnaire E1 fourni dans P est utilisé pour
    achever l'exécution de P.

(2) Si l'exception ERROR est déclenchée dans la séquence d'instructions de Q,
    le gestionnaire E2 fourni dans Q est utilisé pour terminer l’exécution de
    Q. Le contrôle sera renvoyé au point d'appel de Q une fois l'opération terminée.
    du gestionnaire.

(3) Si l'exception ERROR est levée dans le corps de R, appelée par Q, le 
    l'exécution de R est abandonnée et la même exception est levée dans le
    corps de Q. Le gestionnaire E2 est ensuite utilisé pour terminer l’exécution de
    Q, comme dans la situation (2).

Notez que dans la troisième situation, l'exception levée dans R entraîne
(indirectement) transférer le contrôle à un gestionnaire qui fait partie de Q et donc
non entouré par R. Notez également que si un gestionnaire était fourni dans R pour
l'exception choix autres, la situation (3) provoquerait l'exécution de ce
gestionnaire, plutôt que la terminaison directe de R.   

Enfin, si ERROR avait été déclarée dans R, plutôt que dans P, les handlers E1
et E2 n'a pas pu fournir de gestionnaire explicite pour ERROR puisque cela
l'identifiant ne serait pas visible dans les corps de P et Q. Dans la situation
(3), l'exception pourrait cependant être gérée dans Q en fournissant un gestionnaire pour
l'exception choisit les autres.                                                   

Remarques:

Le langage ne définit pas ce qui se passe lors de l'exécution de l'opération principale.
le programme est abandonné après une exception non gérée.

Les exceptions prédéfinies sont celles qui peuvent être propagées par le
opérations et les opérateurs prédéfinis.

Le cas d'une trame qui est une unité générique est déjà couvert par les règles
pour les corps de sous-programmes et de packages, puisque la séquence d'instructions de ces
une frame n'est pas exécutée mais est le modèle des séquences correspondantes
d'instructions des sous-programmes ou packages obtenus par générique
instanciation.

Références : instruction accept 9.5, opération de base 3.3.3, instruction block
5.6, bout de corps 10.2, complétion 9.4, élément déclaratif 3.9, partie déclarative
3.9, tâche dépendante 9.4, élaboration 3.1 3.9, exception 11, exception
gestionnaire 11.2, frame 11.2, instanciation générique 12.3, unité générique 12,
unité de bibliothèque 10.1, programme principal 10.1, exception numeric_error 11.1, package
7, corps du colis 7.1, opérateur prédéfini 4.5, procédure 6.1, séquence de
instructions 5.1, instruction 5, sous-programme 6, corps du sous-programme 6.3, sous-programme
appel 6.4, sous-unité 10.2, tâche 9, corps de tâche 9.1   

11.4.2 Exceptions soulevées lors de l'élaboration des déclarations 

Si une exception est soulevée lors de l'élaboration de la partie déclarative du
dans un cadre donné, cette élaboration est abandonnée. La prochaine action dépend de
la nature du cadre :

(a) Pour un corps de sous-programme, la même exception est à nouveau levée au point
    d'appel du sous-programme, sauf si le sous-programme est le programme principal
    lui-même, auquel cas l'exécution du programme principal est abandonnée.

(b) Pour une instruction de bloc, la même exception est à nouveau levée immédiatement
    après l'instruction block.

(c) Pour un corps de package qui est un élément déclaratif, la même exception est
    à nouveau soulevé immédiatement après ce point déclaratif, dans le texte ci-joint
    partie déclarative. Si le corps du package est celui d'une sous-unité, le
    l'exception est à nouveau levée à la place du stub de corps correspondant.
    Si le package est une unité de bibliothèque, l'exécution du programme principal est
    abandonné.

(d) Pour un corps de tâche, la tâche devient terminée et l'exception
    TASKING_ERROR est déclenché au point d'activation de la tâche, comme
    expliqué à la section 9.3.

De même, si une exception est soulevée lors de l'élaboration d'un
déclaration de package ou une déclaration de tâche, cette élaboration est abandonnée ;
l'action suivante dépend de la nature de la déclaration.  

(e) Pour une déclaration de package ou une déclaration de tâche, c'est une déclaration déclarative
    élément, l'exception est à nouveau levée immédiatement après le déclaratif
    élément dans la partie déclarative ou la spécification de package ci-jointe. Pour
    la déclaration d'un package de bibliothèque, l'exécution du programme principal
    le programme est abandonné.

Une exception qui est à nouveau levée (comme dans les cas (a), (b), (c) et
(e)) est dit se propager, soit par l'exécution du sous-programme, soit
instruction de bloc, ou par l'élaboration de la déclaration du package, de la tâche
déclaration ou corps de package.                                                          

Exemple d'exception dans la partie déclarative d'une instruction de bloc (cas (b)) :

   la procédure P est
      ...
   commencer
      déclarer
         N : ENTIER := F; -- la fonction F peut générer une ERREUR
      commencer
         ...
      exception
         quand ERREUR => -- gestionnaire E1
      fin;
      ...
   exception
      quand ERREUR => -- gestionnaire E2
   fin P;

   -- si l'exception ERROR est levée dans la déclaration de N, elle est gérée par E2

Références : activation 9.3, instruction de bloc 5.6, stub de corps 10.2, terminé
tâche 9.4, point déclaratif 3.9, partie déclarative 3.9, élaboration 3.1 3.9,
exception 11, cadre 11.2, unité de bibliothèque 10.1, programme principal 10.1, package
corps 7.1, déclaration de package 7.1, spécification de package 7.1, sous-programme 6,
corps du sous-programme 6.3, appel du sous-programme 6.4, sous-unité 10.2, tâche 9, corps de la tâche
9.1, déclaration de tâche 9.1, exception tasking_error 11.1   

11.5 Exceptions soulevées lors de la communication de tâches   

Une exception peut être propagée à une tâche communiquant ou tentant de
communiquer, avec une autre tâche. Une exception peut également être propagée à un
tâche appelante si l'exception est levée lors d'un rendez-vous.

Lorsqu'une tâche appelle une entrée d'une autre tâche, l'exception TASKING_ERROR est
levée dans la tâche appelante, à l'endroit de l'appel, si la tâche appelée est
terminé avant d'accepter l'appel d'entrée ou est déjà terminé au moment
heure de l’appel.

Un rendez-vous peut se dérouler anormalement dans deux cas :

(a) Lorsqu'une exception est levée dans une déclaration d'acceptation, mais pas
    manipulés dans un cadre intérieur. Dans ce cas, l'exécution du
    L'instruction accept est abandonnée et la même exception est à nouveau levée
    immédiatement après l'instruction accept dans la tâche appelée ; le
    L'exception est également propagée à la tâche appelante au point de
    appel d'entrée.

(b) Lorsque la tâche contenant l'instruction d'acceptation est terminée anormalement
    à la suite d'une instruction d'abandon. Dans ce cas, l'exception
    TASKING_ERROR est déclenché dans la tâche appelante au point d'entrée 
    appel.

En revanche, si une tâche émettant un appel d'entrée devient anormale (comme le
résultat d'une instruction d'abandon), aucune exception n'est levée dans la tâche appelée.
Si le rendez-vous n'a pas encore commencé, l'appel d'entrée est annulé. Si la
le rendez-vous est en cours, il se termine normalement et la tâche appelée est
non affecté.                                                              

Références : tâche anormale 9.10, instruction d'abandon 9.10, instruction d'acceptation
9.5, tâche terminée 9.4, appel d'entrée 9.5, exception 11, image 11.2,
rendez-vous 9.5, tâche 9, fin de tâche 9.4, exception tasking_error 11.1   

11.6 Exceptions et optimisation 

Cette section a pour objet de préciser les conditions dans lesquelles un
la mise en œuvre est autorisée à effectuer certaines actions plus tôt ou
plus tard que spécifié par d'autres règles de la langue.

En général, lorsque les règles linguistiques précisent un ordre pour certaines actions
(l'ordre canonique), une implémentation ne peut utiliser qu'un ordre alternatif
s'il peut garantir que l'effet du programme n'est pas modifié par le
réorganisation. En particulier, aucune exception ne devrait être prévue pour l'exécution de
le programme réorganisé si aucun ne se produit pour l'exécution du programme dans
l'ordre canonique. Quand, en revanche, l'ordre de certaines actions
n'est pas défini par la langue, n'importe quel ordre peut être utilisé par le
mise en œuvre. (Par exemple, les arguments d'un opérateur prédéfini peuvent
être évalué dans n'importe quel ordre puisque les règles données à la section 4.5 ne
nécessitent un ordre d’évaluation spécifique.)

Une liberté supplémentaire est laissée à une implémentation pour réorganiser les actions
impliquant des opérations prédéfinies qui sont soit des opérateurs prédéfinis, soit
opérations de base autres que les affectations. Cette liberté est laissée, telle que définie
ci-dessous, même dans le cas où l'exécution de ces opérations prédéfinies
peut propager une exception (prédéfinie):

a) Aux fins de déterminer si le même effet est obtenu en
    l'exécution de certaines actions dans le canonique et dans un
    ordre alternatif, on peut supposer qu'aucun des éléments prédéfinis
    les opérations invoquées par ces actions propagent un message (prédéfini)
    exception, à condition que les deux conditions suivantes soient remplies par le
    ordre alternatif : premièrement, une opération ne doit pas être invoquée dans le  
    ordre alternatif s'il n'est pas invoqué dans l'ordre canonique ;
    Deuxièmement, pour chaque opération, le cadre englobant le plus intérieur ou accepter
    la déclaration doit être la même dans l'ordre alternatif que dans le
    ordre canonique, et les mêmes gestionnaires d’exceptions doivent s’appliquer.

(b) Dans une expression, l'association des opérateurs avec des opérandes est
    spécifié par la syntaxe. Cependant, pour une séquence de
    opérateurs de même niveau de priorité (et en l’absence de
    parenthèses imposant une association spécifique), toute association de
    les opérateurs avec des opérandes sont autorisés s'ils satisfont aux conditions suivantes
    condition : un résultat entier doit être égal à celui donné par le
    ordre canonique de gauche à droite ; un résultat réel doit appartenir au
    intervalle de modèle de résultat défini pour l'ordre canonique de gauche à droite
    (voir 4.5.7). Une telle réorganisation est autorisée même si elle peut supprimer un
    exception, ou introduire une autre exception prédéfinie.

De même, une liberté supplémentaire est laissée à une mise en œuvre pour le
évaluation d'expressions numériques simples. Pour l'évaluation d'un 
opération prédéfinie, une implémentation est autorisée à utiliser l'opération de
un type qui a une plage plus large que celle du type de base des opérandes,
à condition que cela donne le résultat exact (ou un résultat dans les délais
précision déclarée, dans le cas d'un type réel), même si certains intermédiaires
les résultats se situent en dehors de la plage du type de base. L'éxéption
NUMERIC_ERROR n'a pas besoin d'être déclenché dans un tel cas. En particulier, si le
l'expression numérique est un opérande d'un opérateur relationnel prédéfini, le
L'exception NUMERIC_ERROR n'a pas besoin d'être déclenchée par l'évaluation du
relation, à condition que le résultat BOOLÉEN correct soit obtenu.  

Une opération prédéfinie n'a pas besoin d'être invoquée du tout, si c'est la seule chose possible
L'effet est de propager une exception prédéfinie. De même, un prédéfini
Il n’est pas nécessaire d’invoquer l’opération si la suppression des opérations ultérieures par
la règle ci-dessus rend cette invocation inefficace.

Remarques:

La règle (b) s'applique aux opérateurs prédéfinis mais pas au court-circuit
formulaires de contrôle.

L'expression SPEED < 300_000.0 peut être remplacée par TRUE si la valeur
300_000.0 se situe en dehors du type de base de SPEED, même si le
la conversion du littéral numérique déclencherait l'exception NUMERIC_ERROR.

Exemple:

   déclarer
      N : ENTIER ;
   commencer
      N := 0 ; -- (1)
      pour J en 1 .. 10 boucle
         N := N + J**A(K); -- A et K sont des variables globales
      terminer la boucle ;
      METTRE(N);
   exception
      quand d'autres => PUT("Une erreur est survenue"); METTRE(N);
   fin;

L'évaluation de A(K) peut être effectuée avant la boucle, et éventuellement
immédiatement avant l'énoncé de mission (1), même si cette évaluation peut
lever une exception. Par conséquent, dans le gestionnaire d'exceptions, la valeur
de N est soit la valeur initiale non définie, soit une valeur attribuée ultérieurement. Sur
par contre, l’évaluation de A(K) ne peut pas être déplacée avant de commencer puisque
une exception serait alors gérée par un autre gestionnaire. Pour ça
raison, l’initialisation de N dans la déclaration elle-même exclurait le
possibilité d'avoir une valeur initiale non définie de N dans le gestionnaire.

Références : acceptez la déclaration 9.5, précision des opérations réelles 4.5.7,
affectation 5.2, type de base 3.3, opération de base 3.3.3, conversion 4.6, erreur 
situation 11, exception 11, gestionnaire d'exceptions 11.2, image 11.2,
exception numeric_error 11.1, opérateur prédéfini 4.5, prédéfini
sous-programme 8.6, propagation d'une exception 11.4, type réel 3.5.6,
valeur non définie 3.2.1   

11.7 Suppression de chèques 

La présence d'un pragma SUPPRESS autorise une implémentation à
omettre certaines vérifications d'exécution. La forme de ce pragma est la suivante :

   pragma SUPPRESS(identifiant [, [ON =>] nom]);  

L'identifiant est celui du chèque qui peut être omis. Le nom (si
présent) doit être soit un nom simple, soit un nom développé et il doit
désigne soit un objet, un type ou un sous-type, une unité de tâche ou une unité générique ;
alternativement, le nom peut être un nom de sous-programme, auquel cas il peut être
pour plusieurs sous-programmes visiblement surchargés.                                                   

Un pragma SUPPRESS n'est autorisé qu'immédiatement dans une partie déclarative ou
immédiatement dans une spécification de package. Dans ce dernier cas, le seul
la forme autorisée est avec un nom qui désigne une entité (ou plusieurs
sous-programmes) déclarés immédiatement dans la spécification du package. Le
la permission d'omettre le contrôle donné s'étend du lieu du pragma à
la fin de la région déclarative associée à l'enceinte la plus interne
instruction de bloc ou unité de programme. Pour un pragma donné dans un paquet
spécification, l'autorisation s'étend jusqu'à la fin de la portée du nom
entité.

Si le pragma inclut un nom, l'autorisation d'omettre la vérification donnée est 
encore plus restreint : il n'est donné que pour les opérations sur l'objet nommé ou
sur tous les objets du type de base d'un type ou sous-type nommé ; pour les appels d'un
sous-programme nommé ; pour les activations de tâches du type de tâche nommé ; ou pour
instanciations de l’unité générique donnée.

Les contrôles suivants correspondent aux situations dans lesquelles l'exception
CONSTRAINT_ERROR peut être déclenché ; pour ces contrôles, le nom (si présent)
doit désigner soit un objet, soit un type.

ACCESS_CHECK Lors de l'accès à un composant sélectionné, un fichier indexé
                     composant, tranche ou attribut d'un objet
                     désigné par une valeur d'accès, vérifiez que l'accès
                     la valeur n'est pas nulle.

DISCRIMINANT_CHECK Vérifier qu'un discriminant d'une valeur composée a
                     la valeur imposée par une contrainte discriminante.
                     De plus, lorsque vous accédez à un composant d'enregistrement, vérifiez que
                     il existe pour les valeurs discriminantes courantes.

INDEX_CHECK Vérifiez que les limites d'une valeur de tableau sont égales à
                     les limites correspondantes d’une contrainte d’index.
                     De plus, lors de l'accès à un composant d'un objet tableau,
                     vérifier pour chaque dimension que la valeur d'index donnée
                     appartient à la plage définie par les limites du
                     objet tableau. De plus, lors de l'accès à une tranche d'un
                     objet tableau, vérifiez que la plage discrète donnée est
                     compatible avec la plage définie par les limites de
                     l'objet tableau.

LENGTH_CHECK Vérifiez qu'il existe un composant correspondant pour chaque
                     composant d'un tableau, dans le cas d'un tableau
                     affectations, conversions de types et opérateurs logiques  
                     pour les tableaux de composants booléens.

RANGE_CHECK Vérifiez qu'une valeur satisfait une contrainte de plage.
                     Aussi, pour l’élaboration d’une indication de sous-type,
                     vérifier que la contrainte (si présente) est compatible
                     avec la marque de type. Aussi, pour un agrégat, vérifiez
                     qu'un indice ou une valeur discriminante appartient au
                     sous-type correspondant. Enfin, vérifiez s'il y a
                     contrôles de contraintes effectués par un générique
                     instanciation.   

Les contrôles suivants correspondent aux situations dans lesquelles l'exception
NUMERIC_ERROR est déclenché. Les seuls noms autorisés dans le champ correspondant
les pragmas sont des noms de types numériques.

DIVISION_CHECK Vérifier que le deuxième opérande n'est pas nul pour le
                     opérations /, rem et mod.

OVERFLOW_CHECK Vérifier que le résultat d'une opération numérique ne
                     débordement.

Le contrôle suivant correspond aux situations dans lesquelles l'exception
PROGRAM_ERROR est déclenché. Les seuls noms autorisés dans le champ correspondant
les pragmas sont des noms désignant des unités de tâches, des unités génériques ou des sous-programmes.

ELABORATION_CHECK Lors de l'appel d'un sous-programme, une activation de tâche
                     est accompli, ou une instanciation générique est
                     élaboré, vérifier que le corps du texte correspondant
                     L'unité a déjà été élaborée.                                      

Le contrôle suivant correspond aux situations dans lesquelles l'exception 
STORAGE_ERROR est déclenché. Les seuls noms autorisés dans le champ correspondant
les pragmas sont des noms désignant des types d'accès, des unités de tâches ou des sous-programmes.

STORAGE_CHECK Vérifier que l'exécution d'un allocateur ne nécessite pas
                     plus d'espace que ce qui est disponible pour une collection. Vérifier
                     que l'espace disponible pour une tâche ou un sous-programme dispose
                     pas été dépassé.

Si une situation d'erreur survient en l'absence du runtime correspondant
contrôles, l'exécution du programme est erronée (les résultats ne sont pas
défini par la langue).

Exemples:

   pragma SUPPRESS(RANGE_CHECK);
   pragma SUPPRESS(INDEX_CHECK, ON => TABLE);

Remarques:

Pour certaines implémentations, il peut être impossible ou trop coûteux de supprimer
certains contrôles. Le pragma SUPPRESS correspondant peut être ignoré. Ainsi,
l'apparition d'un tel pragma au sein d'une unité donnée ne garantit pas que
l'exception correspondante ne se produira pas ; les exceptions peuvent également être
propagé par les unités appelées. 

Les références:
type d'accès 3.8, valeur d'accès 3.8, activation 9.3, agrégat 4.3, allocateur
4.8, tableau 3.6, attribut 4.1.4, instruction de bloc 5.6, collection 3.8,
compatible 3.3.2, composante d'un tableau 3.6, composante d'un enregistrement 3.7,
type composite 3.3, contrainte 3.3, exception constraint_error 11.1,
partie déclarative 3.9, désigner 3.8, dimension 3.6, plage discrète 3.6,
discriminant 3.7.1, contrainte discriminante 3.7.2, élaboration 3.1 3.9,
erroné 1.6, situation d'erreur 11, nom étendu 4.1.3, corps générique 11.1,
instanciation générique 12.3, unité générique 12, identifiant 2.3, index 3.6,
contrainte d'index 3.6.1, composant indexé 4.1.1, valeur d'accès nulle 3.8,
opération numérique 3.5.5 3.5.8 3.5.10, type numérique 3.5, numeric_error
exception 11.1, objet 3.2, opération 3.3.3, corps du package 7.1, package
spécification 7.1, pragma 2.8, exception program_error 11.1, unité de programme
6, propagation d'une exception 11.4, contrainte de portée 3.5, type d'enregistrement 3.7,
nom simple 4.1, tranche 4.1.2, sous-programme 6, corps du sous-programme 6.3, sous-programme
appel 6.4, sous-type 3.3, sous-unité 10.2, tâche 9, corps de tâche 9.1, type de tâche 9.1,
unité de travail 9, type 3.3, marque de type 3.3.2
