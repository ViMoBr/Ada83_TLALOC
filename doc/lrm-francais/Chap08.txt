
                           8. Règles de visibilité  

Les règles définissant le champ d'application des déclarations et les règles définissant lesquelles
les identifiants sont visibles à différents endroits dans le texte du programme sont
décrit dans ce chapitre. La formulation de ces règles utilise la notion
d’une région déclarative.

Références : déclaration 3.1, région déclarative 8.1, identifiant 2.3, portée
8.2, visibilité 8.3  

8.1 Région déclarative 

Une région déclarative est une partie du texte du programme. Un célibataire ou Individual
La région déclarative est formée par le texte de chacun des éléments suivants :

 - Une déclaration de sous-programme, une déclaration de package, une déclaration de tâche,
    ou une déclaration générique, accompagnée de l'organisme correspondant, si
    n'importe lequel. Si le corps est un stub de corps, la région déclarative inclut également
    la sous-unité correspondante. Si l'unité de programme comporte des sous-unités, elles sont
    également compris.

 - Une déclaration d'entrée accompagnée de l'acceptation correspondante
    déclarations.

 - Une déclaration de type d'enregistrement, accompagnée d'un identifiant privé ou
    déclaration de type incomplète le cas échéant, et accompagnée d'une déclaration de type correspondante
    clause de représentation du dossier, le cas échéant.

 - Une déclaration de renommage qui inclut une partie formelle, ou un générique
    déclaration de paramètre qui inclut soit une partie formelle, soit un
    partie discriminante.

 - Une instruction de bloc ou une instruction de boucle.

Dans chacun des cas ci-dessus, la région déclarative est dite associée
avec la déclaration ou l'attestation correspondante. On dit qu'une déclaration
se produire immédiatement dans une région déclarative si cette région est la
région la plus intérieure qui renferme la déclaration, sans compter la
région déclarative (le cas échéant) associée à la déclaration elle-même.

Une déclaration qui se produit immédiatement dans une région déclarative est dite  
être local dans la région. Les déclarations dans les régions extérieures (englobantes) sont
dit être global à une région déclarative interne (fermée). Un local
l'entité est une entité déclarée par une déclaration locale ; une entité mondiale en est une
déclarée par une déclaration globale. 

Certaines des formes ci-dessus de région déclarative incluent plusieurs
parties (par exemple, d'autres éléments déclaratifs peuvent se trouver entre la déclaration
d'un colis et de son corps). Chaque région déclarative est néanmoins
considérée comme une partie (logiquement) continue du texte du programme. Ainsi
si une règle définit une partie de texte comme le texte qui s'étend d'une certaine
point spécifique d'une région déclarative à la fin de cette région, alors ce
portion est le sous-ensemble correspondant de la région déclarative (par exemple
il ne comprend pas d'éléments déclaratifs intermédiaires entre les deux parties de
un paquet).                                                                        

Remarques:

Tel que défini à la section 3.1, le terme déclaration inclut les informations de base
déclarations, déclarations implicites et déclarations qui font partie
de déclarations de base, par exemple, discriminant et paramètre
Caractéristiques. Il découle de la définition d'une région déclarative
qu'une spécification discriminante se produit immédiatement dans la région
associé à la déclaration de type d'enregistrement englobante. De même, un
la spécification des paramètres se produit immédiatement dans la région associée
avec le corps du sous-programme englobant ou l'instruction accept.

Le package STANDARD forme une région déclarative qui englobe toutes les bibliothèques 
unités : la déclaration implicite de chaque unité de bibliothèque est supposée se produire
immédiatement dans ce package (voir sections 8.6 et 10.1.1).

Les régions déclaratives peuvent être imbriquées dans d’autres régions déclaratives. Pour
exemple, sous-programmes, packages, unités de tâches, unités génériques et blocs
les instructions peuvent être imbriquées les unes dans les autres et peuvent contenir un type d'enregistrement
déclarations, instructions de boucle et instructions d'acceptation.

Références : instruction accept 9.5, déclaration de base 3.1, instruction block
5.6, talon de corps 10.2, déclaration 3.1, partie discriminante 3.7.1, discriminant
spécification 3.7.1, déclaration d'entrée 9.5, partie formelle 6.1, corps générique
12.2, déclaration générique 12.1, déclaration de paramètres génériques 12.1,
déclaration implicite 3.1, déclaration de type incomplète 3.8.1, unité de bibliothèque
10.1, instruction de boucle 5.5, package 7, corps du package 7.1, déclaration de package
7.1, spécification de paramètre 6.1, déclaration de type privé 7.4, enregistrement
clause de représentation 13.4, type d'enregistrement 3.7, déclaration de changement de nom 8.5,
package standard 8.6, corps du sous-programme 6.3, déclaration du sous-programme 6.1,
sous-unité 10.2, corps de tâche 9.1, déclaration de tâche 9.1, unité de tâche 9   

8.2 Portée des déclarations 

Pour chaque forme de déclaration, les règles linguistiques définissent une certaine part
du texte du programme appelé portée de la déclaration. La portée d'un
La déclaration est également appelée le périmètre de toute entité déclarée par le
déclaration. De plus, si la déclaration associe une notation à
une entité déclarée, cette partie du texte est également appelée le champ d'application de
cette notation (soit un identifiant, un caractère littéral, un opérateur
symbole, ou la notation pour une opération de base). Dans le cadre d'un
entité, et seulement là, il y a des endroits où il est légal d'utiliser le
notation associée afin de faire référence à l'entité déclarée. Ces places
sont définis par les règles de visibilité et de surcharge.

La portée d'une déclaration qui apparaît immédiatement dans un déclaratif
La région s'étend du début de la déclaration à la fin de la
région déclarative ; cette partie de la portée d'une déclaration est appelée la
portée immédiate. Par ailleurs, pour chacune des déclarations listées ci-dessous,
la portée de la déclaration s’étend au-delà de la portée immédiate :  

(a) Une déclaration qui apparaît immédiatement dans la partie visible d'un
    déclaration de paquet.

(b) Une déclaration d'entrée.

(c) Une déclaration de composant.

(d) Une spécification discriminante.

(e) Une spécification de paramètre.

(f) Une déclaration de paramètre générique.                                            

Dans chacun de ces cas, la déclaration donnée intervient immédiatement dans
une déclaration englobante, et la portée de la déclaration donnée s'étend
jusqu'à la fin du champ d'application de la déclaration ci-jointe.

En l'absence de déclaration de sous-programme, la spécification du sous-programme
donné dans le corps du sous-programme ou dans le stub du corps fait office de déclaration
et la règle (e) s’applique également dans un tel cas.

Note:

Les règles de champ d'application ci-dessus s'appliquent à toutes les formes de déclaration définies par la section
3.1 ; en particulier, elles s'appliquent également aux déclarations implicites. Règle (a)
s'applique à une déclaration de package et donc pas à la spécification du package
d'une déclaration générique. Pour les déclarations imbriquées, les règles (a) à
(f) postuler à chaque niveau. Par exemple, si une unité de tâche est déclarée dans le
partie visible d'un package, la portée d'une entrée de l'unité de tâche s'étend
jusqu'à la fin du périmètre de l'unité de tâche, c'est-à-dire jusqu'à la fin du périmètre  
du colis qui l'entoure. La portée d'une clause d'utilisation est définie dans la section
8.4. 

Références : opération de base 3.3.3, stub de corps 10.2, caractère littéral 2.5,
déclaration de composant 3.7, déclaration 3.1, région déclarative 8.1,
spécification discriminante 3.7.1, déclaration d'entrée 9.5, étend 8.1,
déclaration générique 12.1, déclaration de paramètre générique 12.1, identifiant
2.3, déclaration implicite 3.1, apparaît immédiatement dans 8.1, opérateur
symbole 6.1, surcharge 6.6 8.7, déclaration du package 7.1, package
spécification 7.1, spécification de paramètre 6.1, type d'enregistrement 3.7, changement de nom
déclaration 8.5, corps du sous-programme 6.3, déclaration du sous-programme 6.1, tâche
déclaration 9.1, unité de tâche 9, déclaration de type 3.3.1, utiliser la clause 8.4,
visibilité 8.3, partie visible 7.2   

8.3 Visibilité 

La signification de l'occurrence d'un identifiant à un endroit donné du texte
est défini par les règles de visibilité et également, en cas de surcharge
déclarations, par les règles de surcharge. Les identifiants pris en compte dans ce
chapitre comporter tout identifiant autre qu'un mot réservé, un attribut
désignateur, un identifiant pragma, l'identifiant d'un argument pragma, ou un
identifiant donné en argument pragma. Les lieux considérés dans ce document
chapitre sont ceux où apparaît un élément lexical (tel qu’un identifiant).
Les déclarations surchargées considérées dans ce chapitre sont celles pour
sous-programmes, littéraux d’énumération et entrées uniques.

Pour chaque identifiant et à chaque endroit du texte, les règles de visibilité
déterminer un ensemble de déclarations (avec cet identifiant) qui définissent les possibles
significations d’une occurrence de l’identifiant. On dit qu'une déclaration est
visible à un endroit donné du texte lorsque, selon la visibilité
règles, la déclaration définit une signification possible de cette occurrence. Deux
des cas se présentent.  

 - Les règles de visibilité déterminent au plus un sens possible. Dans un tel
    Dans ce cas, les règles de visibilité sont suffisantes pour déterminer
    déclaration définissant la signification de l'occurrence de l'identifiant,
    ou en l'absence d'une telle déclaration, de déterminer que le
    l'événement n'est pas légal au moment donné.

 - Les règles de visibilité déterminent plus d'une signification possible. Dans
    dans un tel cas, l'apparition de l'identifiant est légale à ce stade si
    et seulement si exactement une déclaration visible est acceptable pour le
    règles de surcharge dans le contexte donné (voir section 6.6 pour les règles
    de surcharge et la section 8.7 pour le contexte utilisé pour la surcharge
    résolution).                                                               

Une déclaration n'est visible que dans une certaine partie de son champ d'application ; ce
la partie commence à la fin de la déclaration sauf dans un package
spécification, auquel cas elle commence au mot réservé qui est donné après
l'identifiant de la spécification du package. (Cette règle s'applique, dans
en particulier, pour les déclarations implicites.)

La visibilité est soit par sélection, soit directe. Une déclaration est visible par
sélection aux endroits définis comme suit.

(a) Pour une déclaration figurant dans la partie visible d'une déclaration de colis :
    à la place du sélecteur après le point d'un nom développé dont
    le préfixe désigne le package.

(b) Pour une déclaration d'entrée d'un type de tâche donné : au lieu du
    sélecteur après le point d'un composant sélectionné dont le préfixe est
    approprié au type de tâche.   

(c) Pour une déclaration de composant d'une déclaration de type d'enregistrement donné : à
    la place du sélecteur après le point d'un composant sélectionné dont
    le préfixe est approprié pour le type ; également à l'endroit d'un composant
    nom simple (avant le délimiteur composé =>) dans un composant nommé
    association d'un agrégat du type.

d) Pour une spécification discriminante d'une déclaration de type donnée :
    mêmes endroits que pour une déclaration de composant ; également à l'endroit d'un
    nom simple discriminant (avant le délimiteur composé =>) dans un nom
    association discriminante d'une contrainte discriminante pour le type.

(e) Pour une spécification de paramètre d'une spécification de sous-programme donnée ou
    déclaration d'entrée : à la place du paramètre formel (avant le
    délimiteur composé =>) dans une association de paramètres nommés d'un
    sous-programme ou appel d'entrée correspondant.

(f) Pour une déclaration de paramètre générique d'une unité générique donnée : à la
    place du paramètre formel générique (avant le délimiteur composé
    =>) dans une association générique nommée d'un générique correspondant
    instanciation.

Enfin, au sein de la région déclarative associée à une construction autre
qu'une déclaration de type enregistrement, toute déclaration qui se produit immédiatement
au sein de la région est visible par sélection à la place du sélecteur
après le point d'un nom développé dont le préfixe désigne la construction.

Lorsqu'elle n'est pas visible par sélection, une déclaration visible est dite
directement visible. Une déclaration est directement visible dans une certaine partie
de sa portée immédiate ; cette partie s'étend jusqu'à la fin de l'immédiat
champ d'application de la déclaration, mais exclut les endroits où la déclaration est
caché comme expliqué ci-dessous. De plus, une déclaration survenant
immédiatement dans la partie visible d'un emballage peut être réalisé directement
visible au moyen d’une clause d’usage selon les règles décrites dans
article 8.4. (Voir également la section 8.6 pour la visibilité des unités de bibliothèque.)

On dit qu'une déclaration est cachée dans (une partie de) un déclaratif interne
région si la région intérieure contient un homographe de cette déclaration ; le
la déclaration externe est alors cachée dans la portée immédiate de la déclaration interne 
homographe. Chacune de deux déclarations est dite être un homographe de l'autre
si les deux déclarations ont le même identifiant et que la surcharge est autorisée
pour au plus un des deux. Si la surcharge est autorisée pour les deux
déclarations, alors chacun des deux est un homographe de l'autre s'ils ont
le même identifiant, symbole d'opérateur ou caractère littéral, ainsi que le
même profil de paramètre et de type de résultat (voir 6.6).

Dans la spécification d'un sous-programme, chaque déclaration avec le même
désignateur car le sous-programme est masqué ; il en va de même dans un générique
instanciation qui déclare un sous-programme, et dans une déclaration d'entrée
ou la partie formelle d'une déclaration d'acceptation ; où caché de cette manière, un
La déclaration n’est visible ni par sélection ni directement.                                            

Deux déclarations qui se produisent immédiatement dans la même région déclarative
ne doivent pas être des homographes, à moins que l'une ou les deux exigences suivantes
sont remplies : (a) exactement l’une d’elles est la déclaration implicite d’un
opération prédéfinie ; (b) exactement l'un d'eux est la déclaration implicite
d'un sous-programme dérivé. Dans de tels cas, une opération prédéfinie est toujours
caché par l'autre homographe; un sous-programme dérivé cache un prédéfini
opération, mais est masqué par tout autre homographe. Où est caché là-dedans
manière, une déclaration implicite est cachée dans toute la portée du
autre déclaration (quelle que soit la déclaration qui apparaît en premier) ; le
la déclaration implicite n'est visible ni par sélection ni directement.

Chaque fois qu'une déclaration avec un certain identifiant est visible à partir d'un
point, l'identifiant et l'entité déclarée (le cas échéant) sont également dits
visible de ce point. La visibilité directe et la visibilité par sélection sont
également défini pour les caractères littéraux et les symboles d'opérateur. Un opérateur
est directement visible si et seulement si la déclaration de l'opérateur correspondante
est directement visible. Enfin, la notation associée à une base
l’opération est directement visible dans toute la portée de cette opération.

Exemple:

   la procédure P est
      A, B : BOOLÉEN ;

      la procédure Q est
         C : BOOLÉEN ;
         B : BOOLÉEN ; -- un homographe interne de B
      commencer
         ...
         B := A ; -- signifie QB := PA ;
         C := PB; -- signifie QC := PB ;
      fin;
   commencer
      ...
      UNE := B; -- signifie PA := PB ;
   fin;

Note sur la visibilité des unités de bibliothèque :

La visibilité des unités de bibliothèque est déterminée par les clauses with (voir 10.1.1)
et par le fait que les unités de bibliothèque sont implicitement déclarées dans le package
NORME (voir 8.6).

Remarque sur les homographes :

Le même identifiant peut apparaître dans différentes déclarations et peut donc être
associés à des entités différentes, même si les périmètres de celles-ci
les déclarations se chevauchent. Chevauchement des portées des déclarations avec les mêmes
l'identifiant peut résulter d'une surcharge des sous-programmes et de l'énumération
littéraux. De tels chevauchements peuvent également se produire pour les entités déclarées dans le package
parties visibles et pour les entrées, les composants d'enregistrement et les paramètres, où  
il y a un chevauchement des portées des déclarations du package englobant, de la tâche
déclarations, déclarations de type d'enregistrement, déclarations de sous-programmes, changement de nom
déclarations, ou déclarations génériques. Enfin, des portées qui se chevauchent peuvent
résultent de la nidification. 

Remarque sur la portée immédiate, le masquage et la visibilité :

Les règles définissant la portée immédiate, le masquage et la visibilité impliquent qu'un
la référence à un identifiant dans sa propre déclaration est illégale (sauf
pour les packages et packages génériques). L'identifiant cache les homographes extérieurs
dans son champ d’application immédiat, c’est-à-dire dès le début de la déclaration ;
en revanche, l'identifiant n'est visible qu'après la fin de la
déclaration. Pour cette raison, tous les éléments suivants, sauf le dernier
les déclarations sont illégales :                                                             

   K : ENTIER := K * K; -- illégal
   T : T ; -- illégal
   procédure P(X : P); -- illégal
   procédure Q(X : RÉEL := Q); -- illégal, même s'il existe un
                                          fonction nommée Q
   procédure R(R : RÉEL); -- une déclaration interne est légale (bien que
                                déroutant)

Références : accepter la déclaration 9.5, agrégat 4.3, approprié pour un type
4.1, argument 2.8, opération de base 3.3.3, caractère littéral 2.5, composant
association 4.3, déclaration de composant 3.7, délimiteur composé 2.2,
déclaration 3.1, région déclarative 8.1, désigner 3.8, discriminant
contrainte 3.7.2, spécification discriminante 3.7.1, appel d'entrée 9.5, entrée
déclaration 9.5, famille d'entrées 9.5, spécification littérale d'énumération 3.5.1, 
nom étendu 4.1.3, étend 8.1, paramètre formel 6.1, association générique
12.3, paramètre formel générique 12.1, instanciation générique 12.3, générique
package 12.1, déclaration de paramètres génériques 12.1, unité générique 12,
identifiant 2.3, portée immédiate 8.2, déclaration implicite 3.1, lexical
l'élément 2.2, l'unité de bibliothèque 10.1, l'objet 3.2, apparaissent immédiatement dans 8.1,
opérateur 4.5, symbole opérateur 6.1, surcharge 6.6 8.7, colis 7,
paramètre 6.2, association de paramètres 6.4, spécification de paramètre 6.1,
pragma 2.8, unité de programme 6, type d'enregistrement 3.7, mot réservé 2.9, portée 8.2,
composant sélectionné 4.1.3, sélecteur 4.1.3, nom simple 4.1, sous-programme 6,
appel de sous-programme 6.4, déclaration de sous-programme 6.1, spécification de sous-programme
6.1, type de tâche 9.1, unité de tâche 9, type 3.3, déclaration de type 3.3.1, utilisation
clause 8.4, partie visible 7.2   

8.4 Clauses d'utilisation 

Une clause use permet d'obtenir une visibilité directe des déclarations qui apparaissent dans le
parties visibles des packages nommés.

   use_clause ::= use package_name {, package_name} ;

Pour chaque clause d'utilisation, il existe une certaine zone de texte appelée portée de
la clause d'utilisation. Cette région commence immédiatement après la clause d'utilisation. Si un
La clause use est un élément déclaratif d'une région déclarative, la portée de
la clause s'étend jusqu'à la fin de la région déclarative. Si une clause d'usage
se produit dans une clause de contexte d'une unité de compilation, la portée de l'utilisation
La clause s'étend jusqu'à la fin de la région déclarative associée au
unité de compilation.

Afin de définir quelles déclarations sont rendues directement visibles à un moment donné
place by use clauses, considérez l'ensemble des packages nommés par toutes les clauses use
dont les portées entourent cet endroit, en omettant de cet ensemble tous les packages qui
enfermer ce lieu. Une déclaration qui peut être rendue directement visible par un
La clause use (une déclaration potentiellement visible) est toute déclaration qui
se produit immédiatement dans la partie visible d'un emballage de l'ensemble. UN
la déclaration potentiellement visible est en fait rendue directement visible sauf dans
les deux cas suivants :

 - Une déclaration potentiellement visible n'est pas rendue directement visible si le
    le lieu considéré entre dans le champ d'application immédiat d'un homographe du 
    déclaration.

 - Les déclarations potentiellement visibles qui ont le même identifiant ne le sont pas
    rendus directement visibles sauf si chacun d'eux est soit une énumération
    spécification littérale ou la déclaration d'un sous-programme (par un
    déclaration de sous-programme, une déclaration de renommage, une déclaration générique
    instanciation, ou une déclaration implicite).

L'élaboration d'une clause d'utilisation n'a pas d'autre effet.

Note:

Les règles ci-dessus garantissent qu'une déclaration rendue directement visible
par une clause use ne peut pas masquer une déclaration autrement directement visible. Le
les règles ci-dessus sont formulées en termes d'un ensemble de packages nommés par l'utilisation
clauses.                                        

Par conséquent, les lignes de texte suivantes ont toutes le même effet
(en supposant un seul paquet P).

   utilisez P ;
   utilisez P ; utilisez P, P;

Exemple de noms contradictoires dans deux packages :

   la procédure R est
      Le forfait TRAFIC est
         le type COULEUR est (ROUGE, AMBRE, VERT) ;
         ...
      mettre fin au TRAFIC ;

      le paquet WATER_COLORS est                   
         le type COULEUR est (BLANC, ROUGE, JAUNE, VERT, BLEU, MARRON, NOIR) ;
         ...
      fin WATER_COLORS ;

    utilisez TRAFIC ; -- COULEUR, ROUGE, AMBRE et VERT sont directement visibles
    utilisez WATER_COLORS ; -- deux homographes de VERT sont directement visibles
                       -- mais la COULEUR n'est plus directement visible

    le sous-type LIGHT est TRAFFIC.COLOR ; -- Les sous-types sont utilisés pour résoudre
    le sous-type SHADE est WATER_COLORS.COLOR ; -- le nom de type en conflit COULEUR

      SIGNAL : LUMIÈRE;
      PEINTURE : OMBRE;
   commencer
      SIGNAL := VERT; -- celui de TRAFIC
      PEINTURE := VERT; -- celui de WATER_COLORS
   fin R;

Exemple d'identification de nom avec une clause d'utilisation :

      le paquet D est
         T, U, V : BOOLÉEN ;
      fin D;

      la procédure P est
         le paquet E est
            B, W, V : ENTIER ;
         que E ;

         la procédure Q est
            T, X : RÉEL ;
            utilisez D, E ;
         commencer
            -- le nom T signifie QT, pas DT
            -- le nom U signifie DU
            -- le nom B signifie EB
            -- le nom W signifie EW
            -- le nom X signifie QX
            -- le nom V est illégal : il faut utiliser soit DV, soit EV
            ... 
         fin Q;
      commencer
         ...
      fin P;                                                                      

Références : unité de compilation 10.1, clause contextuelle 10.1, déclaration 3.1,
élément déclaratif 3.9, région déclarative 8.1, visibilité directe 8.3,
élaboration 3.1 3.9, l'élaboration n'a pas d'autre effet 3.1, énumération
spécification littérale 3.5.1, étend 8.1, cache 8.3, homographe 8.3,
identifiant 2.3, portée immédiate 8.2, nom 4.1, se produit immédiatement dans
8.1, package 7, portée 8.2, déclaration de sous-programme 6.1, partie visible 7.2   

8.5 Renommer les déclarations 

Une déclaration de changement de nom déclare un autre nom pour une entité.

   renaming_declaration ::=
        identifiant : type_mark renomme object_name ;
      | identifiant : exception renomme exception_name;
      | l'identifiant du package renomme package_name ;
      | subprogram_spécification renomme subprogram_or_entry_name ;

L'élaboration d'une déclaration de renommage évalue le nom qui suit
le mot réservé renomme et détermine ainsi l'entité désignée par ce
nom (l’entité renommée). À tout moment où une déclaration de renommage est
visible, l'identifiant, ou symbole opérateur de cette déclaration désigne le
entité renommée.

La première forme de déclaration de renommage est utilisée pour renommer des objets.
L'entité renommée doit être un objet du type de base de la marque de type.
Les propriétés de l'objet renommé ne sont pas affectées par le changement de nom.
déclaration. En particulier, sa valeur et s'il s'agit ou non d'une constante
ne sont pas concernés ; de même, les contraintes qui s'appliquent à un objet ne sont pas
affecté par le renommage (toute contrainte impliquée par la marque de type du
la déclaration de changement de nom est ignorée). La déclaration de changement de nom est uniquement légale
si exactement un objet a ce type et peut être désigné par le nom de l'objet.

Les restrictions suivantes s'appliquent au changement de nom d'un sous-composant qui
dépend des discriminants d’une variable. Le changement de nom n'est pas autorisé si le
sous-type de la variable, tel que défini dans une déclaration d'objet correspondante,
la déclaration de composant, ou indication de sous-type de composant, est une déclaration sans contrainte
taper; ou si la variable est un objet formel générique (de mode in out).
De même si la variable est un paramètre formel, le changement de nom n'est pas
autorisé si la marque de type donnée dans la spécification du paramètre indique un  
Type nconstrained dont les discriminants ont des expressions par défaut.

La deuxième forme de déclaration de changement de nom est utilisée pour renommer
des exceptions; la troisième forme, pour le renommage des packages.

La dernière forme de déclaration de changement de nom est utilisée pour renommer
sous-programmes et entrées. Le sous-programme ou l'entrée renommé et le
la spécification du sous-programme donnée dans la déclaration de changement de nom doit avoir le
même profil de paramètre et de type de résultat (voir 6.6). La déclaration de changement de nom
n'est légal que si exactement un sous-programme ou une entrée visible satisfait aux
ci-dessus les exigences et peut être désigné par le sous-programme ou l'entrée donné
nom. De plus, les modes de paramètres doivent être identiques pour les paramètres formels 
qui sont à la même position de paramètre.

Les sous-types des paramètres et le résultat (le cas échéant) d'un sous-programme renommé
ou l'entrée ne sont pas affectés par le changement de nom. Ces sous-types sont ceux donnés dans
la déclaration de sous-programme d'origine, l'instanciation générique ou l'entrée
déclaration (pas celles de la déclaration de renommage) ; même pour les appels
utilisez le nouveau nom. En revanche, une déclaration de renommage peut introduire
noms de paramètres et expressions par défaut qui diffèrent de ceux du
sous-programme renommé ; associations nommées d'appels avec le nouveau sous-programme
name doit utiliser le nouveau nom du paramètre ; appels avec l'ancien nom de sous-programme
doit utiliser les anciens noms de paramètres.                                                   

Une procédure ne peut être renommée qu'en procédure. Soit d'une fonction, soit
l'opérateur peut être renommé en tant que fonction ou opérateur ; pour renommer  
en tant qu'opérateur, la spécification du sous-programme donnée dans le changement de nom
la déclaration est soumise aux règles indiquées à la section 6.7 pour l'opérateur
déclarations. Les littéraux d'énumération peuvent être renommés en fonctions ;
de même, les attributs définis comme fonctions (tels que SUCC et PRED) peuvent être
renommé en fonctions. Une entrée ne peut être renommée qu'en tant que procédure ; le
le nouveau nom ne peut apparaître que dans des contextes autorisant un nom de procédure.
Une entrée d'une famille peut être renommée, mais une famille d'entrées ne peut pas être renommée
dans son ensemble.

Exemples:

   déclarer
      L : PERSON renomme LEFTMOST_PERSON ; -- voir 3.8.1
   commencer
      L.AGE := L.AGE + 1;
   fin;

   FULL : l'exception renomme TABLE_MANAGER.TABLE_FULL; -- voir 7.5

   le package TM renomme TABLE_MANAGER ;

   la fonction REAL_PLUS(LEFT, RIGHT : REAL ) renvoie REAL renomme "+" ;
   fonction INT_PLUS (GAUCHE, DROITE : INTEGER) renvoie INTEGER renomme "+" ;

   la fonction ROUGE renvoie COULEUR renomme ROUGE ; -- voir 3.5.1
   la fonction ROT renvoie COULEUR renomme ROUGE ;
   la fonction ROSSO renvoie COULEUR renomme ROUGE ;

   fonction NEXT(X : COULEUR) return COULEUR renomme COLOR'SUCC; -- voir 3.5.5

Exemple de déclaration de renommage avec de nouveaux noms de paramètres :

   la fonction "*" (X,Y : VECTOR) renvoie REAL renomme DOT_PRODUCT ; -- voir 6.1

Exemple de déclaration de renommage avec une nouvelle expression par défaut :

   function MINIMUM(L : LINK := HEAD) return CELL renomme MIN_CELL; -- voir 6.1

Remarques:

Renommer peut être utilisé pour résoudre des conflits de noms et pour servir de raccourci.
Renommer avec un identifiant ou un symbole d'opérateur différent ne masque pas le
ancien nom; le nouveau nom et l'ancien nom ne doivent pas nécessairement être visibles en même temps
points. Les attributs POS et VAL ne peuvent pas être renommés car le
les spécifications correspondantes ne peuvent pas être écrites ; il en va de même pour le
opérateurs de multiplication prédéfinis avec un résultat universal_fixed.  

Les appels avec le nouveau nom d'une entrée renommée sont des instructions d'appel de procédure
et ne sont pas autorisés aux endroits où la syntaxe nécessite un appel d'entrée
déclaration dans les appels d'entrée conditionnels et temporisés ; de même, le COMPTE
L'attribut n'est pas disponible pour le nouveau nom.   

Un objet tâche déclaré par une déclaration d'objet peut être renommé en
un objet. Cependant, une seule tâche ne peut pas être renommée puisque
le type de tâche correspondant est anonyme. Pour des raisons similaires, un objet d'un
Le type de tableau anonyme ne peut pas être renommé. Aucune forme syntaxique n'existe pour
renommer une unité générique.

Un sous-type peut être utilisé pour obtenir l'effet de renommer un type (y compris un
type de tâche) comme dans

   le sous-type MODE est TEXT_IO.FILE_MODE ;                                              

Références : autoriser 1.6, attribut 4.1.4, type de base 3.3, entrée conditionnelle
appelez 9.7.2, constante 3.2.1, sous-type contraint 3.3, contrainte 3.3,
déclaration 3.1, expression par défaut 6.1, dépendent d'un discriminant 3.7.1,
discriminant 3.7.1, élaboration 3.1 3.9, entrée 9.5, appel d'entrée 9.5, entrée
instruction d'appel 9.5, déclaration d'entrée 9.5, famille d'entrée 9.5, énumération
littéral 3.5.1, évaluation d'un nom 4.1, exception 11, paramètre formel
6.1, fonction 6.5, identifiant 2.3, légal 1.6, mode 6.1, nom 4.1, objet
3.2, déclaration d'objet 3.2, opérateur 6.7, déclaration d'opérateur 6.7,
symbole d'opérateur 6.1, paquet 7, paramètre 6.2, spécification de paramètre 6.1,
procédure 6.1, instruction d'appel de procédure 6.4, mot réservé 2.9,
sous-composant 3.3, sous-programme 6, appel de sous-programme 6.4, déclaration de sous-programme
6.1, spécification de sous-programme 6.1, sous-type 3.3.2, objet de tâche 9.2, chronométré
appel d'entrée 9.7.3, type 3.3, marque de type 3.3.2, variable 3.2.1, visibilité 8.3   

8.6 La norme de paquet 

Les types prédéfinis (par exemple les types BOOLEAN, CHARACTER et INTEGER)
sont les types déclarés dans un package prédéfini appelé STANDARD ;
ce package comprend également les déclarations de leurs opérations prédéfinies.
Le package STANDARD est décrit en Annexe C. Hormis les éléments prédéfinis
types numériques, la spécification du package STANDARD doit être la même
pour toutes les implémentations du langage.

Le package STANDARD forme une région déclarative qui englobe chaque
unité de bibliothèque et par conséquent le programme principal ; la déclaration de chaque
l'unité de bibliothèque est supposée se produire immédiatement dans ce package. Le
les déclarations implicites des unités de bibliothèque sont supposées être ordonnées dans un tel ordre.
manière dont la portée d'une unité de bibliothèque donnée inclut toute unité de compilation
qui mentionne l'unité de bibliothèque donnée dans une clause with. Cependant, le seul
les unités de bibliothèque visibles dans une unité de compilation donnée sont les suivantes :
suit : ils incluent les unités de bibliothèque nommées par tous avec des clauses qui
s'applique à l'unité donnée, et de plus, si l'unité donnée est une unité secondaire
unité d'une unité de bibliothèque, ils incluent cette unité de bibliothèque.

Remarques:

Si toutes les instructions de bloc d'un programme sont nommées, alors le nom de chacune
l'unité de programme peut toujours être écrite sous la forme d'un nom étendu commençant par
STANDARD (sauf si ce package est lui-même caché).

Si un type est déclaré dans la partie visible d'un package de bibliothèque, alors il est
une conséquence des règles de visibilité qu'une opération de base (telle que
affectation) pour ce type est directement visible aux endroits où le type
lui-même n'est pas visible (que ce soit par sélection ou directement). Cependant ceci
L’opération ne peut être appliquée qu’aux opérandes visibles et
la déclaration de ces opérandes nécessite la visibilité soit du type, soit du
un de ses sous-types. 

Références : applicable avec la clause 10.1.1, nom de bloc 5.6, instruction de bloc
5.6, déclaration 3.1, région déclarative 8.1, nom étendu 4.1.3, masquage 
8.3, identifiant 2.3, déclaration implicite 3.1, unité de bibliothèque 10.1, boucle
instruction 5.5, programme principal 10.1, doit 1.6, nom 4.1, se produire immédiatement
dans 8.1, opérateur 6.7, package 7, unité de programme 6, unité secondaire 10.1,
sous-type 3.3, type 3.3, visibilité 8.3, avec clause 10.1.1   

8.7 Le contexte de la résolution des surcharges 

La surcharge est définie pour les sous-programmes, les littéraux d'énumération, les opérateurs,
et les entrées uniques, ainsi que pour les opérations inhérentes à
plusieurs opérations de base telles que l'affectation, les tests d'adhésion, les allocateurs,
le littéral null, les agrégats et les littéraux de chaîne.                                         

Pour les entités surchargées, la résolution de surcharge détermine la signification réelle
qu'a une occurrence d'un identifiant, chaque fois que les règles de visibilité ont
déterminé que plus d'une signification est acceptable à l'endroit de ce
occurrence; la résolution de la surcharge détermine également la signification réelle de
une occurrence d'un opérateur ou d'une opération de base.

A un tel endroit, toutes les déclarations visibles sont prises en compte. L'événement est
seulement légal s’il existe exactement une interprétation de chaque constituant de
le contexte complet le plus intérieur ; un contexte complet est l'un des
suivant:

 - Une déclaration.

 - Une déclaration.

 - Une clause de représentation.

Lorsqu’on considère les interprétations possibles d’un contexte complet, la seule
les règles considérées sont les règles de syntaxe, les règles de portée et de visibilité, et
les règles du formulaire décrit ci-dessous.

(a) Toute règle qui exige qu'un nom ou une expression ait un certain type, ou
    avoir le même type qu'un autre nom ou une autre expression.

(b) Toute règle qui exige que le type d'un nom ou d'une expression soit un type
    d'une certaine classe; de même, toute règle qui nécessite un certain type
    être un nombre discret, entier, réel, universel, caractère, booléen ou
    type non limité.

(c) Toute règle qui exige qu'un préfixe soit approprié pour un certain type.

(d) Toute règle qui spécifie un certain type comme type de résultat d'un
    opération, et toute règle qui spécifie que ce type est d'un certain
    classe.

(e) Les règles qui exigent que le type d'un agrégat ou d'un littéral de chaîne soit
    être déterminable uniquement à partir du contexte complet englobant (voir 4.3
    et 4.2). De même, les règles qui exigent le type du préfixe de
    un attribut, le type de l'expression d'une instruction case ou le
    type de l'opérande d'une conversion de type, à déterminer
    indépendamment du contexte (voir 4.1.4, 5.4, 4.6 et 6.4.1).

(f) Les règles données à la section 6.6, pour la résolution des problèmes de surcharge.
    appels de sous-programmes ; dans la section 4.6, pour les conversions implicites de
    expressions universelles ; à la section 3.6.1, pour l’interprétation de
    plages discrètes avec des limites de type universel ; et dans la section
    4.1.3, pour l'interprétation d'un nom développé dont le préfixe désigne
    un sous-programme ou une instruction d'acceptation.

Les noms de sous-programmes utilisés comme arguments pragma suivent une règle différente : le
pragma peut s'appliquer à plusieurs sous-programmes surchargés, comme expliqué dans la section
6.3.2 pour le pragma INLINE, à la section 11.7 pour le pragma SUPPRESS, et
dans la section 13.9 pour le pragma INTERFACE.   

De même, les noms simples donnés dans les clauses contextuelles (voir 10.1.1) et dans
les clauses d'adresse (voir 13.5) suivent des règles différentes.                                                      

Remarques:

S'il n'y a qu'une seule interprétation possible, l'identifiant désigne le
entité correspondante. Toutefois, cela ne signifie pas que l'événement est
nécessairement légal puisqu'il existe d'autres exigences qui ne sont pas prises en compte
pour la résolution des surcharges ; par exemple, le fait qu'une expression soit
statique, les modes de paramètres, si un objet est constant, la conformité
règles, forçage des occurrences pour une clause de représentation, ordre de
élaboration, etc.

De même, les sous-types ne sont pas pris en compte pour la résolution des surcharges (le
la violation d'une contrainte ne rend pas un programme illégal mais soulève une
exception lors de l'exécution du programme).

Une spécification de paramètre de boucle est une déclaration, et donc un contexte complet.

Règles qui exigent que certaines constructions aient le même paramètre et le même résultat
le profil de type relève de la catégorie (a); il en va de même pour les règles qui
exiger la conformité de deux constructions puisque la conformité exige que
les noms correspondants doivent avoir la même signification par la visibilité et
règles de surcharge.

Références : agrégat 4.3, allocateur 4.8, affectation 5.2, opération de base
3.3.3, instruction de cas 5.4, classe de type 3.3, déclaration 3.1, entrée 9.5,
littéral d'énumération 3.5.1, exception 11, expression 4.4, partie formelle 6.1,
identifiant 2.3, légal 1.6, littéral 4.2, spécification des paramètres de boucle 5.5,
test d'appartenance 4.5.2, nom 4.1, littéral nul 3.8, opération 3.3.3,
opérateur 4.5, surcharge 6.6, pragma 2.8, clause de représentation 13.1,
instruction 5, expression statique 4.9, sous-type statique 4.9, sous-programme 6,
sous-type 3.3, conversion de type 4.6, visibilité 8.3

Règles de la forme (a) : clause d'adresse 13.5, affectation 5.2, choix 3.7.3
4.3.2 5.4, association de composants 4.3.1 4.3.2, règles de conformité 9.5,
expression par défaut 3.7 3.7.1 6.1 12.1.1, instruction de retard 9.6, discrète
plage 3.6.1 5,5 9,5, contrainte discriminante 3.7.2, énumération
clause de représentation 13.3, association de paramètres génériques 12.3.1, index
contrainte 3.6.1, expression d'index 4.1.1 4.1.2 9.5, valeur initiale 3.2.1,
test d'appartenance 4.5.2, association de paramètres 6.4.1, paramètre et résultat
profil de type 8.5 12.3.6, expression qualifiée 4.7, contrainte de portée 3.5,
renommer un objet 8.5, expression résultat 5.8

Règles de la forme (b) : instruction d'abandon 9.10, affectation 5.2, cas
expression 5.4, condition 5.3 5.5 5.7 9.7.1, plage discrète 3.6.1 5.5 9.5,
déclaration de type à virgule fixe 3.5.9, déclaration de type à virgule flottante 3.5.7,
déclaration de type entier 3.5.4, clause de longueur 13.2, test d'appartenance 4.4,
déclaration de numéro 3.2.2, clause de représentation d'enregistrement 13.4, sélectionnée
composant 4.1.3, formulaire de contrôle de court-circuit 4.4, attribut val 3.5.5

Règles de la forme (c) : composante indexée 4.1.1, composante sélectionnée 4.1.3,
tranche 4.1.2

Règles de la forme (d) : agrégat 4.3, allocateur 4.8, test d'appartenance 4.4,
littéral nul 4.2, littéral numérique 2.4, formulaire de contrôle de court-circuit 4.4,
chaîne littérale 4.2 
