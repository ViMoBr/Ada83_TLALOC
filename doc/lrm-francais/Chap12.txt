
                            12. Unités génériques  

Une unité générique est une unité de programme qui est soit un sous-programme générique, soit un
paquet générique. Une unité générique est un modèle paramétré ou
pas, et à partir desquels les sous-programmes ou packages (non génériques) correspondants peuvent
être obtenu. Les unités de programme résultantes sont considérées comme des instances du
unité générique d'origine.

Une unité générique est déclarée par une déclaration générique. Cette forme de
La déclaration comporte une partie formelle générique déclarant toute forme formelle générique.
paramètres. Une instance d'une unité générique est obtenue à la suite d'une
instanciation générique avec des paramètres réels génériques appropriés pour le
paramètres formels génériques. Une instance d'un sous-programme générique est un
sous-programme. Une instance d'un package générique est un package.

Les unités génériques sont des modèles. En tant que modèles, ils n'ont pas les propriétés
qui sont spécifiques à leurs homologues non génériques. Par exemple, un générique
le sous-programme peut être instancié mais il ne peut pas être appelé. En revanche, le
l'instance d'un sous-programme générique est un sous-programme non générique ; par conséquent, ceci
L'instance peut être appelée mais elle ne peut pas être utilisée pour produire d'autres instances.

Références : déclaration 3.1, paramètre générique réel 12.3, générique
déclaration 12.1, paramètre formel générique 12.1, partie formelle générique 12.1,
instanciation générique 12.3, package générique 12.1, sous-programme générique 12.1,
instance 12.3, package 7, unité de programme 6, sous-programme 6   

12.1 Déclarations génériques 

Une déclaration générique déclare une unité générique, qui est soit une unité générique
sous-programme ou un package générique. Une déclaration générique comprend un générique
partie formelle déclarant tous les paramètres formels génériques. Un formel générique
le paramètre peut être un objet ; alternativement (contrairement à un paramètre d'un
sous-programme), il peut s'agir d'un type ou d'un sous-programme.

   generic_declaration ::= generic_spécification;

   spécification_générique ::=
        generic_formal_part sous-programme_spécification
      | generic_formal_part package_spécification

   generic_formal_part ::= générique {generic_parameter_declaration}

   generic_parameter_declaration ::=
        liste_identifiant : [in [out]] type_mark [:= expression]; 
      | l'identifiant de type est generic_type_definition ;
      | déclaration_type_privée
      | avec subprogram_spécification [est le nom] ;
      | avec subprogram_spécification [is <>] ;

   generic_type_definition ::=
        (<>) | plage <> | chiffres <> | delta <>
      | array_type_definition | access_type_definition                          

Les termes objet formel générique (ou simplement objet formel), formel générique
type (ou simplement, type formel) et sous-programme formel générique (ou simplement,
sous-programme formel) sont utilisés pour faire référence au formel générique correspondant
paramètres.

La seule forme d'indication de sous-type autorisée dans une partie formelle générique est
une marque de type (c'est-à-dire que l'indication de sous-type ne doit pas inclure de mention explicite)
contrainte). Le désignateur d'un sous-programme générique doit être un identifiant.

En dehors de la spécification et du corps d'une unité générique, le nom de cette
l'unité de programme désigne l'unité générique. En revanche, dans le cadre déclaratif
région associée à un sous-programme générique, le nom de cette unité de programme
désigne le sous-programme obtenu par l'instanciation en cours du générique
unité. De même, au sein de la région déclarative associée à un générique
package, le nom de cette unité de programme désigne le package obtenu par le
instanciation actuelle.

L'élaboration d'une déclaration générique n'a pas d'autre effet.

Exemples de parties formelles génériques :

   générique -- sans paramètre

   générique
      TAILLE : NATUREL; -- objet formel

   générique
      LONGUEUR : ENTIER := 200; -- objet formel avec une valeur par défaut
                                           expression
      ZONE : ENTIER := LONGUEUR*LONGUEUR; -- objet formel avec une valeur par défaut
                                            expression

   générique
      tapez ITEM est privé ; -- type formel
      tapez INDEX est (<>); -- type formel
      le type ROW est un tableau (plage INDEX <>) de ITEM ; -- type formel
      avec la fonction "<"(X, Y : ITEM) return BOOLEAN ; -- sous-programme formel

Exemples de déclarations génériques déclarant des sous-programmes génériques :

   générique
      le type ELEM est privé ;
   procédure EXCHANGE(U, V : entrée sortie ELEM);

   générique
      tapez ITEM est privé ;
      avec la fonction "*"(U, V : ITEM) return ITEM est <>;
   fonction CARRÉ(X : ARTICLE) renvoie ARTICLE ;

Exemple de déclaration générique déclarant un package générique :

   générique
      tapez ITEM est privé ;
      le type VECTOR est un tableau (plage POSITIVE <>) de ITEM ;
      avec la fonction SUM(X, Y : ITEM) renvoie ITEM;
   le package ON_VECTORS est
      fonction SOMME (A, B : VECTEUR) renvoie VECTEUR ; 
      la fonction SIGMA(A : VECTOR) renvoie ARTICLE ;
      LENGTH_ERROR : exception ;
      fin;                                                                     

Remarques:

Au sein d'un sous-programme générique, le nom de cette unité de programme fait office de nom
d'un sous-programme. Ce nom peut donc être surchargé et apparaître dans un
appel récursif de l'instanciation en cours. Pour la même raison, ceci
le nom ne peut pas apparaître après le mot réservé new dans un générique (récursif)
instanciation.

Une expression qui apparaît dans une partie formelle générique est soit la valeur par défaut
expression pour un objet formel générique de mode dans, ou un constituant d'un
nom d'entrée donné comme nom par défaut pour un sous-programme formel, ou le nom par défaut
expression pour un paramètre d’un sous-programme formel. Expressions par défaut pour
les objets formels génériques et les noms par défaut des sous-programmes formels sont uniquement
évalué pour les instanciations génériques qui utilisent de telles valeurs par défaut. Défaut
les expressions pour les paramètres des sous-programmes formels ne sont évaluées que pour
appels des sous-programmes formels qui utilisent de telles valeurs par défaut. (L'habituel
les règles de visibilité s'appliquent à tout nom utilisé dans une expression par défaut : le
l'entité désignée doit donc être visible à l'endroit de l'expression.)

Ni les paramètres formels génériques ni leurs attributs ne sont autorisés
constituants des expressions statiques (voir 4.9).

Références : définition de type d'accès 3.8, définition de type de tableau 3.6,
attribut 4.1.4, contrainte 3.3, déclaration 3.1, désignateur 6.1,
l'élaboration n'a pas d'autre effet 3.1, entité 3.1, expression 4.4, fonction
6.5, instanciation générique 12.3, identifiant 2.3, liste d'identifiants 3.2,
instance 12.3, nom 4.1, objet 3.2, surcharge 6.6 8.7, package
spécification 7.1, paramètre d'un sous-programme 6.2, définition de type privé
7.4, procédure 6.1, mot réservé 2.9, expression statique 4.9, sous-programme 6,
spécification de sous-programme 6.1, indication de sous-type 3.3.2, type 3.3, marque de type
3.3.2   

12.1.1 Objets formels génériques 

La première forme de déclaration de paramètre générique déclare un formulaire générique
objets. Le type d'un objet formel générique est le type de base du type 
désigné par la marque de type donnée dans la déclaration du paramètre générique. UN
une déclaration de paramètre générique avec plusieurs identifiants équivaut à un
séquence de déclarations de paramètres génériques uniques, comme expliqué dans la section
3.2.

Un objet formel générique a un mode qui est soit in, soit in out. Dans le
absence d'indication de mode explicite dans une déclaration de paramètre générique,
le mode in est supposé ; sinon le mode est celui indiqué. Si un
La déclaration de paramètre générique se termine par une expression, l'expression est
l'expression par défaut du paramètre formel générique. Un défaut
l'expression n'est autorisée que si le mode est (que ce mode soit
indiqué explicitement ou implicitement). Le type d'une expression par défaut doit
être celui du paramètre formel générique correspondant.                       

Un objet formel générique de mode in est une constante dont la valeur est une copie de
la valeur fournie comme paramètre générique réel correspondant dans un générique
instanciation, comme décrit dans la section 12.3. Le type d'un formel générique
l'objet du mode in ne doit pas être un type limité ; le sous-type d'un tel
l'objet formel générique est le sous-type désigné par la marque de type donnée dans le
déclaration de paramètre générique.

Un objet formel générique de mode in out est une variable et désigne l'objet
fourni comme paramètre réel générique correspondant dans un
instanciation, comme décrit dans la section 12.3. Les contraintes qui s'appliquent à
l'objet formel générique sont ceux de l'objet réel générique correspondant
paramètre.                                                                      

Note:

Les contraintes qui s'appliquent à un objet formel générique de mode in out sont
ceux du paramètre réel générique correspondant (et non ceux impliqués par
la marque de type qui apparaît dans la déclaration du paramètre générique). Chaque fois que
possible (pour éviter toute confusion), il est recommandé que le nom d'une base
type être utilisé pour la déclaration d’un tel objet formel. Si toutefois le
Le type de base est anonyme, il est recommandé que le nom du sous-type défini par
la déclaration de type pour le type de base soit utilisée.

Références : type anonyme 3.3.1, affectation 5.2, type de base 3.3, constante
déclaration 3.2, contrainte 3.3, déclaration 3.1, paramètre réel générique
12.3, objet formel générique 12.1, paramètre formel générique 12.1, générique
instanciation 12.3, déclaration de paramètre générique 12.1, identifiant 2.3,
type limité 7.4.4, correspondant au paramètre générique réel 12.3, mode 6.1, nom
4.1, objet 3.2, nom simple 4.1, sous-type 3.3, déclaration de type 3.3, type
marque 3.3.2, variable 3.2.1   

12.1.2 Types formels génériques  

Une déclaration de paramètre générique qui inclut une définition de type générique ou
une déclaration de type privé déclare un type formel générique. Un générique
Le type formel désigne le sous-type fourni comme élément réel correspondant.
paramètre dans une instanciation générique, comme décrit en 12.3(d). Cependant,
au sein d'une unité générique, un type formel générique est considéré comme étant
distinct de tous les autres types (formels ou non formels). La forme de
contrainte applicable à un type formel dans une indication de sous-type dépend de
la classe du type comme pour un type non formel.

La seule forme de plage discrète autorisée dans la déclaration d'un
Le type de tableau générique formel (contraint) est une marque de type.

La partie discriminante d'un type privé formel générique ne doit pas comporter de
expression par défaut pour un discriminant. (Par conséquent, une variable qui est
déclaré par une déclaration d'objet doit être contraint si son type est un
type formel générique avec discriminants.)

Au sein de la déclaration et du corps d'une unité générique, les opérations disponibles
pour les valeurs d'un type formel générique (en dehors de toute opération supplémentaire
spécifié par un sous-programme formel générique) sont déterminés par le sous-programme générique
déclaration de paramètre pour le type formel :

(a) Pour une déclaration de type privé, les opérations disponibles sont celles
    définis à l’article 7.4.2 (notamment l’affectation, l’égalité et
    les inégalités sont disponibles pour un type privé, sauf si elles sont limitées).                                                                                                                                                                                                                                                

(b) Pour une définition de type tableau, les opérations disponibles sont celles
    définis à la section 3.6.2 (ils incluent par exemple la formation de
    composants et tranches indexés).   

(c) Pour une définition de type d'accès, les opérations disponibles sont celles
    défini à la section 3.8.2 (par exemple, des allocateurs peuvent être utilisés).

Les quatre formes de définition de type générique dans lesquelles une boîte apparaît (c'est-à-dire
le délimiteur composé <>) correspondent aux formes majeures suivantes de
type scalaire :

(d) Types discrets : (<>)

    Les opérations disponibles sont les opérations communes à l'énumération et
    types entiers ; ceux-ci sont définis à la section 3.5.5.                                             

(e) Types entiers : plage <>

    Les opérations disponibles sont les opérations de types entiers définis
    à la section 3.5.5.

(f) Types à virgule flottante : chiffres <>

    Les opérations disponibles sont celles définies à la section 3.5.8.

(g) Types à virgule fixe : delta <> 

    Les opérations disponibles sont celles définies à la section 3.5.10. 

Dans tous les cas (a) à (f) ci-dessus, chaque opération implicitement
associé à un type formel (c'est-à-dire autre qu'une opération spécifiée
par un sous-programme formel) est implicitement déclaré à l'endroit du
déclaration du type formel. Il en va de même pour un point fixe formel
type, à l’exception des opérateurs multiplicateurs qui fournissent un résultat du
tapez universal_fixed (voir 4.5.5), puisque ces opérateurs spéciaux sont
déclaré dans le colis STANDARD.

Pour une instanciation de l'unité générique, chacune de ces opérations est la
opération de base correspondante ou opérateur prédéfini du réel correspondant
taper. Pour un opérateur, cette règle s'applique même si l'opérateur a été
redéfini pour le type réel ou pour un type parent du type réel. 

Exemples de types formels génériques :

   tapez ITEM est privé ;
   le type BUFFER(LENGTH : NATURAL) est limité en privé ;

   tapez ENUM est (<>);
   le type INT est une plage <> ;
   tapez ANGLE est delta <> ;
   tapez MASS en chiffres <> ;

   le type TABLE est un tableau (ENUM) de ITEM ; 

Exemple de partie formelle générique déclarant un type formel entier :

   générique
      tapez RANK est une plage <> ;
      PREMIER : RANG := RANG'FIRST;
      DEUXIÈME : RANG := PREMIER + 1; -- l'opérateur "+" de type RANK 

Références : définition du type d'accès 3.8, allocateur 4.8, type de tableau
définition 3.6, affectation 5.2, corps d'une unité générique 12.2, classe de type
3.3, contrainte 3.3, déclaration 3.1, déclaration d'une unité générique 12.1,
plage discrète 3.6, type discret 3.5, partie discriminante 3.7.1, énumération
type 3.5.1, égalité 4.5.2, type à virgule fixe 3.5.9, type à virgule flottante
3.5.7, type réel générique 12.3, partie formelle générique 12.1, formelle générique 
sous-programme 12.1.3, type formel générique 12.1, déclaration de paramètre générique
12.1, définition de type générique 12.1, composante indexée 4.1.1, inégalité
4.5.2, instanciation 12.3, type entier 3.5.4, type privé limité 7.4.4,
correspondant au type réel générique 12.3.2 12.3.3 12.3.4 12.3.5, multiplication
opérateur 4.5 4.5.5, opération 3.3, opérateur 4.5, type parent 3.4, privé
définition de type 7.4, type scalaire 3.5, tranche 4.1.2, package standard 8.6 C,
indication de sous-type 3.3.2, marque de type 3.3.2, universal_fixed 3.5.9                                                  

12.1.3 Sous-programmes formels génériques 

Une déclaration de paramètre générique qui inclut une spécification de sous-programme
déclare un sous-programme formel générique.

Deux formes alternatives de défauts peuvent être spécifiées dans la déclaration d'un
sous-programme formel générique. Dans ces formulaires, la spécification du sous-programme est
suivi du mot réservé est et soit d'une case, soit du nom d'un
sous-programme ou entrée. Les règles de correspondance pour ces valeurs par défaut sont expliquées
à la section 12.3.6.

Un sous-programme formel générique désigne le sous-programme, le littéral d'énumération ou
entrée fournie comme paramètre réel générique correspondant dans un
instanciation, comme décrit dans la section 12.3(f).

Exemples de sous-programmes formels génériques :

   avec la fonction INCREASE(X : INTEGER) return INTEGER;
   avec la fonction SUM(X, Y : ITEM) renvoie ITEM;

   avec la fonction "+"(X, Y : ITEM) return ITEM est <>;
   avec la fonction IMAGE(X : ENUM) return STRING est ENUM'IMAGE ;

   avec la procédure UPDATE est DEFAULT_UPDATE ;

Remarques:

Les contraintes qui s'appliquent à un paramètre d'un sous-programme formel sont celles  
du paramètre correspondant dans la spécification du réel correspondant
sous-programme (pas ceux impliqués par la marque de type correspondante dans le
spécification du sous-programme formel). Une remarque similaire s'applique à
résultat d'une fonction. Dans la mesure du possible (pour éviter toute confusion), il est
recommandé d'utiliser le nom d'un type de base plutôt que le nom d'un
sous-type dans toute déclaration d’un sous-programme formel. Si toutefois la base
type est anonyme, il est recommandé que le nom du sous-type défini par le
déclaration de type à utiliser.

Le type spécifié pour un paramètre formel d'un sous-programme formel générique
peut être n'importe quel type visible, y compris un type formel générique du même
partie formelle générique.

Références : type anonyme 3.3.1, type de base 3.3, délimiteur de boîte 12.1.2,
contrainte 3.3, désignateur 6.1, paramètre réel générique 12.3, générique
fonction formelle 12.1, sous-programme formel générique 12.1, instanciation générique
12.3, déclaration de paramètre générique 12.1, identifiant 2.3, correspondant générique
sous-programme actuel 12.3.6, symbole d'opérateur 6.1, paramètre d'un sous-programme
6.2, déclaration de renommage 8.5, mot réservé 2.9, portée 8.2, sous-programme 6,
spécification de sous-programme 6.1, sous-type 3.3.2, type 3.3, marque de type 3.3.2   

12.2 Corps génériques  

Le corps d'un sous-programme générique ou d'un package générique est un modèle pour le
corps des sous-programmes ou packages correspondants obtenus par générique
instanciations. La syntaxe d'un corps générique est identique à celle d'un
corps non générique.

A chaque déclaration d'un sous-programme générique, il doit y avoir un correspondant
corps.                                                                                

L'élaboration d'un corps générique n'a d'autre effet que d'établir
que le corps puisse désormais servir de modèle pour obtenir le
instances correspondantes. 

Exemple de corps de procédure générique :

   la procédure EXCHANGE(U, V : in out ELEM) est -- voir exemple en 12.1
      T : ÉLEM ; -- le type formel générique
   commencer
      T := U;
      U := V;
      V := T ;
   fin de l'ÉCHANGE ; 

Exemple de corps de fonction générique :

   fonction SQUARING(X : ITEM) renvoie ITEM is -- voir exemple en 12.1
   commencer
      renvoyer X*X ; -- l'opérateur formel "*"
   fin; 

Exemple de corps de package générique :

   le corps du package ON_VECTORS est -- voir l'exemple en 12.1

      fonction SOMME(A, B : VECTEUR) retour VECTEUR est
         RESULTAT : VECTEUR(A'RANGE); -- le type formel VECTOR
         BIAS : constant INTEGER := B'FIRST - A'FIRST;
      commencer
         si A'LENGTH /= B'LENGTH alors
            augmenter LENGTH_ERROR ;
         fin si;

         pour N dans la boucle A'RANGE
            RÉSULTAT(N) := SOMME(A(N), B(N + BIAIS)); -- la fonction formelle SOMME
         terminer la boucle ;
         retourner le RÉSULTAT ;
      fin;

      la fonction SIGMA(A : VECTOR) renvoie ITEM est
         TOTAL : ARTICLE := A(A'FIRST); -- le type formel ITEM
      commencer 
         pour N dans A'FIRST + 1 .. A'LAST boucle
            TOTAL := SOMME(TOTAL, A(N)); -- la fonction formelle SOMME
         terminer la boucle ;
         retourner TOTAL ;
      fin;
   fin; 

Références : corps 3.9, élaboration 3.9, corps générique 12.1, générique
instanciation 12.3, package générique 12.1, sous-programme générique 12.1, instance 
12.3, corps du package 7.1, package 7, sous-programme 6, corps du sous-programme 6.3                                                       

12.3 Instanciation générique

Une instance d'une unité générique est déclarée par une instanciation générique.

   générique_instantiation ::=
        l'identifiant du paquet est
            nouveau nom_paquet_générique [generic_actual_part] ;
      | l'identifiant de la procédure est
            nouveau nom_procédure_générique [generic_actual_part] ;
      | le désignateur de fonction est
            nouveau nom_fonction_générique [generic_actual_part] ;

   generic_actual_part ::=
      (association_générique {, association_générique})

   association_générique ::=
      [generic_formal_parameter =>] generic_actual_parameter

   generic_formal_parameter ::= paramètre_simple_name | symbole_opérateur

   generic_actual_parameter ::= expression | Nom de variable
      | nom_sous-programme | nom_entrée | type_mark

Un paramètre réel générique explicite doit être fourni pour chaque
paramètre formel, sauf si la déclaration du paramètre générique correspondant
spécifie qu'une valeur par défaut peut être utilisée. Les associations génériques peuvent être soit
positionnel ou nommé de la même manière que les associations de paramètres de
appels de sous-programmes (voir 6.4). Si deux sous-programmes formels ou plus ont le
même désignateur, les associations nommées ne sont pas autorisées pour le
paramètres génériques correspondants.

Chaque paramètre générique réel doit correspondre au paramètre formel générique correspondant.
paramètre. Une expression peut correspondre à un objet formel de mode dans ; une variable
le nom peut correspondre à un objet formel de mode in out ; un nom de sous-programme ou un
le nom de l'entrée peut correspondre à un sous-programme formel ; une marque de type peut correspondre à une marque formelle
taper. Les règles détaillées définissant les matchs autorisés sont données dans
les articles 12.3.1 à 12.3.6; ce sont les seuls matchs autorisés.  

L'instance est une copie de l'unité générique, à l'exception de l'unité formelle générique.
partie; ainsi l'instance d'un package générique est un package, celle d'un
une procédure générique est une procédure, et celle d'une fonction générique est une
fonction. Pour chaque occurrence, au sein de l'unité générique, d'un nom qui
désigne une entité donnée, la liste suivante définit quelle entité est notée
par l'occurrence correspondante dans l'instance.

(a) Pour un nom qui désigne l'unité générique : Le correspondant
    l'occurrence désigne l'instance.

(b) Pour un nom qui désigne un objet formel générique de mode dans : Le
    le nom correspondant désigne une constante dont la valeur est une copie du
    valeur du paramètre réel générique associé.

(c) Pour un nom qui désigne un objet formel générique de mode in out : Le
    le nom correspondant désigne la variable nommée par le 
    paramètre réel générique.

(d) Pour un nom qui désigne un type formel générique : le correspondant
    nom désigne le sous-type nommé par le réel générique associé
    paramètre (le sous-type réel).

(e) Pour un nom qui désigne un discriminant d'un type formel générique : Le
    le nom correspondant désigne le discriminant correspondant (il faut
    être un) du type réel associé au type formel générique.                                               

(f) Pour un nom qui désigne un sous-programme formel générique :
    le nom correspondant désigne le sous-programme, le littéral d'énumération ou
    entrée nommée par le paramètre réel générique associé (le paramètre réel
    sous-programme). 

(g) Pour un nom qui désigne un paramètre formel d'un formel générique
    sous-programme : le nom correspondant désigne le formel correspondant
    paramètre du sous-programme réel associé au formulaire formel
    sous-programme.

(h) Pour un nom qui désigne une entité locale déclarée dans le générique
    unité : Le nom correspondant désigne l'entité déclarée par le
    déclaration locale correspondante dans l'instance.

(i) Pour un nom qui désigne une entité globale déclarée en dehors du
    unité générique : Le nom correspondant désigne la même entité globale.

Des règles similaires s'appliquent aux opérateurs et aux opérations de base : notamment,
les opérateurs formels suivent une règle similaire à la règle (f), les opérations locales suivent
une règle similaire à la règle (h), et les opérations pour les types globaux suivent une règle
similaire à la règle (i). De plus, si au sein de l'unité générique un
opérateur ou une opération de base d’un type formel est utilisé, alors dans le
instance, l'occurrence correspondante fait référence à l'instance correspondante
opération prédéfinie du type réel associé au type formel.

Les règles ci-dessus s'appliquent également à toute marque de type ou expression (par défaut) donnée
au sein de la partie formelle générique de l’unité générique.

Pour l'élaboration d'une instanciation générique, chaque expression fournie comme
un paramètre réel générique explicite est d'abord évalué, ainsi que chaque
expression qui apparaît comme constituant d'un nom de variable ou d'un nom d'entrée
fourni comme paramètre réel générique explicite ; ces évaluations
procéder dans un ordre qui n’est pas défini par le langage. Ensuite, pour chaque
association générique omise (le cas échéant), l'expression par défaut correspondante
ou le nom par défaut est évalué ; ces évaluations sont effectuées dans l'ordre
des déclarations de paramètres génériques. Enfin, le généré implicitement 
l’instance est élaborée. L'élaboration d'une instanciation générique peut
impliquent également certaines vérifications de contraintes comme décrit dans les sous-sections suivantes.

L'instanciation générique récursive n'est pas autorisée dans le sens suivant : si
une unité générique donnée comprend une instanciation d'une deuxième unité générique,
alors l'instance générée par cette instanciation ne doit pas inclure de
instance de la première unité générique (que cette instance soit générée
directement, ou indirectement par des instanciations intermédiaires).

Exemples d'instanciations génériques (voir 12.1) :

   la procédure SWAP est nouvelle EXCHANGE(ELEM => INTEGER);
   la procédure SWAP est un nouveau EXCHANGE(CHARACTER); -- SWAP est surchargé

   la fonction SQUARE est nouvelle SQUARING(INTEGER); -- "*" de INTEGER utilisé par défaut
   la fonction SQUARE est nouvelle SQUARING(ITEM => MATRIX, "*" => MATRIX_PRODUCT);
   la fonction SQUARE est nouvelle SQUARING(MATRIX, MATRIX_PRODUCT) ; -- idem que le précédent   

   le package INT_VECTORS est nouveau ON_VECTORS(INTEGER, TABLE, "+");

Exemples d'utilisation d'unités instanciées :

   ÉCHANGER(A, B);
   A := CARRÉ(A);

   T : TABLE(1 .. 5) := (10, 20, 30, 40, 50);
   N : ENTIER := INT_VECTORS.SIGMA(T); -- 150 (voir 12.2 pour le corps de
                                             SIGMA)
   utilisez INT_VECTORS ;
   M : ENTIER := SIGMA(T); -- 150                                           

Remarques:

L'omission d'un paramètre réel générique n'est autorisée que si un paramètre correspondant
la valeur par défaut existe. Si des expressions par défaut ou des noms par défaut (autres que simples
noms) sont utilisés, ils sont évalués dans l’ordre dans lequel les noms correspondants
les paramètres formels génériques sont déclarés. 

Si deux sous-programmes surchargés sont déclarés dans une spécification de package générique
diffèrent uniquement par le type (formel) de leurs paramètres et résultats, alors
il existe des instanciations légales pour lesquelles tous les appels de ces sous-programmes
de l’extérieur de l’instance sont ambiguës. Par exemple:

   générique
      le type A est (<>);
      le type B est privé ;
   le paquet G est
      fonction NEXT(X : A) renvoie A ;
      fonction NEXT(X : B) renvoie B ;
   fin;

   le package P est nouveau G(A => BOOLEAN, B => BOOLEAN);
   -- les appels de P.NEXT sont ambigus

Références : déclaration 3.1, désignateur 6.1, discriminant 3.7.1,
élaboration 3.1 3.9, entité 3.1, nom d'entrée 9.5, évaluation 4.5, expression
4.4, objet formel générique 12.1, paramètre formel générique 12.1, générique
sous-programme formel 12.1, type formel générique 12.1, paramètre générique
déclaration 12.1, déclaration globale 8.1, identifiant 2.3, implicite
déclaration 3.1, déclaration locale 8.1, mode en 12.1.1, mode en sortie 12.1.1,
nom 4.1, opération 3.3, symbole opérateur 6.1, surcharge 6.6 8.7, package
7, nom simple 4.1, sous-programme 6, appel de sous-programme 6.4, nom de sous-programme 6.1,
déclaration de sous-type 3.3.2, marque de type 3.3.2, variable 3.2.1, visibilité 8.3         

12.3.1 Règles de correspondance pour les objets formels 

Un paramètre formel générique de mode in d'un type donné correspond à un
expression du même type. Si une unité générique a un objet formel générique
du mode in, on vérifie que la valeur de l'expression appartient à
le sous-type désigné par la marque de type, comme pour une constante explicite
déclaration (voir 3.2.1). L'exception CONSTRAINT_ERROR est levée si cela
la vérification échoue.

Un paramètre formel générique de mode in hors d'un type donné correspond au
nom d'une variable du même type. La variable ne doit pas être une variable formelle
paramètre du mode out ou un sous-composant de celui-ci. Le nom doit désigner un 
variable pour laquelle le renommage est autorisé (voir 8.5).

Remarques:

Le type d'un paramètre réel générique de mode en ne doit pas être limité
taper. Les contraintes qui s'appliquent à un paramètre formel générique de mode dans 
sont ceux du paramètre réel générique correspondant (voir 12.1.1).

Références : contrainte 3.3, exception constraint_error 11.1, expression
4.4, paramètre formel 6.1, paramètre générique réel 12.3, paramètre formel générique
objet 12.1.1, paramètre formel générique 12.1, instanciation générique 12.3,
unité générique 12.1, type limité 7.4.4, correspondant au paramètre générique réel
12.3, mode en 12.1.1, mode en sortie 12.1.1, mode en sortie 6.2, nom 4.1, élévation
des exceptions 11, satisfont 3.3, sous-composant 3.3, type 3.3, marque de type 3.3.2,
variable 3.2.1                                                                       

12.3.2 Règles de correspondance pour les types privés formels

Un type privé formel générique correspond à n'importe quel type ou sous-type (le type réel
sous-type) qui satisfait aux conditions suivantes :

 - Si le type formel n'est pas limité, le type réel ne doit pas être un
    type limité. (Si par contre le type formel est limité, aucun
    cette condition est imposée au type réel correspondant, qui peut
    être limité ou non.)

 - Si le type formel comporte une partie discriminante, le type réel doit être un
    tapez avec le même nombre de discriminants ; le type d'un
    discriminant qui apparaît à une position donnée dans la partie discriminante
    du type réel doit être le même que le type du discriminant
    qui apparaît à la même position dans la partie discriminante du  
    type formel; et le sous-type réel doit être sans contrainte. (Si, le
    en revanche, le type formel n'a pas de discriminants, le type réel
    est autorisé à avoir des discriminants.)

De plus, considérons toute occurrence du nom du type formel à un moment donné.
endroit où ce nom est utilisé comme indication de sous-type sans contrainte. Le
le sous-type réel ne doit pas être un type de tableau sans contrainte ou un type
tapez avec des discriminants, si l'une de ces occurrences se produit à un endroit où
soit une contrainte, soit des discriminants par défaut seraient requis pour un tableau
type ou pour un type avec discriminants (voir 3.6.1 et 3.7.2). Le même
la restriction s'applique aux occurrences du nom d'un sous-type du formulaire formel
type, et aux occurrences du nom de tout type ou sous-type dérivé,
directement ou indirectement, du type formel.

Si une unité générique a un type privé formel avec des discriminants, le
l'élaboration d'une instanciation générique correspondante vérifie que le
le sous-type de chaque discriminant du type réel est le même que le sous-type
du discriminant correspondant de type formel. L'éxéption
CONSTRAINT_ERROR est déclenché si cette vérification échoue.

Références : type de tableau 3.6, contrainte 3.3, exception constraint_error
11.1, expression par défaut pour un discriminant 3.7.1, type dérivé 3.4,
discriminant 3.7.1, partie discriminante 3.7.1, élaboration 3.9, générique
type réel 12.3, corps générique 12.2, type formel générique 12.1.2, générique
instanciation 12.3, spécification générique 12.1, type limité 7.4.4,
correspondant au paramètre générique réel 12.3, nom 4.1, type privé 7.4, augmentant
des exceptions 11, sous-type 3.3, indication de sous-type 3.3.2, type 3.3, type
avec discriminants 3.3, type tableau sans contrainte 3.6, sous-type sans contrainte
3.3

12.3.3 Règles de correspondance pour les types scalaires formels   

Un type formel générique défini par (<>) correspond à n'importe quel sous-type discret
(c'est-à-dire toute énumération ou sous-type entier). Un type formel générique
défini par range <> correspond à n’importe quel sous-type entier. Un formel générique 
le type défini par les chiffres <> correspond à n'importe quel sous-type à virgule flottante. UN
le type formel générique défini par delta <> correspond à n'importe quel point fixe
sous-type. Aucune autre correspondance n'est possible pour ces types formels génériques.

Références : délimiteur de boîte 12.1.2, type discret 3.5, type énumération
3.5.1, type à virgule fixe 3.5.9, type à virgule flottante 3.5.7, réel générique
type 12.3, type formel générique 12.1.2, définition de type générique 12.1,
type entier 3.5.4, correspondant au paramètre générique réel 12.3, type scalaire 3.5                                                

12.3.4 Règles de correspondance pour les types de tableaux formels

Un type de tableau formel correspond à un sous-type de tableau réel qui satisfait
les conditions suivantes :

 - Le type de tableau formel et le type de tableau réel doivent être identiques
    dimensionnalité; le type formel et le sous-type réel doivent être soit
    à la fois contraints ou à la fois non contraints.

 - Pour chaque position d'index, le type d'index doit être le même pour
    type de tableau réel comme pour le type de tableau formel.

 - Le type de composant doit être le même pour le type de tableau réel que pour
    le type de tableau formel. Si le type de composant est autre qu'un scalaire
    type, alors les sous-types de composants doivent être à la fois contraints ou
    tous deux sans contrainte.

Si une unité générique a un type formel de tableau, l'élaboration d'un 
l'instanciation correspondante vérifie que les contraintes (le cas échéant) sur le
Les types de composants sont les mêmes pour le type de tableau réel que pour le type formel
type de tableau, et de même que pour toute position d'index donnée, l'index
les sous-types ou les plages discrètes ont les mêmes limites. L'éxéption
CONSTRAINT_ERROR est déclenché si cette vérification échoue.

Exemple:

   -- étant donné le package générique

   générique
      tapez ITEM est privé ;
      tapez INDEX est (<>);
      le type VECTOR est un tableau (plage INDEX <>) de ITEM ;
      le type TABLE est un tableau (INDEX) de ITEM ;
   le paquet P est
      ...
   fin;

   -- et les types

   le type MIX est un tableau (plage COULEUR <>) de BOOLEAN ;
   le type OPTION est un tableau (COLOR) de BOOLEAN ;

   -- alors MIX peut correspondre à VECTOR et OPTION peut correspondre à TABLE

   le package R est le nouveau P(ITEM => BOOLEAN, INDEX => COLOR,
                      VECTEUR => MÉLANGE, TABLE => OPTION);

   -- Notez que MIX ne peut pas correspondre à TABLE et OPTION ne peut pas correspondre à VECTOR

Note:

Pour les règles ci-dessus, si l'un des types d'index ou de composants du formulaire formel
le type de tableau est lui-même un type formel, puis dans l'instance son nom
désigne le sous-type réel correspondant (voir 12.3(d)). 

Références : type de tableau 3.6, définition de type de tableau 3.6, composant d'un
tableau 3.6, type de tableau contraint 3.6, contrainte 3.3, constraint_error
exception 11.1, élaboration 3.9, type formel 12.1, type formel générique
12.1.2, instanciation générique 12.3, index 3.6, contrainte d'index 3.6.1,
correspondant au paramètre générique réel 12.3, instruction raise 11.3, sous-type 3.3,
type de tableau sans contrainte 3.6                                                    

12.3.5 Règles de correspondance pour les types d'accès formels

Un type d'accès formel correspond à un sous-type d'accès réel si le type de
les objets désignés sont les mêmes pour le type réel que pour le type formel
taper. Si le type désigné est autre qu'un type scalaire, alors le
les sous-types désignés doivent être à la fois contraints ou non contraints.

Si une unité générique a un type d'accès formel, l'élaboration d'un
l'instanciation correspondante vérifie que toutes les contraintes sur l'objet désigné
les objets sont les mêmes pour le sous-type d'accès réel que pour l'accès formel
taper. L'exception CONSTRAINT_ERROR est levée si cette vérification échoue.

Exemple:

   -- les types formels du package générique

   générique
      le type NODE est privé ;
      tapez LINK est accès NODE ;
   le paquet P est
      ...
   fin;

   -- peut être adapté aux types réels

   tapez VOITURE ;
   tapez CAR_NAME est accès CAR ;

   le type CAR est
      enregistrer
         PRED, SUCC : CAR_NAME ;
         NUMÉRO : LICENSE_NUMBER ;
         PROPRIÉTAIRE : PERSONNE ;
      terminer l'enregistrement ; 

   -- dans l'instanciation générique suivante

   le package R est le nouveau P(NODE => CAR, LINK => CAR_NAME);

Note:

Pour les règles ci-dessus, si le type désigné est lui-même un type formel, alors
dans l'instance, son nom désigne le sous-type réel correspondant (voir
12.3(d)).

Références : type d'accès 3.8, définition du type d'accès 3.8, contrainte 3.3,
constraint_error exception 11.1, désigner 3.8, élaboration 3.9, générique
type formel 12.1.2, instanciation générique 12.3, correspondant au réel générique
paramètre 12.3, objet 3.2, instruction raise 11.3, valeur du type d'accès 3.8     

12.3.6 Règles de correspondance pour les sous-programmes formels

Un sous-programme formel correspond à un sous-programme réel, énumération
littéral ou entrée si les deux ont le même paramètre et le même profil de type de résultat
(voir 6.6) ; de plus, les modes de paramètres doivent être identiques pour les
paramètres qui sont à la même position de paramètre.

Si une unité générique possède un sous-programme par défaut spécifié par un nom, ce nom
doit désigner un sous-programme, un littéral d'énumération ou une entrée qui correspond
le sous-programme formel (dans le sens ci-dessus). L’évaluation du défaut
le nom a lieu lors de l'élaboration de chaque instanciation qui utilise le
par défaut, tel que défini à la section 12.3.

Si une unité générique possède un sous-programme par défaut spécifié par une case, le
Le paramètre réel correspondant peut être omis si un sous-programme, une énumération
littéral, ou entrée correspondant au sous-programme formel, et avec le même
désigné comme sous-programme formel, est directement visible à l'endroit de
l'instanciation générique ; ce sous-programme, ce littéral d'énumération ou cette entrée
est alors utilisé par défaut (il doit y avoir exactement un sous-programme, énumération
littéral, ou entrée satisfaisant aux conditions précédentes).

Exemple:

   -- étant donné la spécification de la fonction générique

   générique
      tapez ITEM est privé ;
      avec la fonction "*" (U, V : ITEM) return ITEM est <>;
   fonction CARRÉ(X : ARTICLE) renvoie ARTICLE ;

   -- et la fonction

   fonction MATRIX_PRODUCT(A, B : MATRIX) return MATRIX ;

   -- l'instanciation suivante est possible

   la fonction SQUARE est nouvelle SQUARING(MATRIX, MATRIX_PRODUCT) ;

   -- les instanciations suivantes sont équivalentes

   la fonction SQUARE est nouvelle SQUARING(ITEM => INTEGER, "*" => "*");
   la fonction SQUARE est nouvelle SQUARING(INTEGER, "*");
   la fonction SQUARE est nouvelle SQUARING(INTEGER);

Remarques:

Les règles de correspondance pour les sous-programmes formels énoncent les exigences qui sont  
similaires à celles s'appliquant aux déclarations de renommage de sous-programmes (voir 8.5).
En particulier, le nom d'un paramètre du sous-programme formel n'a pas besoin d'être
la même que celle du paramètre correspondant du sous-programme réel ;
de même, pour ces paramètres, les expressions par défaut ne doivent pas nécessairement correspondre.

Un sous-programme formel correspond à un attribut d'un type si l'attribut
est une fonction avec une spécification correspondante. Un littéral d'énumération d'un 
le type donné correspond à une fonction formelle sans paramètre dont le type de résultat est le
type donné.

Références : attribut 4.1.4, délimiteur de case 12.1.2, désignateur 6.1, entrée
9.5, fonction 6.5, type réel générique 12.3, sous-programme formel générique
12.1.3, type formel générique 12.1.2, instanciation générique 12.3, correspondance
paramètre générique réel 12.3, nom 4.1, profil de type de paramètre et de résultat
6.3, sous-programme 6, spécification du sous-programme 6.1, sous-type 3.3, visibilité 8.3                                               

12.4 Exemple de package générique

L'exemple suivant fournit une formulation possible de piles au moyen de
un package générique. La taille de chaque pile et le type de pile
les éléments sont fournis en tant que paramètres génériques.

   générique
      TAILLE : POSITIF;
      tapez ITEM est privé ;
   le package STACK est
      procédure PUSH(E : dans ITEM);
      procédure POP (E : sortie ITEM) ;
      DÉBORDEMENT, SOUS-PLEIN : exception ;
   terminer la PILE ;

   le corps du paquet STACK est

      le type TABLE est un tableau (plage POSITIVE <>) de ITEM ;
      ESPACE : TABLE(1 .. TAILLE);
      INDICE : NATUREL := 0;

      la procédure PUSH(E : dans ITEM) est
      commencer
         si INDEX >= TAILLE alors
            augmenter le DÉBORDEMENT ;
         fin si;
         INDICE := INDICE + 1;
         ESPACE(INDEX) := E;
      terminer POUSSER ;

      la procédure POP(E : out ITEM) est
      commencer
         si INDICE = 0 alors
            augmenter le SOUS-FLUX ;
         fin si;
         E := ESPACE(INDEX);
         INDICE := INDICE - 1;
      terminer POP ;

   terminer la PILE ;

Les instances de ce package générique peuvent être obtenues comme suit :

   le package STACK_INT est un nouveau STACK(SIZE => 200, ITEM => INTEGER);
   le package STACK_BOOL est un nouveau STACK(100, BOOLEAN) ;

Par la suite, les procédures des packages instanciés peuvent être appelées comme
suit :

   STACK_INT.PUSH(N);
   STACK_BOOL.PUSH(TRUE);                                                      

Alternativement, une formulation générique du type STACK peut être donnée sous la forme
suit (corps du package omis) :

   générique
      tapez ITEM est privé ;
   le package ON_STACKS est
      le type STACK(SIZE : POSITIVE) est limité en privé ;
      procédure PUSH(S : entrée sortie STACK; E : entrée ITEM);
      procédure POP (S : entrée sortie STACK ; E : sortie ITEM) ;
      DÉBORDEMENT, SOUS-PLEIN : exception ;
   privé
      le type TABLE est un tableau (plage POSITIVE <>) de ITEM ;
      tapez PILE(TAILLE : POSITIF) est
         enregistrer
            ESPACE : TABLE(1 .. TAILLE);
            INDICE : NATUREL := 0;
         terminer l'enregistrement ;
   fin;

Pour utiliser un tel package, une instanciation doit être créée et
par la suite, des piles du type correspondant peuvent être déclarées :

   déclarer
      le package STACK_REAL est nouveau ON_STACKS(REAL); utilisez STACK_REAL ;
      S : PILE (100)
   commencer
      ...
      POUSSER(S, 2.54);
      ...
   fin;                          

