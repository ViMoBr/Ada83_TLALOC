
                           2. Éléments lexicaux  

Le texte d'un programme est constitué des textes d'une ou plusieurs compilations. Le texte d'une compilation est une séquence d'éléments lexicaux, chacun composé de personnages; les règles de composition sont données dans ce chapitre. Les pragmas, qui fournissent certaines informations au compilateur, sont également décrit dans ce chapitre.

Références : caractère 2.1, compilation 10.1, élément lexical 2.2, pragma 2.8   

2.1 Jeu de caractères 

Les seuls caractères autorisés dans le texte d'un programme sont le graphique caractères et effecteurs de format. Chaque caractère graphique correspond à un code unique du jeu de caractères codés ISO à sept bits (norme ISO 646), et est représenté (visuellement) par un symbole graphique. Un graphique les personnages sont représentés par différents symboles graphiques en alternative représentations nationales du jeu de caractères ISO. La description du la définition du langage dans ce manuel de référence standard utilise l'ASCII symboles graphiques, la représentation graphique ANSI du caractère ISO ensemble.

   caractère_graphique ::= caractère_graphique_basique
      | lettre_case_inférieure | autre_personnage_spécial

   caractère_graphique_de base ::=
        upper_case_letter | chiffre
      | caractère_spécial | caractère_espace

   personnage_de base ::=
        caractère_graphique_de base | format_effecteur

Le jeu de caractères de base est suffisant pour écrire n’importe quel programme. Le caractères inclus dans chacune des catégories de caractères graphiques de base sont définis comme suit :

(a) lettres majuscules
    ABCDEFGHIJKLMNOPQRSTU VWXYZ

(b) chiffres
    0 1 2 3 4 5 6 7 8 9   

(c) caractères spéciaux
    " # & ' ( ) * + , - . / : ; < = > _ |

(d) le caractère espace

Les effecteurs de format sont les caractères ISO (et ASCII) appelés horizontaux tabulation, tabulation verticale, retour chariot, saut de ligne et saut de page.                                                 

Les personnages inclus dans chacune des catégories restantes de graphiques les caractères sont définis comme suit :

(e) lettres minuscules
    abcdefghijklmnopqrstu vwxyz

(f) autres caractères spéciaux
    ! $% ? @ [ \ ] ^ ` { } ~

Remplacements autorisés pour la barre verticale des caractères spéciaux (|), pointue (#) et quote (") sont définis dans la section 2.10.

Remarques:

Le caractère ISO qui correspond au symbole graphique pointu dans le La représentation ASCII apparaît comme un symbole de la livre sterling en français, Représentations nationales standard en Allemagne et au Royaume-Uni. Dans tous les cas, la conception de la police des symboles graphiques (par exemple, s'ils sont en italique ou gras) ne fait pas partie de la norme ISO.

La signification des acronymes utilisés dans cette section est la suivante : ANSI signifie American National Standards Institute, ASCII signifie American Code standard pour l'échange d'informations, et ISO signifie International Organisation de normalisation.

Les noms suivants sont utilisés pour faire référence à des caractères spéciaux et autres caractères spéciaux:

   nom du symbole nom du symbole

     " cotation > supérieure à
     # souligné _ souligné
     & esperluette | barre verticale
     'apostrophe ! point d'exclamation
     ( parenthèse gauche $ dollar
     ) parenthèse droite % pour cent
     * étoile, multiplier ? point d'interrogation
     + plus @ commercial à
     , virgule [ crochet gauche
     - trait d'union, moins \ barre oblique inverse
     . point, point, point ] crochet droit
     / barre oblique, diviser ^ circonflexe
     : deux points ` accent grave
     ; point-virgule { accolade gauche
     < inférieur à } accolade droite
     = égal ~ tilde   

2.2 Éléments lexicaux, séparateurs et délimiteurs 

Le texte d'un programme est constitué des textes d'une ou plusieurs compilations. Le texte de chaque compilation est une séquence d'éléments lexicaux distincts. Chaque élément lexical est soit un délimiteur, soit un identifiant (qui peut être un mot réservé), un littéral numérique, un littéral de caractère, un littéral de chaîne, ou un commentaire. L'effet d'un programme dépend uniquement du contexte particulier séquences d'éléments lexicaux qui forment ses compilations, à l'exclusion des commentaires, le cas échéant.                                                   

Dans certains cas, un séparateur explicite est requis pour séparer les éléments adjacents. éléments lexicaux (à savoir, sans séparation, interprétation comme un un seul élément lexical est possible). Un séparateur est n'importe lequel d'un espace  caractère, un effecteur de format ou la fin d'une ligne. Un caractère espace est un séparateur sauf dans un commentaire, une chaîne littérale ou un espace littéral. Les effecteurs de format autres que la tabulation horizontale sont toujours séparateurs. La tabulation horizontale est un séparateur sauf à l'intérieur d'un commentaire.

La fin d'une ligne est toujours un séparateur. La langue ne définit pas ce que provoque la fin d'une ligne. Cependant si, pour une implémentation donnée, la fin d'une ligne est signifié par un ou plusieurs caractères, alors ces caractères doivent être des effecteurs de format autres que la tabulation horizontale. En tout cas, un séquence d'un ou plusieurs effecteurs de format autres que la tabulation horizontale doit provoquer au moins une fin de ligne.

Un ou plusieurs séparateurs sont autorisés entre deux éléments lexicaux adjacents. éléments, avant le premier de chaque compilation, ou après la dernière. À au moins un séparateur est requis entre un identifiant ou un littéral numérique et un identifiant adjacent ou un littéral numérique.

Un délimiteur est l'un des caractères spéciaux suivants (dans le langage de base jeu de caractères)

   & ' ( ) * + , - . / : ; < = > |

ou l'un des délimiteurs composés suivants, chacun composé de deux éléments adjacents
caractères spéciaux

   => .. ** := /= >= <= << >> <>

Chacun des caractères spéciaux répertoriés pour les délimiteurs de caractères uniques est un délimiteur unique sauf si ce caractère est utilisé comme caractère d'un délimiteur composé, ou comme caractère d'un commentaire, d'une chaîne littérale, caractère littéral ou littéral numérique.

Les autres formes d'élément lexical sont décrites dans d'autres sections de ce chapitre.

Remarques:

Chaque élément lexical doit tenir sur une seule ligne, puisque la fin d'une ligne est un séparateur. Les caractères guillemets, pointus et soulignés, ainsi que deux les traits d'union adjacents ne sont pas des délimiteurs, mais peuvent faire partie d'autres traits d'union lexicaux.éléments.   

Les noms suivants sont utilisés pour désigner les délimiteurs composés :

   nom du délimiteur

      => flèche
      .. double point
      ** étoile double, exponentielle
      := affectation (prononcé : "devient")
      /= inégalité (prononcé : "pas égal")
      >= supérieur ou égal 
      <= inférieur ou égal
      << support d'étiquette gauche
      >> support d'étiquette droit
      <> case

Références : caractère littéral 2.5, commentaire 2.7, compilation 10.1, format
effecteur 2.1, identifiant 2.3, littéral numérique 2.4, mot réservé 2.9, espace
caractère 2.1, caractère spécial 2.1, chaîne littérale 2.6                                                

2.3 Identifiants 

Les identifiants sont utilisés comme noms et également comme mots réservés.

   identifiant ::=
      lettre {[souligné] letter_or_digit}

   letter_or_digit ::= lettre | chiffre

   lettre ::= upper_case_letter | lettre minuscule

Tous les caractères d'un identifiant sont significatifs, y compris tout soulignement
caractère inséré entre une lettre ou un chiffre et une lettre ou un chiffre adjacent
chiffre. Identifiants ne différant que par l'utilisation des lettres supérieures et supérieures correspondantes.
les lettres minuscules sont considérées comme identiques.

Exemples:

   COUNT X get_symbol Ethelyn Marion

   SNOBOL_4 X1 Nombre de pages STORE_NEXT_ITEM

Note:

Aucun espace n'est autorisé dans un identifiant puisqu'un espace est un séparateur.

Références : chiffre 2.1, lettre minuscule 2.1, nom 4.1, mot réservé 2.9, séparateur 2.2, espace 2.1, lettre majuscule 2.1   

2.4 Littéraux numériques 

Il existe deux classes de littéraux numériques : les littéraux réels et les entiers. littéraux. Un vrai littéral est un littéral numérique qui inclut un point ; un un littéral entier est un littéral numérique sans point. Les vrais littéraux sont les littéraux de type universal_real. Les littéraux entiers sont les littéraux du type universal_integer.

   numeric_literal ::= décimal_literal | base_literal 

Références : littéral 4.2, type universal_integer 3.5.4, type universal_real 3.5.6   

2.4.1 Littéraux décimaux    

Un littéral décimal est un littéral numérique exprimé au format conventionnel
notation décimale (c'est-à-dire que la base est implicitement dix).

   decimal_literal ::= entier [.integer] [exposant]

   entier ::= chiffre {[souligné] chiffre}

   exposant ::= E [+] entier | E - entier                                                

Un caractère de soulignement inséré entre les chiffres adjacents d'une décimale
littéral n’affecte pas la valeur de ce littéral numérique. La lettre E de
l'exposant, le cas échéant, peut être écrit soit en minuscule, soit en majuscule,
avec la même signification.

Un exposant indique la puissance de dix par laquelle la valeur de la décimale
littéral sans l'exposant doit être multiplié pour obtenir la valeur du
littéral décimal avec l'exposant. Un exposant pour un littéral entier doit
pas de signe moins.

Exemples:

   12 0 1E6 123_456 -- littéraux entiers

   12,0 0,0 0,456 3.14159_26 -- vrais littéraux

   1.34E-12 1.0E+6 -- vrais littéraux avec exposant 

Remarques:   

Les zéros non significatifs sont autorisés. Aucun espace n'est autorisé dans un littéral numérique, pas
même entre les constituants de l'exposant, puisqu'un espace est un séparateur. UN
zéro exposant est autorisé pour un littéral entier.

Références : chiffre 2.1, lettre minuscule 2.1, littéral numérique 2.4,
séparateur 2.2, espace 2.1, lettre majuscule 2.1   

2.4.2 Littéraux basés 

Un littéral basé est un littéral numérique exprimé sous une forme qui spécifie le
base explicitement. La base doit être d'au moins deux et d'au plus seize.

   based_literal ::=
      base # based_integer [.based_integer] # [exposant]

   base ::= entier

   based_integer ::=
      Extended_digit {[souligné] Extended_digit}

   Extended_digit ::= chiffre | lettre

Un caractère de soulignement inséré entre les chiffres adjacents d'un littéral basé
n'affecte pas la valeur de ce littéral numérique. La base et le
les exposants, le cas échéant, sont en notation décimale. Les seules lettres autorisées comme
les chiffres étendus sont les lettres de A à F pour les chiffres de dix à
quinze. Une lettre dans un littéral basé (soit un chiffre étendu, soit le
la lettre E d'un exposant) peut être écrite soit en minuscule, soit en majuscule
cas, avec la même signification.  

Le sens conventionnel de la notation basée est assumé ; en particulier le
la valeur de chaque chiffre étendu d'un littéral basé doit être inférieure à la base.
Un exposant indique la puissance de la base par laquelle la valeur de la base
littéral sans l'exposant doit être multiplié pour obtenir la valeur du
basé sur un littéral avec l'exposant.                                                   

Exemples: 

 2#1111_1111# 16#FF# 016#0FF# -- littéraux entiers de valeur 255
 16#E#E1 2#1110_0000 # -- littéraux entiers de valeur 224
 16#F.FF#E+2 2#1.1111_1111_111#E11 -- vrais littéraux de valeur 4095.0

Références : chiffre 2.1, exposant 2.4.1, lettre 2.3, lettre minuscule 2.1,
littéral numérique 2.4, lettre majuscule 2.1   

2.5 Littéraux de caractères 

Un caractère littéral est formé en encadrant l'un des 95 graphiques
caractères (y compris l'espace) entre deux caractères apostrophes. UN
Le caractère littéral a une valeur qui appartient à un type de caractère.

   caractère_literal ::= 'graphic_character'

Exemples:

   'UN' '*' ''' ' '

Références : type de caractère 3.5.2, caractère graphique 2.1, littéral 4.2,
caractère espace 2.1   

2.6 Littéraux de chaîne 

Une chaîne littérale est formée par une séquence de caractères graphiques (éventuellement
aucun) entouré de deux guillemets utilisés comme crochets de chaîne.

   string_literal ::= "{graphic_character}"

Une chaîne littérale a une valeur qui est une séquence de valeurs de caractères
correspondant aux caractères graphiques de la chaîne littérale en dehors de
le caractère de citation lui-même. Si une valeur de caractère de guillemet doit être
représenté dans la séquence de valeurs de caractères, puis une paire de valeurs adjacentes
les guillemets doivent être écrits à l'endroit correspondant dans le
chaîne littérale. (Cela signifie qu'une chaîne littérale qui comprend deux
les guillemets adjacents ne sont jamais interprétés comme deux chaînes adjacentes
littéraux.)

La longueur d'une chaîne littérale est le nombre de valeurs de caractères dans le
séquence représentée. (Chaque caractère de guillemet doublé est compté comme un
un seul caractère.)

Exemples:   

   "Le message du jour:"  

   "" -- une chaîne littérale vide
   " " "A" """" -- trois chaînes littérales de longueur 1

   "Les caractères tels que $, %, et } sont autorisés dans les chaînes littérales"                                                  

Note:

Une chaîne littérale doit tenir sur une seule ligne puisqu'il s'agit d'un élément lexical (voir
2.2). Des séquences plus longues de valeurs de caractères graphiques peuvent être obtenues en
caténation de chaînes littérales. De même, caténation des constantes déclarées
dans le package ASCII peut être utilisé pour obtenir des séquences de valeurs de caractères
qui incluent des valeurs de caractères non graphiques (ce que l'on appelle
personnages). Des exemples de telles utilisations de la caténation sont donnés ci-dessous :

   "PREMIÈRE PARTIE D'UNE SÉQUENCE DE PERSONNAGES" &
   "CELA CONTINUE SUR LA LIGNE SUIVANTE"
   "séquence qui inclut le" & ASCII.ACK & "caractère de contrôle"

Références : package prédéfini ascii C, opération de caténation 4.5.3,
valeur de caractère 3.5.2, constante 3.2.1, déclaration 3.1, fin de ligne 2.2,
caractère graphique 2.1, élément lexical 2.2   

2.7 Commentaires 

Un commentaire commence par deux tirets adjacents et s'étend jusqu'à la fin du
doubler. Un commentaire peut apparaître sur n'importe quelle ligne d'un programme. La présence ou
l'absence de commentaires n'a aucune influence sur la légalité ou non d'un programme.
illégal. De plus, les commentaires n’influencent pas l’effet d’un programme ;
leur seul objectif est l’illumination du lecteur humain.

Exemples:

   -- la dernière phrase ci-dessus fait écho au rapport Algol 68

   fin; -- le traitement de LINE est terminé

   -- un long commentaire peut être divisé en
   -- deux ou plusieurs lignes consécutives  

   ---------------- les deux premiers tirets commencent le commentaire 

Note:

La tabulation horizontale peut être utilisée dans les commentaires, après le double trait d'union,
et équivaut à un ou plusieurs espaces (voir 2.2).

Références : fin de ligne 2.2, illégal 1.6, légal 1.6, espace 2.1   

2.8 Pragmas    

Un pragma est utilisé pour transmettre des informations au compilateur. Un pragma commence
avec le mot réservé pragma suivi d'un identifiant qui est le nom de
le pragme.

   pragma ::=
      identifiant pragma [(argument_association {, argument_association})];

   argument_association ::=
        [argument_identifier =>] nom
      | [argument_identifiant =>] expression                                              

Les pragmas ne sont autorisés qu'aux endroits suivants dans un programme :

 - Après un délimiteur point-virgule, mais pas dans une partie formelle ou
    partie discriminante.

 - A tout endroit où les règles de syntaxe autorisent une construction définie par un
    catégorie syntaxique dont le nom se termine par "déclaration", "instruction",
    "clause", ou "alternative", ou l'une des variantes des catégories syntaxiques
    et gestionnaire d'exceptions ; mais pas à la place d’une telle construction. Également à
    tout endroit où une unité de compilation serait autorisée.

Des restrictions supplémentaires existent pour le placement de pragmas spécifiques.

Certains pragmas ont des arguments. Les associations d'arguments peuvent être soit
positionnel ou nommé comme pour les associations de paramètres des appels de sous-programme (voir
6.4). Les associations nommées ne sont toutefois possibles que si l'argument
Des identifiants sont définis. Un nom donné dans un argument doit être soit un nom
visible à l'endroit du pragma ou un identifiant propre au pragma.

Les pragmas définis par le langage sont décrits en Annexe B : ils doivent être
pris en charge par chaque implémentation. De plus, une mise en œuvre peut
fournir des pragmas définis par l'implémentation, qui doivent ensuite être décrits dans
Annexe F. Une implémentation n'est pas autorisée à définir des pragmas dont
la présence ou l'absence influence la légalité du texte en dehors de ces
pragmas. Par conséquent, la légalité d'un programme ne dépend pas de la
présence ou absence de pragmas définis par l’implémentation.

Un pragma qui n'est pas défini par le langage n'a aucun effet si son identifiant est
non reconnu par l'implémentation (actuelle). De plus, un pragme
(qu'il soit défini par le langage ou par l'implémentation) n'a aucun effet si son
le placement ou ses arguments ne correspondent pas à ce qui est autorisé pour le
pragma. La région du texte sur laquelle un pragma a un effet dépend de
le pragme.

Exemples:

   pragma LISTE(OFF);
   pragma OPTIMISER(TEMPS);
   pragma INLINE(SETMASK);
   pragma SUPPRESS(RANGE_CHECK, ON => INDEX); 

Note:

Il est recommandé (mais pas obligatoire) que les implémentations émettent des avertissements
pour les pragmas qui ne sont pas reconnus et donc ignorés.

Références : unité de compilation 10.1, délimiteur 2.2, partie discriminante 3.7.1,
gestionnaire d'exceptions 11.2, expression 4.4, partie formelle 6.1, identifiant 2.3,
pragma F défini par l'implémentation, pragma B défini par le langage, légal 1.6, nom
4.1, mot réservé 2.9, instruction 5, expression statique 4.9, variante 3.7.3,
visibilité 8.3

Les catégories se terminant par « déclaration » comprennent : la déclaration de base 3.1,
déclaration de composant 3.7, déclaration d'entrée 9.5, paramètre générique
déclaration 12.1 

Les catégories se terminant par « clause » comprennent : la clause d'alignement 13.4, le composant
clause 13.4, clause de contexte 10.1.1, clause de représentation 13.1, clause d'utilisation
8.4, avec la clause 10.1.1

Les catégories se terminant par « alternative » comprennent : accepter l'alternative 9.7.1,
alternative d'instruction de cas 5.4, alternative de retard 9.7.1, alternative de sélection
9.7.1, alternative d'attente sélective 9.7.1, alternative de fin 9.7.1                                                 

2.9 Mots réservés 

Les identifiants listés ci-dessous sont appelés mots réservés et sont réservés à
importance particulière dans la langue. Pour la lisibilité de ce manuel, le
les mots réservés apparaissent en minuscules et en gras. 

   abandonner la déclaration générique de select
   retard abs aller à ou se séparer
   accepter les autres sous-types delta
   accéder aux chiffres en cas d'absence
   tout le monde fait sa tâche
   et le package est terminé
   tableau pragma alors
   sinon type privé
               procédure limitée Elsif
               boucle de fin
   commencer l'entrée augmenter l'utilisation
   plage d'exceptions du corps
               quitter l'enregistrement du mod quand
                                       rem pendant que
                            nouveaux noms avec
   cas de non-retour
   fonction constante nulle inverse xor

Un mot réservé ne doit pas être utilisé comme identifiant déclaré.

Remarques:

Mots réservés ne différant que par l'utilisation des majuscules et des minuscules correspondantes 
les lettres de cas sont considérées comme identiques (voir 2.3). Dans certains attributs, le
l'identifiant qui apparaît après l'apostrophe est identique à certains réservés
mot.
Références : attribut 4.1.4, déclaration 3.1, identifiant 2.3, minuscule
lettre 2.1, lettre majuscule 2.1   

2.10 Remplacements de caractères autorisés 

Les remplacements suivants sont autorisés pour la barre verticale, pointue et
caractères de base de la citation :

 - Un caractère barre verticale (|) peut être remplacé par un point d'exclamation
    (!) lorsqu'il est utilisé comme délimiteur.

 - Les caractères dièses (#) d'un littéral basé peuvent être remplacés par des deux-points
    (:) à condition que le remplacement soit effectué pour les deux occurrences.

 - Les guillemets ("") utilisés comme crochets de chaîne aux deux extrémités d'un
    le littéral de chaîne peut être remplacé par des caractères de pourcentage (%) à condition que 
    la séquence de caractères ci-jointe ne contient aucun caractère de guillemet,
    et à condition que les deux supports de cordes soient remplacés. N'importe quel pourcentage
    caractère dans la séquence de caractères doit alors être doublé et
    chacun de ces caractères de pourcentage doublé est interprété comme un seul pourcentage
    valeur du caractère.                                                   

Ces remplacements ne changent pas le sens du programme.

Remarques:

Il est recommandé d'utiliser des remplacements pour la barre verticale, pointus,
et les guillemets soient limités aux cas où le texte correspondant
les symboles graphiques ne sont pas disponibles. Notez que la barre verticale apparaît comme
une barre cassée sur certains équipements ; le remplacement n'est pas recommandé dans ce cas
cas. 

Les règles données pour les identifiants et les littéraux numériques sont telles que des valeurs inférieures
les lettres majuscules et majuscules peuvent être utilisées indifféremment ; ces lexicaux
les éléments peuvent ainsi être écrits en utilisant uniquement les caractères du caractère de base
ensemble. Si une chaîne littérale du type prédéfini STRING contient des caractères
qui ne figurent pas dans le jeu de caractères de base, la même séquence de caractères
les valeurs peuvent être obtenues en caténant des chaînes littérales qui contiennent uniquement
caractères du jeu de caractères de base avec des constantes de caractères appropriées
déclaré dans le package prédéfini ASCII. Ainsi la chaîne littérale "AB$CD"
pourrait être remplacé par "AB" & ASCII.DOLLAR & "CD". De même, la chaîne
le littéral "ABcd" avec des lettres minuscules pourrait être remplacé par "AB" &
ASCII.LC_C & ASCII.LC_D.

Références : paquet prédéfini C ascii, basé sur le littéral 2.4.2, basique
caractère 2.1, opération de caténation 4.5.3, valeur de caractère 3.5.2, délimiteur
2.2, caractère graphique 2.1, symbole graphique 2.1, identifiant 2.3, lexical
élément 2.2, lettre minuscule 2.1, littéral numérique 2.4, parenthèse de chaîne
2.6, chaîne littérale 2.6, lettre majuscule 2.1  
