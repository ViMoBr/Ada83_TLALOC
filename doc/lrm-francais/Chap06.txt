
                             6. Sous-programmes   

Les sous-programmes sont l'une des quatre formes d'unité de programme, dont les programmes
peut être composé. Les autres formulaires sont des packages, des unités de tâches et des génériques.
unités.

Un sous-programme est une unité de programme dont l'exécution est invoquée par un sous-programme
appel. Il existe deux formes de sous-programmes : les procédures et les fonctions. UN
l'appel de procédure est une instruction ; un appel de fonction est une expression et
renvoie une valeur. La définition d'un sous-programme peut être donnée en deux parties :
une déclaration de sous-programme définissant ses conventions d'appel, et un sous-programme
organe définissant son exécution.

Références : fonction 6.5, appel de fonction 6.4, unité générique 12, package 7,
procédure 6.1, appel de procédure 6.4, corps de sous-programme 6.3, appel de sous-programme
6.4, déclaration de sous-programme 6.1, unité de tâche 9  

6.1 Déclarations de sous-programme 

Une déclaration de sous-programme déclare une procédure ou une fonction, comme indiqué
par le mot réservé initial. 

   subprogram_declaration ::= subprogram_spécification ;

   spécification_sous-programme ::=
        identifiant de procédure [formal_part]
      | désignateur de fonction [formal_part] return type_mark

   désignateur ::= identifiant | symbole_opérateur

   opérateur_symbole ::= string_literal

   formal_part ::=
      (paramètre_spécification {; paramètre_spécification})

   spécification_paramètre ::=
      liste_identifiant : mode type_mark [:= expression]

   mode ::= [dans] | entrée dehors | dehors 

La spécification d'une procédure précise son identifiant et sa forme
paramètres (le cas échéant). La spécification d'une fonction précise son 
désignateur, ses paramètres formels (le cas échéant) et le sous-type du renvoyé
value (le sous-type de résultat). Un désignateur qui est un symbole d'opérateur est 
utilisé pour la surcharge d'un opérateur. La séquence de caractères
représenté par un symbole d'opérateur doit être un opérateur appartenant à l'un des
les six classes d'opérateurs surchargeables définies à la section 4.5 (extra
les espaces ne sont pas autorisés et la casse des lettres n'est pas significative).                                                  

Une spécification de paramètre avec plusieurs identifiants équivaut à un
séquence de spécifications de paramètres uniques, comme expliqué dans la section 3.2.
Chaque spécification de paramètre unique déclare un paramètre formel. Sinon
mode est explicitement donné, le mode in est supposé. Si un paramètre
la spécification se termine par une expression, l'expression est la valeur par défaut
expression du paramètre formel. Une expression par défaut n'est autorisée que
dans une spécification de paramètre si le mode est (que ce mode soit
indiqué explicitement ou implicitement). Le type d'une expression par défaut doit
être celui du paramètre formel correspondant.

L'utilisation d'un nom désignant un paramètre formel n'est pas autorisée par défaut
expressions d'une partie formelle si la spécification du paramètre est
lui-même donné dans cette partie formelle.

L'élaboration d'une déclaration de sous-programme élabore les
partie formelle. L'élaboration d'une partie formelle n'a pas d'autre effet.

Exemples de déclarations de sous-programme :

   procédure TRAVERSE_TREE ;
   procédure INCREMENT(X : entrée sortie INTEGER);
   procédure RIGHT_INDENT(MARGIN : out LINE_SIZE); -- voir 3.5.4
   procédure SWITCH(FROM, TO : entrée sortie LINK); -- voir 3.8.1

   fonction RANDOM renvoie PROBABILITÉ ; -- voir 3.5.7   

   la fonction MIN_CELL(X : LINK) renvoie CELL ; -- voir 3.8.1
   fonction NEXT_FRAME(K : POSITIVE) return FRAME; -- voir 3.8
   la fonction DOT_PRODUCT(LEFT,RIGHT: VECTOR) renvoie REAL ; -- voir 3.6

   fonction "*"(GAUCHE, DROITE : MATRIX) return MATRIX; -- voir 3.6 

Exemples de paramètres in avec expressions par défaut : 

 procédure PRINT_HEADER(PAGES : en NATUREL;
               HEADER : in LINE := (1 .. LINE'LAST => ' '); -- voir 3.6
               CENTRE : en BOOLÉEN := VRAI);

Remarques:

L'évaluation des expressions par défaut est provoquée par certains sous-programmes
appels, comme décrit dans la section 6.4.2 (les expressions par défaut ne sont pas évaluées
lors de l'élaboration de la déclaration du sous-programme).

Tous les sous-programmes peuvent être appelés de manière récursive et sont réentrants. 

Références : déclaration 3.1, élaboration 3.9, évaluation 4.5, expression
4.4, paramètre formel 6.2, fonction 6.5, identifiant 2.3, liste d'identifiants
3.2, mode 6.2, nom 4.1, l'élaboration n'a pas d'autre effet 3.9, opérateur 4.5,
surcharge 6.6 8.7, procédure 6, chaîne littérale 2.6, appel de sous-programme 6.4, 
marque de type 3.3.2                                                                      

6.2 Modes de paramètres formels 

La valeur d'un objet est dite lue lorsque cette valeur est évaluée ; il
est également dit lu lorsqu'un de ses sous-composants est lu. La valeur
d'une variable est dite mise à jour lorsqu'une affectation est effectuée à la
variable, et aussi (indirectement) lorsque la variable est utilisée comme valeur réelle
paramètre d'un appel de sous-programme ou d'une instruction d'appel d'entrée qui met à jour son
valeur; on dit aussi qu'il est mis à jour lorsqu'un de ses sous-composants est
mis à jour.

Un paramètre formel d'un sous-programme a l'un des trois modes suivants :

 in Le paramètre formel est une constante et permet uniquement la lecture
         de la valeur du paramètre réel associé.

 in out Le paramètre formel est une variable et permet à la fois la lecture et
         mise à jour de la valeur du paramètre réel associé.

 out Le paramètre formel est une variable et permet de mettre à jour le
         valeur du paramètre réel associé.

         La valeur d'un paramètre scalaire qui n'est pas mis à jour par l'appel
         n'est pas défini au retour ; il en va de même pour la valeur d'un
         sous-composant scalaire, autre qu’un discriminant. Lire le
         limites et discriminants du paramètre formel et de ses
         les sous-composants sont autorisés, mais aucune autre lecture.

Pour un paramètre scalaire, les effets ci-dessus sont obtenus par copie : au
début de chaque appel, si le mode est in ou in out, la valeur du courant réel
Le paramètre est copié dans le paramètre formel associé ; puis après
achèvement normal du corps du sous-programme, si le mode est in out ou out, le
La valeur du paramètre formel est recopiée dans le paramètre réel associé.
paramètre. Pour un paramètre dont le type est un type d'accès, la copie est utilisée
pour les trois modes, et recopie pour les modes in out et out.

Pour un paramètre dont le type est un type de tableau, d'enregistrement ou de tâche, un
la mise en œuvre peut également obtenir les effets ci-dessus par copie, comme pour
types scalaires. De plus, si copy est utilisé pour un paramètre de mode out,
alors la copie est requise au moins pour les limites et les discriminants du
paramètre réel et de ses sous-composants, ainsi que pour chaque sous-composant
dont le type est un type d'accès. Alternativement, une mise en œuvre peut atteindre
ces effets par référence, c'est-à-dire en faisant en sorte que chaque utilisation du
paramètre formel (pour lire ou mettre à jour sa valeur) soit traité comme une utilisation de
le paramètre réel associé, tout au long de l'exécution du sous-programme
appel. Le langage ne définit pas lequel de ces deux mécanismes doit être
adopté pour le passage des paramètres, ni si différents appels au même
Le sous-programme doit utiliser le même mécanisme. L'exécution d'un programme est
erroné si son effet dépend du mécanisme choisi par le
mise en œuvre.

Pour un paramètre dont le type est un type privé, les effets ci-dessus sont
réalisé selon la règle qui s'applique au type complet correspondant
déclaration.   

Dans le corps d'un sous-programme, un paramètre formel est soumis à n'importe quelle
contrainte résultant de la marque de type donnée en paramètre
spécification. Pour un paramètre formel d'un type tableau sans contrainte, le
les limites sont obtenues à partir du paramètre réel et le paramètre formel est
contraint par ces limites (voir 3.6.1). Pour un paramètre formel dont
La déclaration spécifie un type sans contrainte (privé ou enregistrement) avec
discriminants, les discriminants du paramètre formel sont initialisés
avec les valeurs des discriminants correspondants du paramètre réel ;
le paramètre formel est sans contrainte si et seulement si le mode est in out ou
out et le nom de variable donné pour le paramètre réel indique un
variable sans contrainte (voir 3.7.1 et 6.4.1).

Si le paramètre réel d'un appel de sous-programme est un sous-composant qui dépend
sur les discriminants d'une variable d'enregistrement non contrainte, puis l'exécution de
l'appel est erroné si la valeur de l'un des discriminants du  
la variable est modifiée par cette exécution ; cette règle ne s'applique pas si le
le mode est activé et le type du sous-composant est un type scalaire ou un accès
taper.                                                                                

Remarques:

Pour les paramètres de type tableau et enregistrement, les règles de transmission des paramètres ont
ces conséquences :

 - Si l'exécution d'un sous-programme est abandonnée suite à un
    exception, la valeur finale d'un paramètre réel d'un tel type peut
    être soit sa valeur avant l'appel, soit une valeur attribuée au formel
    paramètre lors de l’exécution du sous-programme.

 - Si aucun paramètre réel d'un tel type n'est accessible par plus d'un
    chemin, alors l'effet d'un appel de sous-programme (sauf abandon) est le
    même si l'implémentation utilise ou non la copie pour le paramètre
    qui passe. Toutefois, s'il existe plusieurs chemins d'accès à un tel
    paramètre (par exemple, si une variable globale ou un autre paramètre formel
    paramètre, fait référence au même paramètre réel), puis la valeur du
    formel n'est pas défini après la mise à jour du réel autrement qu'en mettant à jour
    le formel. Un programme utilisant une valeur aussi indéfinie est erroné.

Les mêmes modes de paramètres sont définis pour les paramètres formels des entrées (voir
9.5) avec la même signification que pour les sous-programmes. Différents modes de paramètres
sont définis pour les paramètres formels génériques (voir 12.1.1).

Pour tous les modes, si un paramètre réel désigne une tâche, le paramètre associé
le paramètre formel désigne la même tâche ; il en va de même pour un
sous-composant d'un paramètre réel et le sous-composant correspondant de
le paramètre formel associé.

Références : type d'accès 3.8, paramètre réel 6.4.1, type de tableau 3.6,
affectation 5.2, borne d'un tableau 3.6.1, contrainte 3.3, dépend d'un
discriminant 3.7.1, discriminant 3.7.1, déclaration d'appel d'entrée 9.5, erronée
1.6, évaluation 4.5, exception 11, expression 4.4, paramètre formel 6.1,
paramètre formel générique 12.1, global 8.1, mode 6.1, valeur d'accès nulle 3.8,
objet 3.2, spécification de paramètre 6.1, type privé 7.4, type d'enregistrement 3.7,
type scalaire 3.5, sous-composant 3.3, corps du sous-programme 6.3, appel de sous-programme
instruction 6.4, tâche 9, type de tâche 9.2, marque de type 3.3.2, tableau sans contrainte
type 3.6, sans contrainte type avec discriminants 3.7.1, sans contrainte
variable 3.2.1, variable 3.2.1   

6.3 Corps des sous-programmes 

Un corps de sous-programme spécifie l'exécution d'un sous-programme.

   corps_sous-programme ::=
       spécification_sous-programme est
          [partie déclarative]
       commencer
           séquence_of_statements
      [exception
           exception_handler
          {exception_handler}] 
       fin [désignateur] ;

La déclaration d'un sous-programme est facultative. En l'absence d'un tel
déclaration, la spécification du sous-programme du corps du sous-programme (ou du corps
stub) fait office de déclaration. Pour chaque déclaration de sous-programme, il faut
être un corps correspondant (sauf pour un sous-programme écrit dans un autre
langue, comme expliqué à la section 13.9). Si à la fois une déclaration et un corps
sont données, la spécification du sous-programme du corps doit être conforme aux
spécification du sous-programme de la déclaration (voir la section 6.3.1 pour
règles de conformité).                                              

Si un indicateur apparaît à la fin du corps d'un sous-programme, il doit répéter le
désignateur de la spécification du sous-programme.

L'élaboration d'un organe de sous-programme n'a d'autre effet que d'établir
que le corps puisse désormais être utilisé pour l'exécution des appels du
sous-programme.

L'exécution d'un corps de sous-programme est invoquée par un appel de sous-programme (voir
6.4). Pour cette exécution, après avoir établi l'association entre
paramètres formels et paramètres réels, la partie déclarative du corps
est élaboré, et la séquence d'énoncés du corps est ensuite exécutée.
Une fois le corps terminé, le retour est effectué vers l'appelant (et tout
la recopie nécessaire des paramètres formels vers les paramètres réels a lieu (voir 6.2)).
Les gestionnaires d'exceptions facultatifs à la fin d'un descripteur de corps de sous-programme
exceptions soulevées lors de l'exécution de la séquence d'instructions du
corps du sous-programme (voir 11.4).

Note:

Il résulte des règles de visibilité que si un sous-programme déclaré dans un
package doit être visible à l’extérieur du package, une spécification de sous-programme
doit être indiqué dans la partie visible du colis. Les mêmes règles dictent
qu'une déclaration de sous-programme doit être donnée si un appel du sous-programme
apparaît textuellement avant le corps du sous-programme (la déclaration doit alors
se produire avant l'appel dans le texte du programme). Les règles données dans
les sections 3.9 et 7.1 impliquent qu'une déclaration de sous-programme et le
le corps correspondant doit apparaître immédiatement dans le même corps déclaratif
région.

Exemple de corps de sous-programme :

   la procédure PUSH(E : in ELEMENT_TYPE; S : in out STACK) est
   commencer
      si S.INDEX = S.TAILLE alors
         augmenter STACK_OVERFLOW ;
      autre
         S.INDEX := S.INDEX + 1;
         S.ESPACE(S.INDEX) := E;
      fin si;
   terminer POUSSER ; 

Références : paramètre actuel 6.4.1, stub du corps 10.2, conforme 6.3.1, 
déclaration 3.1, partie déclarative 3.9, région déclarative 8.1, désignateur
6.1, élaboration 3.9, l'élaboration n'a pas d'autre effet 3.1, exception 11,
le gestionnaire d'exceptions 11.2, paramètre formel 6.1, se produit immédiatement dans 8.1,
package 7, séquence d'instructions 5.1, sous-programme 6, appel de sous-programme 6.4,
déclaration de sous-programme 6.1, spécification de sous-programme 6.1, visibilité 8.3,
partie visible 7.2   

6.3.1 Règles de conformité  

Chaque fois que les règles linguistiques exigent ou permettent la spécification d'un
sous-programme devant être fourni à plusieurs endroits, les variations suivantes
sont autorisés à chaque endroit :

 - Un littéral numérique peut être remplacé par un littéral numérique différent si
    et seulement si les deux ont la même valeur.

 - Un nom simple peut être remplacé par un nom développé dans lequel ce simple
    name est le sélecteur, si et seulement si aux deux endroits la signification du
    le nom simple est donné par la même déclaration.

 - Une chaîne littérale donnée comme symbole d'opérateur peut être remplacée par un
    chaîne littérale différente si et seulement si les deux représentent la même chose
    opérateur.                                                                       

Deux spécifications de sous-programme sont dites conformes si, hormis les commentaires
et les variations autorisées ci-dessus, les deux spécifications sont formées par le
même séquence d'éléments lexicaux, et les éléments lexicaux correspondants sont
donné le même sens par les règles de visibilité et de surcharge.

La conformité est également définie pour les parties formelles, les parties discriminantes et
marques de type (pour les constantes différées et pour les paramètres réels qui ont le
forme d'une conversion de type (voir 6.4.1)).

Remarques: 

Un nom simple peut être remplacé par un nom développé même si le nom simple
est lui-même le préfixe d'un composant sélectionné. Par exemple, QR peut être
remplacé par PQR si Q est déclaré immédiatement dans P.

Les spécifications suivantes ne sont pas conformes car elles ne sont pas constituées par
la même séquence d'éléments lexicaux :

   procédure P(X,Y : ENTIER)
   procédure P(X : ENTIER; Y : ENTIER)
   procédure P(X,Y : en ENTIER) 

Références : paramètre actuel 6.4 6.4.1, autoriser 1.6, commentaire 2.7,
déclaration 3.1, constante différée 7.4.3, visibilité directe 8.3,
partie discriminante 3.7.1, nom étendu 4.1.3, partie formelle 6.1, lexical
élément 2, nom 4.1, littéral numérique 2.4, symbole d'opérateur 6.1, surcharge
6.6 8.7, préfixe 4.1, composant sélectionné 4.1.3, sélecteur 4.1.3, nom simple
4.1, spécification de sous-programme 6.1, conversion de type 4.6, visibilité 8.3   

6.3.2 Extension en ligne des sous-programmes 

Le pragma INLINE est utilisé pour indiquer que l'expansion en ligne du
Le corps du sous-programme est souhaité pour chaque appel de chacun des sous-programmes nommés.
La forme de ce pragma est la suivante :

   pragma INLINE (nom {, nom});

Chaque nom est soit le nom d'un sous-programme, soit le nom d'un programme générique.
sous-programme. Le pragma INLINE n'est autorisé qu'à l'endroit d'un
élément déclaratif dans une partie déclarative ou une spécification de package, ou après un
unité de bibliothèque dans une compilation, mais avant toute unité de compilation ultérieure.

Si le pragma apparaît à la place d'une rubrique déclarative, chaque nom doit
désigne un sous-programme ou un sous-programme générique déclaré par un précédent
élément déclaratif de la même partie déclarative ou spécification de package. Si
plusieurs sous-programmes (surchargés) satisfont à cette exigence, le pragma
s'applique à tous. Si le pragma apparaît après une unité de bibliothèque donnée,
le seul nom autorisé est le nom de cette unité. Si le nom d'un générique 
le sous-programme est mentionné dans le pragma, cela indique que l'expansion en ligne
est souhaité pour les appels de tous les sous-programmes obtenus par instanciation du 
unité générique nommée.

La signification d'un sous-programme n'est pas modifiée par le pragma INLINE. Pour chaque
appel des sous-programmes nommés, une implémentation est libre de suivre ou de
ignorer la recommandation exprimée par le pragma. (Remarquez notamment
que la recommandation ne peut généralement pas être suivie pour un traitement récursif
sous-programme.) 

Références : allow 1.6, compilation 10.1, unité de compilation 10.1,
élément déclaratif 3.9, partie déclarative 3.9, sous-programme générique 12.1,
unité générique 12 12.1, instanciation 12.3, unité bibliothèque 10.1, nom 4.1,
surcharge 6.6 8.7, spécification du package 7.1, pragma 2.8, sous-programme 6,
corps du sous-programme 6.3, appel du sous-programme 6.4                                          

6.4 Appels de sous-programme 

Un appel de sous-programme est soit une instruction d'appel de procédure, soit un appel de fonction ;
il invoque l'exécution du corps du sous-programme correspondant. L'appel
spécifie l'association des paramètres réels, le cas échéant, avec des
paramètres du sous-programme.

   procédure_call_statement ::=
       nom_procédure [actual_parameter_part] ;

   appel_fonction ::=
       nom_fonction [actual_parameter_part]

   actual_parameter_part ::=
       (paramètre_association {, paramètre_association})

   paramètre_association ::=
      [paramètre_formal =>] paramètre_actuel

   formal_parameter ::= paramètre_simple_name

   paramètre_actuel ::=
      expressions | nom_variable | type_mark(nom_variable) 

Chaque association de paramètres associe un paramètre réel à un
paramètre formel correspondant. Une association de paramètres est dite
nommé si le paramètre formel est nommé explicitement ; on dit autrement
être positionnel. Pour une association positionnelle, le paramètre réel
correspond au paramètre formel avec la même position dans le formel
partie.

Les associations nommées peuvent être données dans n'importe quel ordre, mais si à la fois leur position et leur position
les associations nommées sont utilisées dans le même appel, les associations positionnelles doivent
se produisent en premier, à leur position normale. Par conséquent, une fois qu'une association nommée est
utilisé, le reste de l'appel doit utiliser uniquement des associations nommées.

Pour chaque paramètre formel d'un sous-programme, un appel de sous-programme doit spécifier
exactement un paramètre réel correspondant. Ce paramètre réel est
spécifié soit explicitement, par une association de paramètres, soit, en l'absence
d'une telle association, par une expression par défaut (voir 6.4.2).

Les associations de paramètres d'un appel de sous-programme sont évaluées dans un certain ordre
cela n’est pas défini par la langue. De même, les règles linguistiques ne
définir dans quel ordre les valeurs des paramètres in out ou out sont copiées
revenir aux paramètres réels correspondants (une fois cela fait).

Exemples d'appels de procédure :

 TRAVERSE_TREE ; -- voir 6.1
 TABLE_MANAGER.INSERT(E); -- voir 7.5
 PRINT_HEADER(128, TITRE, VRAI); -- voir 6.1

 COMMUTATEUR(DE => X, À => SUIVANT); -- voir 6.1
 PRINT_HEADER(128, HEADER => TITLE, CENTER => TRUE -- voir 6.1
 PRINT_HEADER(HEADER => TITRE, CENTRE => VRAI, PAGES => 128); -- voir 6.1

Exemples d'appels de fonctions :

   DOT_PRODUCT(U, V) -- voir 6.1 et 6.5
   HORLOGE -- voir 9.6                                                  

Références : expression par défaut pour un paramètre formel 6.1, erronée 1.6,
expression 4.4, paramètre formel 6.1, partie formelle 6.1, nom 4.1, simple
nom 4.1, sous-programme 6, marque de type 3.3.2, variable 3.2.1   

6.4.1 Associations de paramètres 

Chaque paramètre réel doit avoir le même type que le paramètre formel correspondant.
paramètre.

Un paramètre réel associé à un paramètre formel de mode in doit être
une expression; il est évalué avant l'appel.

Un paramètre réel associé à un paramètre formel de mode in out ou
out doit être soit le nom d'une variable, soit la forme d'un type
conversion dont l'argument est le nom d'une variable. Dans les deux cas, pour
le mode in out, la variable ne doit pas être un paramètre formel du mode out ou
un sous-composant de celui-ci. Pour un paramètre réel qui a la forme d'un
conversion de type, la marque de type doit être conforme (voir 6.3.1) à la marque de type de
le paramètre formel ; les types d'opérandes et de cibles autorisés sont les mêmes que
pour les conversions de types (voir 4.6).

Le nom de variable donné pour un paramètre réel du mode in out ou out est
évalué avant l’appel. Si le paramètre réel a la forme d'un type
conversion, puis avant l'appel, pour un paramètre de mode in out, le
la variable est convertie dans le type spécifié ; après l'achèvement (normal) de
le corps du sous-programme, pour un paramètre de mode in out ou out, le formel
Le paramètre est reconverti en type de variable. (Le type
spécifié dans la conversion doit être celui du paramètre formel.)

Les contrôles de contraintes suivants sont effectués pour les paramètres scalaires et
types d'accès :

 - Avant l'appel : pour un paramètre de mode in ou in out, il est vérifié
    que la valeur du paramètre réel appartient au sous-type du
   paramètre formel.

 - Après achèvement (normal) du corps du sous-programme : pour un paramètre de
    mode in out ou out, on vérifie que la valeur du formel
    Le paramètre appartient au sous-type de la variable réelle. Dans le cas
    d'une conversion de type, la valeur du paramètre formel est convertie
    et le contrôle s'applique au résultat de la conversion.

Dans chacun des cas ci-dessus, l'exécution du programme est erronée si
la valeur vérifiée n'est pas définie.

Pour les autres types, pour tous les modes, une vérification est effectuée avant l'appel comme pour
types scalaires et d'accès ; aucun contrôle n'est effectué au retour.

L'exception CONSTRAINT_ERROR est levée à l'endroit du sous-programme
appelez si l’une de ces vérifications échoue.  

Note:

Pour les types tableaux et pour les types avec discriminants, la vérification avant l'appel
est suffisant (un contrôle au retour serait redondant) si la marque de type de
le paramètre formel désigne un sous-type contraint, puisque ni le tableau
les limites ni les discriminants ne peuvent alors varier.                                                  

Si cette marque de type désigne un type de tableau sans contrainte, le paramètre formel
est contraint par les limites du paramètre réel correspondant et aucun
un contrôle (ni avant l'appel ni au retour) n'est nécessaire (voir 3.6.1).
De même, aucune vérification n'est nécessaire si la marque de type indique un
type avec discriminants, puisque le paramètre formel est alors contraint  
exactement comme le paramètre réel correspondant (voir 3.7.1).

Références : paramètre réel 6.4, tableau lié 3.6, type de tableau 3.6, appel de
un sous-programme 6.4, conforme 6.3.1, sous-type contraint 3.3, contrainte 3.3,
constraint_error exception 11.1, discriminant 3.7.1, erroné 1.6,
évaluation 4.5, évaluation d'un nom 4.1, expression 4.4, paramètre formel
6.1, mode 6.1, nom 4.1, association de paramètres 6.4, sous-type 3.3, type 3.3,
conversion de type 4.6, marque de type 3.3.2, type de tableau sans contrainte 3.6,
type sans contrainte avec discriminants 3.7.1, valeur non définie 3.2.1,
variable 3.2.1   

6.4.2 Paramètres par défaut 

Si une spécification de paramètre inclut une expression par défaut pour un paramètre
du mode in, alors les appels de sous-programme correspondants n'ont pas besoin d'inclure un
association de paramètres pour le paramètre. Si une association de paramètres est
donc omis d'un appel, puis le reste de l'appel, suite à tout initial
les associations de position, doivent utiliser uniquement des associations nommées.

Pour toute association de paramètres omise, l'expression par défaut est évaluée
avant l'appel et la valeur résultante est utilisée comme valeur réelle implicite
paramètre.

Exemples de procédures avec valeurs par défaut :

   procédure ACTIVATE(PROCESS : dans PROCESS_NAME;
                      APRÈS : dans PROCESS_NAME := NO_PROCESS ;
                      ATTENDRE : en DURÉE := 0.0;
                      PRIOR : en BOOLEAN := FALSE);

   procédure PAIR(LEFT, RIGHT : PERSON_NAME := new PERSONNE);

Exemples de leurs appels :

   ACTIVER(X);
   ACTIVER(X, APRÈS => Y);
   ACTIVER(X, ATTENDRE => 60.0, AVANT => VRAI);
   ACTIVER(X, Y, 10.0, FAUX);

   PAIRE;
   PAIRE(GAUCHE => nouvelle PERSONNE, DROITE => nouvelle PERSONNE);

Note:

Si une expression par défaut est utilisée pour deux paramètres ou plus dans un multiple
spécification du paramètre, l'expression par défaut est évaluée une fois pour chaque 
paramètre omis. Ainsi dans les exemples ci-dessus, les deux appels de PAIR sont
équivalent.

Références : paramètre actuel 6.4.1, expression par défaut pour un
paramètre 6.1, évaluation 4.5, paramètre formel 6.1, mode 6.1, nommé
association de paramètres 6.4, association de paramètres 6.4, paramètre
spécification 6.1, association de paramètres de position 6.4, appel de sous-programme
6.4                                                                                   

6.5 Sous-programmes de fonction 

Une fonction est un sous-programme qui renvoie une valeur (le résultat de la fonction
appel). La spécification d'une fonction commence par le mot réservé
fonction, et les paramètres, le cas échéant, doivent avoir le mode activé (que ce soit
le mode est spécifié explicitement ou implicitement). Les déclarations du
corps de fonction (à l'exclusion des instructions d'unités de programme internes au
corps de la fonction) doit inclure une ou plusieurs instructions return spécifiant le
valeur renvoyée.

L'exception PROGRAM_ERROR est levée si un corps de fonction est laissé sinon
que par une instruction return. Ceci ne s'applique pas si l'exécution du
la fonction est abandonnée à la suite d’une exception.

Exemple:

   la fonction DOT_PRODUCT(LEFT, RIGHT : VECTOR) renvoie REAL est
      SOMME : RÉEL := 0.0;
   commencer
      CHECK(LEFT'FIRST = DROITE'FIRST et GAUCHE'LAST = DROITE'LAST);
      pour J dans la boucle LEFT'RANGE
         SOMME := SOMME + GAUCHE(J)*DROITE(J);
      terminer la boucle ;
      retourner la SOMME ;
   terminer DOT_PRODUCT ;

Références : exception 11, paramètre formel 6.1, fonction 6.1, fonction
corps 6.3, appel de fonction 6.4, spécification de fonction 6.1, mode 6.1,
exception program_error 11.1, levée d'exceptions 11, instruction return
5.8, déclaration 5   

6.6 Profil de type de paramètre et de résultat - Surcharge des sous-programmes 

On dit que deux parties formelles ont le même profil de type de paramètre si et
seulement s'ils ont le même nombre de paramètres, et à chaque paramètre
Les paramètres correspondant à la position ont le même type de base. Un sous-programme ou
l'entrée a le même profil de paramètre et de type de résultat qu'un autre sous-programme
ou entrée si et seulement si les deux ont le même profil de type de paramètre, et
soit les deux sont des fonctions avec le même type de base de résultats, soit aucun des deux
deux est une fonction.

Le même identifiant de sous-programme ou symbole d'opérateur peut être utilisé dans plusieurs
spécifications du sous-programme. L'identifiant ou symbole de l'opérateur est alors dit
être surchargé; les sous-programmes qui ont cet identifiant ou cet opérateur
on dit également que les symboles sont surchargés et se surchargent mutuellement. Comme
expliqué à la section 8.3, si deux sous-programmes se surchargent, l'un des
ils ne peuvent cacher l'autre que si les deux sous-programmes ont le même paramètre
et profil de type de résultat (voir la section 8.3 pour les autres exigences qui
doit être satisfait pour se cacher).  

Un appel à un sous-programme surchargé est ambigu (et donc illégal) si
le nom du sous-programme, le nombre d'associations de paramètres, le
types et l'ordre des paramètres réels, les noms des formels
paramètres (si des associations nommées sont utilisées) et le type de résultat (pour
fonctions) ne suffisent pas à en déterminer exactement une (surchargée)
spécification du sous-programme.                                                               

Exemples de sous-programmes surchargés :

   procédure PUT(X : ENTIER);
   procédure PUT(X : CHAÎNE);

   procédure SET(TEINE : COULEUR);
   procédure SET(SIGNAL : LUMIÈRE);

Exemples d'appels :

   METTRE(28);
   PUT("pas d'ambiguïté possible ici");

   SET(TEINE => ROUGE);
   ENSEMBLE(SIGNAL => ROUGE);
   ENSEMBLE(COULEUR'(ROUGE));

   -- SET(RED) serait ambigu puisque RED peut
   -- désigne une valeur soit de type COULEUR, soit de type LUMIÈRE

Remarques:

La notion de paramètre et de profil de type résultat n'inclut pas les paramètres
noms, modes de paramètres, sous-types de paramètres, expressions par défaut et leurs
Présence ou absence.

Des ambiguïtés peuvent (mais pas nécessairement) surgir lorsque les paramètres réels de l'appel de
un sous-programme surchargé sont eux-mêmes des appels de fonction surchargés,
des littéraux ou des agrégats. Des ambiguïtés peuvent également (mais pas nécessairement) surgir lorsque
plusieurs sous-programmes surchargés appartenant à différents packages sont visibles.
Ces ambiguïtés peuvent généralement être résolues de plusieurs manières :
les expressions peuvent être utilisées pour certains ou tous les paramètres réels, et pour le
résultat, le cas échéant ; le nom du sous-programme peut être exprimé plus
explicitement sous forme de nom développé ; enfin, le sous-programme peut être renommé.

Références : paramètre actuel 6.4.1, agrégat 4.3, type de base 3.3, par défaut
expression pour un paramètre formel 6.1, entrée 9.5, paramètre formel 6.1,
fonction 6.5, appel de fonction 6.4, masquage 8.3, identifiant 2.3, illégal 1.6,
littéral 4.2, mode 6.1, association de paramètres nommée 6.4, symbole d'opérateur
6.1, surcharge 8.7, package 7, paramètre d'un sous-programme 6.2, qualifié
expression 4.7, déclaration de renommage 8.5, sous-type de résultat 6.1, sous-programme 6,
spécification de sous-programme 6.1, sous-type 3.3, type 3.3   

6.7 Surcharge des opérateurs 

La déclaration d'une fonction dont le désignateur est un symbole d'opérateur est 
utilisé pour surcharger un opérateur. La séquence de caractères de l'opérateur
Le symbole doit être soit un logique, soit un relationnel, soit un ajout binaire, soit un unaire.
un opérateur d'addition, de multiplication ou de priorité la plus élevée (voir 4.5). Ni l'un ni l'autre
les tests d'adhésion ni les formulaires de contrôle de court-circuit ne sont autorisés car
désignateurs de fonction. 

La spécification de sous-programme d'un opérateur unaire doit avoir un seul
paramètre. La spécification de sous-programme d'un opérateur binaire doit avoir deux
paramètres; pour chaque utilisation de cet opérateur, le premier paramètre prend le
l'opérande gauche comme paramètre réel, le deuxième paramètre prend l'opérande droit
opérande. De même, une instanciation de fonction générique dont le désignateur est
un symbole d'opérateur n'est autorisé que si la spécification du nom générique
La fonction a le nombre correspondant de paramètres. Expressions par défaut
ne sont pas autorisés pour les paramètres d'un opérateur (que l'opérateur soit
déclaré avec une spécification explicite de sous-programme ou par un générique
instanciation).                                              

Pour chacun des opérateurs "+" et "-", la surcharge est autorisée à la fois à titre de
unaire et comme opérateur binaire.

La déclaration explicite d'une fonction qui surcharge l'opérateur d'égalité
"=", autrement que par une déclaration de renommage, n'est autorisé que si les deux
les paramètres sont du même type limité. Une surcharge d’égalité doit
délivrer un résultat de type prédéfini BOOLEAN ; c'est aussi implicitement
surcharge l'opérateur d'inégalité "/=" afin que cela donne toujours le
résultat complémentaire à l’opérateur d’égalité. Surcharge explicite du
L’opérateur d’inégalité n’est pas autorisé.

Une déclaration de renommage dont le désignateur est l'opérateur d'égalité n'est que
autorisé à renommer un autre opérateur d’égalité. (Par exemple, un tel renommage
la déclaration peut être utilisée lorsque l'égalité est visible par sélection mais pas
directement visible.)

Note:

La surcharge des opérateurs relationnels n'affecte pas les comparaisons de base telles que
comme tester l'appartenance à une plage ou les choix dans une déclaration de cas.

Exemples:

   fonction "+" (GAUCHE, DROITE : MATRIX) renvoie MATRIX ;
   la fonction "+" (GAUCHE, DROITE : VECTEUR) renvoie VECTEUR ;

   -- en supposant que A, B et C sont du type VECTOR
   -- les trois missions suivantes sont équivalentes

   UNE := B + C;

   A := "+"(B,C);
   A := "+"(GAUCHE => B, DROITE => C);

Références : autoriser 1.6, paramètre réel 6.4.1, opérateur d'addition binaire 4.5
4.5.3, type booléen prédéfini 3.5.3, caractère 2.1, résultat complémentaire
4.5.2, déclaration 3.1, expression par défaut pour un paramètre formel 6.1,
désignateur 6.1, directement visible 8.3, opérateur d'égalité 4.5, formel
paramètre 6.1, déclaration de fonction 6.1, opérateur de priorité la plus élevée 4.5
4.5.6, déclaration implicite 3.1, opérateur d'inégalité 4.5.2, type limité
7.4.4, opérateur logique 4.5 4.5.1, test d'appartenance 4.5 4.5.2, multiplication
opérateur 4.5 4.5.5, opérateur 4.5, symbole opérateur 6.1, surcharge 6.6 8.7,
opérateur relationnel 4.5 4.5.2, forme de contrôle de court-circuit 4.5 4.5.1, type
définition 3.3.1, opérateur d'addition unaire 4.5 4.5.4, visible par sélection 8.3     
