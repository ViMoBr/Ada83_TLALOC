GRAMMAR.TXT

Ada Information Clearinghouse, 1-800-AdaIC-11 (232-4211), 703/681-2466

                      "A LALR(1) GRAMMAR FOR ANSI Ada"
                  BY GERRY FISHER AND PHILLIPE CHARLES, 1983

                       A LALR(1) grammar for ANSI Ada*

                              November 17, 1983
                                Gerry Fisher

                        Computer Sciences Corporation
                             4045 Hancock Street
                             San Diego, CA 92121


                              Phillipe Charles
                                 Ada Project
                             New York University
                              251 Mercer Street
                          New York, New York 10012


     This grammar is organized in the same order as the syntax summary     
  in appendix E of the ANSI Ada Reference Manual.   All reserved words     
  are   written  in  upper  case  letters.    The  lexical  categories     
  numeric_literal, string_literal, etc, are viewed as terminals.   The     
  rules  for  pragmas as  stated in  chapter 2,  section 8,  have been     
  incorporated in the grammar.   Comments are included wherever we had     
  to deviate from the syntax given in appendix E. Constructs involving     
  meta brackets, e.g., {, identifier} are represented by a nonterminal     
  formed  by  concatenating  the  construct symbols ( as {,identifier}     
  in the example)   for  which  the  rules are given at the end.  When     
  reading  this  grammar,  it  is  important to  note that all symbols     
  appearing  in the  rules are  separated by  one or  more  blanks.  A     
  string  such  as   'identifier:type_mark'   is  actually  a   single     
  nonterminal symbol defined at the end of the rules.  The '--' symbol     
  is used  to indicate that the rest of  the  line is a comment,  just     
  as in Ada programs.                                                        






  This grammar is  presented here in  a form suitable  for input to  a
LALR parser  generator.   It has  been  processed by  the  NYU  Parser
Generator and tested against Version 1.3 of the ACVC Test Suite.
                                                                             
 *Ada is a registered trade mark of the  Department of  Defense  (Ada     
  Joint Program  Office).                                                    



terminals -------------------------------------------------------------

  ABORT ABS ACCEPT  ACCESS ALL  AND ARRAY  AT BEGIN  BODY CASE  CONSTANT
  DECLARE DELAY DELTA DIGITS DO ELSE ELSIF END  ENTRY EXCEPTION EXIT FOR
  FUNCTION GENERIC  GOTO IF IN  IS LIMITED LOOP MOD  NEW NOT  NULL OF OR
  OTHERS OUT  PACKAGE PRAGMA  PRIVATE PROCEDURE  RAISE  RANGE RECORD REM
  RENAMES RETURN REVERSE  SELECT  SEPARATE SUBTYPE  TASK TERMINATE  THEN
  TYPE USE WHEN WHILE WITH XOR

  identifier    numeric_literal     string_literal     character_literal

  & ' ( ) * + , - . / : ;  < = >  '|' => .. **  := /=  >=  <= <<  >>  <>


%start -----------------------------------------------------------------

    compilation

%rules -----------------------------------------------------------------


-- 2.8

pragma  ::=
        PRAGMA identifier [(argument_association{,argument_association})] ;

argument_association  ::=
        [argument_identifier=>]expression__|__[argument_identifier=>]name  



-- 3.1

basic_declaration  ::=
        deferred_constant_declaration__|__object_declaration
   |    type_declaration               |  subtype_declaration
   |    subprogram_declaration         |  package_declaration
   |    task_declaration               |  generic_declaration
   |    exception_declaration          |  generic_instantiation
   |    renaming_declaration           |  number_declaration



-- 3.2

object_declaration  ::=
        identifier_list : [CONSTANT]subtype_indication [:=expression] ;
   |    identifier_list : [CONSTANT]constrained_array_definition
                                                        [:=expression] ;


number_declaration  ::=
        identifier_list : CONSTANT := universal_static_expression ;


identifier_list  ::=  identifier {,identifier}


-- 3.3.1

type_declaration  ::=
        full_type_declaration
   |    incomplete_type_declaration
   |    private_type_declaration

full_type_declaration  ::=  
        TYPE identifier [discriminant_part]IS type_definition ;


type_definition  ::=
        enumeration_type_definition     |  integer_type_definition
   |    real_type_definition            |  array_type_definition
   |    record_type_definition          |  access_type_definition
   |    derived_type_definition


-- 3.3.2

subtype_declaration  ::=  
        SUBTYPE identifier IS subtype_indication ;


subtype_indication  ::=  type_mark [constraint]


type_mark  ::=  type_name__|__subtype_name


constraint  ::=
        range_constraint
   |    floating_point_constraint  |  fixed_point_constraint
   |    index_constraint__|__discriminant_constraint



-- 3.4

derived_type_definition  ::=  NEW subtype_indication


-- 3.5

range_constraint  ::=  RANGE range

range  ::=
        range_attribute__|__simple_expression..simple_expression


-- 3.5.1

enumeration_type_definition  ::=
        ( enumeration_literal_specification
                        {,enumeration_literal_specification} )


enumeration_literal_specification  ::=  enumeration_literal

enumeration_literal  ::=  identifier  |  character_literal


-- 3.5.4

integer_type_definition  ::=  range_constraint


-- 3.5.6

real_type_definition  ::=  
        floating_point_constraint  |  fixed_point_constraint


-- 3.5.7

floating_point_constraint  ::=  
        floating_accuracy_definition [range_constraint]


floating_accuracy_definition  ::=  
        DIGITS static_simple_expression 


-- 3.5.9

fixed_point_constraint  ::=  
        fixed_accuracy_definition [range_constraint]


fixed_accuracy_definition  ::=  
        DELTA static_simple_expression 


-- 3.6

array_type_definition  ::=
        unconstrained_array_definition  |  constrained_array_definition


unconstrained_array_definition  ::=
        ARRAY ( index_subtype_definition {,index_subtype_definition} ) OF 
                                         component_subtype_indication


constrained_array_definition  ::=
        ARRAY index_constraint OF component_subtype_indication


index_subtype_definition  ::=   type_mark__RANGE__<>


index_constraint  ::=  ( discrete_range {,discrete_range} )


discrete_range  ::=  discrete_subtype_indication__|__range



-- 3.7

record_type_definition  ::=
        RECORD 
            component_list
        END RECORD


component_list  ::=
        component_declaration{component_declaration}
   |    {component_declaration}variant_part
   |    NULL;


component_declaration  ::=
        identifier_list : component_subtype_definition [:=expression] ;


component_subtype_definition  ::=  subtype_indication



-- 3.7.1

discriminant_part  ::=  
        ( discriminant_specification {;discriminant_specification} )


discriminant_specification  ::=  
        identifier_list : type_mark [:=expression]


-- 3.7.2

-- discriminant_constraint  ::=
--      ( discriminant_association {, discriminant_association} )
--
-- discriminant_association  ::=
--      [discriminant_simple_name {| discriminant_simple_name} =>] expression
--
-- "discriminant_constraint" is included under "aggregate"


-- 3.7.3

variant_part  ::=
        CASE discriminant_simple_name IS
            variant{variant}
        END CASE ;


variant  ::=
        WHEN choice {|choice} =>
            component_list


choice  ::=  simple_expression__|__discrete_range__|__component_simple_name
   |    OTHERS



-- 3.8

access_type_definition  ::=  ACCESS subtype_indication


-- 3.8.1

incomplete_type_declaration  ::=
        TYPE identifier [discriminant_part];

-- 3.9

declarative_part  ::=
        {basic_declarative_item}{later_declarative_item}


basic_declarative_item  ::=
        basic_declaration
   |    representation_clause  |  use_clause


later_declarative_item  ::=  body
   |    subprogram_declaration  |  package_declaration
   |    task_declaration        |  generic_declaration
   |    use_clause              |  generic_instantiation

body  ::=  proper_body  |  body_stub

proper_body  ::=
        subprogram_body  |  package_body  |  task_body
 


-- 4.1

name  ::=  simple_name
   |    character_literal  |  operator_symbol
   |    indexed_component__|__slice
   |    selected_component |  attribute


simple_name  ::=  identifier


prefix  ::=  name__|__function_call



-- 4.1.1

indexed_component  ::=  
        prefix(expression{,expression})


-- 4.1.2

-- slice  ::=  prefix ( discrete_range )
--
-- included under "indexed_component".


-- 4.1.3

selected_component  ::=  prefix . selector

selector  ::=  simple_name
   |    character_literal  |  operator_symbol  |  ALL



-- 4.1.4

attribute  ::=  prefix ' attribute_designator


attribute_designator ::=
        simple_name[(universal_static_expression)]



-- 4.3

aggregate  ::=  
        ( component_association {,component_association} )


component_association  ::=  
        [choice{|choice}=>]expression



-- 4.4

expression  ::=
        relation{AND__relation}  |  relation{AND__THEN__relation}
   |    relation{OR__relation}   |  relation{OR__ELSE__relation}
   |    relation{XOR__relation}


relation  ::=
        simple_expression [relational_operator__simple_expression]
   |    simple_expression[NOT]IN__range__|__simple_expression[NOT]IN__type_mark


simple_expression  ::=
        [unary_adding_operator]term{binary_adding_operator__term}


term  ::=  factor{multiplying_operator__factor}


factor  ::=  primary [**__primary]  |  ABS primary  |  NOT primary


primary  ::=
        numeric_literal  |  NULL  
   |    allocator  |  qualified_expression
   |    name__|__string_literal__|__function_call__|__type_conversion
   |    aggregate__|__(expression)



-- 4.5

-- logical_operator  ::=  AND  |  OR  |  XOR
--
-- This is an unused syntactic class.


relational_operator  ::=  =  |  /=  |  <  |  <=  |  >  |  >=


binary_adding_operator  ::=  +  |  -  |  &


unary_adding_operator  ::=  +  |  -


multiplying_operator  ::=  *  |  /  |  MOD  |  REM


-- highest_precedence_operator  ::=  **   |   ABS   |   NOT
--
-- This is an unused syntactic class.



-- 4.6

-- type_conversion  ::=  type_mark ( expression )
--
-- The class "type_conversion" is included under "name".


-- 4.7

qualified_expression  ::=
        type_mark'aggregate__|__type_mark'(expression)



-- 4.8

allocator  ::=
        NEW__subtype_indication  |  NEW__qualified_expression



-- 5.1

sequence_of_statements  ::=  statement{statement}


statement  ::=
        {label} simple_statement  |  {label} compound_statement


simple_statement  ::=  null_statement
   |    assignment_statement      |  exit_statement
   |    return_statement          |  goto_statement
   |    delay_statement           |  abort_statement
   |    raise_statement           |  code_statement
   |    procedure_call_statement__|__entry_call_statement


compound_statement  ::=
        if_statement      |  case_statement
   |    loop_statement    |  block_statement
   |    accept_statement  |  select_statement


label  ::=  << label_simple_name >>


null_statement  ::=  NULL ; 


-- 5.2

assignment_statement  ::=  variable_name := expression ; 


-- 5.3

if_statement  ::=
        IF condition THEN
            sequence_of_statements
        {ELSIF__condition__THEN__sequence_of_statements}
        [ELSE__sequence_of_statements]
        END IF ; 


condition  ::=  boolean_expression  


-- 5.4

case_statement  ::=
        CASE expression IS
            case_statement_alternative{case_statement_alternative}
        END CASE ;


case_statement_alternative  ::=
        WHEN choice {|choice} =>
            sequence_of_statements


-- 5.5

loop_statement  ::=
        [loop_simple_name:]
            [iteration_scheme] LOOP
                sequence_of_statements
            END LOOP [loop_simple_name] ;



iteration_scheme  ::=
        WHILE condition
   |    FOR loop_parameter_specification


loop_parameter_specification  ::=
        identifier IN [REVERSE] discrete_range


-- 5.6

block_statement  ::=
        [block_simple_name:]
            [DECLARE__declarative_part]
            BEGIN
                sequence_of_statements
            [EXCEPTION__exception_handler{exception_handler}]
            END [block_simple_name] ; 


-- 5.7

exit_statement  ::=
        EXIT [loop_name] [WHEN__condition] ; 


-- 5.8

return_statement  ::=  RETURN [expression] ; 


-- 5.9

goto_statement  ::=  GOTO label_name ; 



-- 6.1

subprogram_declaration  ::=  subprogram_specification ;


subprogram_specification  ::=
        PROCEDURE identifier [formal_part]
   |    FUNCTION  designator [formal_part] RETURN type_mark


designator  ::=  identifier  |  operator_symbol


operator_symbol  ::=  string_literal


formal_part  ::=
        ( parameter_specification {;parameter_specification} )


parameter_specification  ::=  
        identifier_list : mode type_mark [:=expression]


mode  ::=  [IN]  |  IN OUT  |  OUT



-- 6.3

subprogram_body  ::=
        subprogram_specification IS
            [declarative_part]          
        BEGIN
            sequence_of_statements
        [EXCEPTION__exception_handler{exception_handler}]
        END [designator] ; 


-- 6.4

-- procedure_call_statement  ::=
--      procedure_name [actual_parameter_part] ;
--
-- function_call  ::=
--      function_name [actual_parameter]
--
-- actual_parameter_part  ::= 
--      ( parameter_association {, parameter_association })
--
-- parameter_association  ::=
--      [formal_parameter =>] actual_parameter
--
-- formal_parameter  ::= parameter_simple_name
--
-- actual_parameter  ::=
--      expression  |  variable_name  |  type_mark ( variable_name )
--
-- "procedure_call_statement" and "function_call" are included under "name".



-- 7.1

package_declaration  ::=  package_specification ;

package_specification  ::=
        PACKAGE identifier IS
            {basic_declarative_item}
        [PRIVATE{basic_declarative_item}]
        END [package_simple_name]


package_body  ::=
        PACKAGE BODY package_simple_name IS
            [declarative_part]
[BEGIN__sequence_of_statements[EXCEPTION__exception_handler{exception_
handler}]]
        END [package_simple_name] ;



-- 7.4

private_type_declaration  ::=
        TYPE identifier [discriminant_part]IS [LIMITED] PRIVATE ;

-- deferred_constant_declaration  ::=
--      identifier_list : CONSTANT type_mark ;
--
-- Included under "object_declaration".



-- 8.4

use_clause  ::=  USE package_name {,package_name} ; 



-- 8.5

renaming_declaration  ::=
        identifier:type_mark      RENAMES object_name ;
   |    identifier:EXCEPTION      RENAMES exception_name ;
   |    PACKAGE identifier        RENAMES package_name ;
   |    subprogram_specification  RENAMES subprogram_or_entry_name ;


-- 9.1

task_declaration  ::=  task_specification ;

task_specification  ::=
        TASK [TYPE] identifier
            [IS{entry_declaration}{representation_clause}END[task_simple_name]]


task_body  ::=
        TASK BODY task_simple_name IS
            [declarative_part]      
        BEGIN
            sequence_of_statements
        [EXCEPTION__exception_handler{exception_handler}]
        END [task_simple_name] ;


-- 9.5

entry_declaration  ::=
        ENTRY identifier [(discrete_range)][formal_part] ;


entry_call_statement  ::=  
        entry_name[actual_parameter_part] ; 


accept_statement  ::=
        ACCEPT entry_simple_name [(entry_index)][formal_part]
            [DO__sequence_of_statements__END[entry_simple_name]] ;


entry_index  ::=  expression


-- 9.6

delay_statement  ::=  DELAY simple_expression ; 


-- 9.7

select_statement  ::=  selective_wait
   |    conditional_entry_call  |  timed_entry_call
  

-- 9.7.1

selective_wait  ::=
        SELECT
            select_alternative
            {OR__select_alternative}
            [ELSE__sequence_of_statements]
        END SELECT ; 


select_alternative  ::=  
        [WHEN__condition=>]selective_wait_alternative


selective_wait_alternative  ::=  accept_alternative
   |    delay_alternative  |  terminate_alternative


accept_alternative  ::=  
        accept_statement[sequence_of_statements]


delay_alternative  ::=  
        delay_statement[sequence_of_statements]


terminate_alternative  ::=  TERMINATE;


-- 9.7.2        

conditional_entry_call  ::=
        SELECT
            entry_call_statement   
            [sequence_of_statements]
        ELSE
            sequence_of_statements
        END SELECT ; 



-- 9.7.3

timed_entry_call  ::=
        SELECT
            entry_call_statement   
            [sequence_of_statements]
        OR
            delay_alternative
        END SELECT ; 


-- 9.10

abort_statement  ::=  ABORT task_name {,task_name} ; 


-- 10.1 

compilation  ::=  {compilation_unit}


compilation_unit  ::=
        context_clause library_unit

   |    context_clause secondary_unit


library_unit  ::=
        subprogram_declaration  |  package_declaration
   |    generic_declaration     |  generic_instantiation
   |    subprogram_body


secondary_unit  ::=
        library_unit_body  |  subunit


library_unit_body  ::=
        package_body__|__subprogram_body 



-- 10.1.1

context_clause  ::= {with_clause{use_clause}}


with_clause  ::=  WITH unit_simple_name {,unit_simple_name} ;

 
-- 10.2

body_stub  ::=
        subprogram_specification IS SEPARATE ;
   |    PACKAGE BODY package_simple_name IS SEPARATE ;
   |    TASK BODY task_simple_name    IS SEPARATE ;


subunit  ::=  SEPARATE ( parent_unit_name ) proper_body



-- 11.1

exception_declaration  ::=  identifier_list : EXCEPTION ;


-- 11.2

exception_handler  ::=
        WHEN exception_choice {|exception_choice} => 
            sequence_of_statements


exception_choice  ::=  exception_name  |  OTHERS


-- 11.3

raise_statement  ::=  RAISE [exception_name] ; 



-- 12.1

generic_declaration  ::=  generic_specification ;

generic_specification  ::=
        generic_formal_part subprogram_specification
   |    generic_formal_part package_specification


generic_formal_part  ::=  GENERIC {generic_parameter_declaration}


generic_parameter_declaration  ::=
        identifier_list : [IN[OUT]] type_mark [:=expression] ;
   |    TYPE identifier IS generic_type_definition ;
   |    private_type_declaration
   |    WITH subprogram_specification [IS<>] ;
-- |    WITH subprogram_specification [IS name] ;
--
-- This rule is included in the previous one.


generic_type_definition  ::=
        ( <> )  |  RANGE <>  |  DIGITS <>  |  DELTA <>
   |    array_type_definition  |  access_type_definition


-- 12.3

generic_instantiation  ::=
        PACKAGE identifier IS
            NEW generic_package_name [generic_actual_part] ;
   |    PROCEDURE__identifier__IS
            NEW generic_procedure_name [generic_actual_part] ;
   |    FUNCTION  designator IS
            NEW generic_function_name [generic_actual_part] ;


generic_actual_part  ::=  
        ( generic_association {,generic_association} )


generic_association  ::=
        [generic_formal_parameter=>]generic_actual_parameter


generic_formal_parameter  ::=
        parameter_simple_name  |  operator_symbol

generic_actual_parameter  ::=  
  expression__|__variable_name__|__subprogram_name__|__entry_name__|__type_mark



-- 13.1

representation_clause  ::=
        type_representation_clause  |  address_clause

type_representation_clause  ::=  length_clause
   |    enumeration_representation_clause
   |    record_representation_clause


-- 13.2

length_clause  ::=  FOR attribute USE simple_expression ;



-- 13.3

enumeration_representation_clause  ::=
        FOR__type_simple_name__USE aggregate ; 



-- 13.4

record_representation_clause  ::=
        FOR__type_simple_name__USE
            RECORD [alignment_clause]
                {component_clause}
            END RECORD ; 


alignment_clause  ::=   AT MOD static_simple_expression ; 


component_clause  ::=
        component_name AT static_simple_expression RANGE static_range ;



-- 13.5

address_clause  ::=  FOR simple_name USE AT simple_expression ; 


--13.8

code_statement  ::=  type_mark'record_aggregate ;


------------------------------------------------------------------------

-- The following rules define semantically qualified symbols under more
-- general categories.

type_name__|__subtype_name  ::=  expanded_name
--
-- An "expanded_name" is used for names that can be written using only
-- selectors.

universal_static_expression  ::=  expression

static_simple_expression  ::=  simple_expression

component_subtype_indication  ::=  subtype_indication

discriminant_simple_name  ::=  simple_name

label_simple_name  ::=  simple_name

variable_name  ::=  name

boolean_expression  ::=  expression

label_name  ::=  expanded_name

package_simple_name  ::=  simple_name

object_name  ::=  name

exception_name  ::=  expanded_name

package_name  ::=  expanded_name

subprogram_or_entry_name  ::=  name

task_simple_name  ::=  simple_name

entry_simple_name  ::=  simple_name

task_name  ::=  name

unit_simple_name  ::=  simple_name

parent_unit_name  ::=  expanded_name

generic_package_name  ::=  expanded_name

generic_procedure_name  ::=  expanded_name

generic_function_name  ::=  expanded_name

parameter_simple_name  ::=  simple_name

component_name  ::=  name

static_range  ::=  range


-- The following rules expand the concatenated constructs and define the
-- specially added syntactical classes.


-- 2.1

{pragma}  ::=
        empty
   |    {pragma} pragma
 
[(argument_association{,argument_association})]  ::=
        empty
   |    ( argument_association_list )

argument_association_list  ::=
        argument_association
   |    argument_association_list , argument_association

[argument_identifier=>]expression__|__[argument_identifier=>]name  ::=
        expression
   |    identifier => expression
--
-- "name" is included under "expression"


-- 3.1

deferred_constant_declaration__|__object_declaration  ::=  object_declaration
--
--  "deferred_constant_declaration" is included under "object_declaration".

[:=expression]  ::=
        empty
   |    := expression

[CONSTANT]subtype_indication  ::=
        subtype_indication
   |    CONSTANT subtype_indication

[CONSTANT]constrained_array_definition  ::=
        constrained_array_definition
   |    CONSTANT constrained_array_definition

{,identifier}  ::=
        empty
   |    {,identifier} , identifier

[discriminant_part]IS  ::=
        IS
   |    discriminant_part IS

[constraint]  ::=
        empty
   |    constraint

index_constraint__|__discriminant_constraint  ::=  aggregate
--
-- "index_constraint" and "discriminant_constraint" are included under
-- the class "aggregate".

expanded_name  ::=
        identifier
   |    expanded_name . identifier

 range_attribute__|__simple_expression..simple_expression  ::=
        name
   |    simple_expression .. simple_expression
--
--  This expansion generalizes "range" so that it may include type and 
--  subtype names.

{,enumeration_literal_specification} ::=
        empty
   |    {,enumeration_literal_specification} , 
                enumeration_literal_specification

[range_constraint]  ::=
        empty
   |    range_constraint

{,index_subtype_definition}  ::=
        empty
   |    {,index_subtype_definition} , index_subtype_definition

type_mark__RANGE__<>  ::=  name RANGE <>
--
-- To avoid conflicts, the more general class "name" is used.

{,discrete_range} ::=
        empty
   |    {,discrete_range} , discrete_range

discrete_subtype_indication__|__range  ::=
        range
   |    name range_constraint
--
-- A discrete subtype indication given as a type mark is included under "range".

component_declaration{component_declaration}  ::=
        {pragma} {component_declaration} component_declaration {pragma}

{component_declaration}variant_part  ::=
        {pragma} {component_declaration} variant_part {pragma}

NULL;  ::=  {pragma} NULL ; {pragma}

{component_declaration} ::=
        empty
   |    {component_declaration} component_declaration {pragma}

{;discriminant_specification}  ::=
        empty
   |    {;discriminant_specification} ; discriminant_specification

variant{variant}  ::=  {pragma} variant {variant}

-- Pragmas that can appear between two consecutive variants are picked
-- up in the component_list part of the variants themselves.

{variant}  ::=
        empty
   |    {variant} variant

{|choice} ::=
        empty
   |    {|choice} '|' choice

simple_expression__|__discrete_range__|__component_simple_name  ::=
        simple_expression
   |    name range_constraint
   |    simple_expression .. simple_expression
--
-- The "simple_expression" by itself may be a "discrete_range" or a 
-- "component_simple_name".

[discriminant_part];  ::=
        ;
   |    discriminant_part ;

{basic_declarative_item}{later_declarative_item}  ::=
        {basic_declarative_item}
   |    {basic_declarative_item} body {later_declarative_item}
--
-- A body is the only later_declarative_item that is not also a
-- basic_declarative_item.  It is therefore used as the dividing
-- point between the two lists of declarative items.

{basic_declarative_item}  ::=
        {pragma}
   |    {basic_declarative_item} basic_declarative_item {pragma}

{later_declarative_item}  ::=
        {pragma}
   |    {later_declarative_item} later_declarative_item {pragma}


-- 4.1

indexed_component__|__slice  ::=  indexed_component
--
-- "slice" is included under "indexed_component".

name__|__function_call  ::=  name
--
-- The definition of "name" includes "function_call".
-- A parameterless function call is recognized as a simple name or a
-- selected component.  A function call with parameters is recognized
-- as an indexed component.

prefix(expression{,expression})  ::=  
        prefix aggregate
--
--  This can be an attribute, indexed component, slice, or subprogram call.

simple_name[(universal_static_expression)]  ::=  
        simple_name
   |    DIGITS
   |    DELTA
   |    RANGE
--
-- Reserved word attribute designators are included in the rules as a
-- convenience.  Alternativly, since an attribute designator is always
   preceded
-- by an apostrophe, as noted in the RR 4.1.4, such usage may be detected 
-- during lexical analysis thus obviating the need for special rules.
--
-- The universal static expression of an attribute designator is reduced
-- as an "indexed_component".

{,component_association}  ::=
        empty
   |    {,component_association} , component_association

[choice{|choice}=>]expression  ::=
        expression
   |    choice {|choice} => expression
   |    simple_expression .. simple_expression
   |    name range_constraint

--
-- Component associations are generalized to include discrete ranges.
-- Thus, an "aggregate" can be used for slices and index and discriminant
-- constraints.

relation{AND__relation}  ::=
        relation AND relation
   |    relation{AND__relation} AND relation

relation{OR__relation}  ::=
        relation OR relation
   |    relation{OR__relation} OR relation

relation{XOR__relation}  ::=
        relation
   |    {XOR__relation}

{XOR__relation}  ::=
        relation XOR relation
   |    {XOR__relation} XOR relation

relation{AND__THEN__relation}  ::=
        relation AND THEN relation
   |    relation{AND__THEN__relation} AND THEN relation

relation{OR__ELSE__relation}  ::=
        relation OR ELSE relation
   |    relation{OR__ELSE__relation} OR ELSE relation

[relational_operator__simple_expression]  ::=
        empty
   |    relational_operator simple_expression

simple_expression[NOT]IN__range__|__simple_expression[NOT]IN__type_mark  ::=
        simple_expression [NOT] IN range
--
-- The "type_mark" is included under "range"

[NOT]  ::=
        empty
   |    NOT

[unary_adding_operator]term{binary_adding_operator__term}  ::=
        term
   |    unary_adding_operator term
   |    [unary_adding_operator]term{binary_adding_operator__term}
        binary_adding_operator term

factor{multiplying_operator__factor}  ::=
        factor
   |    factor{multiplying_operator__factor} multiplying_operator factor

[**__primary]  ::=
        empty
   |    ** primary

name__|__string_literal__|__function_call__|__type_conversion  ::=  name
--
-- "string_literal" is included under "name" as "operator_symbol".
-- "function_call" is included under "name".
-- "type_conversion" is included under "name".

aggregate__|__(expression)  ::=  aggregate
--
-- "( expression )" is included under "aggregate".

type_mark'aggregate__|__type_mark'(expression)  ::=
        prefix ' aggregate
--
-- The "prefix must be a "type_mark".  The "(expression)" is an "aggregate".

NEW__qualified_expression  ::=
        NEW type_mark ' aggregate
--
-- Here the "qualified_expression" can be given exactly

NEW__subtype_indication  ::=
        NEW type_mark
   |    NEW type_mark aggregate
--
-- We use the fact that the constraint must be an index or discriminant 
-- constraint.


-- 5.1

statement{statement}  ::=  {pragma} statement {statement}

{statement}  ::=
        {pragma}
   |    {statement} statement {pragma}


{label}   ::=
        empty
   |    {label} label

procedure_call_statement__|__entry_call_statement  ::= name ;
--
-- Procedure and entry call statements are included under "name".


{ELSIF__condition__THEN__sequence_of_statements}  ::=
        empty
   |    {ELSIF__condition__THEN__sequence_of_statements}
                ELSIF condition THEN
                    sequence_of_statements

[ELSE__sequence_of_statements]  ::=
        empty
   |    ELSE
            sequence_of_statements

case_statement_alternative{case_statement_alternative}  ::=
            {pragma} 
            case_statement_alternative
            {case_statement_alternative}

{case_statement_alternative}  ::=
        empty
   |    {case_statement_alternative} case_statement_alternative

[simple_name:]  ::=
        empty
   |    simple_name :

[simple_name] ::=
        empty
   |    simple_name

[iteration_scheme]  ::=
        empty
   |    iteration_scheme

[loop_simple_name:]  ::=  [simple_name:]

[loop_simple_name]   ::=  [simple_name]

[REVERSE] ::=
        empty
   |    REVERSE

[block_simple_name:]  ::=  [simple_name:]

[block_simple_name]   ::=  [simple_name]

[DECLARE__declarative_part]  ::=
        empty
   |    DECLARE 
            declarative_part

[EXCEPTION__exception_handler{exception_handler}]  ::=
        empty
   |    EXCEPTION 
            {pragma} exception_handler_list

exception_handler_list  ::=
        exception_handler
   |    exception_handler_list exception_handler

[loop_name]  ::=  [expanded_name]

[expanded_name]  ::=
        empty
   |    expanded_name

[WHEN__condition]  ::=
        empty
   |    WHEN condition

[expression]  ::=
        empty
   |    expression


-- 6.1

[formal_part]  ::=
        empty
   |    formal_part

{;parameter_specification}  ::=
        empty
   |    {;parameter_specification} ; parameter_specification

[IN]  ::=
        empty
   |    IN

[declarative_part]  ::=  declarative_part
--
-- A "declarative_part" may be empty.

[designator]  ::=
        empty
   |    designator


-- 7.1

[PRIVATE{basic_declarative_item}]  ::=
        empty
   |    PRIVATE 
            {basic_declarative_item}

[BEGIN__sequence_of_statements[EXCEPTION__exception_handler{exception_handler}]]
                                ::=
        empty
   |    BEGIN
            sequence_of_statements
        [EXCEPTION__exception_handler{exception_handler}]

[LIMITED]  ::=
        empty
   |    LIMITED

{,package_name} ::=
        empty
   |    {,package_name} , package_name

[package_simple_name]  ::=  [simple_name]


-- 8.1

identifier:type_mark  ::= identifier_list : type_mark
--
-- identifier_list in the two above rule must contain only one
-- identifier.

identifier:EXCEPTION  ::= identifier_list : EXCEPTION
--
-- identifier_list in the two above rule must contain only one
-- identifier.



-- 9.1

[TYPE]  ::=
        empty
   |    TYPE

[IS{entry_declaration}{representation_clause}END[task_simple_name]]  ::=
        empty
   |    IS
            {entry_declaration}
            {representation_clause}
        END [task_simple_name]

[task_simple_name]  ::=
        [simple_name]

{entry_declaration}  ::=
        {pragma}
   |    {entry_declaration} entry_declaration {pragma}

{representation_clause}  ::=
        empty
   |    {representation_clause} representation_clause {pragma}

entry_name[actual_parameter_part]  ::=  {pragma} name

[(discrete_range)][formal_part]  ::=
        [formal_part]
   |    ( discrete_range ) [formal_part]

[(entry_index)][formal_part]  ::=
        [formal_part]
   |    ( entry_index ) [formal_part]

[entry_simple_name]  ::=  [simple_name] 

[DO__sequence_of_statements__END[entry_simple_name]]  ::=
        empty
   |    DO
          sequence_of_statements
        END [entry_simple_name]

{OR__select_alternative}  ::=
        empty
   |    {OR__select_alternative} OR select_alternative

[WHEN__condition=>]selective_wait_alternative  ::=
        selective_wait_alternative
   |    WHEN condition => selective_wait_alternative

accept_statement[sequence_of_statements]  ::=
        {pragma} accept_statement [sequence_of_statements]

delay_statement[sequence_of_statements]  ::=
        {pragma} delay_statement [sequence_of_statements]

TERMINATE;   ::=  {pragma} TERMINATE ; {pragma}

[sequence_of_statements]  ::=
        {pragma}
   |    sequence_of_statements

{,task_name}  ::=
        empty
   |    {,task_name} , task_name



-- 10.1

{compilation_unit}  ::=
        {pragma}
   |    {compilation_unit} compilation_unit {pragma}
 
package_body__|__subprogram_body   ::=  package_body
--
-- "subprogram_body" is already contained in the class "library_unit".

{with_clause{use_clause}}  ::=
        empty
   |    {with_clause{use_clause}} with_clause use_clause_list 


use_clause_list  ::=
        {pragma}
   |    use_clause_list use_clause {pragma}
 
{,unit_simple_name}  ::=
        empty
   |    {,unit_simple_name} , unit_simple_name



-- 11.1

{|exception_choice}  ::=
        empty
   |    {|exception_choice} '|' exception_choice

[exception_name]  ::=
        [expanded_name]



-- 12.1

{generic_parameter_declaration}  ::=
        empty
   |    {generic_parameter_declaration} generic_parameter_declaration

[IN[OUT]]  ::=
        [IN]
   |    IN OUT

[IS<>]  ::=
        empty
   |    IS name
   |    IS <>
 
PROCEDURE__identifier__IS  ::=  subprogram_specification IS
--
-- To avoid conflicts, the more general "subprogram_specification" is used.

[generic_actual_part]  ::=
        empty
   |    generic_actual_part

{,generic_association}  ::=
        empty
   |    {,generic_association} , generic_association

[generic_formal_parameter=>]generic_actual_parameter  ::=
        generic_actual_parameter
   |    generic_formal_parameter => generic_actual_parameter

expression__|__variable_name__|__subprogram_name__|__entry_name__|__type_mark
                                ::=  expression
--
-- The above alternatives are included under "expression".


-- 13.1

FOR__type_simple_name__USE  ::=
        FOR simple_name USE
--
-- The "simple_name" must be a "type_simple_name".

[alignment_clause]  ::=
        {pragma}
   |    {pragma} alignment_clause {pragma}

{component_clause}  ::=
        empty
   |    {component_clause} component_clause {pragma}

type_mark'record_aggregate  ::=  qualified_expression
--
-- The qualified expression must contain a record aggregate.

                          **********************

The views, opinions, and findings contained in this report are those of 
the author(s) and should not be construed as an official Agency position, 
policy, or decision, unless so designated by other official documentation.

                          **********************

                   Ada Information Clearinghouse (AdaIC)
                              P.O. Box 1866
                         Falls Church, VA  22204
         Telephone:  1-800-AdaIC-11 (1-800/232-4211) or 703/681-2466
                            Fax:  703/681-2869
                 E-mail:  adainfo@sw-eng.falls-church.va.us

The AdaIC is sponsored by the Ada Joint Program Office and operated by IIT 
Research Institute.

