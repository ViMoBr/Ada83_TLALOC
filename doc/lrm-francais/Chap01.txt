Le Bureau du Programme Conjoint Ada ne garantit pas l'exactitude de ces informations.
fichier, par rapport au contenu de ANSI/MIL-STD-1815A-1983,
le manuel de référence du langage de programmation Ada. Si des erreurs ou
des divergences sont trouvées dans cette version lisible par machine, veuillez
transmettre vos commentaires via le Defense Data Network (DDN) à :

                    ACTION@AJPO.SEI.CMU.EDU

ou par courrier classique à

                 Centre d’échange d’informations Ada
                  3D139 (1211 S. Fern, C-107)
                        Le Pentagone
                  Washington, DC 20301-3081

-------------------------------------------------- ---------------------

Copyright 1980, 1982, 1983 détenu par le gouvernement des États-Unis en tant que
représenté par le sous-secrétaire à la Défense, à la Recherche et à la
Ingénierie. Tous droits réservés. À condition que l'avis de droit d'auteur
est inclus sur la première page, ce document peut être copié dans son
l'intégralité sans modification ou telle que modifiée par (1) l'ajout de texte qui est
clairement marqué comme une insertion ; (2) ombrager ou mettre en évidence les éléments existants
texte; (3) supprimer des exemples. Autorisation de publier d'autres extraits
à obtenir auprès du Bureau du Programme Conjoint Ada, OUSDRE (R&AT),
Le Pentagone, Washington, DC 20301-2081, États-Unis


                             1. Introduction  

Ada est un langage de programmation conçu conformément aux exigences
défini par le Département de la Défense des États-Unis : le soi-disant Steelman
exigences. Globalement, ces exigences nécessitent un langage avec
une puissance expressive considérable couvrant un large domaine d’application. Comme un
résultat, la langue inclut les facilités offertes par les langues classiques
comme Pascal ainsi que des installations que l'on trouve souvent uniquement dans des
langues. Le langage est donc un langage algorithmique moderne avec le
structures de contrôle habituelles, et avec la capacité de définir des types et
sous-programmes. Il répond également au besoin de modularité, grâce auquel les données, les types,
et les sous-programmes peuvent être empaquetés. Il traite de la modularité dans le domaine physique
sens également, avec une possibilité de prendre en charge une compilation séparée.

Outre ces aspects, le langage couvre la programmation temps réel,
avec des fonctionnalités pour modéliser des tâches parallèles et gérer les exceptions. Ça aussi
couvre la programmation des systèmes ; cela nécessite un contrôle précis de la
représentation des données et accès aux propriétés dépendantes du système. Enfin,
les entrées-sorties au niveau de l'application et au niveau de la machine sont définies.  

1.1 Portée de la norme 

Cette norme précise la forme et la signification des unités de programme écrites en
Ada. Son objectif est de promouvoir la portabilité des programmes Ada vers un
variété de systèmes de traitement de données.  

1.1.1 Portée de la norme 

Cette norme précise :

(a) La forme d'une unité de programme écrite en Ada.

(b) L'effet de la traduction et de l'exécution d'une telle unité de programme.

(c) La manière dont les unités du programme peuvent être combinées pour former Ada
    programmes.

(d) Les unités de programme prédéfinies qu'une implémentation conforme doit
    fournir.

(e) Les variations autorisées au sein de la norme et la manière de
    qu'ils doivent être précisés. 

(f) Les violations de la norme qu'une implémentation conforme est
    requis pour détecter, et l'effet de la tentative de traduction ou
    exécuter une unité de programme contenant de telles violations.

(g) Les violations de la norme qu'une implémentation conforme est
    pas nécessaire de détecter.                                                  

Cette norme ne précise pas :

(h) Le moyen par lequel une unité de programme écrite en Ada est transformée en
    code objet exécutable par un processeur.

(i) Moyens par lesquels la traduction ou l'exécution d'unités de programme est invoquée
    et les unités d'exécution sont contrôlées.

(j) La taille ou la vitesse du code objet, ou la vitesse d'exécution relative
    de différentes constructions linguistiques.

(k) La forme ou le contenu de toute liste produite par les implémentations ; dans
    en particulier, la forme ou le contenu des messages d'erreur ou d'avertissement.

(l) L'effet de l'exécution d'une unité de programme contenant une violation
    qu'une implémentation conforme n'est pas tenue de détecter.

(m) La taille d'un programme ou d'une unité de programme qui dépassera la capacité de
    une implémentation conforme particulière.

Lorsque cette norme précise qu'une unité de programme écrite en Ada a un
effet exact, cet effet est la signification opérationnelle de l'unité de programme
et doit être produit par toutes les implémentations conformes. Où ce
la norme spécifie les variations admissibles dans les effets des constituants de 
une unité de programme écrite en Ada, la signification opérationnelle de l'unité de programme
dans son ensemble, on entend l'éventail des effets possibles qui résultent
de toutes ces variations, et une implémentation conforme est autorisée à
produire l’un de ces effets possibles. Exemples de variantes autorisées
sont:

 - Les valeurs représentées de grandeurs numériques fixes ou flottantes, et
    les résultats des opérations sur eux.

 - L'ordre d'exécution des instructions dans différentes tâches parallèles, en
    l'absence de synchronisation explicite.  

1.1.2 Conformité d'une implémentation à la norme 

Une implémentation conforme est celle qui :

(a) Traduit et exécute correctement les unités de programme légales écrites en Ada,
    à condition qu'ils ne soient pas si grands qu'ils dépassent la capacité du
    mise en œuvre.

(b) Rejette toutes les unités de programme dont la taille dépasse la capacité
    de la mise en œuvre.

(c) Rejette toutes les unités de programme contenant des erreurs dont la détection est
    requis par la norme.

(d) Fournit toutes les unités de programme prédéfinies requises par la norme.  

(e) Ne contient aucune variation, sauf lorsque la norme le permet.

(f) Spécifie toutes ces variations autorisées de la manière prescrite par
    le standard.                                                    

1.2 Structure de la norme 

Ce manuel de référence contient quatorze chapitres, trois annexes, trois
des annexes et un index.

Chaque chapitre est divisé en sections qui ont une structure commune. Chaque  
La section présente son sujet, donne toutes les règles de syntaxe nécessaires et
décrit la sémantique des constructions de langage correspondantes. Exemples
et des notes, puis des références, peuvent apparaître à la fin d'une section.

Les exemples sont destinés à illustrer les formes possibles des constructions
décrit. Les notes sont destinées à souligner les conséquences des règles
décrit dans la section ou ailleurs. Les références sont destinées à attirer le
attention des lecteurs sur un terme ou une expression ayant une signification technique définie
dans une autre rubrique.

La définition standard du langage de programmation Ada comprend le
quatorze chapitres et les trois annexes, sous réserve de ce qui suit
restriction : le matériel contenu dans chacun des éléments énumérés ci-dessous est
informatif et ne faisant pas partie de la définition standard de la programmation Ada
langue:

 - Section 1.3 Objectifs et sources de conception

 - Section 1.4 Résumé linguistique

 - Les exemples, notes et références donnés à la fin de chaque section

 - Chaque section dont le titre commence par le mot « Exemple » ou « Exemples »  

1.3 Objectifs et sources de conception 

Ada a été conçu avec trois préoccupations primordiales : la fiabilité du programme et
maintenance, programmation en tant qu'activité humaine et efficacité.

Le besoin de langages qui favorisent la fiabilité et simplifient la maintenance est
bien établi. L'accent a donc été mis sur la lisibilité du programme
facilité d'écriture. Par exemple, les règles de la langue exigent que
les variables du programme soient explicitement déclarées et que leur type soit spécifié.
Puisque le type d'une variable est invariant, les compilateurs peuvent garantir que
les opérations sur les variables sont compatibles avec les propriétés destinées à
objets du type. De plus, les notations sujettes aux erreurs ont été évitées,
et la syntaxe du langage évite l'utilisation de formes codées au profit de
des constructions plus anglaises. Enfin, le langage offre un support pour
compilation séparée des unités de programme de manière à faciliter le programme
développement et maintenance, et qui offre le même degré de contrôle
entre les unités comme au sein d’une unité.

Le souci du programmeur humain a également été souligné lors de la conception.
On s'est surtout efforcé de garder la langue aussi petite que possible,
compte tenu du caractère ambitieux du domaine d’application. Nous avons tenté de 
couvrir ce domaine avec un petit nombre de concepts sous-jacents intégrés dans
de manière cohérente et systématique. Nous avons néanmoins essayé d'éviter le
pièges d'une involution excessive et dans la recherche constante de solutions plus simples.
conceptions, nous avons essayé de fournir des constructions de langage qui correspondent
intuitivement à ce que les utilisateurs attendent normalement.

Comme beaucoup d’autres activités humaines, le développement de programmes devient
toujours plus décentralisé et distribué. Par conséquent, la capacité de
assembler un programme à partir de composants logiciels produits indépendamment a été
une idée centrale dans cette conception. Les notions de forfaits, de types privés,
et d'unités génériques sont directement liées à cette idée, qui a
des ramifications dans de nombreux autres aspects de la langue.                                            

Aucune langue ne peut éviter le problème de l’efficacité. Langues qui nécessitent
des compilateurs trop élaborés, ou qui conduisent à une utilisation inefficace du stockage ou
temps d'exécution, imposer ces inefficacités sur toutes les machines et sur tous
programmes. Chaque construction du langage a été examinée à la lumière de
présenter les techniques de mise en œuvre. Toute construction proposée dont
la mise en œuvre n'était pas claire ou nécessitait des ressources machine excessives.
rejeté.

Aucun des objectifs de conception ci-dessus n’a été considéré comme réalisable après coup.
Les objectifs de conception ont guidé l’ensemble du processus de conception depuis le début.

Une difficulté perpétuelle dans la conception d'un langage est qu'il faut à la fois identifier
les capacités requises par le domaine d'application et le langage de conception
fonctionnalités qui offrent ces capacités. La difficulté résidait dans ce domaine
conception, bien que dans une moindre mesure que d'habitude en raison du Steelman
exigences. Ces exigences simplifiaient souvent le processus de conception en
lui permettant de se concentrer sur la conception d'un système donné fournissant un puits
ensemble défini de capacités, plutôt que sur la définition du
capacités elles-mêmes.

Une autre simplification significative du travail de conception résulte de précédentes
expérience acquise par plusieurs dérivés Pascal réussis développés avec
des objectifs similaires. Ce sont les langues Euclide, Lis, Mesa, Modula et Sue.
Bon nombre des idées clés et des formes syntaxiques développées dans ces langues ont
homologues à Ada. Plusieurs langages existants tels que Algol 68 et
Simula, mais aussi des langages de recherche récents comme Alphard et Clu,
influencé cette langue à plusieurs égards, bien que dans une moindre mesure
que la famille Pascal.

Enfin, les rapports d'évaluation reçus sur une formulation antérieure (la
langage vert) et sur des propositions alternatives (le langage rouge, bleu et jaune)
langues), les révisions linguistiques qui ont eu lieu à différentes étapes de
ce projet, et les milliers de commentaires reçus d'une quinzaine de personnes différentes
pays pendant les étapes préliminaires de la conception d’Ada et pendant la
ANSI, tous ont eu un impact significatif sur la définition standard de
la langue.  

1.4 Résumé linguistique  

Un programme Ada est composé d’une ou plusieurs unités de programme. Ce programme
les unités peuvent être compilées séparément. Les unités de programme peuvent être des sous-programmes (qui
définir des algorithmes exécutables), des unités de package (qui définissent des collections de
entités), unités de tâches (qui définissent des calculs parallèles) ou génériques
unités (qui définissent des formes paramétrées de packages et de sous-programmes).
Chaque unité se compose normalement de deux parties : un cahier des charges contenant les
informations qui doivent être visibles par les autres unités, et un corps contenant les
les détails de mise en œuvre, qui n’ont pas besoin d’être visibles par les autres unités.

Cette distinction de la spécification et du corps, et la capacité de compiler
unités séparément, permet à un programme d'être conçu, écrit et testé comme un
ensemble de composants logiciels largement indépendants.  

Un programme Ada utilisera normalement une bibliothèque d'unités de programme de
utilité générale. La langue fournit des moyens par lesquels l'individu
les organisations peuvent créer leurs propres bibliothèques. Le texte d'un séparément
L'unité de programme compilée doit nommer les unités de bibliothèque dont elle a besoin.

Unités de programme

Un sous-programme est l'unité de base pour exprimer un algorithme. Il y en a deux
types de sous-programmes : procédures et fonctions. Une procédure est le moyen
d'invoquer une série d'actions. Par exemple, il peut lire des données, mettre à jour
variables, ou produire une sortie. Il peut avoir des paramètres, pour fournir un
moyen contrôlé de transmission d'informations entre la procédure et le point
d'appel.                                           

Une fonction est le moyen d’invoquer le calcul d’une valeur. C'est  
similaire à une procédure, mais renverra en plus un résultat.

Un package est l'unité de base permettant de définir une collection d'éléments logiquement liés.
entités. Par exemple, un package peut être utilisé pour définir un pool commun de
des données et des types, une collection de sous-programmes associés ou un ensemble de types
déclarations et opérations associées. Des portions d'un colis peuvent être
caché à l'utilisateur, permettant ainsi l'accès uniquement aux propriétés logiques
exprimé par la spécification du paquet.

Une unité de tâche est l'unité de base permettant de définir une tâche dont la séquence d'actions
peuvent être exécutés en parallèle avec ceux d’autres tâches. De telles tâches peuvent être
implémenté sur multi-ordinateurs, multiprocesseurs ou avec entrelacé
exécution sur un seul processeur. Une unité de tâche peut définir soit un seul
tâche d'exécution ou un type de tâche permettant la création d'un nombre quelconque de
tâches similaires.

Déclarations et déclarations

Le corps d'une unité de programme contient généralement deux parties : une partie déclarative
partie, qui définit les entités logiques à utiliser dans l'unité de programme,
et une séquence d'instructions, qui définit l'exécution du programme
unité.

La partie déclarative associe les noms aux entités déclarées. Par exemple,
un nom peut désigner un type, une constante, une variable ou une exception. UN
La partie déclarative introduit également les noms et paramètres des autres
sous-programmes, packages, unités de tâches et unités génériques à utiliser dans le
unité de programme.

La séquence d'instructions décrit une séquence d'actions qui doivent être
effectué. Les instructions sont exécutées successivement (sauf si une sortie,
return, ou goto, ou la levée d'une exception, provoque l'exécution
pour continuer depuis un autre endroit).

Une instruction d'affectation modifie la valeur d'une variable. Un appel de procédure
appelle l'exécution d'une procédure après avoir associé des paramètres réels  
fourni lors de l’appel avec les paramètres formels correspondants.

Les instructions Case et if permettent la sélection d'un
séquence d'instructions basée sur la valeur d'une expression ou sur la valeur
d'un état.

L'instruction loop fournit le mécanisme itératif de base du langage.
Une instruction de boucle spécifie qu'une séquence d'instructions doit être exécutée
à plusieurs reprises selon les instructions d'un schéma d'itération, ou jusqu'à ce qu'une instruction de sortie
est rencontré.

Une instruction de bloc comprend une séquence d'instructions précédées du
déclaration des entités locales utilisées par les relevés.

Certaines déclarations ne s'appliquent qu'aux tâches. Une instruction de retard retarde
l'exécution d'une tâche pour une durée déterminée. Un relevé d'appel d'entrée
est écrit sous la forme d'une instruction d'appel de procédure ; il précise que la tâche
l'émission de l'appel est prête pour un rendez-vous avec une autre tâche qui a ceci 
entrée. La tâche appelée est prête à accepter l'appel d'entrée lorsque son
l'exécution atteint une instruction accept correspondante, qui spécifie le
actions à accomplir ensuite. Une fois le rendez-vous terminé, les deux
la tâche appelante et la tâche ayant l'entrée peuvent continuer leur exécution dans
parallèle. Une forme de l'instruction select permet une attente sélective pour un
de plusieurs rendez-vous alternatifs. Autres formes de l'instruction select
autoriser les appels d'entrée conditionnels ou chronométrés.                                                 

L'exécution d'une unité de programme peut rencontrer des situations d'erreur dans lesquelles
l'exécution du programme ne peut pas continuer. Par exemple, un calcul arithmétique 
peut dépasser la valeur maximale autorisée d'un nombre, ou une tentative peut être faite
pour accéder à un composant de tableau en utilisant une valeur d'index incorrecte. Négocier
avec de telles situations d'erreur, les instructions d'une unité de programme peuvent être
textuellement suivi de gestionnaires d'exceptions qui spécifient les actions à effectuer.
prise lorsque la situation d’erreur survient. Des exceptions peuvent être levées explicitement
par une instruction raise.

Types de données

Chaque objet du langage possède un type qui caractérise un ensemble de
valeurs et un ensemble d’opérations applicables. Les principales classes de types sont
les types scalaires (comprenant les types énumération et numériques), les types composites,
types d’accès et types privés.

Un type d'énumération définit un ensemble ordonné d'énumérations distinctes
des littéraux, par exemple une liste d'états ou un alphabet de caractères. Le
les types d'énumération BOOLEAN et CHARACTER sont prédéfinis.

Les types numériques permettent d'effectuer des calculs numériques exacts ou approximatifs.
calculs. Les calculs exacts utilisent des types entiers, qui désignent des ensembles de
entiers consécutifs. Les calculs approximatifs utilisent soit le point fixe
types, avec des limites absolues sur l'erreur, ou des types à virgule flottante, avec
limites relatives de l’erreur. Les types numériques INTEGER, FLOAT et
Les DURÉES sont prédéfinies.

Les types composites permettent de définir des objets structurés avec des
Composants. Les types composites du langage fournissent des tableaux et
enregistrements. Un tableau est un objet avec des composants indexés du même type.
Un enregistrement est un objet avec des composants nommés de types éventuellement différents.
Le type de tableau STRING est prédéfini.

Un enregistrement peut comporter des composants spéciaux appelés discriminants. Alternative
des structures d'enregistrement qui dépendent des valeurs des discriminants peuvent être définies
dans un type d'enregistrement.

Les types d'accès permettent la construction de structures de données liées créées par  
l’évaluation des répartiteurs. Ils permettent plusieurs variables d'un accès
type pour désigner le même objet, et les composants d'un objet pour désigner
désigner le même objet ou d'autres objets. Les deux éléments d'un tel lien
la structure des données et leur relation avec d'autres éléments peuvent être modifiées au cours
exécution du programme.

Les types privés peuvent être définis dans un package qui dissimule les détails structurels
qui ne sont pas pertinents à l'extérieur. Seules les propriétés logiquement nécessaires
(y compris les éventuels discriminants) sont rendus visibles aux utilisateurs de ces types.

Le concept de type est affiné par le concept de sous-type, grâce auquel un
l'utilisateur peut contraindre l'ensemble des valeurs autorisées d'un type. Les sous-types peuvent être
utilisé pour définir des sous-gammes de types scalaires, des tableaux avec un ensemble limité de
valeurs d'index, enregistrements et types privés avec un discriminant particulier
valeurs.   

Autres installations

Les clauses de représentation peuvent être utilisées pour spécifier le mappage entre les types et
fonctionnalités d’une machine sous-jacente. Par exemple, l'utilisateur peut préciser que
les objets d'un type donné doivent être représentés avec un nombre de bits donné, ou
que les composants d'un enregistrement doivent être représentés à l'aide d'un stockage donné
mise en page. D'autres fonctionnalités permettent l'utilisation contrôlée de systèmes de faible niveau, non portables,
ou aspects dépendants de la mise en œuvre, y compris l’insertion directe de
langage machine.

Les entrées-sorties sont définies dans le langage au moyen d'une bibliothèque prédéfinie
paquets. Des installations sont fournies pour l'entrée-sortie des valeurs de
définis par l'utilisateur ainsi que de types prédéfinis. Moyens standards de
représentant des valeurs sous forme d'affichage sont également fournis.                                          

Enfin, le langage fournit un puissant moyen de paramétrage de
unités de programme, appelées unités de programme génériques. Les paramètres génériques peuvent être
types et sous-programmes (ainsi que des objets) et permettent ainsi des algorithmes généraux
à appliquer à tous les types d’une classe donnée.  

1.5 Méthode de description et notation syntaxique 

La forme des unités du programme Ada est décrite au moyen d'un modèle hors contexte
syntaxe ainsi que les exigences dépendant du contexte exprimées par le récit
règles.

La signification des unités du programme Ada est décrite au moyen de règles narratives
définissant à la fois les effets de chaque construit et les règles de composition pour
construit. Ce récit emploie des termes techniques dont la précision
la définition est donnée dans le texte (références à la section contenant la
la définition d'un terme technique apparaît à la fin de chaque section qui utilise
le terme).

Tous les autres termes sont en langue anglaise et portent leur signification naturelle,
tel que défini dans le troisième nouveau dictionnaire international de l'anglais de Webster
Langue. 

La syntaxe hors contexte du langage est décrite à l'aide d'une variante simple
de Backus-Naur-Form. En particulier,

(a) Les mots minuscules, certains contenant des soulignements intégrés, sont utilisés pour
    désignent des catégories syntaxiques, par exemple :

         ajout_opérateur 

    Chaque fois que le nom d'une catégorie syntaxique est utilisé en dehors du
    la syntaxe se règle elle-même, les espaces remplacent les soulignements
    (donc : opérateur d'ajout).

(b) Les mots en gras sont utilisés pour désigner des mots réservés, par exemple :

         tableau 

(c) Les crochets entourent les éléments facultatifs. Ainsi les deux règles suivantes
    sont équivalents.

         return_statement ::= return [expression];
         return_statement ::= return; | expression de retour ; 

(d) Des accolades entourent un élément répété. L'élément peut apparaître zéro ou plus 
    fois; les répétitions se font de gauche à droite comme pour un équivalent
    règle récursive à gauche. Ainsi les deux règles suivantes sont équivalentes.  

         terme ::= facteur {facteur multiplying_operator}
         terme ::= facteur | terme facteur d'opérateur_multiplicateur                                                      

(e) Une barre verticale sépare les éléments alternatifs, sauf si cela se produit
    immédiatement après une accolade ouvrante, auquel cas cela signifie
    lui-même :

         letter_or_digit ::= lettre | chiffre
         association_composant ::= [choix {| choix} =>] expression 

(f) Si le nom d'une catégorie syntaxique commence par une partie en italique,
    c'est l'équivalent du nom de la catégorie sans la partie en italique.
    La partie en italique est destinée à transmettre des informations sémantiques.
    Par exemple, type_name et task_name sont tous deux équivalents au nom seul.

Note:

Les règles de syntaxe décrivant les constructions structurées sont présentées sous la forme
cela correspond au paragraphe recommandé. Par exemple, un si
la déclaration est définie comme

   if_statement ::=
       si condition alors
         séquence_of_statements
      {autre condition alors
         séquence_of_statements}
      [autre
         séquence_de_statements]
       fin si;

Différentes lignes sont utilisées pour les parties d'une règle de syntaxe si la ligne correspondante
les parties de la construction décrites par la règle sont destinées à être sur
lignes différentes. L'indentation dans la règle est une recommandation pour
indentation de la partie correspondante de la construction. C'est recommandé
que toutes les indentations soient des multiples d'un pas de base d'indentation (le
le nombre de places pour l'étape de base n'est pas défini). Les endroits préférés
pour les autres sauts de ligne, ils sont après les points-virgules. En revanche, si un
une construction complète peut tenir sur une seule ligne, cela est également autorisé dans le
paragraphes recommandés.  

1.6 Classification des erreurs 

La définition du langage classe les erreurs en plusieurs catégories différentes.
catégories:

(a) Erreurs qui doivent être détectées au moment de la compilation par chaque Ada
    compilateur.

    Ces erreurs correspondent à toute violation d'une règle donnée dans ce
    manuel de référence, autres que les violations qui correspondent à (b) ou
    (c) ci-dessous. En particulier, violation de toute règle utilisant les termes
    doit, autorisé, légal ou illégal appartient à cette catégorie. N'importe lequel
    un programme qui contient une telle erreur n’est pas un programme Ada légal ; sur 
    d'un autre côté, le fait qu'un programme soit légal ne signifie pas, au sens propre du terme,
    soi, que le programme est exempt d’autres formes d’erreur.

(b) Erreurs qui doivent être détectées au moment de l'exécution par l'exécution d'un Ada
    programme.

    Les situations d'erreur correspondantes sont associées aux noms de
    les exceptions prédéfinies. Chaque compilateur Ada est requis pour générer
    code qui déclenche l'exception correspondante si une telle erreur
    Cette situation se présente pendant l’exécution du programme. Si une exception est certaine
    être déclenché à chaque exécution d'un programme, alors les compilateurs sont
    autorisé (bien que non obligatoire) à signaler ce fait lors de la compilation
    temps.                                           

(c) Exécution erronée.

    Les règles du langage précisent certaines règles auxquelles doivent obéir les programmes Ada,
    bien qu'il n'y ait aucune obligation pour les compilateurs Ada de fournir soit un
    au moment de la compilation ou d'une détection au moment de l'exécution de la violation de ces
    règles. Les erreurs de cette catégorie sont indiquées par l'utilisation du
    mot erroné pour qualifier l'exécution du correspondant
    construit. L'effet d'une exécution erronée est imprévisible.

(d) Dépendances d'ordre incorrectes.

    Chaque fois que le manuel de référence précise que différentes parties d'un
    la construction donnée doit être exécutée dans un ordre qui n'est pas défini
    par le langage, cela signifie que l'implémentation est autorisée à
    exécuter ces parties dans un ordre donné, en suivant les règles qui
    résultent de cet ordre donné, mais pas en parallèle. Par ailleurs, le
    la construction est incorrecte si l'exécution de ces parties dans un autre
    l'ordre aurait un effet différent. Les compilateurs ne sont pas tenus de
    fournir une détection au moment de la compilation ou de l'exécution des erreurs
    dépendances d’ordre. Ce qui précède s'exprime en termes de processus
    cela s’appelle l’exécution ; cela s'applique également aux processus qui
    sont appelés évaluation et élaboration.

Si un compilateur est capable de reconnaître au moment de la compilation qu'une construction est
erroné ou contient une dépendance d'ordre incorrecte, alors le compilateur est
autorisé à générer, à la place du code autrement généré pour le
construction, code qui déclenche l'exception prédéfinie PROGRAM_ERROR.
De même, les compilateurs sont autorisés à générer du code qui vérifie au moment de l'exécution
pour des constructions erronées, pour des dépendances d'ordre incorrectes, ou pour les deux.
L'exception prédéfinie PROGRAM_ERROR est levée si une telle vérification échoue.                          

