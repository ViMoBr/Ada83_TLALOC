                       3. Déclarations et types  

Ce chapitre décrit les types du langage et les règles de
déclarer des constantes, des variables et des nombres nommés.  

3.1 Déclarations 

Le langage définit plusieurs types d'entités qui sont déclarées, soit
explicitement ou implicitement, par des déclarations. Une telle entité peut être un nombre
littéral, un objet, un discriminant, un composant d'enregistrement, un paramètre de boucle,
une exception, un type, un sous-type, un sous-programme, un package, une unité de tâche, un
unité générique, une entrée unique, une famille d'entrées, un paramètre formel (d'un
sous-programme, entrée ou sous-programme générique), un paramètre formel générique, un
un bloc ou une boucle nommé, une instruction étiquetée ou une opération (en particulier,
un attribut ou un littéral d'énumération ; voir 3.3.3).

Il existe plusieurs formes de déclaration. Une déclaration de base est une forme de
déclaration définie comme suit.

   déclaration_de base ::=
        déclaration_objet | numéro_déclaration
      | type_declaration | déclaration_sous-type
      | déclaration_sous-programme | déclaration_paquet
      | déclaration_de-tâche | déclaration_générique
      | déclaration_exception | générique_instantiation
      | renommage_déclaration | déclaration_constante_ferrée

Certaines formes de déclaration apparaissent toujours (explicitement) dans le cadre d'un
déclaration; ces formes sont des spécifications discriminantes, composantes
déclarations, déclarations d'entrée, spécifications de paramètres, génériques
déclarations de paramètres et spécifications littérales d’énumération. Une boucle
la spécification des paramètres est une forme de déclaration qui n'apparaît que dans
certaines formes d'instructions de boucle.

Les autres formes de déclaration sont implicites : le nom d'un bloc, le
le nom d'une boucle et le label d'une instruction sont implicitement déclarés. Certain
les opérations sont implicitement déclarées (voir 3.3.3).   

Pour chaque forme de déclaration, les règles linguistiques définissent une certaine région de
texte appelé portée de la déclaration (voir 8.2). Plusieurs formes de
déclaration associe un identifiant à une entité déclarée. Au sein de son
portée, et seulement là, il y a des endroits où il est possible d'utiliser le
identifiant pour faire référence à l'entité déclarée associée ; ces endroits sont
défini par les règles de visibilité (voir 8.3). Dans de tels endroits, l'identifiant
est dit être un nom de l'entité (son nom simple) ; on dit que le nom est 
désignent l’entité associée.

Certaines formes de spécification littérale d'énumération associent un caractère
littéral avec l'entité déclarée correspondante. Certaines formes de
déclaration associe un symbole d'opérateur ou une autre notation à un
opération déclarée explicitement ou implicitement.

Le processus par lequel une déclaration produit ses effets est appelé
élaboration de la déclaration; ce processus se produit pendant le programme
exécution.                                              

Après son élaboration, une déclaration est dite élaborée. Avant
l'achèvement de son élaboration (y compris avant l'élaboration), le
La déclaration n’est pas encore élaborée. L'élaboration de toute déclaration a
toujours au moins l'effet de la réalisation de ce changement d'état (de pas encore
élaboré à élaboré). L'expression « l'élaboration n'a pas d'autre
effet" est utilisé dans ce manuel chaque fois que ce changement d'état est le seul
effet d’élaboration d’une certaine forme de déclaration. Un processus d'élaboration
est également défini pour les parties déclaratives, les éléments déclaratifs et la compilation
unités (voir 3.9 et 10.5).

Les déclarations d'objet, de nombre, de type et de sous-type sont décrites ici. Le
les déclarations de base restantes sont décrites dans les chapitres suivants.

Note:

Les règles de syntaxe utilisent le terme identifiant pour la première occurrence d'un
identifiant sous une forme de déclaration ; le terme nom simple est utilisé pour
toute occurrence d'un identifiant qui désigne déjà une entité déclarée.

Références : attribut 4.1.4, nom de bloc 5.6, instruction de bloc 5.6,
caractère littéral 2.5, déclaration de composant 3.7, élément déclaratif 3.9,
partie déclarative 3.9, déclaration constante différée 7.4, discriminante
spécification 3.7.1, élaboration 3.9, déclaration d'entrée 9.5, énumération
spécification littérale 3.5.1, déclaration d'exception 11.1, générique
déclaration 12.1, instanciation générique 12.3, déclaration de paramètre générique
12.1, identifiant 2.3, étiquette 5.1, nom de boucle 5.5, paramètre de boucle
spécification 5.5, instruction de boucle 5.5, nom 4.1, déclaration numérique 3.2.2,
littéral numérique 2.4, déclaration d'objet 3.2.1, opération 3.3, opérateur
symbole 6.1, déclaration de package 7.1, spécification de paramètre 6.1, enregistrement
composant 3.7, déclaration de renommage 8.5, clause de représentation 13.1, portée
8.2, nom simple 4.1, corps du sous-programme 6.3, déclaration du sous-programme 6.1,
déclaration de sous-type 3.3.2, déclaration de tâche 9.1, déclaration de type 3.3.1,
visibilité 8.3  

3.2 Objets et numéros nommés 

Un objet est une entité qui contient (a) une valeur d'un type donné. Un
l'objet est l'un des éléments suivants :

 - un objet déclaré par une déclaration d'objet ou par une tâche unique
    déclaration,

 - un paramètre formel d'un sous-programme, d'une entrée ou d'un sous-programme générique,

 - un objet formel générique,

 - un paramètre de boucle,

 - un objet désigné par une valeur d'un type d'accès,

 - un composant ou une tranche d'un autre objet.    

Une déclaration de nombre est une forme spéciale de déclaration d'objet qui
associe un identifiant à une valeur de type universal_integer ou
universal_real.

   déclaration_objet ::=
        identifier_list : [constante] subtype_indication [:= expression] ;
      | identifier_list : [constant] constrained_array_definition [:= expression];

   number_declaration ::=
        identifier_list : constante := universal_static_expression;

   identifier_list ::= identifiant {, identifiant}                                            

Une déclaration d'objet est appelée déclaration d'objet unique si sa
la liste d'identifiants a un seul identifiant ; c'est ce qu'on appelle un objet multiple
déclaration si la liste d’identifiants contient deux identifiants ou plus. Un multiple
la déclaration d'objet équivaut à une séquence du numéro correspondant
de déclarations d'objet unique. Pour chaque identifiant de la liste, le
la séquence équivalente a une seule déclaration d'objet formée par ce
identifiant, suivi de deux points et de ce qui apparaît à droite du
deux points dans la déclaration d'objets multiples ; la séquence équivalente est dans
le même ordre que la liste des identifiants.

Une équivalence similaire s'applique également aux listes d'identifiants de numéros
déclarations, déclarations de composants, spécifications discriminantes,
spécifications de paramètres, déclarations de paramètres génériques, exception
déclarations et déclarations constantes différées.

Dans la suite de ce manuel de référence, des explications sont données pour
déclarations avec un seul identifiant ; les explications correspondantes pour
les déclarations avec plusieurs identifiants découlent de l’équivalence déclarée
au-dessus de.

Exemple:

   -- la déclaration d'objets multiples

   JOHN, PAUL : PERSON_NAME := nouvelle PERSONNE(SEXE => M); -- voir 3.8.1

   -- équivaut aux deux déclarations d'objet unique dans l'ordre
       donné

   JOHN : PERSON_NAME := nouvelle PERSONNE(SEXE => M);
   PAUL : PERSON_NAME := nouvelle PERSONNE(SEX => M);

Références : type d'accès 3.8, définition de tableau contraint 3.6, composant
3.3, déclaration 3.1, déclaration constante différée 7.4, désigner 3.8,
spécification discriminante 3.7.1, entrée 9.5, déclaration d'exception 11.1,
expression 4.4, paramètre formel 6.1, objet formel générique 12.1.1, générique
déclaration des paramètres 12.1, unité générique 12, sous-programme générique 12.1,
identifiant 2.3, paramètre de boucle 5.5, type numérique 3.5, paramètre
spécification 6.1, portée 8.2, nom simple 4.1, déclaration de tâche unique 9.1,
tranche 4.1.2, expression statique 4.9, sous-programme 6, indication de sous-type 3.3.2,
type 3.3, type universel_entier 3.5.4, type universel_réel 3.5.6  

3.2.1 Déclarations d'objet 

Une déclaration d'objet déclare un objet dont le type est donné soit par un
indication de sous-type ou par une définition de tableau contraint. Si l'objet
La déclaration inclut le délimiteur composé d'affectation suivi d'un
expression, l'expression spécifie une valeur initiale pour le déclaré
objet; le type de l'expression doit être celui de l'objet.

L'objet déclaré est une constante si le mot réservé constante apparaît dans
la déclaration d'objet ; la déclaration doit alors inclure une mention explicite
initialisation. La valeur d'une constante ne peut plus être modifiée après 
initialisation. Paramètres formels de mode d'entrée des sous-programmes et des entrées,
et les paramètres formels génériques du mode in, sont également des constantes ; une boucle  
le paramètre est une constante dans la boucle correspondante ; un sous-composant ou
la tranche d'une constante est une constante.

Un objet qui n'est pas une constante est appelé une variable (en particulier le
objet déclaré par une déclaration d'objet qui n'inclut pas le contenu réservé
la constante du mot est une variable). Les seules façons de changer la valeur d'un
variable sont soit directement par une affectation, soit indirectement lorsque la
variable est mise à jour (voir 6.2) par une instruction d'appel de procédure ou d'entrée (cette
l'action peut être effectuée soit sur la variable elle-même, soit sur un sous-composant de
la variable, ou sur une autre variable qui a la variable donnée comme
sous-composant).                                           

L'élaboration d'une déclaration d'objet se déroule de la manière suivante :

(a) L'indication de sous-type ou la définition de tableau contraint est la première
    élaboré. Ceci établit le sous-type de l'objet.

(b) Si la déclaration d'objet inclut une initialisation explicite, le
    la valeur initiale est obtenue en évaluant l’expression correspondante.
    Sinon, toutes les valeurs initiales implicites pour l'objet ou pour son
    Les sous-composants sont évalués.

(c) L'objet est créé.

(d) Toute valeur initiale (qu'elle soit explicite ou implicite) est attribuée au
    objet ou au sous-composant correspondant.

Des valeurs initiales implicites sont définies pour les objets déclarés par object
déclarations, et pour les composants de ces objets, dans les cas suivants :

 - Si le type d'un objet est un type d'accès, la valeur initiale implicite
    est la valeur nulle du type d'accès.

 - Si le type d'un objet est un type de tâche, l'initiale implicite (et
    uniquement) la valeur désigne une tâche correspondante.   

 - Si le type d'un objet est un type avec des discriminants et le sous-type
    de l'objet est contrainte, la valeur initiale (et unique) implicite de
    chaque discriminant est défini par le sous-type de l'objet.

 - Si le type d'un objet est un type composite, l'initiale implicite
    la valeur de chaque composant qui a une expression par défaut est obtenue par
    évaluation de cette expression, sauf si la composante est discriminante
    d'un objet contraint (cas précédent).

Dans le cas d'un composant qui est lui-même un objet composite et dont
la valeur n'est définie ni par une initialisation explicite ni par une valeur par défaut
expression, toutes les valeurs initiales implicites pour les composants du composite
objet sont définis par les mêmes règles que pour un objet déclaré.

Les étapes (a) à (d) sont réalisées dans l'ordre indiqué. Pour l'étape (b),
si l'expression par défaut d'un discriminant est évaluée, alors ceci
l'évaluation est effectuée avant celle des expressions par défaut pour
sous-composantes qui dépendent des discriminants, et aussi avant celle du défaut
expressions qui incluent le nom du discriminant. Séparé de
règle précédente, l'évaluation des expressions par défaut est effectuée dans certains
ordre qui n’est pas défini par la langue.

L'initialisation d'un objet (l'objet déclaré ou l'un de ses
sous-composants) vérifie que la valeur initiale appartient au sous-type du
objet; pour un objet tableau déclaré par une déclaration d'objet, un implicite
la conversion de sous-type est d'abord appliquée comme pour une instruction d'affectation, sauf si
l'objet est une constante dont le sous-type est un type tableau sans contrainte. Le
l'exception CONSTRAINT_ERROR est levée si cette vérification échoue.   

La valeur d'une variable scalaire n'est pas définie après l'élaboration du  
déclaration d'objet correspondante, sauf si une valeur initiale est affectée à l'objet
variable par une initialisation (explicite ou implicite).

Si l'opérande d'une conversion de type ou d'une expression qualifiée est une variable
qui a des sous-composants scalaires avec des valeurs non définies, alors les valeurs du
les sous-composants correspondants du résultat ne sont pas définis. L'exécution de
un programme est erroné s'il tente d'évaluer une variable scalaire avec
une valeur indéfinie. De même, l'exécution d'un programme est erronée si
il tente d'appliquer un opérateur prédéfini à une variable qui a un scalaire
sous-composant avec une valeur indéfinie.                                             

Exemples de déclarations de variables :

   COMPTE, SOMME : ENTIER ;
   TAILLE : plage INTEGER 0 .. 10_ := 0;
   TRIÉ : BOOLÉEN := FAUX;
   COLOR_TABLE : tableau(1 .. N) de COULEUR ;
   OPTION : BIT_VECTOR(1 .. 10) := (autres => VRAI);

Exemples de déclarations constantes :

   LIMITE : constante ENTIER := 10_
   LOW_LIMIT : constante INTEGER := LIMIT/10;
   TOLÉRANCE : constante RÉEL := DISPERSION(1.15);

Note:

L'expression initialisant un objet constant n'a pas besoin d'être une expression statique
expression (voir 4.9). Dans les exemples ci-dessus, LIMIT et LOW_LIMIT sont
initialisé avec des expressions statiques, mais la TOLÉRANCE ne l'est pas si la DISPERSION est
une fonction définie par l'utilisateur.

Références : type d'accès 3.8, affectation 5.2, délimiteur composé d'affectation
5.2, composant 3.3, type composite 3.3, définition de tableau contraint 3.6,
sous-type contraint 3.3, exception constraint_error 11.1, conversion 4.6,
déclaration 3.1, expression par défaut pour un discriminant 3.7, initiale par défaut
valeur pour un type d'accès 3.8, dépendre d'un discriminant 3.7.1, désigner
3.8, discriminant 3.3, élaboration 3.9, entrée 9.5, évaluation 4.5,
expression 4.4, paramètre formel 6.1, paramètre formel générique 12.1 12.3,
unité générique 12, dans un certain ordre 1.6, type limité 7.4.4, mode en 6.1,
package 7, opérateur prédéfini 4.5, primaire 4.4, type privé 7.4,
expression qualifiée 4.7, mot réservé 2.9, type scalaire 3.5, tranche 4.1.2,
sous-composant 3.3, sous-programme 6, sous-type 3.3, indication de sous-type 3.3.2, tâche
9, type de tâche 9.2, type 3.3, partie visible 7.2  

3.2.2 Déclarations numériques 

Une déclaration numérique est une forme spéciale de déclaration constante. Le type
de l'expression statique donnée pour l'initialisation d'un nombre
La déclaration doit être soit du type universal_integer, soit du type
universal_real. La constante déclarée par une déclaration numérique est appelée un
numéro nommé et a le type de l’expression statique.

Note:

Les règles concernant les expressions de type universel sont expliquées dans
article 4.10. C'est une conséquence de ces règles que si chaque primaire
contenu dans l’expression est du type universal_integer, alors le
le numéro nommé est également de ce type. De même, si chaque primaire est du
tapez universal_real, alors le numéro nommé est également de ce type.

Exemples de déclarations de nombres :  

 PI : constante := 3.14159_26536; -- un vrai nombre
 TWO_PI : constante := 2.0*PI; -- un vrai nombre
 MAX : constante := 5 -- un nombre entier
 POWER_16 : constante := 2**16; -- l'entier 65_536
 UN, UN, EINS : constante := 1; -- trois noms différents pour 1

Références : identifiant 2.3, primaire 4.4, expression statique 4.9, type 3.3,
type universal_integer 3.5.4, type universal_real 3.5.6, type universel
4.1 4                                             

3.3 Types et sous-types 

Un type est caractérisé par un ensemble de valeurs et un ensemble d'opérations.

Il existe plusieurs classes de types. Les types scalaires sont des types entiers, réels
les types et les types définis par énumération de leurs valeurs ; valeurs de ces
les types n’ont aucun composant. Les types de tableau et d'enregistrement sont composites ; une valeur
d'un type composite est constitué de valeurs de composants. Un type d'accès est un type
dont les valeurs donnent accès aux objets. Les types privés sont des types pour lesquels
l'ensemble des valeurs possibles est bien défini, mais n'est pas directement disponible pour
les utilisateurs de ces types. Enfin, il existe des types de tâches. (Types privés
sont décrits au chapitre 7, les types de tâches sont décrits au chapitre 9, les
d'autres classes de types sont décrites dans ce chapitre.)

Certains types d'enregistrement et privés ont des composants spéciaux appelés
discriminants dont les valeurs distinguent des formes alternatives de valeurs d'un
de ces types. Si un type privé a des discriminants, ils sont connus pour
utilisateurs du type. Un type privé n'est donc connu que par son nom, son
discriminants s’il y en a, et par l’ensemble d’opérations correspondant.

L'ensemble des valeurs possibles pour un objet d'un type donné peut être soumis
à une condition appelée contrainte (le cas où la contrainte
n'impose aucune restriction est également inclus) ; on dit qu’une valeur satisfait un
contrainte si elle satisfait à la condition correspondante. Un sous-type est un
tapez avec une contrainte ; on dit qu’une valeur appartient à un sous-type de
un type donné s'il appartient au type et satisfait la contrainte ; le 
le type donné est appelé le type de base du sous-type. Un type est un sous-type de
lui-même ; un tel sous-type est dit sans contrainte : il correspond à un
condition qui n’impose aucune restriction. Le type de base d'un type est le type
lui-même.

L'ensemble des opérations définies pour un sous-type d'un type donné comprend les
les opérations définies pour le type ; cependant l'opération d'affectation
à une variable ayant un sous-type donné, n'attribue que des valeurs appartenant au
sous-type. Des opérations complémentaires, telles que la qualification (dans un
expression), sont implicitement définis par une déclaration de sous-type.

Certains types ont des valeurs initiales par défaut définies pour les objets du type ;
certains autres types ont des expressions par défaut définies pour tout ou partie des
leurs composants. Certaines opérations de types et sous-types sont appelées
les attributs; ces opérations sont désignées par la forme du nom décrite dans
paragraphe 4.1.4.

Le terme sous-composant est utilisé dans ce manuel à la place du terme composant
pour indiquer soit un composant, soit un composant d'un autre composant ou
sous-composant. Lorsque d'autres sous-composants sont exclus, le terme composant
est utilisé à la place.

Un type donné ne doit pas avoir de sous-composant dont le type est le type donné
lui-même.

Le nom d'une classe de types est utilisé dans ce manuel comme qualificatif pour
les objets et les valeurs qui ont un type de la classe considérée. Par exemple,
le terme « objet tableau » est utilisé pour un objet dont le type est un type tableau ; 
de même, le terme « valeur d'accès » est utilisé pour une valeur d'un type d'accès.

Note:

L'ensemble des valeurs d'un sous-type est un sous-ensemble des valeurs du type de base.
Ce sous-ensemble n'a pas besoin d'être un sous-ensemble approprié ; il peut s'agir d'un sous-ensemble vide.

Références : type d'accès 3.8, type de tableau 3.6, affectation 5.2, attribut  
4.1.4, composante d'un tableau 3.6, composante d'un enregistrement 3.7, discriminant
contrainte 3.7.2, type énumération 3.5.1, type entier 3.5.4, objet 3.2.1,
type privé 7.4, expression qualifiée 4.7, type réel 3.5.6, type d'enregistrement
3.7, déclaration de sous-type 3.3.2, type de tâche 9.1, déclaration de type 3.3.1                                            

3.3.1 Déclarations de type 

Une déclaration de type déclare un type.

   type_declaration ::= full_type_declaration
      | déclaration_type_incomplète | déclaration_type_privée

   full_type_declaration ::=
        l'identifiant de type [discriminant_part] est type_definition ;

   définition_type ::=
        définition_type_énumération | définition_type_entier
      | définition_type_réel | définition_type_tableau
      | définition_type_enregistrement | access_type_definition
      | définition_type_dérivé

L'élaboration d'une déclaration de type complète consiste en l'élaboration de
la partie discriminante, le cas échéant (sauf dans le cas du type complet
déclaration pour une déclaration de type incomplète ou privée), et de la
élaboration de la définition du type.

Les types créés par l'élaboration de définitions de types distinctes sont
types distincts. De plus, l'élaboration de la définition de type pour un
le type numérique ou dérivé crée à la fois un type de base et un sous-type de la base
taper; il en va de même pour une définition de tableau contraint (l'un des deux
formes de définition de type de tableau).

Le nom simple déclaré par une déclaration de type complet désigne le
type, sauf si la déclaration de type déclare à la fois un type de base et un sous-type
du type de base, auquel cas le nom simple désigne le sous-type, et
le type de base est anonyme. Un type est dit anonyme s’il n’a pas
nom simple. À des fins explicatives, ce manuel de référence
fait référence à un type anonyme par un pseudo-nom, écrit en italique, et utilise
ces pseudo-noms à des endroits où la syntaxe nécessite normalement un
identifiant.

Exemples de définitions de types :

   (BLANC, ROUGE, JAUNE, VERT, BLEU, MARRON, NOIR)
   plage1 .. 72
   tableau (1 .. 10) de INTEGER

Exemples de déclarations de type :

   le type COULEUR est (BLANC, ROUGE, JAUNE, VERT, BLEU, MARRON, NOIR) ;
   le type COLUMN est compris entre 1 et 72 ;
   le type TABLE est un tableau (1 .. 10) de INTEGER ;

Remarques:

Deux définitions de types définissent toujours deux types distincts, même s'ils sont
textuellement identique. Ainsi, les définitions de type de tableau données dans le
les déclarations de A et B ci-dessous définissent des types distincts.  

   A : tableau(1 .. 10) de BOOLEAN ;
   B : tableau(1 .. 10) de BOOLEAN ;

Si A et B sont déclarés par une déclaration d'objets multiples comme ci-dessous, leur
les types sont néanmoins différents, puisque la déclaration d'objets multiples est
équivalent aux deux déclarations d'objet unique ci-dessus.

   A, B : tableau(1 .. 10) de BOOLEAN ;                                                

Les déclarations de type incomplètes sont utilisées pour la définition des types récursifs et
types mutuellement dépendants (voir 3.8.1). Les déclarations de type privé sont utilisées
dans les spécifications des paquets et dans les déclarations de paramètres génériques (voir 7.4
et 12.1).

Références : définition de type d'accès 3.8, définition de type de tableau 3.6, base
type 3.3, définition de tableau contraint 3.6, sous-type contraint 3.3, 
déclaration 3.1, type dérivé 3.4, définition de type dérivé 3.4,
partie discriminante 3.7.1, élaboration 3.9, définition du type d'énumération
3.5.1, identifiant 2.3, déclaration de type incomplète 3.8.1, type entier
définition 3.5.4, déclaration d'objets multiples 3.2, type numérique 3.5,
déclaration de type privé 7.4, définition de type réel 3.5.6, mot réservé
2.9, tapez 3.3  

3.3.2 Déclarations de sous-type 

Une déclaration de sous-type déclare un sous-type.

   déclaration_sous-type ::=
      l'identifiant du sous-type est subtype_indication ;

   subtype_indication ::= type_mark [contrainte]

   type_mark ::= type_name | nom_sous-type

   contrainte ::=
        range_constraint | flottant_point_constraint | contrainte_point_fixe
      | index_constraint | contrainte_discriminante

Une marque de type désigne un type ou un sous-type. Si une marque de type est le nom d'un
type, la marque de type désigne ce type ainsi que le correspondant
sous-type sans contrainte. Le type de base d'une marque typographique est, par définition, le
type de base du type ou du sous-type désigné par la marque de type.

Une indication de sous-type définit un sous-type du type de base de la marque de type.
Si une contrainte d'index apparaît après une marque de type dans une indication de sous-type,
la marque de type ne doit pas déjà imposer une contrainte d'index. De même pour un
contrainte discriminante, la marque de type ne doit pas déjà imposer une
contrainte discriminante.

L'élaboration d'une déclaration de sous-type consiste en l'élaboration du
indication du sous-type. L'élaboration d'une indication de sous-type crée un
sous-type. Si l'indication de sous-type ne comprend pas de contrainte, le
le sous-type est le même que celui indiqué par la marque de type. L'élaboration d'un
l'indication de sous-type qui inclut une contrainte se déroule comme suit :

(a) La contrainte est d’abord élaborée.

(b) On vérifie ensuite que la contrainte est compatible avec le type 
    ou sous-type désigné par la marque de type.  

La condition imposée par une contrainte est la condition obtenue après
élaboration de la contrainte. (Les règles d'élaboration des contraintes sont
de telle sorte que les expressions et les plages de contraintes soient évaluées par le
élaboration de ces contraintes.) Les règles définissant la compatibilité sont
donnée pour chaque forme de contrainte dans la section appropriée. Ces règles
sont tels que si une contrainte est compatible avec un sous-type, alors le
la condition imposée par la contrainte ne peut contredire aucune condition déjà
imposé par le sous-type sur ses valeurs. L'exception CONSTRAINT_ERROR est
déclenché si une vérification de compatibilité échoue.                                               

Exemples de déclarations de sous-type : 

   le sous-type RAINBOW est la gamme de COULEURS ROUGE .. BLEU ; -- voir 3.3.1
   le sous-type RED_BLUE est RAINBOW ;
   le sous-type INT est INTEGER ;
   le sous-type SMALL_INT est la plage INTEGER -10 .. 10 ;
   le sous-type UP_TO_K est la plage COLUMN 1 .. K ; -- voir 3.3.1
   le sous-type CARRÉ est MATRIX(1 .. 10, 1 .. 10) ; -- voir 3.6
   le sous-type MALE est PERSONNE (SEXE => M) ; -- voir 3.8

Note:

Une déclaration de sous-type ne définit pas un nouveau type.

Références : type de base 3.3, compatibilité des contraintes discriminantes
3.7.2, compatibilité des contraintes de point fixe 3.5.9, compatibilité des
contraintes de virgule flottante 3.5.7, compatibilité des contraintes d'index 3.6.1,
compatibilité des contraintes de plage 3.5, exception constraint_error 11.1,
déclaration 3.1, discriminant 3.3, contrainte discriminante 3.7.2,  
élaboration 3.9, évaluation 4.5, expression 4.4, contrainte de virgule flottante
3.5.7, contrainte de point fixe 3.5.9, contrainte d'index 3.6.1, plage
contrainte 3.5, mot réservé 2.9, sous-type 3.3, type 3.3, nom de type 3.3.1,
sous-type sans contrainte 3.3  

3.3.3 Classification des opérations 

L'ensemble des opérations d'un type inclut les opérations explicitement déclarées
sous-programmes qui ont un paramètre ou un résultat du type ; de tels sous-programmes
sont nécessairement déclarés après la déclaration de type.

Les opérations restantes sont chacune implicitement déclarées pour un type donné
déclaration, immédiatement après la définition du type. Ceux-ci implicitement
les opérations déclarées comprennent les opérations de base, les opérateurs prédéfinis
(voir 4.5) et les littéraux d'énumération. Dans le cas d'un type dérivé
déclaration, les opérations implicitement déclarées incluent toutes les opérations dérivées
sous-programmes. Les opérations implicitement déclarées pour un type donné
la déclaration se produit après la déclaration de type et avant le prochain explicite
déclaration, le cas échéant. Les déclarations implicites des sous-programmes dérivés
surviennent en dernier.

Une opération de base est une opération inhérente à l'un des éléments suivants :

 - Une affectation (dans les instructions d'affectation et les initialisations), un
    répartiteur, un test d'adhésion ou un formulaire de contrôle de court-circuit.

 - Un composant sélectionné, un composant indexé ou une tranche.

 - Une qualification (en expressions qualifiées), un type explicite
    conversion, ou une conversion de type implicite d'une valeur de type
    universal_integer ou universal_real à la valeur correspondante de
    un autre type numérique. 

 - Un littéral numérique (pour un type universel), le littéral null (pour un
    type d'accès), une chaîne littérale, un agrégat ou un attribut.

Pour chaque type ou sous-type T, l'attribut suivant est défini :

T'BASE Le type de base de T. Cet attribut est autorisé uniquement en tant que
          préfixe du nom d'un autre attribut : par exemple,
          T'BASE'EN PREMIER.                                                

Note:

Chaque littéral est une opération dont l'évaluation donne le correspondant
valeur (voir 4.2). De même, un agrégat est une opération dont l'évaluation
donne une valeur d'un type composite (voir 4.3). Quelques opérations d'un type
opérer sur des valeurs du type, par exemple, des opérateurs prédéfinis et
certains sous-programmes et attributs. L'évaluation de certaines opérations d'un
type renvoie une valeur du type, par exemple, des littéraux et certains
fonctions, attributs et opérateurs prédéfinis. La mission est un
opération qui opère sur un objet et une valeur. L'évaluation du
opération correspondant à un composant sélectionné, un composant indexé ou un
slice, donne l'objet ou la valeur désignée par cette forme de nom. 

Références : agrégat 4.3, allocateur 4.8, affectation 5.2, attribut 4.1.4,
caractère littéral 2.5, type composite 3.3, conversion 4.6, dérivé
sous-programme 3.4, littéral d'énumération 3.5.1, paramètre formel 6.1, fonction
6.5, composant indexé 4.1.1, valeur initiale 3.2.1, littéral 4.2, appartenance
test 4.5 4.5.2, littéral nul 3.8, littéral numérique 2.4, type numérique 3.5,
objet 3.2.1, 6.1, opérateur prédéfini 4.5, expression qualifiée 4.7,
composant sélectionné 4.1.3, formulaire de contrôle de court-circuit 4.5 4.5.1, tranche
4.1.2, chaîne littérale 2.6, sous-programme 6, sous-type 3.3, type 3.3, type
déclaration 3.3.1, type universal_integer 3.5.4, type universal_real 3.5.6,
type universel 4.1 4 

3.4 Types dérivés 

Une définition de type dérivé définit un nouveau type (de base) dont les caractéristiques
sont dérivés de ceux d'un type parent ; le nouveau type est appelé un dérivé
taper. Une définition de type dérivé définit en outre un sous-type dérivé, qui
est un sous-type du type dérivé.

   dérivé_type_definition ::= nouveau sous-type_indication

L'indication de sous-type qui apparaît après le mot réservé new définit le
sous-type parent. Le type parent est le type de base du sous-type parent.
Si une contrainte existe pour le sous-type parent, une contrainte similaire existe
pour le sous-type dérivé ; la seule différence est que pour une gamme
contrainte, et de même pour une contrainte de virgule flottante ou fixe qui
inclut une contrainte de plage, la valeur de chaque limite est remplacée par la
valeur correspondante du type dérivé. Les caractéristiques du
Les types dérivés sont définis comme suit :

 - Le type dérivé appartient à la même classe de types que le parent
    taper. L'ensemble des valeurs possibles pour le type dérivé est une copie de
    l'ensemble des valeurs possibles pour le type parent. Si le type de parent est
    composite, alors les mêmes composants existent pour le type dérivé, et
    le sous-type des composants correspondants est le même.

 - Pour chaque opération de base du type parent, il existe une
    opération de base du type dérivé. Conversion de type explicite d'un
    valeur du type parent dans la valeur correspondante du type dérivé 
    le type est autorisé et vice versa comme expliqué dans la section 4.6.

 - Pour chaque littéral d'énumération ou opérateur prédéfini du type parent
    il existe une opération correspondante pour le type dérivé.

 - Si le type parent est un type de tâche, alors pour chaque entrée du parent
    type, il existe une entrée correspondante pour le type dérivé.

 - Si une expression par défaut existe pour un composant d'un objet ayant le
    type parent, la même expression par défaut est utilisée pour le
    composant correspondant d’un objet ayant le type dérivé.                                             

 - Si le type parent est un type d'accès, alors le parent et le dérivé
    tapez partager la même collection ; il existe une valeur d'accès nulle pour le
    type dérivé et c’est la valeur initiale par défaut de ce type.

 - Si une clause de représentation explicite existe pour le type parent et si
    cette clause apparaît avant la définition du type dérivé, alors il y a
    une clause de représentation correspondante (implicite) pour le
    type dérivé.

 - Certains sous-programmes qui sont des opérations de type parent sont dits
    être dérivable. Pour chaque sous-programme dérivable du type parent, il y a
    est un sous-programme dérivé correspondant pour le type dérivé. Deux types
    de sous-programmes dérivables existent. Premièrement, si le type parent est déclaré
    immédiatement dans la partie visible d'un package, puis un sous-programme
    qui est lui-même explicitement déclaré immédiatement dans la partie visible
    devient dérivable après la fin de la partie visible, s'il s'agit d'un
    opération du type parent. (La déclaration explicite est faite par un
    déclaration de sous-programme, une déclaration de renommage ou une déclaration générique
    instanciation.) Deuxièmement, si le type parent est lui-même un type dérivé,
    alors tout sous-programme dérivé de ce type parent est
    dérivable en outre, sauf si le type parent est déclaré dans le visible 
    partie d'un package et le sous-programme dérivé est masqué par un dérivé
    sous-programme du premier type.

Chaque opération de type dérivé est implicitement déclarée à l'endroit de
la déclaration de type dérivé. Les déclarations implicites de tout dérivé
les sous-programmes surviennent en dernier.

La spécification d'un sous-programme dérivé est obtenue implicitement par
remplacement systématique du type parent par le type dérivé dans le
spécification du sous-programme dérivable. Tout sous-type du type parent
est également remplacé par un sous-type du type dérivé avec un
contrainte (comme pour la transformation d'une contrainte du sous-type parent
dans la contrainte correspondante du sous-type dérivé). Enfin, n'importe quel
l'expression du type parent est faite pour être l'opérande d'un type
conversion qui donne un résultat du type dérivé.

Appeler un sous-programme dérivé équivaut à appeler le sous-programme correspondant
sous-programme du type parent, dans lequel chaque paramètre réel qui est de
le type dérivé est remplacé par une conversion de type de ce paramètre réel
au type parent (cela signifie qu'une conversion vers le type parent se produit
avant l'appel pour les modes in et in out ; une conversion inverse en
le type dérivé se produit après l'appel des modes in out et out, voir
6.4.1). De plus, si le résultat d'une fonction appelée est celui du parent
type, ce résultat est converti en type dérivé.

Si un type dérivé ou privé est déclaré immédiatement dans le visible
partie d'un colis, alors, au sein de cette partie visible, ce type ne doit pas être
utilisé comme type parent d’une définition de type dérivé. (Pour les types privés,
voir également la section 7.4.1.)

Pour l'élaboration d'une définition de type dérivé, l'indication de sous-type est
d'abord élaboré, le type dérivé est ensuite créé, et enfin, le
le sous-type dérivé est créé.     

Exemples:

   tapez LOCAL_COORDINATE est nouveau COORDINATE ; -- deux types différents
   le type MIDWEEK est la nouvelle plage JOUR MAR .. JEU ; -- voir 3.5.1
   le type COUNTER est nouveau POSITIF ; -- même gamme que POSITIF

   tapez SPECIAL_KEY est le nouveau KEY_MANAGER.KEY ; -- voir 7.4.2
   -- les sous-programmes dérivés ont les spécifications suivantes :

   -- procédure GET_KEY(K : sortie SPECIAL_KEY);
   -- fonction "<"(X,Y : SPECIAL_KEY) return BOOLEAN ;                                             

Remarques:

Les règles de dérivation des opérations de base et des littéraux d'énumération impliquent
que la notation de tout littéral ou agrégat du type dérivé est la
idem que pour le type parent ; ces littéraux et agrégats sont dits
surchargé. De même, il s'ensuit que la notation pour désigner un
un composant, un discriminant, une entrée, une tranche ou un attribut est identique
pour le type dérivé comme pour le type parent.

Le masquage d'un sous-programme dérivé est autorisé même au sein du même déclaratif
région (voir 8.3). Un sous-programme dérivé cache un opérateur prédéfini qui
a le même profil de paramètre et de type de résultat (voir 6.6).

Une déclaration de sous-programme générique n'est pas dérivable puisqu'elle déclare un
unité générique plutôt qu’un sous-programme. En revanche, une instanciation
d'un sous-programme générique est un sous-programme (non générique), qui est dérivable si
il satisfait aux exigences de dérivabilité des sous-programmes.

Si le type parent est un type booléen, les opérateurs relationnels prédéfinis
du type dérivé délivrent un résultat de type prédéfini BOOLEAN (voir
4.5.2).   

Si une clause de représentation est donnée pour le type parent mais apparaît après
la déclaration de type dérivé, alors aucune clause de représentation correspondante
s'applique au type dérivé ; d'où une clause de représentation explicite pour
un tel type dérivé est autorisé.

Pour un sous-programme dérivé, si un paramètre appartient au type dérivé, le
Le sous-type de ce paramètre n'a pas besoin d'avoir de valeur commune avec le
sous-type dérivé.

Références : valeur d'accès 3.8, paramètre réel 6.4.1, agrégat 4.3,
attribut 4.1.4, type de base 3.3, opération de base 3.3.3, type booléen 3.5.3,
limite d'une plage 3.5, classe de type 3.3, collection 3.8, composant 3.3,
type composite 3.3, contrainte 3.3, conversion 4.6, déclaration 3.1,
région déclarative 8.1, expression par défaut 3.2.1, valeur initiale par défaut pour
un accès type 3.8, discriminant 3.3, élaboration 3.9, entrée 9.5,
littéral d'énumération 3.5.1, contrainte de virgule flottante 3.5.7, virgule fixe
contrainte 3.5.9, paramètre formel 6.1, appel de fonction 6.4, générique
déclaration 12.1, immédiatement dans 8.1, implicite déclaration 3.1, littérale
4.2, mode 6.1, surcharge 6.6 8.7, package 7, spécification de package 7.1,
association de paramètres 6.4, opérateur prédéfini 4.5, type privé 7.4,
procédure 6, instruction d'appel de procédure 6.4, contrainte de plage 3.5,
clause de représentation 13.1, mot réservé 2.9, tranche 4.1.2, sous-programme 6,
spécification de sous-programme 6.1, indication de sous-type 3.3.2, sous-type 3.3, type
3.3, définition de type 3.3.1, partie visible 7.2  

3.5 Types scalaires 

Les types scalaires comprennent les types d’énumération, les types entiers et les types réels.
Les types d’énumération et les types entiers sont appelés types discrets ; chaque valeur
d'un type discret a un numéro de position qui est une valeur entière. 

Les types entiers et les types réels sont appelés types numériques. Tous les types scalaires
sont ordonnés, c'est-à-dire que tous les opérateurs relationnels sont prédéfinis pour leur
valeurs.

   range_constraint ::= plage plage

   plage ::= plage_attribute
      | expression_simple .. expression_simple                                                

Une plage spécifie un sous-ensemble de valeurs d'un type scalaire. La gamme L..R
spécifie les valeurs de L à R inclus si la relation L <= R est vraie.
Les valeurs L et R sont appelées borne inférieure et borne supérieure de la plage,
respectivement. Une valeur V est dite satisfaire une contrainte de plage si elle
appartient à la gamme ; la valeur V est dite appartenir à la plage si la
les relations L <= V et V <= R sont toutes deux VRAIES. Une plage nulle est une plage pour
dont la relation R < L est VRAIE ; aucune valeur n'appartient à une plage nulle. Le
les opérateurs <= et < dans les définitions ci-dessus sont les opérateurs prédéfinis de
le type scalaire.

Si une contrainte de plage est utilisée dans une indication de sous-type, soit directement, soit
dans le cadre d'une contrainte de virgule flottante ou fixe, le type du simple
les expressions (de même que les limites d'un attribut de plage) doivent être les
identique au type de base de la marque de type de l'indication de sous-type. Une gamme
la contrainte est compatible avec un sous-type si chaque limite de la plage appartient
au sous-type, ou si la contrainte de plage définit une plage nulle ; sinon
la contrainte de plage n'est pas compatible avec le sous-type.

L'élaboration d'une contrainte de portée consiste en l'évaluation de la
gamme. L'évaluation d'une fourchette définit sa borne inférieure et sa borne supérieure.
lié. Si des expressions simples sont données pour spécifier les limites, le 
l'évaluation de la plage évalue ces expressions simples dans un certain ordre
cela n’est pas défini par la langue.

Les attributs

Pour tout type scalaire T ou pour tout sous-type T d'un type scalaire, ce qui suit
les attributs sont définis :

T'FIRST Donne la limite inférieure de T. La valeur de cet attribut a
           du même type que T.

T'LAST Donne la limite supérieure de T. La valeur de cet attribut a
           du même type que T.

Note:

Les règles d'indexation et d'itération utilisent des valeurs de types discrets.

Références : attribut 4.1.4, contrainte 3.3, type d'énumération 3.5.1,
erroné 1.6, évaluation 4.5, contrainte de virgule fixe 3.5.9, virgule flottante
contrainte 3.5.7, index 3.6, type entier 3.5.4, instruction de boucle 5.5, plage
attribut 3.6.2, type réel 3.5.6, opérateur relationnel 4.5 4.5.2, satisfait à un
contrainte 3.3, expression simple 4.4, indication de sous-type 3.3.2, marque de type
3.3.2  

3.5.1 Types d'énumération 

Une définition de type d'énumération définit un type d'énumération.

   enumeration_type_definition ::=
      (enumeration_literal_specification {, enumeration_literal_specification}) 

   enumeration_literal_specification ::= enumeration_literal

   enumeration_literal ::= identifiant | caractère_littéral

Les identifiants et les littéraux de caractères répertoriés par un type d'énumération
la définition doit être distincte. Chaque spécification littérale d'énumération est la
déclaration du littéral d'énumération correspondant : cette déclaration est
équivalent à la déclaration d'une fonction sans paramètre, le désignateur
étant le littéral d'énumération et le type de résultat étant l'énumération
taper. L'élaboration d'une définition de type énumération crée un
type d'énumération ; cette élaboration inclut celle de chaque énumération
spécification littérale.                                            

Chaque littéral d’énumération génère une valeur d’énumération différente. Le
les relations d'ordre prédéfinies entre les valeurs d'énumération suivent l'ordre de
numéros de position correspondants. Le numéro de position de la valeur du
Le premier littéral d’énumération répertorié est zéro ; le numéro de position pour chacun
l'autre littéral d'énumération est un de plus que son prédécesseur dans la liste.

Si le même identifiant ou caractère littéral est spécifié dans plusieurs
définition du type d'énumération, les littéraux correspondants sont dits
surchargé. À tout endroit où un littéral d'énumération surchargé apparaît dans
le texte d'un programme, le type du littéral d'énumération doit être
déterminable à partir du contexte (voir 8.7).

Exemples:

 le type JOUR est (LUN, MAR, MER, JEU, VEN, SAM, DIM) ;
 le type COSTUME est (CLUBS, DIAMANTS, COEURS, PIQUE) ;
 tapez GENRE est (M, F);
 le type NIVEAU est (FAIBLE, MOYEN, URGENT) ;
 le type COULEUR est (BLANC, ROUGE, JAUNE, VERT, BLEU, MARRON, NOIR) ;
 le type LIGHT est (ROUGE, AMBRE, VERT) ; -- ROUGE et VERT sont surchargés

 le type HEXA est ('A', 'B', 'C', 'D', 'E', 'F') ;
 le type MIXED est ('A', 'B', '*', B, NONE, '?', '%');

 le sous-type WEEKDAY est la plage JOUR LUN .. FRI ;
 le sous-type MAJOR est la gamme COSTUME COEURS .. PIQUE ;
 le sous-type RAINBOW est la gamme de COULEURS ROUGE .. BLEU ; -- la couleur ROUGE, pas la
                                                  lumière

Note:

Si un littéral d'énumération apparaît dans un contexte qui ne serait pas autrement
il suffit de déterminer le type du littéral, puis la qualification par le
Le nom du type d'énumération est une façon de résoudre l'ambiguïté (voir 8.7). 

Références : caractère littéral 2.5, déclaration 3.1, désignateur 6.1,  
élaboration 3.9, 6.1, fonction 6.5, identifiant 2.3, nom 4.1, surcharge
6.6 8.7, numéro de position 3.5, expression qualifiée 4.7, opérateur relationnel
4.5 4.5.2, type 3.3, définition du type 3.3.1  

3.5.2 Types de caractères 

Un type énumération est dit type caractère si au moins un de ses
les littéraux d'énumération sont des littéraux de caractères. Le type prédéfini CHARACTER
est un type de caractère dont les valeurs sont les 128 caractères ASCII
jeu de caractères. Chacun des 95 caractères graphiques de ce jeu de caractères est
désigné par le caractère littéral correspondant.

Exemple:

   le type ROMAN_DIGIT est ('I', 'V', 'X', 'L', 'C', 'D', 'M') ;  

Remarques:

Le package prédéfini ASCII inclut la déclaration des constantes désignant
caractères de contrôle et de constantes désignant des caractères graphiques qui sont
pas dans le jeu de caractères de base.                                                   

Un jeu de caractères conventionnel tel que EBCDIC peut être déclaré comme un jeu de caractères
taper; les codes internes des caractères peuvent être précisés par un
clause de représentation par énumération comme expliqué à la section 13.3.

Références : package prédéfini ascii C, caractère de base 2.1, caractère
littéral 2.5, constante 3.2.1, déclaration 3.1, type énumération 3.5.1,
caractère graphique 2.1, identifiant 2.3, littéral 4.2, type prédéfini C, type 3.3  

3.5.3 Types booléens 

Il existe un type d'énumération prédéfini nommé BOOLEAN. Il contient les deux
les littéraux FALSE et TRUE ordonnés avec la relation FALSE < TRUE. Un booléen
type est soit le type BOOLEAN, soit un type dérivé, directement ou 
indirectement, à partir d'un type booléen.

Références : type dérivé 3.4, littéral d'énumération 3.5.1, type d'énumération
3.5.1, opérateur relationnel 4.5 4.5.2, type 3.3  

3.5.4 Types entiers 

Une définition de type entier définit un type entier dont l'ensemble des valeurs
comprend au moins ceux de la plage spécifiée.

   entier_type_definition ::= range_constraint

Si une contrainte de plage est utilisée comme définition de type entier, chaque limite de
la plage doit être définie par une expression statique d'un type entier, mais
les deux limites n'ont pas besoin d'avoir le même type entier. (Les limites négatives sont
autorisé.)

Une déclaration de type du formulaire :

   le type T est la plage L .. R ;

est, par définition, équivalent aux déclarations suivantes :

   le type entier_type est nouveau prédéfini_integer_type ;
   le sous-type T est la plage integer_type integer_type(L) .. integer_type(R);

où integer_type est un type anonyme et où l'entier prédéfini
Le type est implicitement sélectionné par l'implémentation, de manière à contenir le
valeurs L à R incluses. La déclaration de type entier est illégale si aucune
des types entiers prédéfinis satisfont à cette exigence, à l'exception
entier_universel. L'élaboration de la déclaration d'un type entier
consiste en l’élaboration du type et du sous-type équivalents
déclarations.   

Les types entiers prédéfinis incluent le type INTEGER. Une mise en œuvre
peut également avoir des types prédéfinis tels que SHORT_INTEGER et LONG_INTEGER,
qui ont des portées (sensiblement) plus courtes et plus longues, respectivement, que
ENTIER. La plage de chacun de ces types doit être symétrique par rapport à zéro,
à l'exception d'une valeur négative supplémentaire qui peut exister dans certaines implémentations.
Le type de base de chacun de ces types est le type lui-même.                                                     

Les littéraux entiers sont les littéraux d'un type entier prédéfini anonyme
cela est appelé universal_integer dans ce manuel de référence. Autre entier
les types n'ont pas de littéraux. Cependant, pour chaque type entier, il existe un
conversion implicite qui convertit une valeur universal_integer en
valeur correspondante (le cas échéant) du type entier. Les circonstances sous
lesquels ces conversions implicites sont invoquées sont décrits dans la section 4.6.
Le numéro de position d'une valeur entière est la valeur correspondante de la
tapez universal_integer.

Les mêmes opérateurs arithmétiques sont prédéfinis pour tous les types entiers (voir
4.5). L'exception NUMERIC_ERROR est levée par l'exécution d'un
opération (en particulier une conversion implicite) qui ne peut pas délivrer le
résultat correct (c'est-à-dire si la valeur correspondant au résultat mathématique
le résultat n’est pas une valeur de type entier). Cependant, une mise en œuvre est
il n'est pas nécessaire de déclencher l'exception NUMERIC_ERROR si l'opération fait partie
d'une expression plus grande dont le résultat peut être calculé correctement, comme décrit
à l'article 11.6.

Exemples:

   tapez PAGE_NUM est la plage 1 .. 2_
   tapez LINE_SIZE est la plage 1 .. MAX_LINE_SIZE ;

   le sous-type SMALL_INT est la plage INTEGER -10 .. 10 ;
   le sous-type COLUMN_PTR est la plage LINE_SIZE 1 .. 10 ;
   le sous-type BUFFER_SIZE est la plage INTEGER 0 .. MAX ;

Remarques:

Le nom déclaré par une déclaration de type entier est un nom de sous-type. Sur le
en revanche, les opérateurs prédéfinis de type entier fournissent des résultats
dont la plage est définie par le type prédéfini parent ; un tel résultat est nécessaire
n'appartient pas au sous-type déclaré, auquel cas une tentative d'attribution du 
le résultat à une variable du sous-type entier déclenche l'exception
CONSTRAINT_ERROR.

La valeur la plus petite (la plus négative) prise en charge par l'entier prédéfini
types d'une implémentation est le numéro nommé SYSTEM.MIN_INT et le
la valeur la plus grande (la plus positive) est SYSTEM.MAX_INT (voir 13.7).

Références : type anonyme 3.3.1, appartiennent à un sous-type 3.3, lié à un
plage 3.5, exception constraint_error 11.1, conversion 4.6, identifiant 2.3,
entier littéral 2,4, littéral 4,2, exception numeric_error 11,1, type parent
3.4, opérateur prédéfini 4.5, contrainte de plage 3.5, expression statique 4.9,
déclaration de sous-type 3.3.2, package prédéfini par le système 13.7, type 3.3, type
déclaration 3.3.1, définition de type 3.3.1, type universel 4.1 4 

3.5.5 Opérations de types discrets 

Les opérations de base d'un type discret incluent les opérations impliquées dans
l'affectation, les tests d'adhésion et la qualification ; pour un type booléen 
ils comprennent les fiches de contrôle des courts-circuits ; pour un type entier, ils
inclure la conversion explicite des valeurs d'autres types numériques vers le
type entier et la conversion implicite des valeurs du type
universal_integer au type.

Enfin, pour chaque type ou sous-type discret T, les opérations de base incluent
les attributs répertoriés ci-dessous. Dans cette présentation, T est appelé
étant un sous-type (le sous-type T) pour toute propriété qui dépend de
contraintes imposées par T ; les autres propriétés sont indiquées en termes de base
type de T.                                                                              

Le premier groupe d'attributs donne les caractéristiques du sous-type T. Ce 
Le groupe comprend l'attribut BASE (voir 3.3.2), les attributs FIRST et
LAST (voir 3.5), l'attribut de représentation SIZE (voir 13.7.2) et l'attribut
attribut WIDTH défini comme suit :

T'WIDTH Donne la longueur maximale de l'image sur toutes les valeurs du sous-type
           T (l'image est la séquence de caractères renvoyée par le
           attribut IMAGE, voir ci-dessous). Donne zéro pour une plage nulle.
           La valeur de cet attribut est du type universal_integer.

Tous les attributs du deuxième groupe sont des fonctions avec un seul paramètre.
Le paramètre réel correspondant est indiqué ci-dessous par X.

T'POS Cet attribut est une fonction. Le paramètre X doit être une valeur
           du type de base de T. Le type de résultat est le type
           entier_universel. Le résultat est le numéro de position du
           valeur du paramètre.

T'VAL Cet attribut est une fonction spéciale avec un seul paramètre
           qui peut être de n’importe quel type entier. Le type de résultat est la base
           type de T. Le résultat est la valeur dont le numéro de position est
           la valeur universal_integer correspondant à X. L'exception
           CONSTRAINT_ERROR est déclenché si la valeur universal_integer
           correspondant à X n'est pas dans la plage T'POS(T'BASE'FIRST) ..
           T'POS(T'BASE'LAST).

T'SUCC Cet attribut est une fonction. Le paramètre X doit être une valeur
           du type de base de T. Le type de résultat est le type de base de T.
           Le résultat est la valeur dont le numéro de position est supérieur d'un
           que celui de X. L'exception CONSTRAINT_ERROR est levée si X
           est égal à T'BASE'LAST.

T'PRED Cet attribut est une fonction. Le paramètre X doit être une valeur
           du type de base de T. Le type de résultat est le type de base de T.  
           Le résultat est la valeur dont le numéro de position est inférieur de un à
           celui de X. L'exception CONSTRAINT_ERROR est levée si X
           est égal à T'BASE'FIRST.

T'IMAGE Cet attribut est une fonction. Le paramètre X doit être une valeur
           du type de base de T. Le type de résultat est le type prédéfini
           CHAÎNE. Le résultat est l’image de la valeur de X, c’est-à-dire un
           séquence de caractères représentant la valeur sous forme d’affichage.
           L'image d'une valeur entière est la décimale correspondante
           littéral; sans soulignements, zéros non significatifs, exposant ou
           espaces de fin ; mais avec un seul personnage principal qui est
           soit un signe moins, soit un espace. La limite inférieure de l'image
           est une.

           L'image d'une valeur d'énumération est soit la
           identifiant en majuscule ou le caractère littéral correspondant
           (y compris les deux apostrophes) ; ni en tête ni en queue
           les espaces sont inclus. L'image d'un personnage C, autre qu'un
           le caractère graphique est défini par l'implémentation ; le seul
           L'exigence est que l'image soit telle que C soit égal à
           CARACTÈRE'VALEUR(CARACTÈRE'IMAGE(C)). 

T'VALUE Cet attribut est une fonction. Le paramètre X doit être une valeur
           du type prédéfini STRING. Le type de résultat est la base
           type de T. Tous les espaces de début et de fin de la séquence
           des caractères correspondant au paramètre sont ignorés.

           Pour un type énumération, si la séquence de caractères a le
           syntaxe d'un littéral d'énumération et si ce littéral existe pour
           le type de base de T, le résultat est l'énumération correspondante  
           valeur. Pour un type entier, si la séquence de caractères a
           la syntaxe d'un littéral entier, avec un simple facultatif
           caractère principal qui est un signe plus ou moins, et s'il y a
           une valeur correspondante dans le type de base de T, le résultat est ceci
           valeur. Dans tous les autres cas, l'exception CONSTRAINT_ERROR est
           soulevé.                                                                    

De plus, les attributs A'SIZE et A'ADDRESS sont définis pour un objet
A de type discret (voir 13.7.2).

Outre les opérations de base, les opérations de type discret comprennent les
opérateurs relationnels prédéfinis. Pour les types d'énumération, les opérations incluent
littéraux d’énumération. Pour les types booléens, les opérations incluent le prédéfini
opérateur de négation logique unaire non, et les opérateurs logiques prédéfinis.
Pour les types entiers, les opérations incluent les opérateurs arithmétiques prédéfinis :
ce sont les opérateurs d'addition binaires et unaires - et +, tous multiplicateurs
opérateurs, l'opérateur unaire abs et l'opérateur exponentiant.

Les opérations d'un sous-type sont les opérations correspondantes de sa base
type à l’exception des éléments suivants : affectation, tests d’adhésion,
qualification, conversions de types explicites et attributs du premier
groupe; l'effet de chacune de ces opérations dépend du sous-type
(les affectations, les tests d'adhésion, les qualifications et les conversions impliquent un
vérification du sous-type ; les attributs du premier groupe donnent une caractéristique du
sous-type).

Remarques:

Pour un sous-type d'un type discret, les résultats délivrés par les attributs
SUCC, PRED, VAL et VALUE ne doivent pas nécessairement appartenir au sous-type ; de même, le
il n'est pas nécessaire que les paramètres réels des attributs POS, SUCC, PRED et IMAGE
appartiennent au sous-type. Les relations suivantes sont satisfaites (dans le
absence d'exception) par ces attributs :

   T'POS(T'SUCC(X)) = T'POS(X) + 1
   T'POS(T'PRED(X)) = T'POS(X) - 1

   T'VAL(T'POS(X)) = X
   T'POS(T'VAL(N)) = N

Exemples:

   -- Pour les types et sous-types déclarés à la section 3.5.1, nous avons :

   -- COULEUR PREMIER = BLANC, COULEUR DERNIER = NOIR
   -- RAINBOW'FIRST = ROUGE, RAINBOW'LAST = BLEU

   -- COULEUR'SUCC(BLEU) = RAINBOW'SUCC(BLEU) = MARRON
   -- COULEUR'POS(BLEU) = RAINBOW'POS(BLEU) = 4
   -- COULEUR'VAL(0) = RAINBOW'VAL(0) = BLANC 

Références : opérateur abs 4.5 4.5.6, affectation 5.2, attribut 4.1.4, base
type 3.3, opération de base 3.3.3, opérateur d'addition binaire 4.5 4.5.3, booléen
type 3.5.3, limite d'une plage 3.5, caractère littéral 2.5, contrainte 3.3,
exception constraint_error 11.1, conversion 4.6, type discret 3.5,
littéral d'énumération 3.5.1, opérateur exponentiant 4.5 4.5.6, fonction 6.5,
caractère graphique 2.1, identifiant 2.3, type entier 3.5.4, opérateur logique
4.5 4.5.1, test d'appartenance 4.5 4.5.2, opérateur multiplicateur 4.5 4.5.5, non
opérateur 4.5 4.5.6, littéral numérique 2.4, type numérique 3.5, objet 3.2,
opération 3.3, numéro de position 3.5, opérateur prédéfini 4.5, prédéfini
type C, expression qualifiée 4.7, opérateur relationnel 4.5 4.5.2, 
forme de contrôle des courts-circuits 4.5 4.5.1, type de chaîne 3.6.3, sous-type 3.3, type
3.3, opérateur d'addition unaire 4.5 4.5.4, type universal_integer 3.5.4,
type universel 4.1 4                                                                              

3.5.6 Types réels 

Les types réels fournissent des approximations des nombres réels, avec des limites relatives
sur les erreurs pour les types à virgule flottante et avec des limites absolues pour les types fixes
types de points.

   real_type_definition ::=
      flottant_point_constraint | contrainte_point_fixe

Un ensemble de numéros appelés numéros de modèle est associé à chaque type réel.
Les limites d'erreur sur les opérations prédéfinies sont données en termes de modèle
Nombres. Une implémentation de ce type doit inclure au moins ces modèles
nombres et les représenter exactement.

Un ensemble de nombres dépendant de l'implémentation, appelés nombres sûrs, est
également associé à chaque type réel. L'ensemble des nombres sûrs d'un réel
Le type doit inclure au moins l’ensemble des numéros de modèle du type. La gamme
Les numéros de sécurité peuvent être plus grands que la plage des numéros de modèle,
mais les limites d'erreur sur les opérations prédéfinies pour les nombres sûrs sont données par
les mêmes règles que pour les numéros de modèle. Les numéros sûrs fournissent donc
limites d'erreur garanties pour les opérations sur une plage dépendante de l'implémentation
des nombres ; en revanche, la gamme de numéros de modèle dépend uniquement du
définition de type réel et est donc indépendant de l'implémentation.

Les vrais littéraux sont les littéraux d'un type réel prédéfini anonyme qui est
appelé universal_real dans ce manuel de référence. Les autres types réels n'ont pas
littéraux. Cependant, pour chaque type réel, il existe une conversion implicite
qui convertit une valeur universal_real en une valeur de type réel. Le
les conditions dans lesquelles ces conversions implicites sont invoquées sont décrites
à la section 4.6. Si la valeur universal_real est un nombre sûr, le
la conversion implicite fournit la valeur correspondante ; s'il appartient au
plage de nombres sûrs mais n'est pas un nombre sûr, alors la valeur convertie
peut être n'importe quelle valeur dans la plage définie par les nombres sûrs ci-dessus
et en dessous de la valeur universal_real.

L'exécution d'une opération qui donne une valeur de type réel peut augmenter
l'exception NUMERIC_ERROR, comme expliqué dans la section 4.5.7, si elle ne peut pas
délivrer un résultat correct (c'est-à-dire si la valeur correspondant à l'un des
les résultats mathématiques possibles n'appartiennent pas à la gamme des valeurs sûres
Nombres); en particulier, cette exception peut être soulevée par un
conversion. Cependant, une implémentation n'est pas nécessaire pour augmenter le
exception NUMERIC_ERROR si l'opération fait partie d'une expression plus grande
dont le résultat peut être calculé correctement (voir 11.6).

L'élaboration d'une définition de type réel inclut l'élaboration du
contrainte de virgule flottante ou fixe et crée un type réel.

Note:

Un algorithme écrit pour s'appuyer uniquement sur les propriétés numériques minimales
garanti par la définition de type pour les numéros de modèle sera portable
sans autres précautions.   

Références : conversion 4.6, élaboration 3.9, contrainte de point fixe 3.5.9,
contrainte de virgule flottante 3.5.7, littéral 4.2, exception numeric_error 11.1,
opération prédéfinie 3.3.3, littéral réel 2.4, type 3.3, définition de type
3.3.1, type universel 4.10                                                   

3.5.7 Types à virgule flottante 

Pour les types à virgule flottante, la limite d'erreur est spécifiée sous forme relative
précision en donnant le nombre minimum requis de décimales significatives
chiffres.

   float_point_constraint ::=
      float_accuracy_definition [range_constraint]

   float_accuracy_definition ::= chiffres static_simple_expression

Le nombre minimum de chiffres décimaux significatifs est spécifié par la valeur
de l’expression statique simple de la définition de précision flottante. Ce
la valeur doit appartenir à un type entier et doit être positive (différente de zéro) ; il
est noté D dans la suite de cette section. Si la virgule flottante
la contrainte est utilisée comme définition de type réel et comprend une plage
contrainte, alors chaque limite de la plage doit être définie par une valeur statique
expression d'un type réel, mais les deux limites n'ont pas besoin d'avoir la même
type réel.

Pour une base donnée, la forme canonique suivante est définie pour tout flottant
numéro de modèle de point autre que zéro :

   signe * mantisse * (base ** exposant)

Sous cette forme : le signe est soit +1, soit -1 ; la mantisse est exprimée en nombre
base donnée par base ; et l'exposant est un nombre entier (éventuellement négatif)
tel que la partie entière de la mantisse soit zéro et le premier chiffre de sa
la partie fractionnaire n'est pas un zéro.

Le nombre D spécifié est le nombre minimum de chiffres décimaux requis
après le point de la mantisse décimale (c'est-à-dire si la base est dix). Le
la valeur de D détermine à son tour un nombre correspondant B qui est le minimum
nombre de chiffres binaires requis après le point de la mantisse binaire
(c'est-à-dire si la base est deux). Le nombre B associé à D est le plus petit
valeur telle que la précision relative de la forme binaire ne soit pas inférieure à
celui spécifié pour la forme décimale. (Le nombre B est l'entier suivant
ci-dessus (D*log(10)/log(2)) + 1.)

Les numéros de modèle définis par une définition de précision flottante comprennent zéro
et tous les nombres dont la forme canonique binaire a exactement B chiffres après le
point dans la mantisse et un exposant compris entre -4*B .. +4*B. Le
la précision minimale garantie des opérations de type virgule flottante est  
défini en termes de numéros de modèle de la contrainte de virgule flottante qui
forme la définition de type réel correspondante (voir 4.5.7).

Les types à virgule flottante prédéfinis incluent le type FLOAT. Un
l'implémentation peut également avoir des types prédéfinis tels que SHORT_FLOAT et
LONG_FLOAT, qui ont (sensiblement) de moins en plus de précision,
respectivement, que FLOAT. Le type de base de chaque virgule flottante prédéfinie
le type est le type lui-même. Les numéros de modèle de chaque flottant prédéfini
les types de points sont définis en termes de nombre D de chiffres décimaux renvoyés
par l'attribut DIGITS (voir 3.5.8).  

Pour chaque type à virgule flottante prédéfini (donc aussi pour chaque type
qui en dérive), un ensemble de numéros sûrs est défini comme suit. Le coffre-fort
les numéros ont le même nombre B de chiffres de mantisse que les numéros de modèle de
le type et ont un exposant dans la plage -E .. +E où E est
défini par l'implémentation et au moins égal au 4*B des numéros de modèle.
(Par conséquent, les numéros de sécurité incluent les numéros de modèle.) Les règles
la définition de la précision des opérations avec des numéros de modèle et de sécurité est donnée
à la section 4.5.7. Les numéros sûrs d'un sous-type sont ceux de sa base
taper.                                               

Une déclaration de type à virgule flottante de l'une des deux formes (c'est-à-dire avec ou
sans la contrainte de plage facultative indiquée par les crochets) :

   le type T est constitué des chiffres D [plage L .. R] ;

est, par définition, équivalent aux déclarations suivantes :

   le type float_point_type est nouveau prédéfini_floating_point_type ;
   le sous-type T est un chiffre float_point_type D
      [plage float_point_type(L) .. float_point_type(R)];

où float_point_type est un type anonyme et où le prédéfini
Le type à virgule flottante est implicitement sélectionné par l'implémentation afin que
ses numéros de modèle incluent les numéros de modèle définis par D ; de plus, si
une plage L .. R est fournie, alors L et R doivent tous deux appartenir à la plage de
numéros sûrs. La déclaration en virgule flottante est illégale si aucun des éléments
les types à virgule flottante prédéfinis satisfont à ces exigences, à l'exception
universal_real. Le nombre maximum de chiffres pouvant être spécifié dans un
la définition de la précision flottante est donnée par le nombre nommé dépendant du système
SYSTEM.MAX_DIGITS (voir 13.7.1).

L'élaboration d'une déclaration de type à virgule flottante consiste en
élaboration des déclarations équivalentes de type et de sous-type.

Si une contrainte de virgule flottante suit une marque de type dans une indication de sous-type,
la marque de type doit désigner un type ou un sous-type à virgule flottante. Le flottant
la contrainte de point n'est compatible avec la marque de type que si le nombre D
spécifié dans la définition de précision flottante n’est pas supérieur à la
numéro correspondant D pour le type ou le sous-type désigné par la marque de type.
De plus, si la contrainte de virgule flottante inclut une contrainte de plage,
la contrainte de virgule flottante n'est compatible avec la marque de type que si la
la contrainte de portée est, elle-même, compatible avec la marque de type.

L'élaboration d'une telle indication de sous-type comprend l'élaboration de
la contrainte de portée, s'il y en a une ; il crée un sous-type à virgule flottante
dont les numéros de modèle sont définis par la précision flottante correspondante
définition. Une valeur de type virgule flottante appartient à une valeur à virgule flottante
sous-type si et seulement s'il appartient à la plage définie par le sous-type.

Les mêmes opérateurs arithmétiques sont prédéfinis pour tous les types à virgule flottante
(voir 4.5).

Remarques: 

Une contrainte de plage est autorisée dans une indication de sous-type à virgule flottante,
soit directement après la marque de type, soit dans le cadre d'une virgule flottante
contrainte. Dans les deux cas, les limites de la plage doivent appartenir à la base
type de la marque de type (voir 3.5). L'imposition d'une virgule flottante
une contrainte sur une marque de type dans une indication de sous-type ne peut pas réduire la
plage de valeurs, sauf si elle inclut une contrainte de plage (la plage du modèle
les nombres qui correspondent au nombre de chiffres spécifié peuvent être plus petits
que la plage de chiffres de la marque type). Une valeur qui appartient à un
Le sous-type à virgule flottante ne doit pas nécessairement être un numéro de modèle du sous-type.   

Exemples:

   le type COEFFICIENT est composé de chiffres de 10, plage -1,0 .. 1,0 ;

   le type REAL correspond aux chiffres 8 ;
   le type MASS est composé de chiffres 7, plage 0,0 .. 1,0E35 ;

   le sous-type SHORT_COEFF est le chiffre COEFFICIENT 5 ; -- un sous-type avec moins de précision
   le sous-type PROBABILITÉ est la plage RÉELLE 0,0 .. 1,0 ; -- un sous-type avec une plage plus petite                                               

Notes sur les exemples :

La précision implémentée pour COEFFICIENT est celle d'un type prédéfini
ayant au moins 10 chiffres de précision. Par conséquent, la spécification de
5 chiffres de précision pour le sous-type SHORT_COEFF sont autorisés. Le plus large
Le numéro de modèle pour le type MASS est d'environ 1,27E30 et donc inférieur à
la limite supérieure spécifiée (1.0E35). Par conséquent, la déclaration de ce
le type n'est légal que si cette limite supérieure est dans la plage des nombres sûrs
d'un type à virgule flottante prédéfini ayant au moins 7 chiffres de précision.   

Références : type anonyme 3.3.1, opérateur arithmétique 3.5.5 4.5, basé
littéral 2.4.2, appartient à un sous-type 3.3, limité à une plage 3.5, compatible
3.3.2, type dérivé 3.4, chiffre 2.1, élaboration 3.1 3.9, limite d'erreur 3.5.6,
exposant 2.4.1 type entier 3.5.4, numéro de modèle 3.5.6, opération 3.3,
opérateur prédéfini 4.5, type prédéfini C, contrainte de plage 3.5, type réel
3.5.6, définition de type réel 3.5.6, numéro de sécurité 3.5.6, expression simple
4.4, expression statique 4.9, déclaration de sous-type 3.3.2, indication de sous-type
3.3.2, sous-type 3.3, type 3.3, déclaration de type 3.3.1, marque de type 3.3.2  

3.5.8 Opérations des types à virgule flottante 

Les opérations de base d'un type à virgule flottante incluent les opérations
impliqué dans l'affectation, les tests d'adhésion, la qualification, les
conversion de valeurs d'autres types numériques en type à virgule flottante, et
la conversion implicite des valeurs du type universal_real vers le type.

De plus, pour chaque type ou sous-type à virgule flottante T, la base
les opérations incluent les attributs répertoriés ci-dessous. Dans cette présentation, T est
désigné comme étant un sous-type (le sous-type T) pour toute propriété qui
dépend des contraintes imposées par T ; d'autres propriétés sont indiquées en termes
du type de base de T.

Le premier groupe d'attributs donne les caractéristiques du sous-type T. Le
les attributs de ce groupe sont l'attribut BASE (voir 3.3.2), les attributs
FIRST et LAST (voir 3.5), l'attribut de représentation SIZE (voir 13.7.2),
et les attributs suivants :

T'DIGITS Donne le nombre de chiffres décimaux dans la mantisse décimale de
            numéros de modèle du sous-type T. (Cet attribut donne le
            numéro D de la section 3.5.7.) La valeur de cet attribut est de
            le type universal_integer.

T'MANTISSA Donne le nombre de chiffres binaires dans la mantisse binaire de
            numéros de modèle du sous-type T. (Cet attribut donne le
            numéro B de la section 3.5.7.) La valeur de cet attribut est de
            le type universal_integer.

T'EPSILON Donne la valeur absolue de la différence entre le modèle
            numéro 1.0 et le numéro de modèle suivant ci-dessus, pour le sous-type T.
            La valeur de cet attribut est du type universal_real.   

T'EMAX Donne la plus grande valeur d'exposant sous la forme canonique binaire
            des numéros de modèle du sous-type T. (Cet attribut donne le
            produit 4*B de la section 3.5.7.) La valeur de cet attribut est
            du type universal_integer.

T'SMALL Donne le plus petit numéro de modèle positif (différent de zéro) du
            sous-type T. La valeur de cet attribut est du type
            universal_real.

T'LARGE Donne le plus grand numéro de modèle positif du sous-type T.
            La valeur de cet attribut est du type universal_real.                                             

Les attributs du deuxième groupe comprennent les attributs suivants qui
caractéristiques de rendement des numéros sûrs :

T'SAFE_EMAX Donne la plus grande valeur d'exposant sous la forme canonique binaire
            de nombres sûrs du type de base de T. (Cet attribut donne
            le numéro E de la section 3.5.7.) La valeur de cet attribut
            est du type universal_integer.

T'SAFE_SMALL Donne le plus petit nombre sûr positif (non nul) de la base
            type de T. La valeur de cet attribut est du type
            universal_real.  

T'SAFE_LARGE Donne le plus grand nombre positif sûr du type de base de T.
            La valeur de cet attribut est du type universal_real.

De plus, les attributs A'SIZE et A'ADDRESS sont définis pour un objet
A de type virgule flottante (voir 13.7.2). Enfin, pour chaque virgule flottante
tapez, il existe des attributs dépendants de la machine qui ne sont pas liés au modèle
numéros et numéros sûrs. Ils correspondent aux désignateurs d'attributs
MACHINE_RADIX, MACHINE_MANTISSA, MACHINE_EMAX, MACHINE_EMIN,
MACHINE_ROUNDS et MACHINE_OVERFLOWS (voir 13.7.3).

Outre les opérations de base, les opérations de type virgule flottante
inclure les opérateurs relationnels et l'arithmétique prédéfinie suivante
opérateurs : les opérateurs d'addition binaire et unaire - et +, les opérateurs de multiplication
les opérateurs * et /, l'opérateur unaire abs et l'opérateur exponentiant.

Les opérations d'un sous-type sont les opérations correspondantes du type
à l'exception des éléments suivants : affectation, tests d'adhésion, qualification,
conversion explicite et attributs du premier groupe ; les effets de
ces opérations sont redéfinies en termes de sous-type.

Remarques:

Les attributs EMAX, SMALL, LARGE et EPSILON sont fournis pour
commodité. Ils sont tous liés à MANTISSA par les formules suivantes :

   T'EMAX = 4*T'MANTISSA
   T'EPSILON = 2.0**(1 - T'MANTISSA)
   T'PETIT = 2,0**(-T'EMAX - 1)
   T'LARGE = 2,0**T'EMAX * (1,0 - 2,0**(-T'MANTISSA))

L'attribut MANTISSA, donnant le nombre de chiffres binaires dans la mantisse,
est lui-même lié aux CHIFFRES. Les relations suivantes s'appliquent entre le
caractéristiques des numéros de modèles et celles des numéros de sécurité :

   T'BASE'EMAX <= T'SAFE_EMAX
   T'BASE'SMALL >= T'SAFE_SMALL
   T'BASE'LARGE <= T'SAFE_LARGE

Les attributs T'FIRST et T'LAST ne doivent pas nécessairement produire des numéros de modèle ou de sécurité. Si 
un certain nombre de chiffres est précisé dans la déclaration d'un type ou
sous-type T, l'attribut T'DIGITS donne ce numéro.   

Références : opérateur abs 4.5 4.5.6, opérateur arithmétique 3.5.5 4.5,
affectation 5.2, attribut 4.1.4, type de base 3.3, opération de base 3.3.3,
opérateur d'addition binaire 4.5 4.5.3, borne d'un intervalle 3.5, contrainte 3.3,
conversion 4.6, chiffre 2.1, opérateur exponentiant 4.5 4.5.6, flottant
type de point 3.5.7, test d'adhésion 4.5 4.5.2, numéro de modèle 3.5.6,
opérateur multiplicateur 4.5 4.5.5, type numérique 3.5, objet 3.2, opération
3.3, opérateur prédéfini 4.5, expression qualifiée 4.7, opérateur relationnel
4.5 4.5.2, numéro sûr 3.5.6, sous-type 3.3, type 3.3, opérateur d'addition unaire
4.5 4.5.4, type universel 4.10, type universal_integer 3.5.4,
type universel_réel 3.5.6                                                                      

3.5.9 Types à virgule fixe 

Pour les types à virgule fixe, la limite d'erreur est spécifiée sous forme de valeur absolue,
appelé le delta du type à virgule fixe.

   contrainte_point_fixe ::=
      fix_accuracy_definition [range_constraint]

   fix_accuracy_definition ::= delta static_simple_expression

Le delta est spécifié par la valeur de l'expression simple statique du
définition de précision fixe. Cette valeur doit appartenir à un type réel et
doit être positif (différent de zéro). Si la contrainte de point fixe est utilisée comme
définition de type réel, elle doit alors inclure une contrainte de plage ; chaque limite
de la plage spécifiée doit être définie par une expression statique d'un certain réel
type mais les deux limites n’ont pas besoin d’avoir le même type réel. Si le fixe
la contrainte de point est utilisée dans une indication de sous-type, la contrainte de portée est
facultatif.

Une forme canonique est définie pour tout numéro de modèle à virgule fixe autre que
zéro. Sous cette forme : le signe est soit +1, soit -1 ; la mantisse est positive
(différent de zéro) entier ; et tout numéro de modèle est un multiple d'un certain
nombre réel positif dit petit, comme suit :

   signe * mantisse * petit

Pour les numéros de modèle définis par une contrainte de point fixe, le nombre petit
est choisi comme la plus grande puissance de deux qui n’est pas supérieure au delta de
la définition de précision fixe. Alternativement, il est possible de préciser
la valeur de la clause petit d'une longueur (voir 13.2), auquel cas le modèle
les nombres sont des multiples de la valeur spécifiée. Le minimum garanti
la précision des opérations de type virgule fixe est définie en termes de
numéros de modèle de la contrainte de point fixe qui forme le correspondant
définition du type réel (voir 4.5.7).

Pour une contrainte de point fixe incluant une contrainte de plage, le modèle
les nombres comprennent zéro et tous les multiples de petit dont la mantisse peut être
exprimé en utilisant exactement B chiffres binaires, où la valeur de B est choisie comme
le plus petit nombre entier pour lequel chaque limite de la plage spécifiée est
soit un numéro de modèle, soit se trouve au plus petit loin d'un numéro de modèle.
Pour une contrainte de point fixe qui n'inclut pas de contrainte de plage (ceci
n'est autorisé qu'après une marque de type, dans une indication de sous-type), le modèle
les nombres sont définis par le delta de la définition de précision fixe et par
la plage du sous-type désignée par la marque de type.

Une implémentation doit avoir au moins un point fixe prédéfini anonyme
taper. Le type de base de chacun de ces types à virgule fixe est le type lui-même. Le
les numéros de modèle de chaque type de virgule fixe prédéfini comprennent zéro et tous
nombres pour lesquels la mantisse (sous la forme canonique) a le nombre de binaires 
chiffres renvoyés par l'attribut MANTISSA, et pour lesquels le nombre petit
a la valeur renvoyée par l'attribut SMALL.

Une déclaration de type virgule fixe de la forme :  

   le type T est la plage delta D L .. R ;

est, par définition, équivalent aux déclarations suivantes :

   le type fix_point_type est un nouveau type_fixed_point_type prédéfini ;
   le sous-type T est type_point_fixe
      plage type_point_fixe(L) .. type_point_fixe(R);                                                 

Dans ces déclarations, fixed_point_type est un type anonyme, et le
Le type de virgule fixe prédéfini est implicitement sélectionné par l'implémentation, donc
que ses numéros de modèle incluent les numéros de modèle définis par le point fixe
contrainte (c'est-à-dire par D, L et R, et éventuellement par une clause de longueur
en précisant petit).

La déclaration de point fixe est illégale si aucun type prédéfini ne satisfait
ces exigences. Les nombres sûrs de type virgule fixe sont le modèle
numéros de son type de base.

L'élaboration d'une déclaration de type virgule fixe consiste à
élaboration des déclarations équivalentes de type et de sous-type.

Si la contrainte de point fixe suit une marque de type dans une indication de sous-type,
la marque de type doit désigner un type ou un sous-type à virgule fixe. Le point fixe
la contrainte n'est compatible avec la marque de type que si le delta spécifié par
la définition de précision fixe n'est pas inférieure au delta pour le type ou
sous-type désigné par la marque de type. De plus, si le point fixe
La contrainte inclut une contrainte de plage, la contrainte de point fixe est
compatible avec la marque de type uniquement si la contrainte de portée est, elle-même,
compatible avec la marque de type.

L'élaboration d'une telle indication de sous-type comprend l'élaboration de
la contrainte de portée, s'il y en a une ; il crée un sous-type à virgule fixe
dont les numéros de modèle sont définis par la contrainte de point fixe correspondante
et aussi par la clause length précisant small, s'il y en a une. Une valeur
d'un type à virgule fixe appartient à un sous-type à virgule fixe si et seulement s'il
appartient à la plage définie par le sous-type.

Les mêmes opérateurs arithmétiques sont prédéfinis pour tous les types de virgule fixe (voir
4.5). La multiplication et la division de valeurs à virgule fixe donnent des résultats de
un type de virgule fixe prédéfini anonyme appelé universal_fixed dans
ce manuel de référence ; la précision de ce type est arbitrairement bonne. Le
les valeurs de ce type doivent être converties explicitement en un type numérique.

Remarques:

Si S est un sous-type d’un type à virgule fixe ou d’un sous-type T, alors l’ensemble des modèles
les nombres de S sont un sous-ensemble de ceux de T. Si une clause de longueur a été donnée
pour T, alors S et T ont tous deux la même valeur pour petit. Sinon, puisque
petit est une puissance de deux, le petit de S est égal au petit de T
multiplié par une puissance non négative de deux.

Une contrainte de plage est autorisée dans une indication de sous-type à virgule fixe, soit
directement après la marque de type, ou dans le cadre d'une contrainte de point fixe. Dans
dans les deux cas, les limites de la plage doivent appartenir au type de base du
marque de type (voir 3.5).

Exemples:

   le type VOLT est delta 0,125, plage 0,0 .. 255,0 ;
   le sous-type ROUGH_VOLTAGE est VOLT delta 1.0 ; -- même plage que VOLT

   -- Une fraction pure qui nécessite tout l'espace disponible dans un mot
   -- sur une machine à complément à deux peut être déclaré comme FRACTION de type : 

   DEL : constante := 1.0/2**(WORD_LENGTH - 1);  
   le type FRACTION est la plage delta DEL -1,0 .. 1,0 - DEL ;

Références : type anonyme 3.3.1, opérateur arithmétique 3.5.5 4.5, type de base
3.3, appartiennent à un sous-type 3.3, limité à un intervalle 3.5, compatible 3.3.2,
conversion 4.6, élaboration 3.9, limite d'erreur 3.5.6, clause de longueur 13.2,
numéro de modèle 3.5.6, type numérique 3.5, opération 3.3, opérateur prédéfini
4.5, contrainte de portée 3.5, type réel 3.5.6, définition de type réel 3.5.6,
numéro sûr 3.5.6, expression simple 4.4, expression statique 4.9, sous-type
3.3, déclaration de sous-type 3.3.2, indication de sous-type 3.3.2, type 3.3, type
déclaration 3.3.1, marque de type 3.3.2                                                                     

3.5.10 Opérations des types à virgule fixe 

Les opérations de base d'un type à virgule fixe incluent les opérations impliquées
en affectation, aux tests d'adhésion, à la qualification, à la conversion explicite des
les valeurs d'autres types numériques au type à virgule fixe et l'implicite
conversion des valeurs du type universal_real vers le type.

De plus, pour chaque type ou sous-type à virgule fixe T, les opérations de base
inclure les attributs répertoriés ci-dessous. Dans cette présentation, T est désigné
comme étant un sous-type (le sous-type T) pour toute propriété qui dépend de
contraintes imposées par T ; les autres propriétés sont indiquées en termes de base
type de T.

Le premier groupe d'attributs donne les caractéristiques du sous-type T. Le
les attributs de ce groupe sont les attributs BASE (voir 3.3.2), les
les attributs FIRST et LAST (voir 3.5), l'attribut de représentation SIZE (voir
13.7.2) et les attributs suivants :

T'DELTA Donne la valeur du delta spécifié dans la précision fixe
            définition du sous-type T. La valeur de cet attribut est
            du type universal_real.

T'MANTISSA Donne le nombre de chiffres binaires dans la mantisse du modèle
            numéros du sous-type T. (Cet attribut donne le numéro B
            de la section 3.5.9.) La valeur de cet attribut est du type
            entier_universel.

T'SMALL Donne le plus petit numéro de modèle positif (différent de zéro) du
            sous-type T. La valeur de cet attribut est du type
            universal_real.

T'LARGE Donne le plus grand numéro de modèle positif du sous-type T.
            La valeur de cet attribut est du type universal_real.

T'FORE Donne le nombre minimum de caractères requis pour l'entier
            partie de la représentation décimale de toute valeur du sous-type
            T, en supposant que la représentation ne comprend pas de
            exposant, mais inclut un préfixe à un caractère qui est soit un
            signe moins ou un espace. (Ce nombre minimum n'inclut pas
            zéros ou soulignements superflus, et est au moins deux.) Le
            la valeur de cet attribut est du type universal_integer.

T'AFT Donne le nombre de chiffres décimaux nécessaires après le point pour
            s'adapter à la précision du sous-type T, à moins que le delta
            du sous-type T est supérieur à 0,1, auquel cas le
            l'attribut donne la valeur un. (T'AFT est le plus petit
            entier positif N pour lequel (10**N)*T'DELTA est supérieur à
            ou égal à un.) La valeur de cet attribut est du type
            entier_universel.

Les attributs du deuxième groupe comprennent les attributs suivants qui
caractéristiques de rendement des numéros sûrs :   

T'SAFE_SMALL Donne le plus petit nombre sûr positif (non nul) de la base  
            type de T. La valeur de cet attribut est du type
            universal_real.

T'SAFE_LARGE Donne le plus grand nombre positif sûr du type de base de T.
            La valeur de cet attribut est du type universal_real.

De plus, les attributs A'SIZE et A'ADDRESS sont définis pour un objet
A de type virgule fixe (voir 13.7.2). Enfin, pour chaque type de virgule fixe
ou sous-type T, il y a les attributs dépendants de la machine T'MACHINE_ROUNDS
et T'MACHINE_OVERFLOWS (voir 13.7.3).                                             

Outre les opérations de base, les opérations de type virgule fixe comprennent
les opérateurs relationnels et l'arithmétique prédéfinie suivante
opérateurs : les opérateurs d'addition binaire et unaire - et +, les opérateurs de multiplication
les opérateurs * et /, et l'opérateur abs.

Les opérations d'un sous-type sont les opérations correspondantes du type
à l'exception des éléments suivants : affectation, tests d'adhésion, qualification,
conversion explicite et attributs du premier groupe ; les effets de
ces opérations sont redéfinies en termes de sous-type.

Remarques:

La valeur de l'attribut T'FORE dépend uniquement de la plage du sous-type
T. La valeur de l'attribut T'AFT dépend uniquement de la valeur de T'DELTA.
Les relations suivantes existent entre les attributs de type virgule fixe :

   T'LARGE = (2**T'MANTISSA - 1) * T'PETIT
   T'SAFE_LARGE = T'BASE'LARGE
   T'SAFE_SMALL = T'BASE'SMALL

Références : opérateur abs 4.5 4.5.6, opérateur arithmétique 3.5.5 4.5,
affectation 5.2, type de base 3.3, opération de base 3.3.3, ajout binaire
opérateur 4.5 4.5.3, limite d'une plage 3.5, conversion 4.6, delta 3.5.9, 
type à virgule fixe 3.5.9, test d'adhésion 4.5 4.5.2, numéro de modèle 3.5.6,
opérateur multiplicateur 4.5 4.5.5, type numérique 3.5, objet 3.2, opération
3.3, expression qualifiée 4.7, opérateur relationnel 4.5 4.5.2, numéro sûr
3.5.6, sous-type 3.3, opérateur d'addition unaire 4.5 4.5.4, type universal_integer
3.5.4, type universel_réel 3.5.6  

3.6 Types de tableaux 

Un objet tableau est un objet composite composé de composants qui ont
le même sous-type. Le nom d'un composant d'un tableau utilise un ou plusieurs
valeurs d'index appartenant à des types discrets spécifiés. La valeur d'un tableau
L'objet est une valeur composite constituée des valeurs de ses composants.

   array_type_definition ::=
      unconstrained_array_definition | constrained_array_definition

   unconstrained_array_definition ::=
      tableau (index_subtype_definition {, index_subtype_definition}) de
               composant_subtype_indication

   constrained_array_definition ::=
      tableau index_constraint de composant_subtype_indication

   index_subtype_definition ::= plage type_mark <>

   index_constraint ::= (discrete_range {, discrete_range})

   discrete_range ::= discrete_subtype_indication | gamme  

Un objet tableau est caractérisé par le nombre d'indices (le
dimensionnalité du tableau), le type et la position de chaque index, le
limites inférieures et supérieures pour chaque index, ainsi que le type et la contrainte possible
des composants. L'ordre des indices est significatif.                                                    

Un tableau unidimensionnel a un composant distinct pour chaque index possible
valeur. Un tableau multidimensionnel a un composant distinct pour chaque possible
séquence de valeurs d'index qui peuvent être formées en sélectionnant une valeur pour
chaque position d'index (dans l'ordre donné). Les valeurs possibles pour un
index sont toutes les valeurs comprises entre les limites inférieure et supérieure, inclusivement ;
cette plage de valeurs est appelée plage d'index.

Une définition de tableau sans contrainte définit un type de tableau. Pour chaque objet
qui a le type de tableau, le nombre d'indices, le type et la position de
chaque index et le sous-type des composants sont comme dans le type
définition; les valeurs des limites inférieure et supérieure de chaque indice appartiennent
au sous-type d'index correspondant, à l'exception des tableaux nuls comme expliqué dans
paragraphe 3.6.1. Le sous-type d'index pour une position d'index donnée est, par
définition, le sous-type désigné par la marque de type de l'index correspondant
définition du sous-type. Le délimiteur composé <> (appelé boîte) d'un index
La définition du sous-type représente une plage non définie (différents objets du
le type n’a pas besoin d’avoir les mêmes limites). L’élaboration d’un sans contrainte
la définition de tableau crée un type de tableau ; cette élaboration comprend celle de
l'indication du sous-type de composant.

Une définition de tableau contraint définit à la fois un type de tableau et un sous-type de
ce type:

 - Le type tableau est un type anonyme implicitement déclaré ; ce type est
    défini par une définition de tableau (implicite) sans contrainte, dans laquelle le
    l'indication du sous-type de composant est celle du tableau contraint
    définition, et dans lequel la marque de type de chaque sous-type d'index
    la définition désigne le sous-type défini par le discret correspondant
    gamme.

 - Le sous-type tableau est le sous-type obtenu par imposition de l'index
    contrainte sur le type de tableau.

Si une définition de tableau contraint est donnée pour une déclaration de type, le
le nom simple déclaré par cette déclaration désigne le sous-type du tableau.

L'élaboration d'une définition de tableau contraint crée le correspondant
type de tableau et sous-type de tableau. Pour cette élaboration, la contrainte d'index
et l'indication du sous-type de composant sont élaborées. L'évaluation de
chaque plage discrète de la contrainte d'indice et l'élaboration de la
les indications de sous-type de composant sont effectuées dans un ordre qui n'est pas
défini par la langue.

Exemples de déclarations de type avec des définitions de tableau sans contrainte :

   le type VECTOR est un tableau (plage INTEGER <>) de REAL ;
   le type MATRIX est un tableau (plage INTEGER <>, plage INTEGER <>) de REAL ;
   le type BIT_VECTOR est un tableau (plage INTEGER <>) de BOOLEAN ;
   le type ROMAN est un tableau (plage POSITIVE <>) de ROMAN_DIGIT ;

Exemples de déclarations de type avec des définitions de tableaux contraintes :

   le type TABLE est un tableau (1 .. 10) de INTEGER ;
   le type SCHEDULE est un tableau (DAY) de BOOLEAN ;
   type LINE est un tableau (1 .. MAX_LINE_SIZE) de CHARACTER ; 

Exemples de déclarations d'objets avec des définitions de tableaux contraintes :

   GRID : tableau(1 .. 80, 1 .. 100) de BOOLEAN ;
   MIX : tableau (plage de COULEURS ROUGE .. VERT) de BOOLEAN ;
   PAGE : tableau(1 .. 50) de LINE; -- un tableau de tableaux                                                   

Note:

Pour un tableau unidimensionnel, la règle donnée signifie qu'une déclaration de type
avec une définition de tableau contrainte telle que

   le type T est un tableau (plage POSITIVE MIN .. MAX) de COMPONENT ;

est équivalent (en l'absence d'une dépendance d'ordre incorrecte) au
succession de déclarations  

   le sous-type index_subtype est la plage POSITIVE MIN .. MAX ;
   type array_type est un tableau (plage index_subtype <>) de COMPONENT ;
   le sous-type T est array_type (index_subtype) ;

où index_subtype et array_type sont tous deux anonymes. Par conséquent, T est
le nom d'un sous-type et tous les objets déclarés avec cette marque de type sont
tableaux qui ont les mêmes limites. Des transformations similaires s'appliquent à
tableaux multidimensionnels.

Une transformation similaire s'applique à un objet dont la déclaration inclut un
définition de tableau contraint. Une conséquence de ceci est qu'il n'y a pas deux de ces
les objets ont le même type.

Références : type anonyme 3.3.1, limite d'une plage 3.5, composant 3.3,
contrainte 3.3, type discret 3.5, élaboration 3.1 3.9, dans un certain ordre 1.6,
nom 4.1, objet 3.2, plage 3.5, sous-type 3.3, indication de sous-type 3.3.2,
type 3.3, déclaration de type 3.3.1, définition de type 3.3.1, marque de type 3.3.2  

3.6.1 Contraintes d'index et plages discrètes 

Une contrainte d'index détermine la plage de valeurs possibles pour chaque index
d'un type de tableau, et donc les limites du tableau correspondant.

Pour une plage discrète utilisée dans une définition de tableau contraint et définie par
une plage, une conversion implicite vers le type prédéfini INTEGER est supposée
si chaque limite est soit un littéral numérique, un nombre nommé ou un attribut,
et le type des deux limites (avant la conversion implicite) est le type
entier_universel. Sinon, les deux limites doivent être du même discret
type, autre que universal_integer ; ce type doit être déterminable
indépendamment du contexte, mais en utilisant le fait que le type doit être
discret et que les deux limites doivent avoir le même type. Ces règles s'appliquent
également à une plage discrète utilisée dans une règle d'itération (voir 5.5) ou dans le
déclaration d'une famille d'entrées (voir 9.5).

Si une contrainte d'index suit une marque de type dans une indication de sous-type, alors 
le type ou le sous-type désigné par la marque de type ne doit pas déjà imposer un
contrainte d'index. La marque de type doit désigner soit un tableau sans contrainte
type ou un type d'accès dont le type désigné est un tel type de tableau. Dans
dans tous les cas, la contrainte d'index doit fournir une plage discrète pour chaque
l'index du type de tableau et le type de chaque plage discrète doivent être les
identique à celle de l’indice correspondant.  

Une contrainte d'index est compatible avec le type désigné par la marque de type si
et seulement si la contrainte définie par chaque plage discrète est compatible
avec le sous-type d’index correspondant. Si l'une des plages discrètes
définit une plage nulle, tout tableau ainsi contraint est un tableau nul, n'ayant pas
Composants. Une valeur de tableau satisfait une contrainte d'index si à chaque index
positionner la valeur du tableau et la contrainte d'index ont le même index
bornes. (Notez cependant que l'affectation et certaines autres opérations sur
les tableaux impliquent une conversion de sous-type implicite.)                                                

Les limites de chaque objet tableau sont déterminées comme suit :

 - Pour une variable déclarée par une déclaration d'objet, le sous-type
    l'indication de la déclaration d'objet correspondante doit définir un
    sous-type de tableau contraint (et, par conséquent, les limites). Le même
    une exigence existe pour l'indication de sous-type d'un composant
    déclaration, si le type du composant d'enregistrement est un type tableau ;
    et pour l'indication de sous-type de composant d'une définition de type de tableau,
    si le type des composants du tableau est lui-même un type de tableau.

 - Pour une constante déclarée par une déclaration d'objet, les limites de la
    constante sont définis par la valeur initiale si le sous-type de la
    constante n'est pas contrainte ; ils sont autrement définis par ce sous-type
    (dans ce dernier cas, la valeur initiale est le résultat d'un
    conversion de sous-type). La même règle s'applique à un formel générique
    paramètre de mode in.

 - Pour un objet tableau désigné par une valeur d'accès, les bornes doivent être
    défini par l'allocateur qui crée l'objet tableau. (Le
    L'objet alloué est contraint avec les valeurs correspondantes du
    bornes.)

 - Pour un paramètre formel d'un sous-programme ou d'une entrée, les bornes sont
    obtenu à partir du paramètre réel correspondant. (Le formel
    le paramètre est contraint avec les valeurs correspondantes des limites.)

 - Pour une déclaration de renommage et pour un paramètre formel générique de mode
    en sortie, les limites sont celles de l'objet renommé ou du
    paramètre réel générique correspondant.

Pour l’élaboration d’une contrainte d’indice, les plages discrètes sont
évalués dans un ordre qui n’est pas défini par le langage.

Exemples de déclarations de tableau incluant une contrainte d'index :

   CONSEIL : MATRICE(1 .. 8, 1 .. 8); -- voir 3.6
   RECTANGLE : MATRICE(1 .. 20, 1 .. 30);
   INVERSE : MATRICE(1 .. N, 1 .. N); -- N n'a pas besoin d'être statique

   FILTRE : BIT_VECTOR(0 .. 31);

Exemple de déclaration de tableau avec un sous-type de tableau contraint :

   MON_HORAIRE : HORAIRE ; -- tous les tableaux de type SCHEDULE ont le même
                                bornes

Exemple de type d'enregistrement avec un composant qui est un tableau :

   tapez VAR_LINE(LENGTH : INTEGER) est
      enregistrer
         IMAGE : CHAÎNE(1 .. LONGUEUR);
      terminer l'enregistrement ;

   NULL_LINE : VAR_LINE(0); -- NULL_LINE.IMAGE est un tableau nul     

Remarques:

L'élaboration d'une indication de sous-type constituée d'une marque de type suivie
par une contrainte d'index vérifie la compatibilité de la contrainte d'index
avec la marque de type (voir 3.3.2).

Tous les composants d'un tableau ont le même sous-type. En particulier, pour un
tableau de composants qui sont des tableaux unidimensionnels, cela signifie que tous
les composants ont les mêmes limites et donc la même longueur.                                               

Références : type d'accès 3.8, définition du type d'accès 3.8, valeur d'accès 3.8,
paramètre réel 6.4.1, allocateur 4.8, limite du tableau 3.6, composant du tableau
3.6, type de tableau 3.6, définition de type de tableau 3.6, limite d'une plage 3.5,
compatible 3.3.2, déclaration de composant 3.7, constante 3.2.1, contrainte
définition de tableau 3.6, sous-type de tableau contraint 3.6, conversion 4.6,
désigner 3.8, type désigné 3.8, plage discrète 3.6, entrée 9.5, entrée
déclaration de famille 9.5, expression 4.4, paramètre formel 6.1, fonction 6.5,
paramètre générique réel 12.3, paramètre générique formel 12.1 12.3, générique
paramètre 12.1, index 3.6, contrainte d'index 3.6.1, sous-type d'index 3.6,
valeur initiale 3.2.1, littéral entier 2.4, type entier 3.5.4, itération
règle 5.5, mode 12.1.1, nom 4.1, plage nulle 3.5, objet 3.2, objet
déclaration 3.2.1, type C prédéfini, plage 3.5, composant d'enregistrement 3.7,
renommer la déclaration 8.5, sous-type de résultat 6.1, satisfaire 3.3, sous-programme 6,
conversion de sous-type 4.6, indication de sous-type 3.3.2, marque de type 3.3.2,
type de tableau sans contrainte 3.6, sous-type sans contrainte 3.3, type universel
4.10, type universal_integer 3.5.4, variable 3.2.1   

3.6.2 Opérations des types de tableaux 

Les opérations de base d'un type tableau incluent les opérations impliquées dans
affectation et agrégats (sauf si le type de tableau est limité), adhésion
tests, composants indexés, qualification et conversion explicite ; pour
tableaux unidimensionnels, les opérations de base incluent également les opérations
impliqués dans les tranches, ainsi que dans les chaînes littérales si le type de composant est un
type de caractère.

Si A est un objet tableau, une valeur de tableau ou un sous-type de tableau contraint,
les opérations de base incluent également les attributs répertoriés ci-dessous. Ces
les attributs ne sont pas autorisés pour un type de tableau sans contrainte. L'argument N
utilisé dans les désignateurs d'attributs pour la N-ième dimension d'un tableau doit
être une expression statique de type universal_integer. La valeur de N doit être
positif (différent de zéro) et pas supérieur à la dimensionnalité du tableau.

A'FIRST Renvoie la limite inférieure de la première plage d'indice. La valeur
               de cet attribut a le même type que cette borne inférieure.

A'FIRST(N) Donne la limite inférieure de la Nième plage d'indice. La valeur
               de cet attribut a le même type que cette borne inférieure.

A'LAST Donne la limite supérieure de la première plage d'index. La valeur
               de cet attribut a le même type que cette limite supérieure.

A'LAST(N) Renvoie la limite supérieure de la Nième plage d'indices. La valeur
               de cet attribut a le même type que cette limite supérieure.

A'RANGE Renvoie la première plage d'index, c'est-à-dire la plage A'FIRST ..
               UN DERNIER.

A'RANGE(N) Donne la N-ème plage d'indice, c'est-à-dire la plage A'FIRST(N)
               .. UN DERNIER(N).   

A'LENGTH Renvoie le nombre de valeurs de la première plage d'index (zéro
               pour une plage nulle). La valeur de cet attribut est de
               tapez universal_integer.

A'LENGTH(N) Donne le nombre de valeurs de la Nième plage d'index (zéro
               pour une plage nulle). La valeur de cet attribut est de
               tapez universal_integer.

De plus, l'attribut T'BASE est défini pour un type ou sous-type tableau T
(voir 3.3.3) ; l'attribut T'SIZE est défini pour un type ou sous-type tableau
T, et les attributs A'SIZE et A'ADDRESS sont définis pour un objet tableau
A (voir 13.7.2).                                                                    

Outre les opérations de base, les opérations de type tableau incluent les
comparaison prédéfinie pour l'égalité et l'inégalité, sauf si le type de tableau est
limité. Pour les tableaux unidimensionnels, les opérations incluent la caténation,
sauf si le type de tableau est limité ; si le type de composant est un discret
type, les opérations incluent également tous les opérateurs relationnels prédéfinis ; si
le type de composant est un type booléen, alors les opérations incluent également le
opérateur de négation logique unaire non, et les opérateurs logiques.

Exemples (utilisant les tableaux déclarés dans les exemples de la section 3.6.1) :

-- FILTRE'PREMIER = 0 FILTRE'DERNIER = 31 FILTRE'LONGUEUR = 32
-- DERNIER RECTANGLE (1) = 20 DERNIER RECTANGLE (2) = 30

Remarques:

Les attributs A'FIRST et A'FIRST(1) donnent la même valeur. Un similaire
Une relation existe pour les attributs A'LAST, A'RANGE et A'LENGTH. Le
les relations suivantes sont satisfaites (sauf pour un tableau nul) par ce qui précède
attributs si le type d'index est un type entier :

   A'LONGUEUR = A'LAST - A'FIRST + 1
   A'LONGUEUR(N) = A'LAST(N) - A'FIRST(N) + 1

Un type de tableau est limité si son type de composant est limité (voir 7.4.4). 

Références : agrégat 4.3, type de tableau 3.6, affectation 5.2, attribut
4.1.4, opération de base 3.3.3, limite d'une plage 3.5, opérateur de caténation 4.5
4.5.3, type de caractère 3.5.2, sous-type de tableau contraint 3.6, conversion 4.6,
désignateur 6.1, dimension 3.6, index 3.6, composant indexé 4.1.1, limité
type 7.4.4, opérateur logique 4.5 4.5.1, test d'appartenance 4.5 4.5.2, non
opérateur 4.5 4.5.6, plage nulle 3.5, objet 3.2, opération 3.3, prédéfini
opérateur 4.5, expression qualifiée 4.7, opérateur relationnel 4.5 4.5.2,
tranche 4.1.2, expression statique 4.9, chaîne littérale 2.6, sous-composant 3.3,
type 3.3, type de tableau sans contrainte 3.6, type universel 4.10,
type universel_entier 3.5.4  

3.6.3 La chaîne de type 

Les valeurs du type prédéfini STRING sont des tableaux unidimensionnels de
type prédéfini CHARACTER, indexé par les valeurs du sous-type prédéfini
POSITIF:

   le sous-type POSITIVE est la plage INTEGER 1 .. INTEGER'LAST ;
   le type STRING est un tableau (plage POSITIVE <>) de CHARACTER ;

Exemples:

   ÉTOILES : STRING(1 .. 120) := (1 .. 120 => '*' );
   QUESTION : constante STRING := "COMBIEN DE CARACTÈRES ?";
   -- QUESTION'FIRST = 1, QUESTION'LAST = 20 (le nombre de caractères)   

   ASK_TWICE : constante STRING := QUESTION & QUESTION;
   NINETY_SIX : constante ROMAN := "XCVI"; -- voir 3.6

Remarques:

Les littéraux de chaîne (voir 2.6 et 4.2) sont des opérations de base applicables au
tapez STRING et à tout autre type de tableau unidimensionnel dont le composant
type est un type de caractère. L'opérateur de caténation est un opérateur prédéfini
pour le type STRING et pour les types de tableaux unidimensionnels ; il est représenté
comme &. Les opérateurs relationnels <, <=, > et >= sont définis pour les valeurs de
ces types, et correspondent à l’ordre lexicographique (voir 4.5.2).                                              

Références : agrégat 4.3, tableau 3.6, opérateur de caténation 4.5 4.5.3,
type de caractère 3.5.2, type de composant (d'un tableau) 3.6, dimension 3.6,
index 3.6, ordre lexicographique 4.5.2, agrégat positionnel 4.3, prédéfini
opérateur 4.5, type C prédéfini, opérateur relationnel 4.5 4.5.2, chaîne
littéral 2.6, sous-type 3.3, type 3.3  

3.7 Types d'enregistrements 

Un objet d'enregistrement est un objet composite constitué de composants nommés. Le
La valeur d'un objet d'enregistrement est une valeur composite composée des valeurs de
ses composants.

   record_type_definition ::=
      enregistrer
         liste_composants
      fin de l'enregistrement

   liste_composants ::=
         composant_declaration {component_declaration}
      | {component_declaration} variante_part
      | nul;

   déclaration_composant ::=
      liste_identifiant : définition_subtype_composant [:= expression] ;

   composant_subtype_definition ::= subtype_indication

Chaque déclaration de composant déclare un composant du type enregistrement.
Outre les composants déclarés par les déclarations de composants, les composants d'un
le type d'enregistrement inclut tous les composants déclarés par des spécifications discriminantes
de la déclaration du type d'enregistrement. Les identifiants de tous les composants d'un
le type d’enregistrement doit être distinct. L'utilisation d'un nom qui désigne un enregistrement
un composant autre qu'un discriminant n'est pas autorisé dans le type d'enregistrement
définition qui déclare le composant.

Une déclaration de composant avec plusieurs identifiants équivaut à un
séquence de déclarations de composants uniques, comme expliqué dans la section 3.2.
Chaque déclaration de composant unique déclare un composant d'enregistrement dont le sous-type
est spécifié par la définition du sous-type de composant. 

Si une déclaration de composant inclut le délimiteur composé d'affectation
suivi d'une expression, l'expression est l'expression par défaut du
composant d'enregistrement ; l'expression par défaut doit être du type du
composant. Les expressions par défaut ne sont pas autorisées pour les composants de
un type limité.

Si un type d'enregistrement ne comporte pas de partie discriminante, les mêmes composants sont
présent dans toutes les valeurs du type. Si la liste des composants d'un type d'enregistrement
est défini par le mot réservé nul et il n'y a pas de partie discriminante,
alors le type d'enregistrement n'a aucun composant et tous les enregistrements du type sont nuls
enregistrements.  

L'élaboration d'une définition de type d'enregistrement crée un type d'enregistrement ; il
consiste en l’élaboration de tout composant (unique) correspondant
déclarations, dans l'ordre dans lequel elles apparaissent, y compris tout composant
déclaration dans une partie variante. L’élaboration d’une déclaration de composant
consiste en l’élaboration de la définition du sous-type de composant.

Pour l'élaboration d'une définition de sous-type de composant, si la contrainte
ne dépend pas d'un discriminant (voir 3.7.1), alors l'indication de sous-type
est élaboré. Si par contre la contrainte dépend d’un
discriminant, alors l’élaboration consiste en l’évaluation de tout
inclus une expression qui n’est pas discriminante.                                             

Exemples de déclarations de type d'enregistrement :

   tapez DATE est
      enregistrer
         JOUR : ENTIER plage 1 .. 31 ;
         MOIS : MOIS_NAME ;
         ANNÉE : ENTIER plage 0 .. 4000 ;
      terminer l'enregistrement ;

   le type COMPLEXE est
      enregistrer  
         RE : RÉEL := 0.0;
         IM : RÉEL := 0.0;
      terminer l'enregistrement ;

Exemples de variables d'enregistrement :

   DEMAIN, HIER : DATE;
   A, B, C : COMPLEXE ;

   -- les deux composants de A, B et C sont implicitement initialisés à zéro

Remarques:

L'expression par défaut d'un composant d'enregistrement est implicitement évaluée par le
élaboration de la déclaration d'un objet d'enregistrement, en l'absence d'un
initialisation explicite (voir 3.2.1). Si une déclaration de composant a
plusieurs identifiants, l'expression est évaluée une fois pour chacun d'entre eux
composant de l'objet (puisque la déclaration équivaut à une séquence
de déclarations de composants uniques).

Contrairement aux composants d'un tableau, les composants d'un enregistrement n'ont pas besoin d'être
du même type.

Références : délimiteur composé d'affectation 2.2, composant 3.3, composite
valeur 3.3, contrainte 3.3, déclaration 3.1, dépendent d'un discriminant 3.7.1,
discriminant 3.3, partie discriminante 3.7 3.7.1, élaboration 3.9, expression
4.4, identifiant 2.3, liste d'identifiants 3.2, type limité 7.4.4, nom 4.1,
objet 3.2, sous-type 3.3, type 3.3, marque de type 3.3.2, variante partie 3.7.3  

3.7.1 Discriminants 

Une partie discriminante spécifie les discriminants d'un type. Un discriminant
d'un dossier est une composante du dossier. Le type de discriminant doit
être discret.

   partie_discriminante ::=
      (spécification_discriminante {; spécification_discriminante})

   spécification_discriminante ::=
      liste_identifiant : marque_type [:= expression]  

Une partie discriminante n'est autorisée que dans la déclaration de type d'un enregistrement
type, dans une déclaration de type privée ou une déclaration de type incomplète (le
la déclaration complète correspondante doit alors déclarer un type d'enregistrement), et dans le
déclaration de paramètre générique pour un type privé formel.                                                       

Une spécification discriminante avec plusieurs identifiants équivaut à un
séquence de spécifications discriminantes uniques, comme expliqué dans la section
3.2. Chaque spécification discriminante déclare un discriminant. Si un
la spécification discriminante inclut le délimiteur composé d'affectation
suivi d'une expression, l'expression est l'expression par défaut du
discriminant; l'expression par défaut doit être du type du
discriminant. Les expressions par défaut doivent être fournies soit pour tous, soit pour
aucun des discriminants d'une partie discriminante.

L'utilisation du nom d'un discriminant n'est pas autorisée dans les expressions par défaut
d'une partie discriminante si la spécification du discriminant est elle-même
donnée dans la partie discriminante.

Dans une définition de type d'enregistrement, les seules utilisations autorisées du nom d'un
discriminant du type d'enregistrement sont : dans les expressions par défaut pour l'enregistrement
Composants; en variante comme nom discriminant ; et dans un
définition du sous-type de composant, soit comme limite dans une contrainte d'index, soit
pour spécifier une valeur discriminante dans une contrainte discriminante. UN
le nom discriminant utilisé dans ces définitions de sous-types de composants doit apparaître
en soi, et non dans le cadre d’une expression plus large. Ce sous-type de composant
on dit que les définitions et ces contraintes dépendent d’un discriminant.

Une composante est dite dépendante d’un discriminant s’il s’agit d’une composante d’enregistrement
déclaré dans une partie variante, ou un composant d'enregistrement dont le sous-type de composant
la définition dépend d'un discriminant, ou enfin, d'une des sous-composantes
d'une composante qui dépend elle-même d'un discriminant.

Chaque valeur d'enregistrement inclut une valeur pour chaque discriminant spécifié pour le
type d'enregistrement ; il inclut également une valeur pour chaque composant d'enregistrement qui ne
ne dépend pas d'un discriminant. Les valeurs des discriminants déterminent
quelles autres valeurs de composants se trouvent dans la valeur d'enregistrement.

L'affectation directe à un discriminant d'un objet n'est pas autorisée ;
de plus, un discriminant n'est pas autorisé comme paramètre réel de mode dans
out ou out, ou comme paramètre générique réel du mode in out. Le seul
La manière autorisée de modifier la valeur d'un discriminant d'une variable est de
attribuer une valeur (complète) à la variable elle-même. De même, une mission
à la variable elle-même est le seul moyen autorisé de modifier la contrainte de
l'un de ses composants, si la définition du sous-type de composant dépend d'un
discriminant de la variable.

L'élaboration d'une partie discriminante n'a pas d'autre effet.

Exemples:

   tapez BUFFER(SIZE : BUFFER_SIZE := 100) est -- voir 3.5.4
      enregistrer
         POV : BUFFER_SIZE := 0;
         VALEUR : CHAÎNE(1 .. TAILLE);
      terminer l'enregistrement ;

   type CARRÉ(CÔTÉ : ENTIER) est
      enregistrer
         MAT : MATRIX(1 .. CÔTÉ, 1 .. CÔTÉ); -- voir 3.6
      terminer l'enregistrement ; 

   tapez DOUBLE_SQUARE(NUMBER : INTEGER) est
      enregistrer
         GAUCHE : CARRÉ(NUMÉRO);
         DROITE : CARRÉ(NUMÉRO);
      terminer l'enregistrement ;                                                                           

   tapez ARTICLE(NUMÉRO : POSITIF) est
      enregistrer
         CONTENU : ENTIER;
         -- aucune composante ne dépend du discriminant
      terminer l'enregistrement ;  

Références : affectation 5.2, délimiteur composé d'affectation 2.2, limite d'un
plage 3.5, composant 3.3, déclaration de composant 3.7, composant d'un enregistrement
3.7, déclaration 3.1, type discret 3.5, discriminant 3.3, discriminant
contrainte 3.7.2, élaboration 3.9, expression 4.4, type formel générique
12.1, déclaration de paramètres génériques 12.1, identifiant 2.3, liste d'identifiants
3.2, déclaration de type incomplète 3.8.1, contrainte d'index 3.6.1, nom 4.1,
objet 3.2, type privé 7.4, déclaration de type privé 7.4, type d'enregistrement
3.7, portée 8.2, nom simple 4.1, sous-composant 3.3, indication de sous-type
3.3.2, déclaration de type 3.3.1, marque de type 3.3.2, variante partie 3.7.3   

3.7.2 Contraintes discriminantes 

Une contrainte discriminante n'est autorisée que dans une indication de sous-type, après un
marque de type. Cette marque de type doit désigner soit un type avec discriminants, soit
un type d'accès dont le type désigné est un type à discriminants. UN
la contrainte discriminante précise les valeurs de ces discriminants.

   contrainte_discriminante ::=
      (association_discriminante {, association_discriminante})

   association_discriminante ::=
      [nom_simple_discriminant {| discriminant_simple_name} =>] expression

Chaque association discriminante associe une expression à un ou plusieurs
discriminants. Une association discriminatoire est dite désignée si
les discriminants sont explicitement désignés par leur nom ; c'est autrement
dit être positionnel. Pour une association positionnelle, le (unique)
Le discriminant est implicitement spécifié par position, dans l’ordre textuel. Nommé
les associations peuvent être données dans n'importe quel ordre, mais si elles sont à la fois positionnelles et nommées
les associations sont utilisées dans la même contrainte discriminante, puis positionnelle
les associations doivent se produire en premier, à leur position normale. Donc une fois par
l'association nommée est utilisée, le reste de la contrainte discriminante doit utiliser
uniquement des associations nommées.  

Pour une association discriminante nommée, les noms discriminants doivent désigner
discriminants du type pour lequel la contrainte discriminante est donnée.
Une association discriminante avec plus d'un nom discriminant n'est que
autorisé si les discriminants nommés sont tous du même type. En outre,
pour chaque association discriminante (qu’elle soit nommée ou positionnelle), la
l’expression et les discriminants associés doivent avoir le même type. UN
la contrainte discriminante doit fournir exactement une valeur pour chaque
discriminant du type.

Une contrainte discriminante est compatible avec le type noté par un type
marque, si et seulement si chaque valeur discriminante appartient au sous-type du 
discriminant correspondant. De plus, pour chaque sous-composante dont
la spécification du sous-type de composant dépend d'un discriminant, le
la valeur discriminante est substituée au discriminant dans cette composante
spécification du sous-type et compatibilité du sous-type résultant
l’indication est vérifiée.

Une valeur composite satisfait une contrainte discriminante si et seulement si chaque
le discriminant de la valeur composée a la valeur imposée par le
contrainte discriminante.                                                                       

Les valeurs initiales des discriminants d'un objet d'un type avec
les discriminants sont déterminés comme suit :

 - Pour une variable déclarée par une déclaration d'objet, le sous-type
    l'indication de la déclaration d'objet correspondante doit imposer une
    contrainte discriminante sauf si des expressions par défaut existent pour le
    les discriminants; les valeurs discriminantes sont définies soit par le
    contrainte ou, en son absence, par les expressions par défaut. Le même
    une exigence existe pour l'indication de sous-type d'un composant
    déclaration, si le type du composant d'enregistrement a des discriminants ;
    et pour le sous-type de composant, indication d'un type de tableau, si le type
    des composants du tableau est un type avec discriminants.

 - Pour une constante déclarée par une déclaration d'objet, les valeurs des
    les discriminants sont ceux de la valeur initiale si le sous-type du
    constante n'est pas contrainte ; ils sont autrement définis par ce sous-type
    (dans ce dernier cas, une exception est levée si la valeur initiale ne
    n'appartiennent pas à ce sous-type). La même règle s'applique à un générique
    paramètre de mode in.

 - Pour un objet désigné par une valeur d'accès, les valeurs discriminantes
    doit être défini par l'allocateur qui crée l'objet. (Le
    l'objet alloué est contraint avec le discriminant correspondant
    valeurs.)

 - Pour un paramètre formel d'un sous-programme ou d'une entrée, les discriminants de
    les paramètres formels sont initialisés avec ceux des paramètres correspondants
    paramètre réel. (Le paramètre formel est contraint si le
    le paramètre réel correspondant est contraint, et en tout cas si le
    le mode est activé ou si le sous-type du paramètre formel est contraint.)

 - Pour une déclaration de renommage et pour un paramètre formel générique de mode
    in out, les discriminants sont ceux de l'objet renommé ou du
    paramètre réel générique correspondant.

Pour l'élaboration d'une contrainte discriminante, les expressions données dans
les associations discriminantes sont évaluées dans un ordre qui n'est pas
défini par la langue; l'expression d'une association nommée est
évalué une fois pour chaque discriminant nommé.   

Exemples (utilisant les types déclarés dans la section précédente) : 01

 GRAND : TAMPON(200); -- contraint, toujours 200 caractères (explicite
                             valeur discriminante)
 MESSAGE : TAMPON ; -- sans contrainte, initialement 100 caractères
                             (valeur discriminante par défaut)
 BASE : CARRÉ(5); -- contraint, toujours 5 par 5
 ILLÉGAL : PLACE; -- illégal, un CARRÉ doit être contraint

Note:

Les règles ci-dessus et les règles définissant l'élaboration d'un objet
(voir 3.2) garantissent que les discriminants ont toujours une valeur. Dans
en particulier, si une contrainte discriminante est imposée sur un objet
déclaration, chaque discriminant est initialisé avec la valeur spécifiée par
la contrainte. De même, si le sous-type d'un composant a un 
contrainte discriminante, les discriminants de la composante sont
initialisé en conséquence.

Références : type d'accès 3.8, définition du type d'accès 3.8, valeur d'accès 3.8,
paramètre réel 6.4.1, allocateur 4.8, définition du type de tableau 3.6, limite de
une plage 3.5, compatible 3.3.2, composant 3.3, déclaration de composant 3.7,
indication de sous-type de composant 3.7, valeur composite 3.3, constante 3.2.1,
sous-type contraint 3.3, contrainte 3.3, déclaration 3.1, par défaut
expression d'un discriminant 3.7, dépend d'un discriminant 3.7.1,
désigner 3.8, type désigné 3.8, discriminant 3.3, élaboration 3.9,
entrée 9.5, évaluation 4.5, expression 4.4, paramètre formel 6.1, générique
paramètre réel 12.3, paramètre formel générique 12.1 12.3, mode en 6.1,
mode entrée sortie 6.1, nom 4.1, objet 3.2, déclaration d'objet 3.2.1, renommage
déclaration 8.5, mot réservé 2.9, satisfaire 3.3, nom simple 4.1,
sous-composant 3.3, sous-programme 6, sous-type 3.3, indication de sous-type 3.3.2, type
3.3, marque 3.3.2, variable 3.2.1                                                                  

3.7.3 Pièces variantes 

Un type d'enregistrement avec une partie variante spécifie des listes alternatives de
Composants. Chaque variante définit les composants pour le correspondant
valeur ou valeurs du discriminant.

   variante_part ::=
      cas discriminant_simple_name est
          une variante
         {une variante}
      cas final ;

   variante ::=
      quand choix {| choix} =>
         liste_composants

   choix ::= expression_simple
      | plage_discrète | autres | nom_simple_composant

Chaque variante commence par une liste de choix qui doivent être du même type
comme discriminant de la partie variante. Le type de discriminant d'un
la partie variante ne doit pas être un type formel générique. Si le sous-type du
le discriminant est statique, alors chaque valeur de ce sous-type doit être représentée
une et une seule fois dans l'ensemble des choix de la pièce variante, et aucune autre
la valeur est autorisée. Sinon, chaque valeur du type (de base) du
Le discriminant doit être représenté une et une seule fois dans l’ensemble des choix.

Les expressions simples et plages discrètes données en choix dans une variante
la pièce doit être statique. Un choix défini par une gamme discrète représente tous
valeurs dans la plage correspondante (aucune si plage nulle). Le choix
les autres ne sont autorisés que pour la dernière variante et comme seul choix ; il
représente toutes les valeurs (éventuellement aucune) non données dans les choix précédents
variantes. Un nom simple de composant n'est pas autorisé comme choix de variante
(même si cela fait partie de la syntaxe de choix).

Une valeur d'enregistrement contient les valeurs des composants d'une variante donnée si
et seulement si la valeur discriminante est égale à l'une des valeurs précisées
par les choix de la variante. Cette règle s'applique à son tour à tout autre
variante qui est elle-même incluse dans la liste des composants du
une variante. Si la liste des composants d'une variante est spécifiée par null, le
la variante n'a aucun composant.

Exemple de type d'enregistrement avec une partie variante :

   le type DEVICE est (IMPRIMANTE, DISQUE, TAMBOUR) ;
   tapez STATE est (OUVERT, FERMÉ) ;

   tapez PÉRIPHÉRIQUE(UNITÉ : DEVICE := DISQUE) est
      enregistrer
         STATUT : ETAT ;
         cas UNIT est
            quand IMPRIMANTE =>
               LINE_COUNT : plage INTEGER 1 .. PAGE_SIZE ;
            quand les autres =>
               CYLINDRE : CYLINDER_INDEX ;
               PISTE : TRACK_NUMBER ;
            cas final ;
         terminer l'enregistrement ;                                                                           

Exemples de sous-types d'enregistrement :

   le sous-type DRUM_UNIT est PERIPHERAL(DRUM) ;
   le sous-type DISK_UNIT est PERIPHERAL(DISK) ;

Exemples d'ariables d'enregistrement contraintes :

   ÉCRIVAIN : PÉRIPHÉRIQUE(UNITÉ => IMPRIMANTE);
   ARCHIVE : DISK_UNIT ;

Note:

Les choix avec des valeurs discrètes sont également utilisés dans les instructions case et dans les tableaux
agrégats. Les choix avec des noms simples de composants sont utilisés dans l'enregistrement
agrégats.

Références : agrégats de tableaux 4.3.2, type de base 3.3, composant 3.3, composant
liste 3.7, plage discrète 3.6, discriminant 3.3, type formel générique 12.1.2,
plage nulle 3,5, agrégat d'enregistrement 4.3.1, plage 3,5, type d'enregistrement 3,7, simple
expression 4.4, nom simple 4.1, plage discrète statique 4.9, statique
expression 4.9, sous-type statique 4.9, sous-type 3.3

3.7.4 Opérations sur les types d'enregistrement

Les opérations de base d'un type d'enregistrement incluent les opérations impliquées dans
affectation et agrégats (sauf si le type est limité), tests d'adhésion,
sélection des composants d'enregistrement, des qualifications et de la conversion de type (pour
types dérivés)

Pour tout objet A d'un type à discriminants, les opérations de base aussi
inclure l'attribut suivant :

A'CONSTRAINED Renvoie la valeur TRUE si la contrainte discriminante
                 s'applique à l'objet A, ou si l'objet est une constante
                 (y compris un paramètre formel ou un paramètre formel générique
                 du mode en); sinon, renvoie la valeur FALSE. Si A est un
                 paramètre formel générique du mode in out, ou si A est un
                 paramètre formel du mode in out ou out et la marque de type
                 donné dans la spécification du paramètre correspondant
                 désigne un type sans contrainte avec des discriminants, alors
                 la valeur de cet attribut est obtenue à partir de celle du
                 paramètre réel correspondant. La valeur de cet attribut
                 bute est du type prédéfini BOOLEAN.

De plus, les attributs T'BASE et T'SIZE sont définis pour un type d'enregistrement
ou sous-type T (voir 3.3.3) ; les attributs A'SIZE et A'ADDRESS sont définis
pour un objet d'enregistrement A (voir 13.7.2).

Outre les opérations de base, les opérations d'un type enregistrement comprennent les
comparaison prédéfinie pour l'égalité et l'inégalité, sauf si le type est
limité.

Note:

Un type d'enregistrement est limité si le type de l'un de ses composants est limité
(voir 7.4.2).

Références : paramètre actuel 6.4.1, appréciation 4.3, affectation 5.2,
attribut 4.1.4, opération de base 3.3.3, type booléen 3.5.3, constante 3.2.1,
conversion 4.6, type dérivé 3.4, discriminant 3.3, contrainte discriminante
3.7.2, paramètre formel 6.1, paramètre réel générique 12.3, paramètre formel générique
paramètre 12.1 12.3, type limité 7.4.4, test d'appartenance 4.5 4.5.2, mode
6.1, objet 3.2.1, opération 3.3, opérateur prédéfini 4.5, type prédéfini
C, expression qualifiée 4.7, type d'enregistrement 3.7, opérateur relationnel 4.5
4.5.2, composante sélectionnée 4.1.3, sous-composante 3.3, sous-type 3.3, type 3.3                       

3.8 Types d'accès

Un objet déclaré par une déclaration d'objet est créé par l'élaboration
de la déclaration d'objet et est désigné par un nom simple ou par un autre
forme du nom. En revanche, il existe des objets créés par l'évaluation.
uation des allocateurs (voir 4.8) et qui n’ont pas de nom simple. Accès à
un tel objet est atteint par une valeur d'accès renvoyée par un allocateur ; le
on dit que la valeur d'accès désigne l'objet.

   access_type_definition ::= accès subtype_indication

Pour chaque type d'accès, il existe un null littéral qui a une valeur d'accès nulle
ne désignant aucun objet. La valeur nulle d'un type d'accès est la
valeur initiale par défaut du type. Les autres valeurs d'un type d'accès sont
obtenu par évaluation d'une opération spéciale du type appelé un
répartiteur. Chacune de ces valeurs d'accès désigne un objet du sous-type
défini par l'indication de sous-type de la définition du type d'accès ; ce
le sous-type est appelé sous-type désigné ; le type de base de ce sous-type est
appelé le type désigné. Les objets désignés par les valeurs d'un
Le type d’accès forme une collection implicitement associée au type.

L'élaboration d'une définition de type d'accès consiste en l'élaboration de
l'indication de sous-type et crée un type d'accès.

Si un objet d'accès est constant, la valeur d'accès contraint ne peut pas être
changé et désigne toujours le même objet. En revanche, la valeur
de l'objet désigné ne doit pas nécessairement rester le même (attribution au
l'objet désigné est autorisé sauf si le type désigné est limité).

Les seules formes de contrainte autorisées après le nom d'un accès
taper dans une indication de sous-type sont des contraintes d'index et des discriminants
contraintes. (Voir les sections 3.6.1 et 3.7.2 pour les règles applicables aux
ces indications de sous-type.) Une valeur d’accès appartient à un
sous-type d'un type d'accès soit si la valeur d'accès est la valeur nulle, soit
si la valeur de l'objet désigné satisfait la contrainte.

Exemples:

   tapez FRAME pour accéder à MATRIX ; -- voir 3.6

   type BUFFER_NAME est accès BUFFER -- voir 3.7.1

Remarques:

Une valeur d'accès délivrée par un allocateur peut être affectée à plusieurs accès
objets. Il est donc possible qu'un objet créé par un allocateur soit
désigné par plus d’une variable ou constante du type d’accès. Un
la valeur d'accès ne peut désigner qu'un objet créé par un allocateur ; dans
notamment, il ne peut pas désigner un objet déclaré par un objet
déclaration.

Si le type des objets désignés par les valeurs d'accès est un type tableau
ou un type avec discriminants, ces objets sont contraints soit avec le
limites du tableau ou valeurs discriminantes fournies implicitement ou explicitement
pour les répartiteurs correspondants (voir 4.8).

Les valeurs d'accès sont appelées pointeurs de références dans d'autres langages.

Références : allocateur 4.8, type de tableau 3.6, affectation 5.2, appartiennent à un
sous-type 3.3, constante 3.2.1, contrainte 3.3, contrainte discriminante 3.7.2,
élaboration 3.9, contrainte d'index 3.6.1, spécification d'index 3.6, limitée
type 7.4.4, littéral 4.2, nom 4.1, objet 3.2.1, déclaration d'objet 3.2.1,
mot réservé 2.9, satisfaire 3.3, nom simple 4.1, sous-composant 3.3, sous-type
3.3, indication de sous-type 3.3.2, type 3.3 variable 3.2.1                                       

3.8.1 Déclarations de type incomplètes

Il n'y a pas de limitations particulières sur le type désigné d'accès
taper. En particulier, le type d'un composant du type désigné peut être
un autre type d'accès, voire le même type d'accès. Cela permet mutuellement
types d'accès dépendants et récursifs. Leurs déclarations nécessitent un préalable
déclaration de type incomplète (ou privée) pour un ou plusieurs types.

    incomplete_type_declaration ::= identifiant de type [discriminant_part];

Pour chaque déclaration de type incomplète, il doit y avoir un correspondant
déclaration d'un type avec le même identifiant. Le correspondant
La déclaration doit être soit une déclaration de type complet, soit les déclarations d'un
type de tâche. Dans la suite de cette section, des explications sont données en termes de
déclarations de type complet ; les mêmes règles s'appliquent également aux déclarations de tâches
les types. Si la déclaration de type incomplète apparaît immédiatement dans l'un ou l'autre
une partie déclarative ou la partie visible d'une spécification de package, alors le
la déclaration de type complet doit avoir lieu plus tard et immédiatement dans ce
partie déclarative ou partie visible. Si la déclaration de type incomplète se produit
immédiatement dans la partie privée d'un package, puis le type complet
la déclaration doit intervenir ultérieurement et immédiatement soit dans la partie privée
lui-même, ou la partie déclarative du corps du package correspondant.

Une partie discriminante doit être indiquée dans la déclaration de type complète si et seulement
s'il en est donné un dans la déclaration de type incomplète ; si parties discriminantes
sont données, alors ils doivent être conformes (voir 6.3.1 pour les règles de conformité).
Avant la fin de la déclaration de type complète, la seule utilisation autorisée d'un
le nom qui désigne un type déclaré par une déclaration de type incomplète est le suivant
la marque de type dans l'indication de sous-type d'une définition de type d'accès ; le
la seule forme de contrainte autorisée dans cette indication de sous-type est une
contrainte discriminante.

L'élaboration d'une déclaration de type incomplète crée un type. Si la
déclaration de type incomplète a une partie discriminante, cette élaboration
inclut celui de la partie discriminante : dans un tel cas, la partie discriminante
une partie de la déclaration de type complète n’est pas élaborée.

Exemple de type récursif :

   tapez CELLULE ; -- déclaration de type incomplète
   tapez LINK pour accéder à CELL ;

   le type CELL est
      enregistrer
         VALEUR : ENTIER ;
         SUCC : LIEN ;
         PRÉD : LIEN ;
      terminer l'enregistrement ;

   HEAD : LINK := new CELL'(O, null, null);
   SUIVANT : LIEN := HEAD.SUCC;

Exemples de types d'accès mutuellement dépendants :

   tapez PERSONNE(SEXE : GENRE); -- déclaration de type incomplète
   tapez VOITURE ; -- déclaration de type incomplète

   tapez PERSON_NAME est accès PERSONNE ;
   tapez CAR_NAME est accès CAR ;

   le type CAR est
      enregistrer
         NOMBRE : ENTIER;
         PROPRIÉTAIRE :PERSON_NAME ;
      terminer l'enregistrement ;                                                                              

   le type PERSONNE(SEXE : GENRE) est
      enregistrer
         NOM : CHAÎNE(1 .. 20);
         DATE DE NAISSANCE;
         ÂGE : intervalle ENTIER 0 .. 130 ;                
         VÉHICULE : CAR_NAME ;
         cas où le SEXE est
            quand M => FEMME : PERSON_NAME(SEX => F);
            quand F => MARI : PERSONNE_NAME(SEX => M);
         cas final ;
      terminer l'enregistrement ;

   MA_VOITURE, VOTRE_VOITURE, NEXT_CAR : CAR_NAME ; -- implicitement initialisé avec
                                             valeur nulle

Références : type d'accès 3.8, définition du type d'accès 3.8, composant 3.3,
conforme 6.3.1, contrainte 3.3, déclaration 3.1, élément déclaratif 3.9,
désigner 3.8, contrainte discriminante 3.7.2, partie discriminante 3.7.1,
élaboration 3.9, identifiant 2.3, nom 4.1, indication de sous-type 3.3.2, type
3.3, marque de type 3.3.2

3.8.2 Opérations des types d'accès 

Les opérations de base d'un type d'accès incluent les opérations impliquées dans
affectation, allocateurs pour le type d'accès, tests d'adhésion,
qualification, conversion explicite et null littéral. Si la
le type désigné est un type avec des discriminants, les opérations de base incluent
la sélection des discriminants correspondants ; si le type désigné
est un type d'enregistrement, ils incluent la sélection du correspondant
Composants; si le type désigné est un type tableau, ils incluent le
formation de composants et de tranches indexés ; si le type désigné est un
type de tâche, ils comprennent la sélection des entrées et des familles d'entrées.
En outre, les opérations de base comprennent la formation d'un
composant avec le mot réservé all (voir 4.1.3).

Si le type désigné est un type tableau, les opérations de base incluent le
attributs qui ont les désignateurs d'attribut FIRST, LAST, RANGE et
LONGUEUR (de même, les désignateurs d'attributs de la N-ième dimension). Le
le préfixe de chacun de ces attributs doit être une valeur du type d'accès.
Ces attributs donnent les caractéristiques correspondantes de l'entité désignée.
objet (voir 3.6.2).

Si le type désigné est un type de tâche, les opérations de base incluent le
attributs qui ont les désignateurs d'attribut TERMINATED et CALLABLE (voir
9.9). Le préfixe de chacun de ces attributs doit être une valeur du paramètre d'accès
taper. Ces attributs donnent les caractéristiques correspondantes du
objets de tâche désignés.

De plus, l'attribut T'BASE (voir 3.3.3) et la représentation
les attributs T'SIZE et T'STORAGE_SIZE (voir 13.7.2) sont définis pour un accès
type ou sous-type T ; les attributs A'SIZE et A'ADDRESS sont définis pour un
accéder à l'objet A (voir 13.7.2).  

Outre les opérations de base, les opérations de type accès comprennent les
comparaison prédéfinie pour l’égalité et l’inégalité.

Références : type d'accès 3.8, allocateur 4.8, type de tableau 3.6, affectation
5.2, attribut 4.1.4, désignateur d'attribut 4.1.4, type de base 3.3, de base
opération 3.3.3, collection 3.8, sous-type de tableau contraint 3.6, conversion
4.6, désigner 3.8, sous-type désigné 3.8, type désigné 3.8,
discriminant 3.3, composant indexé 4.1.1, littéral 4.2, test d'appartenance 4.5
4.5.2, objet 3.2.1, opération 3.3, type privé 7.4, expression qualifiée
4.7, type d'enregistrement 3.7, composant sélectionné 4.1.3, tranche 4.1.2, sous-type 3.3,
type de tâche 9.1, type 3.3                                                           

3.9 Parties déclaratives 

Une partie déclarative contient des éléments déclaratifs (éventuellement aucun).

   partie déclarative ::=
      {basic_declarative_item} {later_declarative_item}

   basic_declarative_item ::= basic_declaration
      | clause_de représentation | clause_d'utilisation

   later_declarative_item ::= corps  
      | déclaration_sous-programme | déclaration_paquet
      | déclaration_de-tâche | déclaration_générique
      | clause_d'utilisation | générique_instantiation

   corps ::= corps_propre | corps_stub

   proper_body ::= subprogram_body | package_body | task_body

L'élaboration d'une partie déclarative consiste en l'élaboration du
éléments déclaratifs, le cas échéant, dans l'ordre dans lequel ils sont indiqués dans le
partie déclarative. Après son élaboration, un élément déclaratif est dit
élaboré. Avant l'achèvement de son élaboration (y compris avant
l'élaboration), le point déclaratif n'est pas encore élaboré.

Pour plusieurs formes de rubrique déclarative, les règles de langage (notamment
règles de portée et de visibilité) sont telles qu'il est soit impossible, soit
illégal d'utiliser une entité avant l'élaboration de l'élément déclaratif
qui déclare cette entité. Par exemple, il n'est pas possible d'utiliser le nom
d'un type pour une déclaration d'objet si la déclaration de type correspondante
n’est pas encore élaboré. Dans le cas des cadavres, les contrôles suivants sont
effectué :

 - Lors d'un appel de sous-programme, on vérifie que le corps du sous-programme
    est déjà élaboré.

 - Pour l'activation d'une tâche, on vérifie que le corps du
    l'unité de tâche correspondante est déjà élaborée.

 - Pour l'instanciation d'une unité générique possédant un corps, une vérification est
    fait que ce corps est déjà élaboré.

L'exception PROGRAM_ERROR est levée si l'une de ces vérifications échoue.

Si une déclaration de sous-programme, une déclaration de package, une déclaration de tâche ou
une déclaration générique est un élément déclaratif d'une partie déclarative donnée,
puis le corps (s'il y en a un) de l'unité de programme déclaré par le
l'élément déclaratif doit lui-même être un élément déclaratif de cette partie déclarative
(et doit apparaître plus tard). Si le corps est un échantillon de corps, alors un
une sous-unité compilée contenant le corps approprié correspondant est requise pour
l'unité de programme (voir 10.2).

Références : activation 9.3, instanciation 12.3, exception program_error
11.1, portée 8.2, appel de sous-programme 6.4, type 3.3, visibilité 8.3 

Elaboration des déclarations : 3.1, déclaration des composants 3.7, différée
déclaration constante 7.4.3, spécification discriminante 3.7.1, entrée
déclaration 9.5, spécification littérale d'énumération 3.5.1, générique
déclaration 12.1, instanciation générique 12.3, déclaration de type incomplète
3.8.1, spécification des paramètres de boucle 5.5, déclaration numérique 3.2.2, objet
déclaration 3.2.1, déclaration du package 7.2, spécification des paramètres 6.1,
déclaration de type privé 7.4.1, déclaration de renommage 8.5, sous-programme
déclaration 6.1, déclaration de sous-type 3.3.2, déclaration de tâche 9.1, type
déclaration 3.3.1                                                                      

Elaboration des définitions de types : 3.3.1, définition de type d'accès 3.8, tableau
définition de type 3.6, définition de type dérivé 3.4, type d'énumération
définition 3.5.1, définition de type entier 3.5.4, définition de type réel
3.5.6, définition du type d'enregistrement 3.7

Élaboration d'autres constructions : clause de contexte 10.1, stub de corps 10.2,
unité de compilation 10.1, partie discriminante 3.7.1, corps générique 12.2, générique
paramètre formel 12.1 12.3, unité de bibliothèque 10.5, corps du package 7.1,
clause de représentation 13.1, corps du sous-programme 6.3, sous-unité 10.2, corps de la tâche
9.1, objet de tâche 9.2, spécification de tâche 9.1, utiliser la clause 8.4, avec la clause
10.1.1        
