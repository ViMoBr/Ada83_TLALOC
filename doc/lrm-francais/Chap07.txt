
                               7. Forfaits  

Les packages sont l'une des quatre formes d'unités de programme dont les programmes peuvent
être composé. Les autres formulaires sont des sous-programmes, des unités de tâches et des formulaires génériques.
unités.

Les packages permettent la spécification de groupes d’entités logiquement liées.
Dans leur forme la plus simple, les packages spécifient des pools d'objets et de types communs
déclarations. Plus généralement, les packages peuvent être utilisés pour spécifier des groupes de
entités associées, y compris également des sous-programmes pouvant être appelés de l'extérieur
l'emballage, tandis que leurs rouages ​​internes restent cachés et protégés des
utilisateurs extérieurs. 

Références : unité générique 12, unité de programme 6, sous-programme 6, unité de tâche 9,
déclaration de type 3.3.1   

7.1 Structure du paquet 

Un package est généralement fourni en deux parties : une spécification du package et
un corps de paquet. Chaque package a une spécification de package, mais pas tous
les packages ont un corps de package.

   package_declaration ::= package_spécification;

   package_spécification ::=
       l'identifiant du paquet est
         {basic_declarative_item}
      [privé
         {basic_declarative_item}]
       fin [package_simple_name]

   package_body ::=
       le corps du package package_simple_name est
          [partie déclarative]
      [commencer
           séquence_of_statements
      [exception
           exception_handler
          {exception_handler}]]
       fin [package_simple_name] ;

Le nom simple au début du corps d'un package doit répéter le package
identifiant. De même si un simple nom apparaît à la fin du package 
spécification ou corps, il doit répéter l’identifiant du package.

Si une déclaration de sous-programme, une déclaration de package, une déclaration de tâche ou
une déclaration générique est un élément déclaratif d'un package donné
spécification, puis le corps (s'il y en a un) de l'unité de programme déclarée
par l'élément déclaratif doit lui-même être un élément déclaratif du
partie déclarative du corps du package donné.                                                 

Remarques:

Une forme simple de package, spécifiant un pool d'objets et de types, ne
nécessitent un corps de paquet. Une des utilisations possibles de la séquence de
Les instructions d'un corps de package consistent à initialiser de tels objets. Pour chaque
déclaration de sous-programme, il doit y avoir un corps correspondant (sauf pour un
sous-programme écrit dans un autre langage, comme expliqué à la section 13.9). Si
le corps d'une unité de programme est un stub de corps, puis un compilé séparément
une sous-unité contenant le corps propre correspondant est requise pour le
unité de programme (voir 10.2). Un corps n'est pas un élément déclaratif de base et donc
ne peut pas apparaître dans une spécification de package.

Une déclaration de package est soit un package de bibliothèque (voir 10.2), soit un
élément déclaratif déclaré dans une autre unité de programme. 

Références : élément déclaratif de base 3.9, stub du corps 10.2, élément déclaratif
3.9, partie déclarative 3.9, gestionnaire d'exceptions 11.2, corps générique 12.2,
déclaration générique 12.1, identifiant 2.3, unité de bibliothèque 10.1, objet 3.2,
corps du package 7.3, unité de programme 6, corps propre 3.9, séquence d'instructions
5.1, nom simple 4.1, corps du sous-programme 6.3, déclaration du sous-programme 6.1,
sous-unité 10.2, corps de tâche 9.1, déclaration de tâche 9.1, type 3.3   

7.2 Spécifications et déclarations du colis 

La première liste d'éléments déclaratifs d'une spécification de package est appelée
la partie visible du colis. La liste facultative des éléments déclaratifs
après le mot réservé private est appelé la partie privée du package.

Une entité déclarée dans la partie privée d'un package n'est pas visible à l'extérieur
le package lui-même (un nom désignant une telle entité n'est possible que dans
le paquet). En revanche, les noms développés désignant des entités déclarées dans
la partie visible peut être utilisée même en dehors de l'emballage ; en outre, direct
la visibilité de ces entités peut être obtenue au moyen de clauses d'utilisation (voir
4.1.3 et 8.4).

L'élaboration d'une déclaration globale consiste en l'élaboration de son
éléments déclaratifs de base dans l’ordre donné.

Remarques:

La partie visible d'un package contient toutes les informations qu'un autre
l’unité de programme est capable de connaître le package. Un forfait composé de
seule une spécification de package (c'est-à-dire sans corps de package) peut être utilisée
pour représenter un groupe de constantes ou de variables communes, ou un pool commun de
objets et types, comme dans les exemples ci-dessous.

Exemple de package décrivant un groupe de variables communes :

   le package PLOTTING_DATA est
      PEN_UP : BOOLÉEN ; 

      FACTEUR DE CONVERSION,
      X_OFFSET, Y_OFFSET,
      X_MIN, Y_MIN,
      X_MAX, Y_MAX : RÉEL ; -- voir 3.5.7

      X_VALUE : tableau (1 .. 500) de REAL ;
      Y_VALUE : tableau (1 .. 500) de REAL ;
   terminer PLOTTING_DATA ;                                                            

Exemple de package décrivant un pool commun d'objets et de types : 

   le package WORK_DATA est
      le type JOUR est (LUN, MAR, MER, JEU, VEN, SAM, DIM) ;
      le type HOURS_SPENT est delta 0,25, plage 0,0 .. 24,0 ;
      le type TIME_TABLE est un tableau (DAY) de HOURS_SPENT ;

      HEURES_TRAVAIL : TIME_TABLE ;
      NORMAL_HOURS : constante TIME_TABLE :=
                        (LUN.. JEU => 8,25, VEN => 7,0, SAM | DIM => 0,0) ;
   terminer WORK_DATA ;  

Références : élément déclaratif de base 3.9, constante 3.2.1, élément déclaratif
3.9, visibilité directe 8.3, élaboration 3.9, nom étendu 4.1.3, nom 4.1,
déclaration de numéro 3.2.2, déclaration d'objet 3.2.1, package 7, package
déclaration 7.1, identifiant de package 7.1, spécification de package 7.1, portée
8.2, nom simple 4.1, déclaration de type 3.3.1, utiliser la clause 8.4, variable 3.2.1   

7.3 Corps de colis 

Contrairement aux entités déclarées dans la partie visible d'un package
spécification, les entités déclarées dans le corps du package ne sont visibles que
dans le corps du package lui-même. En conséquence, un colis avec un colis
body peut être utilisé pour la construction d’un groupe de sous-programmes liés (un
package au sens habituel), dans lequel les opérations logiques disponibles pour
les utilisateurs sont clairement isolés des entités internes.

Pour l’élaboration d’un corps de package, sa partie déclarative est d’abord
élaboré, et sa séquence d'instructions (le cas échéant) est ensuite exécutée. Le
gestionnaires d'exceptions facultatifs à la fin d'un service de corps de package
exceptions soulevées lors de l'exécution de la séquence d'instructions du
corps du paquet. 

Remarques:

Une variable déclarée dans le corps d'un package n'est visible qu'à l'intérieur de ce
body et, par conséquent, sa valeur ne peut être modifiée que dans le package
corps. En l'absence de tâches locales, la valeur d'une telle variable reste
inchangé entre les appels émis depuis l'extérieur du package vers les sous-programmes
déclaré dans la partie visible. Les propriétés d'une telle variable sont
similaires à celles d'une variable "propre" d'Algol 60.   

L'élaboration du corps d'un sous-programme déclaré dans la partie visible de
un package est provoqué par l’élaboration du corps du package. D'où un
l'appel d'un tel sous-programme par une unité de programme extérieure déclenche l'exception
PROGRAM_ERROR si l'appel a lieu avant l'élaboration du package 
corps (voir 3.9).                                                                 

Exemple de forfait : 

   Le package RATIONAL_NUMBERS est

      le type RATIONNEL est
         enregistrer
            NUMÉRATEUR : ENTIER;
            DÉNOMINATEUR : POSITIF;
         terminer l'enregistrement ;

      fonction EQUAL(X,Y : RATIONAL) return BOOLEAN ;

      la fonction "/" (X,Y : INTEGER) renvoie RATIONAL ; -- construire un
                                                            nombre rationnel
      fonction "+" (X,Y : RATIONAL) return RATIONAL ;
      fonction "-" (X,Y : RATIONAL) return RATIONAL ;
      fonction "*" (X,Y : RATIONAL) return RATIONAL ;
      fonction "/" (X,Y : RATIONAL) return RATIONAL ;
   fin;

   Le corps du package RATIONAL_NUMBERS est

      la procédure SAME_DENOMINATOR (X,Y : entrée sortie RATIONAL) est
      commencer
         -- réduit X et Y au même dénominateur :
         ...
      fin;

      fonction EQUAL(X,Y : RATIONAL) retour BOOLEAN est
         U,V : RATIONNEL;
      commencer
         U := X;
         V := Oui;
         SAME_DENOMINATOR (U,V);
         retourner U.NUMERATEUR = V.NUMERATEUR ;
      fin ÉGAL ;

      fonction "/" (X,Y : INTEGER) return RATIONAL est
      commencer
         si Y > 0 alors
            return (NUMÉRATEUR => X, DÉNOMINATEUR => Y);
         autre  
            return (NUMÉRATEUR => -X, DÉNOMINATEUR => -Y);
         fin si;
      fin "/";

      fonction "+" (X,Y : RATIONAL) return RATIONAL is ... end "+";
      fonction "-" (X,Y : RATIONAL) return RATIONAL is ... end "-";
      fonction "*" (X,Y : RATIONAL) return RATIONAL is ... end "*";
      fonction "/" (X,Y : RATIONAL) return RATIONAL is ... end "/";

   terminer RATIONAL_NUMBERS ;  

Références : déclaration 3.1, partie déclarative 3.9, élaboration 3.1 3.9,
exception 11, gestionnaire d'exceptions 11.2, nom 4.1, spécification de package 7.1,
unité de programme 6, exception program_error 11.1, séquence d'instructions 5.1,
sous-programme 6, variable 3.2.1, partie visible 7.2                                                   

7.4 Déclarations de type privé et de constante différée 

La déclaration d'un type comme type privé dans la partie visible d'un
package sert à séparer les caractéristiques qui peuvent être utilisées directement par
unités de programme extérieures (c'est-à-dire les propriétés logiques) des autres
caractéristiques dont l'usage direct est limité à l'emballage (le détail des
la définition du type lui-même). Les déclarations constantes différées déclarent
constantes de types privés.

   private_type_declaration ::=
      l'identifiant de type [discriminant_part] est [limité] privé ;

   deferred_constant_declaration ::=
      identifier_list : constante type_mark ;

Une déclaration de type privé n'est autorisée qu'en tant qu'élément déclaratif du
partie visible d'un package, ou comme déclaration de paramètre générique pour un
type formel générique dans une partie formelle générique. 

La marque de type d'une déclaration de constante différée doit désigner un type privé
ou un sous-type d'un type privé ; une déclaration de constante différée et le
les déclarations du type privé correspondant doivent être toutes deux déclaratives
articles de la partie visible d’un même colis. Une constante différée
une déclaration avec plusieurs identifiants équivaut à une séquence de simples
déclarations de constantes différées comme expliqué dans la section 3.2.

Exemples de déclarations de type privé :

   le type KEY est privé ;
   le type FILE_NAME est limité en privé ;

Exemple de déclaration de constante différée :

   NULL_KEY : CLÉ constante ; 

Références : constante 3.2.1, déclaration 3.1, rubrique déclarative 3.9,
constante différée 7.4.3, partie discriminante 3.7.1, partie formelle générique 12.1,
type formel générique 12.1, déclaration de paramètre générique 12.1, identifiant
2.3, liste d'identifiants 3.2, type limité 7.4.4, package 7, type privé
7.4.1, unité de programme 6, sous-type 3.3, type 3.3, marque de type 3.3.2, partie visible
7.2   

7.4.1 Types privés    

Si une déclaration de type privée est donnée dans la partie visible d'un package,
alors une déclaration correspondante d'un type avec le même identifiant doit
apparaître comme un élément déclaratif de la partie privée du package. Le
la déclaration correspondante doit être soit une déclaration de type complet, soit le
déclaration d'un type de tâche. Dans le reste de cette section, les explications sont
donné en termes de déclarations de type complet ; les mêmes règles s'appliquent également à
déclarations de types de tâches.                                                       

Une déclaration de type privée et la déclaration de type complète correspondante
définir un seul type. La déclaration de type privée, ainsi que le
partie visible, définissez les opérations disponibles pour le programme extérieur
unités (voir section 7.4.2 sur les opérations disponibles pour les particuliers)
les types). D'un autre côté, la déclaration de type complète définit d'autres
opérations dont l’utilisation directe n’est possible qu’au sein du package lui-même.

Si la déclaration de type privé comporte une partie discriminante, la totalité
La déclaration doit comprendre une partie discriminante conforme (voir 6.3.1 pour
les règles de conformité) et sa définition de type doit être un type d'enregistrement
définition. A l’inverse, si la déclaration de type privée ne comprend pas de
partie discriminante, le type déclaré par la déclaration de type complète (la
type) ne doit pas être un type sans contrainte avec des discriminants. Le type complet
ne doit pas être un type de tableau sans contrainte. Un type limité (en particulier un
type de tâche) n'est autorisé pour le type complet que si le mot réservé est limité
apparaît dans la déclaration de type privée (voir 7.4.4).

Dans la spécification du package qui déclare un type privé et
avant la fin de la déclaration de type complète correspondante, une restriction
s'applique à l'utilisation d'un nom qui désigne le type privé ou un sous-type de
le type privé et, de même, à l'utilisation d'un nom qui désigne n'importe quel type
ou sous-type qui a un sous-composant de type privé. Le seul autorisé
les occurrences d'un tel nom se trouvent dans une déclaration de constante différée, un type
ou une déclaration de sous-type, une spécification de sous-programme ou une entrée
déclaration; de plus, les occurrences dans les définitions de types dérivés ou
dans des expressions simples ne sont pas autorisés.

L'élaboration d'une déclaration de type privé crée un type privé. Si
la déclaration de type privé comporte une partie discriminante, cette élaboration 
inclut celui de la partie discriminante. L'élaboration du type complet
la déclaration consiste en l’élaboration de la définition du type ; le
la partie discriminante, le cas échéant, n'est pas élaborée (puisque la
la partie discriminante de la déclaration de type privé a déjà été
élaboré).

Remarques:

Il résulte des règles données que ni la déclaration d'une variable
de type privé, ni la création par un allocateur d'un objet du
Les types privés sont autorisés avant la déclaration complète du type.
De même avant la déclaration complète, le nom du type privé ne peut pas
être utilisé dans une instanciation générique ou dans une clause de représentation. 

Références : allocateur 4.8, type de tableau 3.6, conforme 6.3.1, élément déclaratif
3.9, déclaration constante différée 7.4.3, type dérivé 3.4, discriminant
partie 3.7.1, élaboration 3.9, déclaration d'entrée 9.5, expression 4.4, complète
déclaration de type 3.3.1, instanciation générique 12.3, identifiant 2.3,
déclaration de type incomplète 3.8.1, type limité 7.4.4, nom 4.1, opération
3.3, package 7, spécification de package 7.1, partie privée 7.2, type privé
7.4, déclaration de type privé 7.4, définition de type d'enregistrement 3.7,
clause de représentation 13.1, mot réservé 2.9, sous-composant 3.3, sous-programme
spécification 6.1, sous-type 3.3, déclaration de sous-type 3.3.2, type 3.3, type
déclaration 3.3.1, définition de type 3.3.1, type de tableau sans contrainte 3.6,
variable 3.2.1, partie visible 7.2 

7.4.2 Opérations de type privé 

Les opérations implicitement déclarées par une déclaration de type privé
inclure les opérations de base. Ce sont les opérations impliquées dans l'affectation
(sauf si le mot réservé limited apparaît dans la déclaration), adhésion
tests, composants sélectionnés pour la sélection de tout discriminant,
qualification et conversions explicites.                                             

Pour un type T privé, les opérations de base incluent également les attributs
T'BASE (voir 3.3.3) et T'SIZE (voir 13.7.2). Pour un objet A d'un particulier
type, les opérations de base incluent l'attribut A'CONSTRAINED si le
le type privé a des discriminants (voir 3.7.4), et dans tous les cas, les attributs
A'SIZE et A'ADDRESS (voir 13.7.2).

Enfin, les opérations implicitement déclarées par une déclaration de type privé
inclure la comparaison prédéfinie pour l’égalité et l’inégalité, sauf si
le mot réservé limité apparaît dans la déclaration de type privé.

Les opérations ci-dessus, ainsi que les sous-programmes qui ont un paramètre ou
résultat de type privé et qui sont déclarés dans la partie visible du
package, sont les seules opérations du package disponibles
en dehors du package pour le type privé.

Dans le package qui déclare le type privé, le paramètre supplémentaire
les opérations implicitement déclarées par la déclaration de type complète sont également
disponible. Cependant, la redéfinition de ceux-ci, implicitement déclarés
les opérations sont autorisées au sein de la même région déclarative, y compris entre
la déclaration de type privé et la déclaration complète correspondante. Un
Le sous-programme explicitement déclaré cache une opération implicitement déclarée qui
a le même profil de paramètre et de type de résultat (cela n'est possible que si
l'opération implicitement déclarée est un sous-programme dérivé ou un prédéfini
opérateur).

Si un type composite possède des sous-composants de type privé et est déclaré
en dehors du package qui déclare le type privé, alors les opérations
qui sont implicitement déclarés par la déclaration du type composite
inclure toutes les opérations qui dépendent uniquement des caractéristiques qui en résultent
à partir de la seule déclaration de type privée. (Par exemple l'opérateur < est
non inclus pour un type de tableau unidimensionnel.)

Si le type composite est lui-même déclaré dans le package qui déclare
le type privé (y compris au sein d'un package interne ou d'un package générique),
puis des opérations complémentaires qui dépendent des caractéristiques du plein
type sont implicitement déclarés, comme l'exigent les règles applicables aux
type composite (par exemple l'opérateur < est déclaré pour un
type tableau unidimensionnel si le type complet est discret). Ces supplémentaires
les opérations sont implicitement déclarées au plus tôt dans la période
portée immédiate du type composite et après la déclaration de type complète.

Les mêmes règles s'appliquent aux opérations implicitement déclarées pour un
type d'accès dont le type désigné est un type privé ou un type déclaré par
une déclaration de type incomplète.

Pour chaque type ou sous-type privé T, l'attribut suivant est défini :

T'CONSTRAINED Renvoie la valeur FALSE si T désigne un
             type privé non formel avec discriminants ; donne également le
             valeur FALSE si T désigne un type privé formel générique, et
             le sous-type réel associé est soit un type sans contrainte
             avec des discriminants ou un type de tableau sans contrainte ; rendements
             la valeur VRAI sinon. La valeur de cet attribut est de
             le type prédéfini BOOLEAN.  

Note:

Une déclaration de type privée et la déclaration de type complète correspondante
définir deux vues différentes d'un seul et même type. En dehors du
définissant le package, les caractéristiques du type sont celles définies par le
partie visible. Au sein de ces unités de programme extérieures, le type n'est qu'un
type privé et toute règle de langage qui s'applique uniquement à une autre classe de
les types ne s’appliquent pas. Le fait que la déclaration complète puisse mettre en œuvre
le type privé avec un type d'une classe particulière (par exemple, en tant que
type de tableau) n’est pertinent que dans le package lui-même.                                              

Les conséquences de cette mise en œuvre effective sont cependant valables
partout. Par exemple : toute initialisation par défaut des composants prend
lieu; l'attribut SIZE fournit la taille du type complet ; tâche
les règles de dépendance s'appliquent toujours aux composants qui sont des objets de tâche.

Exemple:

   le package KEY_MANAGER est
      le type KEY est privé ;
      NULL_KEY : CLÉ constante ;
      procédure GET_KEY(K : out KEY);
      la fonction "<" (X, Y : KEY) renvoie BOOLEAN ;
   privé
      le type KEY est nouveau NATUREL ;
      NULL_KEY : CLÉ constante := 0;
   fin;

   le corps du package KEY_MANAGER est
      LAST_KEY : CLÉ := 0;
      la procédure GET_KEY(K : out KEY) est
      commencer
         LAST_KEY := LAST_KEY + 1 ;
         K := LAST_KEY ;
      terminer GET_KEY ;

      fonction "<" (X, Y : KEY) return BOOLEAN est
      commencer
         retourner INTEGER(X) < INTEGER(Y);
      fin "<" ;
   terminer KEY_MANAGER ;

Notes sur l'exemple :

En dehors du package KEY_MANAGER, les opérations disponibles pour les objets de
type KEY inclut l'affectation, la comparaison de l'égalité ou de l'inégalité, le
la procédure GET_KEY et l'opérateur "<" ; ils n'incluent pas d'autres
des opérateurs relationnels tels que ">=" ou des opérateurs arithmétiques.

L'opérateur "<" explicitement déclaré masque l'opérateur prédéfini "<"
implicitement déclaré par la déclaration de type complète. Dans le corps du
fonction, une conversion explicite de X et Y en type INTEGER est
Il est nécessaire d'invoquer l'opérateur "<" de ce type. Alternativement, le
Le résultat de la fonction pourrait s'écrire non (X >= Y), puisque l'opérateur
">=" n'est pas redéfini.

La valeur de la variable LAST_KEY, déclarée dans le corps du package, reste
inchangé entre les appels de la procédure GET_KEY. (Voir aussi les Notes de
paragraphe 7.3.)

Références : affectation 5.2, attribut 4.1.4, opération de base 3.3.3,
composant 3.3, type composite 3.3, conversion 4.6, déclaration 3.1,
région déclarative 8.1, sous-programme dérivé 3.4, type dérivé 3.4, dimension
3.6, discriminant 3.3, égalité 4.5.2, type complet 7.4.1, type complet 
déclaration 3.3.1, masquage 8.3, portée immédiate 8.2, déclaration implicite
3.1, déclaration de type incomplète 3.8.1, test d'appartenance 4.5, opération 3.3,
package 7, paramètre d'un sous-programme 6.2, fonction prédéfinie 8.6,
opérateur prédéfini 4.5, type privé 7.4, déclaration de type privé 7.4,
unité de programme 6, qualification 4.7, opérateur relationnel 4.5, sélectionné
composant 4.1.3, sous-programme 6, dépendance de tâche 9.4, partie visible 7.2                                                  

7.4.3 Constantes différées 

Si une déclaration de constante différée est donnée dans la partie visible d'un
package puis une déclaration de constante (c'est-à-dire une déclaration d'objet  
déclarant un objet constant, avec une initialisation explicite) avec le même
l'identifiant doit apparaître comme une rubrique déclarative de la partie privée du
emballer. Cette déclaration d'objet est appelée déclaration complète du
constante différée. La marque de type indiquée dans la déclaration complète doit
être conforme à celle donnée dans la déclaration de constante différée (voir 6.3.1).
Des déclarations multiples ou uniques sont autorisées pour le différé et le plein
déclarations, à condition que les déclarations uniques équivalentes soient conformes.

Dans la spécification du package qui déclare une constante différée
et avant la fin de la déclaration complète correspondante, l'utilisation d'un nom
qui désigne la constante différée n'est autorisé que dans la valeur par défaut
expression pour un composant d'enregistrement ou pour un paramètre formel (pas pour un
paramètre formel générique).

L'élaboration d'une déclaration constante différée n'a pas d'autre effet.

L'exécution d'un programme est erronée s'il tente d'utiliser la valeur de
une constante différée avant l’élaboration du full correspondant
déclaration.

Note:

La déclaration complète pour une constante différée qui a un type privé donné
ne doit pas apparaître avant la déclaration de type complète correspondante. C'est un
conséquence des règles définissant les usages autorisés d'un nom qui désigne un
type privé (voir 7.4.1). 

Références : conforme 6.3.1, déclaration constante 3.2.1, élément déclaratif
3.9, expression par défaut d'un discriminant 3.7.1, constante différée 7.4,
déclaration constante différée 7.4, l'élaboration n'a aucun autre effet 3.1,
paramètre formel 6.1, paramètre formel générique 12.1 12.3, identifiant 2.3,
déclaration d'objet 3.2.1, package 7, spécification de package 7.1, privé
partie 7.2, composant d'enregistrement 3.7, marque de type 3.3.2, partie visible 7.2   

7.4.4 Types limités 

Un type limité est un type pour lequel ni l'affectation ni les paramètres prédéfinis 
la comparaison de l’égalité et de l’inégalité est implicitement déclarée.

Une déclaration de type privé qui inclut le mot réservé limited déclare
un type limité. Un type de tâche est un type limité. Un type dérivé d'un
le type limité est lui-même un type limité. Enfin, un type composite est
limité si le type de l’un de ses sous-composants est limité.   

Les opérations disponibles pour un type privé limité sont celles indiquées dans
article 7.4.2 pour les types privés sauf absence d'affectation et de
une comparaison prédéfinie pour l’égalité et l’inégalité.

Pour un paramètre formel dont le type est limité et dont la déclaration a lieu
dans une déclaration explicite de sous-programme, le mode out n'est autorisé que si cela
le type est privé et la déclaration du sous-programme se produit dans le visible
partie du package qui déclare le type privé. Il en va de même pour
paramètres formels des déclarations d'entrée et de la procédure générique
déclarations. Le type complet correspondant ne doit pas être limité si le mode
out est utilisé pour tout paramètre formel de ce type. Sinon, le correspondant
le type complet est autorisé (mais pas obligatoire) à être un type limité (en
en particulier, il est autorisé qu'il s'agisse d'un type de tâche). Si le type complet
correspondant à un type privé limité n'est pas lui-même limité, alors
l'affectation du type est disponible dans le package, mais pas à l'extérieur.                                         

Voici les conséquences des règles pour les types limités :

 - Une initialisation explicite n'est pas autorisée dans une déclaration d'objet si
    le type de l'objet est limité.   

 - Une expression par défaut n'est pas autorisée dans une déclaration de composant si le
    Le type de composant d'enregistrement est limité.

 - Une valeur initiale explicite n'est pas autorisée dans un allocateur si le
    le type désigné est limité.

 - Un paramètre formel générique de mode in ne doit pas être de type limité.

Remarques:

Les règles ci-dessus n'excluent pas une expression par défaut pour un paramètre formel
d'un type limité; ils n'excluent pas une constante différée d'une durée limitée
tapez si le type complet n’est pas limité. Une déclaration explicite d'un
L'opérateur d'égalité est autorisé pour un type limité (voir 6.7).

Les agrégats ne sont pas disponibles pour un type composite limité (voir 3.6.2 et
3.7.4). La caténation n'est pas disponible pour un type de réseau limité (voir 3.6.2).

Exemple:

   le package I_O_PACKAGE est
      le type FILE_NAME est limité en privé ;

      procédure OPEN (F : in out FILE_NAME);
      procédure CLOSE(F : entrée hors FILE_NAME);
      procédure READ (F : dans FILE_NAME; ITEM : out INTEGER);
      procédure WRITE(F : dans FILE_NAME; ITEM : dans INTEGER);
   privé
      tapez FILE_NAME est
         enregistrer
            INTERNAL_NAME : ENTIER := 0;
         terminer l'enregistrement ;
   terminer I_O_PACKAGE ;

   le corps du package I_O_PACKAGE est
      LIMITE : constante := 200;
      tapez FILE_DESCRIPTOR est un enregistrement... fin de l'enregistrement ;
      DIRECTORY : tableau (1 .. LIMIT) de FILE_DESCRIPTOR;
      ...
      la procédure OPEN (F : in out FILE_NAME) est ... fin ;
      la procédure CLOSE(F : in out FILE_NAME) est ... fin ;
      la procédure READ (F : dans FILE_NAME ; ITEM : out INTEGER) est ... fin ;
      procédure WRITE(F : dans FILE_NAME; ITEM : dans INTEGER) est ... fin ;
   commencer
      ...
   terminer I_O_PACKAGE ;

Notes sur l'exemple :   

Dans l'exemple ci-dessus, un sous-programme extérieur utilisant I_O_PACKAGE peut  
obtenez un nom de fichier en appelant OPEN et utilisez-le plus tard dans les appels à READ et
ÉCRIRE. Ainsi, en dehors du package, un nom de fichier obtenu depuis OPEN fait office de
type de mot de passe ; ses propriétés internes (telles que contenir un nombre
valeur) ne sont pas connues et aucune autre opération (telle que l'addition ou
comparaison des noms internes) peut être effectuée sur un nom de fichier.                                                  

Cet exemple est caractéristique de tout cas où un contrôle total sur le
des opérations d’un type sont souhaitées. De tels packages ont un double objectif. Ils
empêcher un utilisateur d’utiliser la structure interne du type. Ils
implémente également la notion de type de données encapsulé où le seul
les opérations sur le type sont celles données dans la spécification du package. 

Références : agrégat 4.3, allocateur 4.8, affectation 5.2, caténation
opérateur 4.5, déclaration de composant 3.7, type de composant 3.3, type composite
3.3, expression par défaut d'un discriminant 3.7, constante différée 7.4.3,
type dérivé 3.4, désigner 3.8, spécification discriminante 3.7.1, égalité
4.5.2, paramètre formel 6.1, type complet 7.4.1, déclaration de type complet 3.3.1,
paramètre formel générique 12.1 12.3, déclaration implicite 3.1, valeur initiale
3.2.1, mode 12.1.1, objet 3.2, opération 3.3, package 7, prédéfini
opérateur 4.5, type privé 7.4, déclaration de type privé 7.4, enregistrement
composant 3.7, type d'enregistrement 3.7, opérateur relationnel 4.5, sous-composant 3.3,
sous-programme 6, type de tâche 9.1 9.2, type 3.3  

7.5 Exemple de package de gestion de tables 

L'exemple suivant illustre l'utilisation de packages pour fournir des
procédures de niveau avec une interface simple pour l'utilisateur.

Le problème est de définir un package de gestion de tables pour l'insertion et
récupérer des éléments. Les éléments sont insérés dans le tableau tels quels
fourni. Chaque article inséré possède un numéro de commande. Les éléments sont récupérés
selon leur numéro de commande, où l'article avec la commande la plus basse
Le numéro est récupéré en premier.

Du point de vue de l'utilisateur, le package est assez simple. Il y a un
type appelé ITEM désignant des éléments de table, une procédure INSERT pour insérer
articles, et une procédure RETRIEVE pour obtenir l'article avec le plus faible
numéro de commande. Il existe un élément spécial NULL_ITEM qui est renvoyé lorsque le
la table est vide, et une exception TABLE_FULL qui est levée par INSERT si
la table est déjà pleine.

Un aperçu d’un tel package est donné ci-dessous. Seule la spécification du
Le package est exposé à l’utilisateur.

   le package TABLE_MANAGER est

      tapez ARTICLE est
         enregistrer
            ORDER_NUM : ENTIER ;
            ITEM_CODE : ENTIER ;
            QUANTITÉ : ENTIER;
            ITEM_TYPE : PERSONNAGE ;
         terminer l'enregistrement ;

      NULL_ITEM : ITEM constant :=
         (ORDER_NUM | ITEM_CODE | QUANTITÉ => 0, ITEM_TYPE => ' ');  

      procédure INSERT (NEW_ITEM : dans ITEM);
      procédure RETRIEVE(FIRST_ITEM : out ITEM);

      TABLE_FULL : exception ; -- déclenché par INSERT lorsque la table est pleine
   fin;                                                                             

Les détails de la mise en œuvre de tels packages peuvent être assez complexes ; dans ce
Dans ce cas, ils impliquent un tableau lié dans les deux sens d’éléments internes. Un local 
la procédure de gestion interne EXCHANGE est utilisée pour déplacer un élément interne entre
les listes occupées et libres. Les liens initiaux entre les tables sont établis par
la partie initialisation. Le corps du package n'a pas besoin d'être montré aux utilisateurs
du colis.

   le corps du package TABLE_MANAGER est
      TAILLE : constante := 2000;
      le sous-type INDEX est une plage INTEGER 0 .. SIZE ;

      tapez INTERNAL_ITEM est
         enregistrer
            CONTENU : ARTICLE ;
            SUCC : INDEX;
            PRED : INDEX;
         terminer l'enregistrement ;

      TABLE : tableau (INDEX) de INTERNAL_ITEM ;
      FIRST_BUSY_ITEM : INDEX := 0;
      FIRST_FREE_ITEM : INDEX := 1;

      fonction FREE_LIST_EMPTY return BOOLEAN est ... fin ;
      fonction BUSY_LIST_EMPTY return BOOLEAN est ... fin ;
      la procédure EXCHANGE (FROM : dans INDEX; TO : dans INDEX) est ... fin ;

      la procédure INSERT (NEW_ITEM : dans ITEM) est
      commencer
         si FREE_LIST_EMPTY alors
            augmenter TABLE_FULL ;
         fin si;
         -- code restant pour INSÉRER
      fin INSÉRER ;

      la procédure RETRIEVE (FIRST_ITEM : out ITEM) est ... fin ;

   commencer
      -- initialisation des liens entre les tables
   terminer TABLE_MANAGER ;  

7.6 Exemple de package de gestion de texte 

Cet exemple illustre un simple package de gestion de texte. Les utilisateurs uniquement
avoir accès à la partie visible ; l'implémentation leur est cachée dans
la partie intime et le corps du colis (non représentés).

Du point de vue de l'utilisateur, un TEXTE est une chaîne de longueur variable. Chaque texte
l'objet a une longueur maximale, qui doit être donnée lorsque l'objet est
déclaré, et une valeur actuelle, qui est une chaîne d'une certaine longueur entre
zéro et le maximum. La longueur maximale possible d'un objet texte est de
constante définie par l'implémentation.  

Le package définit d'abord les types nécessaires, puis les fonctions qui renvoient
quelques caractéristiques des objets du type, puis les fonctions de conversion
entre les textes et les types CHARACTER et STRING prédéfinis, et enfin
certaines des opérations standard sur différentes chaînes. La plupart des opérations sont
surchargé sur les chaînes et caractères ainsi que sur le type TEXTE, afin
pour minimiser le nombre de conversions explicites que l'utilisateur doit écrire.                                                  

   le package TEXT_HANDLER est
      MAXIMUM : constante := SOME_VALUE; -- défini par l'implémentation
      le sous-type INDEX est la plage INTEGER 0 .. MAXIMUM ;

      le type TEXT(MAXIMUM_LENGTH : INDEX) est limité en privé ;

      fonction LONGUEUR (T : TEXTE) renvoie INDEX ;
      fonction VALEUR (T : TEXTE) return STRING ;
      fonction VIDE (T : TEXTE) return BOOLEAN ;

      fonction TO_TEXT (S : STRING; MAX : INDEX) renvoie TEXTE ;
                                                    -- longueur maximale MAX
      fonction TO_TEXT (C : CHARACTER; MAX : INDEX) renvoie TEXTE ;
      la fonction TO_TEXT (S : STRING) renvoie TEXTE ;
                                               -- longueur maximale S'LENGTH
      la fonction TO_TEXT (C : CHARACTER) renvoie TEXTE ;

      fonction "&" (GAUCHE : TEXTE ; DROITE : TEXTE) renvoie TEXTE ;
      fonction "&" (GAUCHE : TEXTE ; DROITE : CHAÎNE) renvoie TEXTE ;
      fonction "&" (GAUCHE : CHAÎNE ; DROITE : TEXTE) renvoie TEXTE ;
      fonction "&" (GAUCHE : TEXTE ; DROITE : CARACTÈRE) renvoie TEXTE ;
      fonction "&" (GAUCHE : CARACTÈRE ; DROITE : TEXTE) renvoie TEXTE ;

      fonction "=" (GAUCHE : TEXTE ; DROITE : TEXTE) return BOOLEAN ;
      fonction "<" (GAUCHE : TEXTE ; DROITE : TEXTE) return BOOLEAN ;
      fonction "<=" (GAUCHE : TEXTE ; DROITE : TEXTE) return BOOLEAN ;
      fonction ">" (GAUCHE : TEXTE ; DROITE : TEXTE) return BOOLEAN ;
      fonction ">=" (GAUCHE : TEXTE ; DROITE : TEXTE) return BOOLEAN ;

      procédure SET (OBJET : en sortie TEXTE ; VALEUR : en TEXTE) ;
      procédure SET (OBJET : entrée TEXTE ; VALEUR : entrée CHAÎNE) ;
      procédure SET (OBJET : en sortie TEXTE ; VALEUR : en CARACTÈRE) ;

      procédure APPEND (TAIL : dans TEXTE; TO : dans hors TEXTE);
      procédure APPEND (TAIL : dans STRING; TO : dans out TEXT);
      procédure APPEND (QUEUE : en CARACTÈRE; TO : en sortie TEXTE);

 procédure MODIFIER (OBJET : en sortie TEXTE ; PAR : en TEXTE ; POSITION : en INDEX) ;
 procédure AMEND (OBJECT : in out TEXT; BY : in STRING; POSITION : in INDEX);
 procédure MODIFIER (OBJET : en sortie TEXTE; PAR : en CARACTÈRE; POSITION :
                                                                   dans l'INDEX);

-- amend remplace une partie de l'objet par le texte, la chaîne ou le caractère donné
-- en commençant à la position donnée dans l'objet

      fonction LOCATE (FRAGMENT : TEXTE ; DANS : TEXTE) return INDEX ;
      fonction LOCATE (FRAGMENT : STRING; Within : TEXT) return INDEX;
      fonction LOCATE (FRAGMENT : CARACTÈRE ; DANS : TEXTE) return INDEX ;

      -- tous renvoient 0 si le fragment n'est pas localisé

   privé
      tapez TEXTE(MAXIMUM_LENGTH : INDEX) est
         enregistrer
            POS : INDICE := 0;
            VALEUR : STRING(1 .. MAXIMUM_LENGTH);
         terminer l'enregistrement ;
   terminer TEXT_HANDLER ;                                                               

Exemple d'utilisation du package de gestion de texte :

Un programme ouvre un fichier de sortie dont le nom est fourni par la chaîne NAME.
Cette chaîne a la forme

   [APPAREIL :] [NOM DU FICHIER [.EXTENSION]]

Il existe des valeurs par défaut standard pour le périphérique, le nom de fichier et l'extension. Le
Le nom fourni par l'utilisateur est transmis à EXPAND_FILE_NAME en tant que paramètre, et le
le résultat est la version étendue, avec toutes les valeurs par défaut nécessaires ajoutées.   

   fonction EXPAND_FILE_NAME (NOM : STRING) renvoie STRING est
      utilisez TEXT_HANDLER ;

      DEFAULT_DEVICE : constante STRING := "SY:";
      DEFAULT_FILE_NAME : constante STRING := "RESULTS";
      DEFAULT_EXTENSION : constante STRING := ".DAT";

      MAXIMUM_FILE_NAME_LENGTH : constante INDEX := SOME_APPROPRIATE_VALUE;
      FILE_NAME : TEXTE(MAXIMUM_FILE_NAME_LENGTH);

   commencer

      SET(FILE_NAME, NOM);

      si VIDE(FILE_NAME) alors
         SET(FILE_NAME, DEFAULT_FILE_NAME);
      fin si;

      si LOCATE(':', FILE_NAME) = 0 alors
         SET(FILE_NAME, DEFAULT_DEVICE & FILE_NAME);
      fin si;

      si LOCATE('.', FILE_NAME) = 0 alors
         APPEND(DEFAULT_EXTENSION, TO => FILE_NAME);
      fin si;

      renvoyer VALEUR(FILE_NAME);

   terminer EXPAND_FILE_NAME ;                

