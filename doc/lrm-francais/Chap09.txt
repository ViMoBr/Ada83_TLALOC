
                                9. Tâches  

L'exécution d'un programme qui ne contient pas de tâche est définie en termes
d'une exécution séquentielle de ses actions, selon les règles décrites
dans d'autres chapitres de ce manuel. Ces actions peuvent être considérées comme
exécuté par un seul processeur logique.

Les tâches sont des entités dont les exécutions se déroulent en parallèle dans les étapes suivantes
sens. Chaque tâche peut être considérée comme exécutée par un processeur logique
de sa propre. Différentes tâches (différents processeurs logiques) se déroulent
indépendamment, sauf aux points où ils se synchronisent.

Certaines tâches ont des entrées. Une entrée d'une tâche peut être appelée par d'autres tâches.
Une tâche accepte un appel d'une de ses entrées en exécutant un accept
déclaration pour l’entrée. La synchronisation est réalisée par rendez-vous entre
une tâche émettant un appel d'entrée et une tâche acceptant l'appel. Quelques entrées
avoir des paramètres ; les appels d'entrée et les déclarations d'acceptation pour ces entrées sont
le principal moyen de communication des valeurs entre les tâches.

Les propriétés de chaque tâche sont définies par une unité de tâche correspondante qui
se compose d’une spécification de tâche et d’un corps de tâche. Les unités de tâches sont l'une des
les quatre formes d'unité de programme dont les programmes peuvent être composés. Le
d'autres formes sont des sous-programmes, des packages et des unités génériques. Les propriétés de
les unités de tâches, les tâches et les entrées, ainsi que les instructions qui affectent le
interaction entre les tâches (c'est-à-dire les instructions d'appel d'entrée, d'acceptation
(instructions, instructions delay, instructions select et instructions abort) sont
décrit dans ce chapitre.

Note:

Des tâches parallèles (processeurs logiques parallèles) peuvent être implémentées sur
multi-ordinateurs, multiprocesseurs ou à exécution entrelacée sur un seul
processeur physique. En revanche, chaque fois qu'une implémentation peut
détecter que le même effet peut être garanti si certaines parties des actions d'un
une tâche donnée est exécutée par différents processeurs physiques agissant dans
parallèlement, elle peut choisir de les exécuter de cette manière ; dans ce cas,
plusieurs processeurs physiques implémentent un seul processeur logique.

Références : instruction abort 9.10, instruction accept 9.5, instruction delay
9.6, entrée 9.5, instruction d'appel d'entrée 9.5, unité générique 12, paquet 7,
paramètre dans un appel d'entrée 9.5, unité de programme 6, rendez-vous 9.5, sélectionnez
instruction 9.7, sous-programme 6, corps de tâche 9.1, spécification de tâche 9.1   

9.1 Spécifications des tâches et organes de tâches  

Une unité de tâche se compose d'une spécification de tâche et d'un corps de tâche. Une tâche
spécification qui commence par les mots réservés type de tâche déclare un
type de tâche. La valeur d'un objet d'un type de tâche désigne une tâche ayant
les entrées, le cas échéant, déclarées dans la spécification de la tâche ; ces
les entrées sont également appelées entrées de cet objet. L'exécution de la tâche
est défini par le corps de mission correspondant.                                                  

Une spécification de tâche sans le type de mot réservé définit une seule tâche.
Une déclaration de tâche avec cette forme de spécification équivaut à la
déclaration d'un type de tâche anonyme immédiatement suivie du
déclaration d'un objet de type tâche, et l'identifiant de l'unité de tâche
nomme l'objet. Dans la suite de ce chapitre, des explications sont données
en termes de déclarations de types de tâches ; les explications correspondantes pour
les déclarations de tâches uniques découlent de l’équivalence déclarée.

   déclaration_de-tâche ::= spécification_de-tâche ;

   spécification_de-tâche ::=
      l'identifiant de la tâche [type] [est
         {entry_declaration}
         {clause_représentation}
      fin [task_simple_name]]

   task_body ::=
       le corps de la tâche task_simple_name est
          [partie déclarative]
       commencer
           séquence_of_statements
      [exception
           exception_handler
          {exception_handler}]
       fin [task_simple_name] ;

Le nom simple au début d'un corps de tâche doit répéter l'unité de tâche
identifiant. De même si un simple nom apparaît à la fin de la tâche
spécification ou corps, il doit répéter l’identifiant de l’unité de tâche. Dans un
corps de tâche, le nom de l'unité de tâche correspondante peut également être utilisé pour
faire référence à l'objet tâche qui désigne la tâche en cours d'exécution.
corps; de plus, l'utilisation de ce nom comme marque de type n'est pas autorisée
au sein de l'unité de travail elle-même.

Pour l'élaboration d'un cahier des charges, des déclarations d'entrée et
les clauses de représentation, le cas échéant, sont élaborées dans l’ordre indiqué. Tel
les clauses de représentation ne s'appliquent qu'aux entrées déclarées dans la tâche
spécification (voir 13.5).

L'élaboration d'un groupe de travail n'a d'autre effet que d'établir que
le corps peut désormais être utilisé pour l'exécution de tâches désignées par
objets du type de tâche correspondant.

L'exécution d'un corps de tâche est invoquée par l'activation d'un objet de tâche
du type correspondant (voir 9.3). Les gestionnaires d'exceptions facultatifs sur
la fin d'un corps de tâche gère les exceptions levées lors de l'exécution de la
séquence d'instructions du corps de tâche (voir 11.4).

Exemples de spécifications de types de tâches :

   le type de tâche RESSOURCE est
      entrée SAISIR;
      entrée LIBÉRATION ;
   fin RESSOURCE ; 

   le type de tâche KEYBOARD_DRIVER est
      entrée READ (C : sortie CARACTÈRE);
      entrée WRITE(C : dans CARACTÈRE);
   terminer KEYBOARD_DRIVER ;                                                    

Exemples de spécifications de tâches uniques :

   la tâche PRODUCER_CONSUMER est
      entrée READ (V : sortie ITEM);
      entrée WRITE(E : dans ITEM);
   fin;

   la tâche CONTROLLER est
      entrée REQUEST(LEVEL)(D : ITEM); -- une famille d'entrées
   fin du CONTRÔLEUR ;

   tâche UTILISATEUR ; -- n'a aucune entrée

Exemple de spécification de tâche et corps correspondant :

   la tâche PROTECTED_ARRAY est
      -- INDEX et ITEM sont des types globaux
      entrée READ (N : dans INDEX; V : sortie ITEM);
      entrée WRITE(N : dans INDEX; E : dans ITEM);
   fin;

   le corps de la tâche PROTECTED_ARRAY est
      TABLE : tableau(INDEX) de ITEM := (INDEX => NULL_ITEM);
   commencer
      boucle
         sélectionner
            accepter READ (N : dans INDEX; V : out ITEM) faire
               V := TABLE(N);
            fin de LIRE ;
         ou
            accepter WRITE(N : dans INDEX; E : dans ITEM) faire
               TABLEAU(N) := E;
            fin ÉCRIRE ;
         fin de la sélection ;
      terminer la boucle ;
   fin PROTECTED_ARRAY ;

Note:

Une spécification de tâche spécifie l'interface des tâches du type de tâche avec
d'autres tâches du même type ou de types différents, ainsi qu'avec les tâches principales
programme.

Références : déclaration 3.1, partie déclarative 3.9, élaboration 3.9, entrée
9.5, déclaration d'entrée 9.5, gestionnaire d'exceptions 11.2, identifiant 2.3, principal
programme 10.1, objet 3.2, déclaration d'objet 3.2.1, clause de représentation
13.1, mot réservé 2.9, séquence d'instructions 5.1, nom simple 4.1, type
3.3, déclaration de type 3.3.1    

9.2 Types de tâches et objets de tâches  

Un type de tâche est un type limité (voir 7.4.4). Donc ni affectation ni
les comparaisons prédéfinies pour l'égalité et l'inégalité sont définies pour
objets de types de tâches ; de plus, le mode out n'est pas autorisé pour un événement formel
paramètre dont le type est un type de tâche.                                                    

Un objet tâche est un objet dont le type est un type de tâche. La valeur d'une tâche
objet désigne une tâche qui possède les entrées de la tâche correspondante
type, et dont l’exécution est spécifiée par le corps de tâche correspondant. Si
un objet tâche est l'objet, ou un sous-composant de l'objet, déclaré par
une déclaration d'objet, alors la valeur de l'objet tâche est définie par le
élaboration de la déclaration d'objet. Si un objet de tâche est l'objet, ou
un sous-composant de l'objet, créé par l'évaluation d'un allocateur,
alors la valeur de l'objet tâche est définie par l'évaluation du
répartiteur. Pour tous les modes paramètres, si un paramètre réel désigne un
tâche, le paramètre formel associé désigne la même tâche ; le même
est valable pour un sous-composant d'un paramètre réel et le correspondant
sous-composant du paramètre formel associé ; enfin c'est pareil
pour les paramètres génériques.

Exemples:

   CONTRÔLE : RESSOURCE ;
   TÉLÉTYPE : CLAVIER_DRIVER ;
   POOL : tableau (1 .. 10) de KEYBOARD_DRIVER ;
   -- voir aussi des exemples de déclarations de tâches uniques en 9.1

Exemple de type d'accès désignant des objets tâche :

   tapez KEYBOARD pour accéder à KEYBOARD_DRIVER ;   
   TERMINAL : CLAVIER := nouveau KEYBOARD_DRIVER ;

Remarques:

Puisqu’un type de tâche est un type limité, il peut apparaître comme la définition d’un
type privé limité dans une partie privée, et comme paramètre réel générique
associé à un paramètre formel dont le type est un type limité. Sur le
en revanche, le type d'un paramètre formel générique de mode in ne doit pas être un
type limité et ne peut donc pas être un type de tâche.

Les objets tâche se comportent comme des constantes (un objet tâche désigne toujours le même
tâche) puisque leurs valeurs sont implicitement définies soit lors de la déclaration, soit
allocation, soit par une association de paramètres, et comme aucune affectation n'est
disponible. Cependant, le mot réservé constante n'est pas autorisé dans le
déclaration d'un objet de tâche car cela nécessiterait une déclaration explicite
initialisation. Un objet tâche qui est un paramètre formel du mode in est un
constante (comme tout paramètre formel de ce mode).

Si une application doit stocker et échanger des identités de tâches, elle peut le faire
en définissant un type d'accès désignant les objets tâches correspondants et
en utilisant des valeurs d'accès à des fins d'identification (voir exemple ci-dessus).
L'affectation est disponible pour un type d'accès comme pour tout type d'accès.

Les déclarations de sous-types sont autorisées pour les types de tâches comme pour les autres types, mais
il n'y a aucune contrainte applicable aux types de tâches.

Références : type d'accès 3.8, paramètre réel 6.4.1, allocateur 4.8,
affectation 5.2, déclaration de composant 3.7, type composite 3.3, constante
3.2.1, déclaration constante 3.2.1, contrainte 3.3, désigner 3.8 9.1, 
élaboration 3.9, entrée 9.5, opérateur d'égalité 4.5.2, paramètre formel 6.2,
paramètre formel mode 6.2, paramètre réel générique 12.3, générique
association 12.3, paramètre formel générique 12.1, paramètre formel générique 
mode 12.1.1, unité générique 12, opérateur d'inégalité 4.5.2, initialisation
3.2.1, type limité 7.4.4, objet 3.2, déclaration d'objet 3.2.1, paramètre
association 6.4, partie privée 7.2, type privé 7.4, mot réservé 2.9,
sous-composant 3.3, sous-programme 6, déclaration de sous-type 3.3.2, corps de tâche 9.1,
tapez 3.3                                                                              

9.3 Exécution des tâches - Activation des tâches 

Un corps de tâche définit l'exécution de toute tâche désignée par une tâche
objet du type de tâche correspondant. La première partie de cette exécution
s'appelle l'activation de l'objet tâche, et aussi celle du
tâche désignée ; il consiste en l'élaboration de la partie déclarative,
le cas échéant, de l'organisme chargé de la tâche. L'exécution de différentes tâches, notamment
leur activation se déroule en parallèle.

Si une déclaration d'objet qui déclare un objet de tâche se produit immédiatement
au sein d'une partie déclarative, alors l'activation de l'objet tâche commence
après l'élaboration de la partie déclarative (c'est-à-dire après avoir passé le
le mot réservé commence après la partie déclarative) ; de même si un tel
la déclaration se produit immédiatement dans une spécification de package, le
l’activation commence après l’élaboration de la partie déclarative du
corps du paquet. Il en va de même pour l'activation d'un objet tâche qui est un
sous-composant d'un objet déclaré immédiatement dans une partie déclarative ou
spécification du paquet. La première déclaration suivant la partie déclarative
n'est exécuté qu'après la conclusion de l'activation de ces objets de tâche.

Si une exception devait être soulevée par l'activation de l'une de ces tâches, cela
la tâche devient une tâche terminée (voir 9.4) ; les autres tâches ne sont pas directement
affecté. Si l'une de ces tâches devait ainsi être achevée au cours de son
activation, l'exception TASKING_ERROR est levée à la fin de la
activation de toutes ces tâches (avec succès ou non) ; le
l'exception est levée à un endroit qui se trouve immédiatement avant le premier
déclaration suivant la partie déclarative (immédiatement après la partie réservée
mot commence). Si plusieurs de ces tâches devaient ainsi être accomplies au cours
leur activation, l'exception TASKING_ERROR n'est levée qu'une seule fois.

Si une exception devait être soulevée par l'élaboration d'une partie déclarative ou
spécification du package, puis toute tâche créée (directement ou
indirectement) par cette élaboration et qui n'est pas encore activé devient
terminé et n'est donc jamais activé (voir section 9.4 pour le
définition d'une tâche terminée).

Pour les règles ci-dessus, dans tout corps de package sans instructions, une valeur null
la déclaration est supposée. Pour tout package sans corps de package, un implicite
le corps du package contenant une seule instruction nulle est supposé. Si un colis
sans corps de package est déclaré immédiatement dans une unité de programme ou
instruction block, le corps implicite du package apparaît à la fin de l'instruction
partie déclarative de l'unité de programme ou de l'instruction de bloc ; s'il y a
plusieurs de ces packages, l'ordre des corps de package implicites est
indéfini.

Un objet de tâche qui est l'objet, ou un sous-composant de l'objet, créé
par l’évaluation d’un allocateur est activé par cette évaluation. Le
l'activation démarre après toute initialisation de l'objet créé par le
répartiteur ; si plusieurs sous-composants sont des objets de tâche, ils sont activés
en parallèle. La valeur d'accès désignant un tel objet est renvoyée par
l'allocateur seulement après la conclusion de ces activations.

Si une exception devait être soulevée par l'activation de l'une de ces tâches, cela
la tâche devient une tâche accomplie ; les autres tâches ne sont pas directement affectées. 
Si l'une de ces tâches se réalise ainsi lors de son activation, le
l'exception TASKING_ERROR est déclenchée à la fin de l'activation de tous
de ces tâches (qu’elles soient réussies ou non) ; l'exception est levée à
l'endroit où l'allocateur est évalué. Si plusieurs de ces tâches
deviennent ainsi complétés lors de leur activation, l'exception TASKING_ERROR
n'est soulevé qu'une seule fois.

Si une exception est levée par l'initialisation de l'objet créé
par un allocateur (donc avant le début de toute activation), toute tâche
désigné par un sous-composant de cet objet devient terminé et est
donc jamais activé.                                                       

Exemple:

   la procédure P est
      A, B : RESSOURCE ; -- élaborer les objets de tâche A, B
      C : RESSOURCE ; -- élaborer l'objet tâche C
   commencer
      -- les tâches A, B, C sont activées en parallèle avant la première instruction
      ...
   fin;

Remarques:

Une entrée d'une tâche peut être appelée avant que la tâche ne soit activée. Si
plusieurs tâches sont activées en parallèle, l'exécution de l'une d'entre elles
les tâches n'ont pas besoin d'attendre la fin de l'activation des autres tâches. Une tâche
peut être complété lors de son activation soit en raison d'une exception
ou parce qu'il est interrompu (voir 9.10).

Références : allocateur 4.8, tâche terminée 9.4, partie déclarative 3.9,
élaboration 3.9, entrée 9.5, exception 11, gestion d'une exception 11.4,
corps du package 7.1, exécution parallèle 9, instruction 5, sous-composant 3.3, tâche 
corps 9.1, objet de tâche 9.2, fin de tâche 9.4, type de tâche 9.1,
exception tasking_error 11.1   

9.4 Dépendance des tâches - Fin des tâches 

Chaque tâche dépend d'au moins un maître. Un maître est une construction qui est
soit une tâche, une instruction de bloc ou un sous-programme en cours d'exécution, ou un
package de bibliothèque (un package déclaré dans une autre unité de programme n’est pas un
maître). La dépendance à l'égard d'un maître est une dépendance directe dans le
deux cas suivants :

(a) La tâche désignée par un objet de tâche qui est l'objet, ou un
    sous-composant de l'objet, créé par l'évaluation d'un allocateur
    dépend du maître qui élabore le type d'accès correspondant
    définition.

(b) La tâche désignée par tout autre objet de tâche dépend du maître
    dont l'exécution crée l'objet tâche.

De plus, si une tâche dépend d'un maître donné, c'est une instruction de bloc
exécuté par un autre maître, alors la tâche dépend aussi de cet autre
maître, de manière indirecte ; il en va de même si le maître donné est un
sous-programme appelé par un autre maître, et si le maître donné est une tâche qui
dépend (directement ou indirectement) d'un autre maître. Des dépendances existent pour
objets de type privé dont la déclaration complète est en termes de tâche
taper.

On dit qu’une tâche a terminé son exécution lorsqu’elle a terminé
exécution de la séquence d'instructions qui apparaît après le réservé 
le mot commence dans le corps correspondant. De même un bloc ou un sous-programme
est dit avoir terminé son exécution lorsqu'il a terminé l'exécution
de la séquence d’instructions correspondante. Pour une instruction de bloc, le
l'exécution est également dite terminée lorsqu'elle atteint une sortie, un retour ou
instruction goto transférant le contrôle hors du bloc. Pour une procédure, le
l'exécution est également dite terminée lorsqu'un retour correspondant
la déclaration est atteinte. Pour une fonction, l’exécution est aussi dite
complété après l'évaluation du résultat expression d'un retour
déclaration. Enfin, l'exécution d'une tâche, d'une instruction de bloc ou d'un sous-programme
est terminé si une exception est levée par l'exécution de sa séquence de
instructions et il n'y a pas de gestionnaire correspondant, ou, s'il y en a un, quand
il a terminé l'exécution du gestionnaire correspondant.                                            

Si une tâche n'a pas de tâche dépendante, sa fin a lieu lorsqu'elle a
a achevé son exécution. Une fois terminée, une tâche est dite
terminé. Si une tâche a des tâches dépendantes, sa terminaison a lieu
lorsque l'exécution de la tâche est terminée et que toutes les tâches dépendantes sont
terminé. Une instruction de bloc ou un corps de sous-programme dont l'exécution est
terminé n'est pas abandonné tant que toutes ses tâches dépendantes ne sont pas terminées.

Par ailleurs, la fin d'une tâche a lieu si et seulement si son exécution
a atteint une alternative de terminaison ouverte dans une instruction select (voir
9.7.1), et les conditions suivantes sont remplies :

 - La tâche dépend d'un maître dont l'exécution est terminée (d'où
    pas un package de bibliothèque).

 - Chaque tâche qui dépend du maître considéré est soit déjà
    terminé ou de la même manière en attente d'une alternative de terminaison ouverte d'un
    instruction de sélection.

Lorsque les deux conditions sont remplies, la tâche considérée devient terminée,
ainsi que toutes les tâches qui dépendent du maître considéré.

Exemple:

   déclarer
      le type GLOBAL est l'accès à la RESSOURCE ; -- voir 9.1
      A, B : RESSOURCE ;
      G : GLOBAL ;
   commencer
      -- activation de A et B
      déclarer
         le type LOCAL est l'accès à la RESSOURCE ;
         X : GLOBAL := nouvelle RESSOURCE ; -- activation de X.all
         L : LOCAL := nouvelle RESSOURCE ; -- activation de L.all
         C : RESSOURCE ;
      commencer
         -- activation de C
         G :=X; -- G et X désignent tous deux le même objet tâche
         ...
      fin; -- attendre la fin de C et L.all (mais pas X.all)
      ...
   fin; -- attendre la fin de A, B et G.all

Remarques:

Les règles données pour la résiliation impliquent que toutes les tâches qui dépendent (directement
ou indirectement) sur un maître donné et qui ne sont pas déjà terminés, peuvent
être résiliés (collectivement) si et seulement si chacun d'eux attend un
alternative open terminate d'une instruction select et l'exécution de la
le maître donné est terminé.

Les règles habituelles s'appliquent au programme principal. En conséquence, la résiliation de
le programme principal attend la fin de toute tâche dépendante même si le
le type de tâche correspondant est déclaré dans un package de bibliothèque. De l'autre
D'autre part, la fin du programme principal n'attend pas la fin des tâches 
qui dépendent des packages de bibliothèques ; le langage ne définit pas si un tel
les tâches doivent être terminées.

Pour un type d'accès dérivé d'un autre type d'accès, le
la définition du type d'accès est celle du type parent ; la dépendance est sur
le maître qui élabore la définition ultime du type d’accès parent.                                                  

Une déclaration de changement de nom définit un nouveau nom pour une entité existante et donc
ne crée aucune dépendance supplémentaire.

Références : type d'accès 3.8, allocateur 4.8, instruction de bloc 5.6,
déclaration 3.1, désignation 3.8 9.1, exception 11, gestionnaire d'exceptions 11.2,
instruction exit 5.7, fonction 6.5, instruction goto 5.9, unité de bibliothèque 10.1,
programme principal 10.1, objet 3.2, alternative ouverte 9.7.1, package 7, programme
unité 6, déclaration de renommage 8.5, instruction return 5.8, attente sélective
9.7.1, séquence d'énoncés 5.1, énoncé 5, sous-composant 3.3,
corps de sous-programme 6.3, appel de sous-programme 6.4, corps de tâche 9.1, objet de tâche 9.2,
mettre fin à l'alternative 9.7.1   

9.5 Entrées, appels d'entrée et déclarations d'acceptation 

Les appels d'entrée et les instructions d'acceptation sont les principaux moyens de synchronisation
des tâches et de la communication des valeurs entre les tâches. Une déclaration d'entrée
est similaire à une déclaration de sous-programme et n'est autorisé que dans une tâche
spécification. Les actions à effectuer lors de l'appel d'une entrée sont
spécifié par les instructions d'acceptation correspondantes.

   déclaration_entrée ::=
      identifiant d'entrée [(discrete_range)] [formal_part] ;

   Entry_call_statement ::= Entry_name [actual_parameter_part] ;

   accept_statement ::=
      accepter Entry_simple_name [(entry_index)] [formal_part] [do
         séquence_of_statements
      fin [entry_simple_name]] ;
   index_entrée ::= expression

Une déclaration d'entrée qui inclut une plage discrète (voir 3.6.1) déclare un
famille d'entrées distinctes ayant la même partie formelle (le cas échéant) ; c'est,
une de ces entrées pour chaque valeur de la plage discrète. Le terme entrée unique
est utilisé dans la définition de toute règle qui s'applique à toute entrée autre que
celui d'une famille. La tâche désignée par un objet d'un type de tâche a (ou
possède) les entrées déclarées dans la spécification du type de tâche. 

Dans le corps d'une tâche, chacune de ses entrées ou familles d'entrées peut
être nommé par le nom simple correspondant. Le nom d'une entrée d'un
la famille prend la forme d'un composant indexé, le nom simple de la famille étant
suivi de l'index entre parenthèses; le type de cet index doit être le
identique à celui de la gamme discrète dans la famille d'entrée correspondante
déclaration. En dehors du corps d'une tâche, un nom d'entrée a la forme d'un
composant sélectionné, dont le préfixe désigne l'objet de tâche et dont
selector est le nom simple de l'une de ses entrées uniques ou familles d'entrées.

Une seule entrée surcharge un sous-programme, un littéral d'énumération ou un autre
entrée unique s’ils ont le même identifiant. La surcharge n'est pas définie 
pour les familles d'entrée. Une entrée unique ou une entrée d'une famille d'entrées peut être
renommé en tant que procédure comme expliqué dans la section 8.5.

Les modes paramètres définis pour les paramètres de la partie formelle d'une entrée
déclaration sont les mêmes que pour une déclaration de sous-programme et ont les mêmes
sens (voir 6.2). La syntaxe d'une instruction d'appel d'entrée est similaire à
celle d'une instruction d'appel de procédure, et les règles pour le paramètre
les associations sont les mêmes que pour les appels de sous-programmes (voir 6.4.1 et 6.4.2).                                                

Une instruction accept spécifie les actions à effectuer lors d'un appel d'un
entrée nommée (il peut s'agir d'une entrée d'une famille). La partie formelle d'une acceptation
déclaration doit être conforme à la partie formelle donnée dans la déclaration du
entrée unique ou famille d'entrées nommée par l'instruction accept (voir la section
6.3.1 pour les règles de conformité). Si un simple nom apparaît à la fin de
une déclaration d'acceptation, elle doit répéter celle donnée au début.

Une instruction d'acceptation pour une entrée d'une tâche donnée n'est autorisée que dans le
corps de travail correspondant ; exclusion dans le corps de toute unité de programme
c'est-à-dire lui-même, à l'intérieur du corps de tâche ; et excluant dans un autre
acceptez l'instruction pour la même entrée unique ou une entrée de la même
famille. (Une conséquence de cette règle est qu'une tâche peut exécuter accept
instructions uniquement pour ses propres entrées.) Un corps de tâche peut contenir plus de
une instruction d'acceptation pour la même entrée.

Pour l'élaboration d'une déclaration d'entrée, la plage discrète, le cas échéant, est
évaluée et la partie formelle, le cas échéant, est ensuite élaborée comme pour un
déclaration de sous-programme.

L'exécution d'une instruction d'acceptation commence par l'évaluation de l'entrée
index (dans le cas d'une entrée de famille). Exécution d'un appel d'entrée
l'instruction commence par l'évaluation du nom de l'entrée ; ceci est suivi
par toutes les évaluations requises pour les paramètres réels de la même manière que pour
un appel de sous-programme (voir 6.4). Exécution ultérieure d'une déclaration d'acceptation et
d'une instruction d'appel d'entrée correspondante sont synchronisées.

Si une entrée donnée est appelée par une seule tâche, il existe deux possibilités :

 - Si la tâche appelante émet une instruction d'appel d'entrée avant un
    l'instruction d'acceptation correspondante est atteinte par la tâche propriétaire du
    entrée, l’exécution de la tâche appelante est suspendue.

 - Si une tâche atteint une instruction accept avant tout appel de cette entrée,
    l'exécution de la tâche est suspendue jusqu'à ce qu'un tel appel soit reçu.

Lorsqu'une entrée a été appelée et qu'une instruction d'acceptation correspondante a été
atteint, la séquence d'instructions, le cas échéant, de l'instruction accept est
exécuté par la tâche appelée (tandis que la tâche appelante reste suspendue).  
Cette interaction s'appelle un rendez-vous. Par la suite, la tâche appelante et
les tâches propriétaires de l'entrée continuent leur exécution en parallèle.

Si plusieurs tâches appellent la même entrée avant une acceptation correspondante
la déclaration est atteinte, les appels sont mis en file d'attente ; il y a une file d'attente associée
à chaque entrée. Chaque exécution d'une instruction accept supprime un appel
de la file d'attente. Les appels sont traités par ordre d'arrivée.

Une tentative d'appel d'une entrée d'une tâche qui a terminé son exécution
déclenche l'exception TASKING_ERROR au moment de l'appel, dans le
tâche; de même, cette exception est déclenchée au moment de l'appel si le
la tâche appelée termine son exécution avant d'accepter l'appel (voir aussi
9.10 pour le cas où la tâche appelée devient anormale). L'éxéption
CONSTRAINT_ERROR est levée si l'index d'une entrée d'une famille n'est pas
dans la plage discrète spécifiée.  

Exemples de déclarations d'entrée :

   entrée READ(V : out ITEM);
   entrée SAISIR;
   entrée REQUEST(LEVEL)(D : ITEM); -- une famille d'entrées

Exemples d'appels d'entrée :

   LIBÉRATION.DE CONTRÔLE ; -- voir 9.2 et 9.1
   PRODUCER_CONSUMER.WRITE(E); -- voir 9.1
   PISCINE (5). READ (NEXT_CHAR); -- voir 9.2 et 9.1
   CONTROLLER.REQUEST(LOW)(SOME_ITEM); -- voir 9.1                                            

Exemples d'instructions d'acceptation :

   acceptez SAISIR ;

   accepter READ(V : out ITEM) faire
      V := LOCAL_ITEM ;
   fin de LIRE ;

   accepter REQUEST(LOW)(D : ITEM) faire
      ...
   terminer la DEMANDE ;

Remarques:   

La partie formelle donnée dans une déclaration d'acceptation n'est pas élaborée ; c'est seulement
utilisé pour identifier l’entrée correspondante.

Une instruction accept peut appeler des sous-programmes qui émettent des appels d'entrée. Un
L'instruction accept n'a pas besoin d'avoir une séquence d'instructions même si l'instruction
l'entrée correspondante a des paramètres. De même, il peut avoir une séquence de
instructions même si l'entrée correspondante n'a pas de paramètres. La séquence
des instructions d'une instruction accept peuvent inclure des instructions return. Une tâche
peut appeler ses propres entrées mais, bien sûr, il se retrouvera dans une impasse. La langue
permet des appels d'entrée conditionnels et temporisés (voir 9.7.2 et 9.7.3). Le
les règles de langage garantissent qu'une tâche ne peut se trouver que dans une seule file d'attente d'entrée à un moment donné
temps.

Si les limites de la plage discrète d'une famille d'entrées sont entières
littéraux, l'index (dans un nom d'entrée ou une instruction accept) doit être du type
type prédéfini INTEGER (voir 3.6.1).

Références : tâche anormale 9.10, paramètre réel partie 6.4, tâche terminée
9.4, appel d'entrée conditionnelle 9.7.2, règles de conformité 6.3.1,
exception constraint_error 11.1, désigner 9.1, plage discrète 3.6.1,
élaboration 3.1 3.9, énumération littérale 3.5.1, évaluation 4.5, expression
4.4, partie formelle 6.1, identifiant 2.3, composant indexé 4.1.1, type entier
3.5.4, nom 4.1, objet 3.2, surcharge 6.6 8.7, exécution parallèle 9,
préfixe 4.1, procédure 6, appel de procédure 6.4, déclaration de renommage 8.5,
instruction return 5.8, portée 8.2, composant sélectionné 4.1.3, sélecteur 4.1.3,
séquence d'instructions 5.1, expression simple 4.4, nom simple 4.1,
sous-programme 6, corps du sous-programme 6.3, déclaration du sous-programme 6.1, tâche 9, tâche
corps 9.1, spécification de tâche 9.1, exception tasking_error 11.1, entrée chronométrée
appeler le 9.7.3  

9.6 Déclarations de retard, durée et heure 

L'exécution d'une instruction delay évalue l'expression simple, et 
suspend la poursuite de l'exécution de la tâche qui exécute l'instruction de retard,
pendant au moins la durée spécifiée par la valeur résultante.

   delay_statement ::= délai simple_expression ;  

L'expression simple doit être du type prédéfini à virgule fixe DURATION ;
sa valeur est exprimée en secondes ; une instruction de retard avec une valeur négative
équivaut à une instruction delay avec une valeur nulle.

Toute implémentation de type DURATION doit permettre la représentation de
durées (à la fois positives et négatives) jusqu'à au moins 86 400 secondes (une
jour); la plus petite durée représentable, DURATION'SMALL ne doit pas être
supérieure à vingt millisecondes (dans la mesure du possible, une valeur non supérieure
(il convient de choisir une durée supérieure à cinquante microsecondes). Notez que DURATION'SMALL nécessite
ne correspond pas au cycle d'horloge de base, le nombre nommé SYSTEM.TICK (voir
13.7).                                                                              

La définition du type TIME est fournie dans la bibliothèque prédéfinie
forfait CALENDRIER. La fonction CLOCK renvoie la valeur actuelle de TIME à
l'heure à laquelle on l'appelle. Les fonctions ANNÉE, MOIS, JOUR et SECONDES renvoient
les valeurs correspondantes pour une valeur donnée de type TIME ; la procédure
SPLIT renvoie les quatre valeurs correspondantes. A l’inverse, la fonction
TIME_OF combine un numéro d'année, un numéro de mois, un numéro de jour et un
durée, en une valeur de type TIME. Les opérateurs "+" et "-" pour
l'addition et la soustraction de temps et de durées, et le relationnel
opérateurs pour les heures, ont le sens conventionnel.

L'exception TIME_ERROR est déclenchée par la fonction TIME_OF si le
les paramètres ne forment pas une date appropriée. Cette exception est également soulevée par le
opérateurs "+" et "-" si, pour les opérandes donnés, ces opérateurs ne peuvent pas
renvoie une date dont le numéro de l'année est compris dans la plage correspondante
sous-type, ou si l'opérateur "-" ne peut pas renvoyer un résultat compris dans la plage
du type DURÉE.

   Le package CALENDRIER est
      le type TIME est privé ;

      le sous-type YEAR_NUMBER est la plage INTEGER 1901 .. 2099 ;
      le sous-type MONTH_NUMBER est la plage INTEGER 1 .. 12 ;
      le sous-type DAY_NUMBER est la plage INTEGER 1 .. 31 ;
      le sous-type DAY_DURATION est la plage DURATION 0,0 .. 86_400,0 ;

      la fonction CLOCK renvoie TIME ;

      fonction ANNÉE (DATE : HEURE) renvoie ANNÉE_NUMÉRO ;
      fonction MOIS (DATE : HEURE) renvoie MOIS_NUMBER ;
      fonction DAY (DATE : TIME) renvoie DAY_NUMBER ;
      fonction SECONDS(DATE : TIME) renvoie DAY_DURATION ;

      procédure SPLIT (DATE : en TEMPS ;
                       ANNÉE : sur YEAR_NUMBER ;
                       MOIS : sortie MONTH_NUMBER ;
                       DAY : sortie DAY_NUMBER ;
                       SECONDS : hors DAY_DURATION );

      fonction TIME_OF(YEAR : YEAR_NUMBER;
                       MOIS : MOIS_NUMBER ;
                       JOUR : DAY_NUMBER ;
                       SECONDS : DAY_DURATION := 0.0) renvoie TIME ; 

      fonction "+" (GAUCHE : TEMPS ; DROITE : DURÉE) renvoie TEMPS ;
      fonction "+" (GAUCHE : DURÉE ; DROITE : TEMPS) renvoie TEMPS ;
      fonction "-" (GAUCHE : TEMPS ; DROITE : DURÉE) renvoie TEMPS ;
      fonction "-" (GAUCHE : TEMPS ; DROITE : TEMPS) renvoie DURÉE ;

      la fonction "<" (GAUCHE, DROITE : TEMPS) renvoie BOOLEAN ;
      la fonction "<=" (GAUCHE, DROITE : TEMPS) renvoie BOOLEAN ;
      fonction ">" (GAUCHE, DROITE : TEMPS) return BOOLEAN ;
      fonction ">=" (GAUCHE, DROITE : TEMPS) return BOOLEAN ;  

      TIME_ERROR : exception ; -- peut être déclenché par TIME_OF, "+" et "-"

   privé
      -- dépendant de la mise en œuvre
   fin;                                                                             

Exemples:

   retard 3.0 ; -- délai 3,0 secondes

   déclarer
      utilisez CALENDRIER ;
      -- INTERVAL est une constante globale de type DURATION
      NEXT_TIME : TEMPS := HORLOGE + INTERVALLE;
   commencer
      boucle
         retarder NEXT_TIME - CLOCK ;
         -- quelques actions
         NEXT_TIME := NEXT_TIME + INTERVAL ;
      terminer la boucle ;
   fin;

Remarques:

Le deuxième exemple provoque la répétition de la boucle toutes les secondes INTERVAL sur
moyenne. Cet intervalle entre deux itérations successives n'est que
approximatif. Toutefois, il n'y aura pas de dérive cumulée tant que le
la durée de chaque itération est (suffisamment) inférieure à INTERVAL. 

Références : opérateur d'addition 4.5, durée C, type à virgule fixe 3.5.9,
appel de fonction 6.4, unité de bibliothèque 10.1, opérateur 4.5, package 7, type privé
7.4, opérateur relationnel 4.5, expression simple 4.4, instruction 5, tâche 9,
tapez 3.3   

9.7 Sélectionner des déclarations 

Il existe trois formes d'instructions de sélection. Un formulaire fournit une sélection
attendez une ou plusieurs alternatives. Les deux autres fournissent des conditions et
appels d'entrée programmés.

   select_statement ::= sélective_wait
      | conditional_entry_call | timed_entry_call 

Références : attente sélective 9.7.1, appel d'entrée conditionnelle 9.7.2, temporisé
appel d'entrée 9.7.3   

9.7.1 Attentes sélectives 

Cette forme de l'instruction select permet une combinaison d'attente et
en sélectionnant parmi une ou plusieurs alternatives. La sélection peut dépendre
conditions associées à chaque alternative de l’attente sélective.                 

   attente_sélective ::=
       sélectionner
         sélectionner_alternative
      {ou
         sélectionnez_alternative}
      [autre
         séquence_de_statements]
       fin de la sélection ;

   select_alternative ::=
      [quand condition =>]
         sélective_wait_alternative

   selective_wait_alternative ::= accept_alternative
      | delay_alternative | terminer_alternative

   accept_alternative ::= accept_statement [sequence_of_statements]

   delay_alternative ::= delay_statement [sequence_of_statements]

   terminate_alternative ::= terminer;

Une attente sélective doit contenir au moins une alternative d'acceptation. En outre
une attente sélective peut contenir soit une alternative de fin (une seule), soit
une ou plusieurs alternatives de retard, ou une autre partie ; ces trois possibilités
s'excluent mutuellement.

Une alternative sélectionnée est dite ouverte si elle ne commence pas par quand et
une condition, ou si la condition est VRAIE. On dit qu'il est fermé
sinon.

Pour l'exécution d'une attente sélective, toutes les conditions spécifiées après quand
sont évalués dans un ordre qui n'est pas défini par le langage ; ouvrir
des alternatives sont ainsi déterminées. Pour une alternative à délai ouvert, le délai
l’expression est également évaluée. De même, pour une alternative ouverte et acceptée
pour une entrée d'une famille, l'indice d'entrée est également évalué. Sélection et
l'exécution d'une alternative ouverte, ou de la partie else, complète alors le
exécution de l'attente sélective ; les règles de cette sélection sont
décrit ci-dessous.

Les alternatives d’acceptation ouverte sont d’abord envisagées. Sélection d'un tel
l'alternative a lieu immédiatement si un rendez-vous correspondant est 
possible, c'est-à-dire s'il existe un appel d'entrée correspondant émis par un autre
tâche et attend d’être accepté. Si plusieurs alternatives peuvent ainsi être
sélectionné, l'un d'eux est sélectionné arbitrairement (c'est-à-dire que la langue ne
pas définir lequel). Lorsqu'une telle alternative est sélectionnée, le
l'instruction d'acceptation correspondante et les éventuelles instructions ultérieures sont
réalisé. Si aucun rendez-vous n'est immédiatement possible et qu'il n'y a pas d'autre
partie, la tâche attend qu'une alternative d'attente sélective ouverte puisse être
choisi.

La sélection des autres formes d'alternative ou d'une autre partie est effectuée
comme suit:   

 - Une alternative de délai ouvert sera sélectionnée si aucune alternative acceptée
    peut être sélectionné avant que le délai spécifié ne soit écoulé (immédiatement,
    pour un délai négatif ou nul en l'absence d'appels d'entrée en file d'attente) ;
    toutes les instructions ultérieures de l'alternative sont ensuite exécutées. Si
    plusieurs alternatives de retard peuvent ainsi être sélectionnées (c'est-à-dire si elles ont
    le même délai), l'un d'eux est choisi arbitrairement.

 - La partie else est sélectionnée et ses instructions sont exécutées si non acceptée
    alternative peut être immédiatement sélectionnée, en particulier si tous
    les alternatives sont fermées.

 - Une alternative à terminaison ouverte est sélectionnée si les conditions énoncées dans
    la section 9.4 sont satisfaites. C'est une conséquence d'autres règles qu'un
    L'alternative de fin ne peut pas être sélectionnée lorsqu'il y a une entrée en file d'attente
    appeler pour toute saisie de la tâche.                                                  

L'exception PROGRAM_ERROR est levée si toutes les alternatives sont fermées et
il n'y a pas d'autre partie.  

Exemples d'une instruction select :

   sélectionner
      acceptez DRIVER_AWAKE_SIGNAL ;
   ou
      délai 30,0*SECONDS ;
      STOP_THE_TRAIN ;
   fin de la sélection ;

Exemple de corps de tâche avec une instruction select :

   le corps de tâche RESOURCE est
      OCCUPÉ : BOOLÉEN := FAUX;
   commencer
      boucle
         sélectionner
            quand il n'est pas occupé =>
               accepter SEIZE faire
                  OCCUPÉ := VRAI ;
               fin;
         ou
            accepter RELEASE faire
               OCCUPÉ := FAUX ;
            fin;
         ou
            mettre fin;
         fin de la sélection ;
      terminer la boucle ;
   fin RESSOURCE ;

Remarques:

Une attente sélective est autorisée pour avoir plusieurs alternatives de délai ouvertes. UN
l'attente sélective est autorisée à avoir plusieurs alternatives d'acceptation ouvertes pour le
même entrée.

Références : accepter la déclaration 9.5, la condition 5.3, la déclaration 3.1, le délai
expression 9.6, instruction de délai 9.6, durée 9.6, entrée 9.5, appel d'entrée
9.5, index d'entrée 9.5, exception program_error 11.1, appel d'entrée en file d'attente 9.5,
rendez-vous 9.5, instruction select 9.7, séquence d'instructions 5.1, tâche 9   

9.7.2 Appels d'entrée conditionnelle 

Un appel d'entrée conditionnel émet un appel d'entrée qui est ensuite annulé si un
le rendez-vous n'est pas immédiatement possible.

   conditional_entry_call ::=
      sélectionner 
          entrée_call_statement
         [séquence_of_statements]
      autre
          séquence_of_statements
      fin de la sélection ;                                                                     

Pour l'exécution d'un appel d'entrée conditionnel, le nom de l'entrée est d'abord 
évalué. Ceci est suivi de toutes les évaluations requises pour la réalité
paramètres comme dans le cas d’un appel de sous-programme (voir 6.4).

L'appel d'entrée est annulé si l'exécution de la tâche appelée n'a pas
atteint un point où il est prêt à accepter l'appel (c'est-à-dire soit un
accept pour l'entrée correspondante, ou une instruction select avec un
ouvrir une alternative d'acceptation pour l'entrée), ou s'il y a une entrée préalable en file d'attente
appelle à cette entrée. Si la tâche appelée a atteint une instruction select,
l'appel d'entrée est annulé si aucune alternative d'acceptation pour cette entrée n'est disponible.
choisi.

Si l'appel d'entrée est annulé, les instructions de la partie else sont
réalisé. Sinon, le rendez-vous a lieu ; et l'optionnel
la séquence d'instructions après l'appel d'entrée est ensuite exécutée.

L'exécution d'un appel d'entrée conditionnelle lève l'exception
TASKING_ERROR si la tâche appelée a déjà terminé son exécution (voir
également 9.10 pour le cas où la tâche appelée devient anormale).

Exemple:

   la procédure SPIN(R : RESOURCE) est
   commencer
      boucle
         sélectionner
            R. SAISIR;
            retour;
         autre
            nul; -- occupé à attendre
         fin de la sélection ;
      terminer la boucle ;
   fin;

Références : tâche anormale 9.10, instruction d'acceptation 9.5, paramètre réel
partie 6.4, tâche terminée 9.4, déclaration d'appel d'entrée 9.5, famille d'entrée 9.5,
indice d'entrée 9.5, évaluation 4.5, expression 4.4, alternative ouverte 9.7.1,
appel d'entrée en file d'attente 9.5, rendez-vous 9.5, instruction select 9.7, séquence de
instructions 5.1, tâche 9, exception tasking_error 11.1   

9.7.3 Appels d'entrée programmés 

Un appel d'entrée programmé émet un appel d'entrée qui est annulé si un rendez-vous est
pas démarré dans un délai donné.

   timed_entry_call ::=
      sélectionner
          entrée_call_statement
         [séquence_of_statements]
      ou
          retard_alternative 
      fin de la sélection ;                                                                

Lors de l'exécution d'un appel d'entrée temporisé, le nom de l'entrée est d'abord évalué.
Ceci est suivi de toutes les évaluations requises pour les paramètres réels comme dans
le cas d'un appel de sous-programme (voir 6.4). L'expression indiquant le retard
est ensuite évalué et l'appel d'entrée est finalement émis.

Si un rendez-vous peut être démarré dans la durée spécifiée (ou
immédiatement, comme pour un appel d'entrée conditionnel, pour un indice négatif ou nul
retard), il est exécuté et la séquence facultative d'instructions après le
l'appel d'entrée est alors exécuté. Dans le cas contraire, l'appel d'entrée est annulé lorsque
la durée spécifiée a expiré et la séquence facultative d'instructions
de l'alternative de retard est exécutée.

L'exécution d'un appel d'entrée temporisé déclenche l'exception TASKING_ERROR si
la tâche appelée termine son exécution avant d'accepter l'appel (voir aussi
9.10 pour le cas où la tâche appelée devient anormale).

Exemple:

   sélectionner
      CONTROLLER.REQUEST(MEDIUM)(SOME_ITEM);
   ou
      retard 45,0 ;
      -- contrôleur trop occupé, essayez autre chose
   fin de la sélection ;

Références : tâche anormale 9.10, instruction d'acceptation 9.5, paramètre réel
partie 6.4, tâche terminée 9.4, appel d'entrée conditionnelle 9.7.2, délai
expression 9.6, instruction de délai 9.6, durée 9.6, instruction d'appel d'entrée
9.5, famille d'entrée 9.5, indice d'entrée 9.5, évaluation 4.5, expression 4.4,
rendez-vous 9.5, séquence d'instructions 5.1, tâche 9, exception tasking_error 11.1   

9.8 Priorités 

Chaque tâche peut (mais pas nécessairement) avoir une priorité, qui est une valeur du
sous-type PRIORITY (de type INTEGER) déclaré dans la bibliothèque prédéfinie
package SYSTEM (voir 13.7). Une valeur inférieure indique un degré inférieur de
urgence; l’éventail des priorités est défini en fonction de la mise en œuvre. Une priorité est
associé à une tâche si un pragma

   pragma PRIORITY (expression_statique);

apparaît dans le cahier des charges correspondant ; la priorité est donnée par
la valeur de l'expression. Une priorité est associée au principal
programme si un tel pragma apparaît dans sa partie déclarative la plus externe. À
la plupart de ces pragmas peuvent apparaître dans une spécification de tâche donnée ou pour un
sous-programme qui est une unité de bibliothèque, et ce sont les seuls emplacements autorisés
pour ce pragma. Un pragma PRIORITY n'a aucun effet s'il apparaît dans un
sous-programme autre que le programme principal.   

La spécification d'une priorité est une indication donnée pour aider le
mise en œuvre dans l'allocation des ressources de traitement à des tâches parallèles
lorsqu'il y a plus de tâches éligibles à l'exécution que ce qui peut être pris en charge
simultanément par les ressources de traitement disponibles. L'effet de
les priorités sur la planification sont définies par la règle suivante :

    Si deux tâches avec des priorités différentes sont toutes deux éligibles à l'exécution
    et pourrait raisonnablement être exécuté en utilisant les mêmes processeurs physiques et
    les mêmes autres ressources de traitement, il ne se peut alors pas que
    la tâche avec la priorité la plus faible est en cours d'exécution tandis que la tâche avec la
    une priorité plus élevée ne l’est pas.                                                      

Pour les tâches de même priorité, l'ordre de planification n'est pas défini par le
langue. Pour les tâches sans priorité explicite, les règles de planification sont
non défini, sauf lorsque ces tâches sont engagées dans un rendez-vous. Si la
les priorités des deux tâches engagées dans un rendez-vous sont définies, les
le rendez-vous est exécuté avec la plus élevée des deux priorités. Si seulement un
des deux priorités est définie, le rendez-vous est exécuté avec au moins
cette priorité. Si aucun des deux n'est défini, la priorité du rendez-vous est
indéfini.

Remarques:

La priorité d'une tâche est statique et donc fixe. Cependant, le
la priorité lors d'un rendez-vous n'est pas nécessairement statique puisqu'elle
dépend de la priorité de la tâche appelant l'entrée. Les priorités devraient
être utilisé uniquement pour indiquer des degrés d’urgence relatifs ; ils ne devraient pas l'être
utilisé pour la synchronisation des tâches.

Références : partie déclarative 3.9, instruction d'appel d'entrée 9.5, type entier
3.5.4, programme principal 10.1, système de packages 13.7, pragma 2.8, rendez-vous 9.5,
expression statique 4.9, sous-type 3.3, tâche 9, spécification de tâche 9.1   

9.9 Attributs de tâche et d'entrée 

Pour un objet de tâche ou une valeur T, les attributs suivants sont définis :

T'CALLABLE Renvoie la valeur FALSE lors de l'exécution de la tâche
             désigné par T est soit terminé, soit terminé, ou lorsque
             la tâche est anormale. Dans le cas contraire, renvoie la valeur TRUE. Le
             la valeur de cet attribut est du type prédéfini BOOLEAN.

T'TERMINATED Renvoie la valeur TRUE si la tâche désignée par T est
             terminé. Dans le cas contraire, renvoie la valeur FALSE. La valeur de
             cet attribut est du type prédéfini BOOLEAN.

De plus, les attributs de représentation STORAGE_SIZE, SIZE et ADDRESS
sont définis pour un objet de tâche T ou un type de tâche T (voir 13.7.2).  

L'attribut COUNT est défini pour une entrée E d'une unité de tâche T. L'entrée
peut être soit une entrée unique, soit une entrée d'une famille (dans les deux cas, la
le nom de l'entrée unique ou de la famille d'entrées peut être soit un simple, soit un
nom développé). Cet attribut n'est autorisé que dans le corps de T, mais
à l'exclusion de toute unité de programme qui est, elle-même, interne au corps de T.

E'COUNT Donne le nombre d'appels d'entrée actuellement en file d'attente sur le
             entrée E (si l'attribut est évalué par l'exécution d'un
             acceptez l'instruction pour l'entrée E, le décompte n'inclut pas
             la tâche appelante). La valeur de cet attribut est de
             tapez universal_integer.

Note:  

Les algorithmes interrogeant l'attribut E'COUNT doivent prendre des précautions pour
permettre l'augmentation de la valeur de cet attribut pour les entrées entrantes
appels, et sa diminution, par exemple avec des appels d'entrée programmés.

Références : tâche anormale 9.10, instruction d'acceptation 9.5, attribut 4.1.4,
type booléen 3.5.3, tâche terminée 9.4, désigner 9.1, entrée 9.5, faux
valeur booléenne 3.5.3, file d'attente des appels d'entrée 9.5, unité de stockage 13.7, tâche 9,
objet de tâche 9.2, type de tâche 9.1, tâche terminée 9.4, appel d'entrée programmé
9.7.3, vraie valeur booléenne 3.5.3, type universal_integer 3.5.4                                               

9.10 Déclarations d'abandon 

Une instruction d'abandon fait qu'une ou plusieurs tâches deviennent anormales, donc
empêchant tout nouveau rendez-vous avec de telles tâches.

   abort_statement ::= abandonner nom_tâche {, nom_tâche} ;

La détermination du type de chaque nom de tâche utilise le fait que le type
du nom est un type de tâche.

Pour l'exécution d'une instruction d'abandon, les noms de tâches donnés sont évalués
dans un ordre qui n'est pas défini par la langue. Chaque tâche nommée alors
devient anormal à moins qu'il ne soit déjà terminé ; de même, toute tâche qui
dépend d'une tâche nommée devient anormale à moins qu'elle ne soit déjà terminée.

Toute tâche anormale dont l'exécution est suspendue à une instruction accept, un
instruction select, ou une instruction de retard est terminée ; tout anormal
tâche dont l'exécution est suspendue lors d'un appel d'entrée, et qui n'est pas encore en cours
un rendez-vous correspondant, devient complété et est supprimé de l'entrée
file d'attente; toute tâche anormale n'ayant pas encore commencé son activation devient
terminé (et donc également terminé). Ceci termine l'exécution du
déclaration d'abandon.

L'achèvement de toute autre tâche anormale ne doit pas nécessairement avoir lieu avant l'achèvement
de l'instruction d'abandon. Cela doit se produire au plus tard lorsque l'anomalie
la tâche atteint un point de synchronisation qui est l'un des suivants : la fin
de son activation ; un point où il provoque l'activation d'une autre tâche ;
un appel d'entrée ; le début ou la fin d'une instruction accept ; une sélection
déclaration; une déclaration de retard ; un gestionnaire d'exceptions ; ou un abandon
déclaration. Si une tâche qui appelle une entrée devient anormale alors qu'elle est dans un
rendez-vous, sa terminaison n'intervient pas avant l'achèvement de
le rendez-vous (voir 11.5).

L'appel d'une entrée de tâche anormale lève l'exception TASKING_ERROR
sur le lieu de l'appel. De même, l'exception TASKING_ERROR est levée
pour toute tâche ayant appelé une entrée de tâche anormale, si l'entrée
l'appel est toujours en file d'attente ou si le rendez-vous n'est pas encore terminé (que le
l'appel d'entrée est une déclaration d'appel d'entrée, ou une entrée conditionnelle ou chronométrée
appel); l'exception est levée au plus tard à l'achèvement de la  
tâche anormale. La valeur de l'attribut CALLABLE est FALSE pour n'importe quelle tâche
qui est anormal (ou terminé).

Si l'achèvement anormal d'une tâche survient alors que la tâche met à jour un
variable, alors la valeur de cette variable est indéfinie. Exemple:

   abandonner USER, TERMINAL.all, POOL(3);

Remarques:

Une instruction d'abandon ne doit être utilisée que dans des situations extrêmement graves.
exigeant une résiliation sans condition. Une tâche est autorisée à abandonner n'importe quelle tâche,
y compris lui-même.   

Références : anormal au rendez-vous 11.5, acceptez la déclaration 9.5, activation
9.3, attribut 4.1.4, appelable (attribut prédéfini) 9.9, conditionnel
appel d'entrée 9.7.2, instruction de retard 9.6, tâche dépendante 9.4, appel d'entrée
instruction 9.5, évaluation d'un nom 4.1, gestionnaire d'exceptions 11.2, false
valeur booléenne 3.5.3, nom 4.1, file d'attente des appels d'entrée 9.5, rendez-vous 9.5,
instruction select 9.7, instruction 5, tâche 9, exception tasking_error 11.1,
tâche terminée 9.4, appel d'entrée programmé 9.7.3                                                 

9.11 Variables partagées 

Le moyen normal de communiquer des valeurs entre les tâches consiste à utiliser des appels d'entrée.
et accepter les déclarations.

Si deux tâches lisent ou mettent à jour une variable partagée (c'est-à-dire une variable
accessible par les deux), alors aucun d'eux ne peut présumer quoi que ce soit sur le
l'ordre dans lequel l'autre effectue ses opérations, sauf aux points
où ils se synchronisent. Deux tâches sont synchronisées au début et à la fin
fin de leur rendez-vous. Au début et à la fin de son activation, un
la tâche est synchronisée avec la tâche qui provoque cette activation. Une tâche
qui a terminé son exécution est synchronisée avec toute autre tâche.

Pour les actions effectuées par un programme utilisant des variables partagées, le
les hypothèses suivantes peuvent toujours être faites :

 - Si entre deux points de synchronisation d'une tâche, cette tâche lit un
    variable partagée dont le type est un type scalaire ou d'accès, alors le
    La variable n'est mise à jour par aucune autre tâche à aucun moment entre ces
    deux points.

 - Si entre deux points de synchronisation d'une tâche, cette tâche met à jour un
    variable partagée dont le type est un type scalaire ou d'accès, alors le
    la variable n'est ni lue ni mise à jour par aucune autre tâche à aucun moment
    entre ces deux points.

L'exécution du programme est erronée si l'une de ces hypothèses est
violé.

Si une tâche donnée lit la valeur d'une variable partagée, les hypothèses ci-dessus
permettre à une implémentation de conserver des copies locales de la valeur (par exemple,
dans des registres ou sous toute autre forme de stockage temporaire) ; et aussi longtemps
car la tâche donnée n'atteint pas de point de synchronisation ni ne met à jour le
valeur de la variable partagée, les hypothèses ci-dessus impliquent que, pour le
tâche donnée, lire une copie locale équivaut à lire la copie partagée
variable elle-même.

De même, si une tâche donnée met à jour la valeur d'une variable partagée, le
les hypothèses ci-dessus permettent à une implémentation de conserver une copie locale du
valeur, et de différer le stockage effectif de la copie locale dans le partage
variable jusqu'à un point de synchronisation, à condition que chaque lecture ou
la mise à jour de la variable par la tâche donnée est traitée comme une lecture ou une mise à jour de
la copie locale. En revanche, une implémentation n'est pas autorisée à
introduire un magasin, à moins que ce magasin soit également exécuté dans le
ordre canonique (voir 11.6).

Le pragma SHARED peut être utilisé pour spécifier que chaque lecture ou mise à jour d'un 
la variable est un point de synchronisation pour cette variable ; c'est-à-dire ce qui précède
les hypothèses sont toujours valables pour la variable donnée (mais pas nécessairement pour
autres variables). La forme de ce pragma est la suivante :

   pragma PARTAGÉ(variable_simple_name);   

Ce pragma n'est autorisé que pour une variable déclarée par un objet
déclaration et dont le type est un type scalaire ou d'accès ; la variable
la déclaration et le pragma doivent tous deux se produire (dans cet ordre) immédiatement
dans la même partie déclarative ou spécification de package ; le pragma doit
apparaître avant toute occurrence du nom de la variable, autrement que dans un
clause d’adresse.

Une implémentation doit restreindre les objets pour lesquels le pragma SHARED est
autorisé aux objets pour lesquels chacune des lectures directes et mises à jour directes est
mis en œuvre comme une opération indivisible.

Références : accept instruction 9.5, activation 9.3, affectation 5.2,
ordre canonique 11.6, partie déclarative 3.9, instruction d'appel d'entrée 9.5,
erroné 1.6, global 8.1, spécification de paquet 7.1, pragma 2.8, lire un
valeur 6.2, rendez-vous 9.5, nom simple 3.1 4.1, tâche 9, type 3.3, mettre à jour un
valeur 6.2, variable 3.2.1                                                         

9.12 Exemple de tâche 

L'exemple suivant définit une tâche de mise en mémoire tampon pour lisser les variations entre
la vitesse de sortie d'une tâche de production et la vitesse d'entrée de certaines
tâche consommatrice. Par exemple, la tâche de production peut contenir le
déclarations

   boucle
      -- produit le caractère suivant CHAR
      TAMPON.ÉCRITURE(CHAR);
      quitter quand CHAR = ASCII.EOT ;
   terminer la boucle ;  

et la tâche consommatrice peut contenir les instructions

   boucle
      TAMPON.LECTURE(CHAR);
      -- consommer le personnage CHAR
      quitter quand CHAR = ASCII.EOT ;
   terminer la boucle ;

La tâche de mise en mémoire tampon contient un pool interne de caractères traités dans un
mode round-robin. Le pool possède deux indices, un IN_INDEX désignant le
espace pour le caractère d'entrée suivant et un OUT_INDEX désignant l'espace pour
le caractère de sortie suivant.

   la tâche BUFFER est
      entrée READ (C : sortie CARACTÈRE);
      entrée WRITE(C : dans CARACTÈRE);
   fin;

   le corps de la tâche BUFFER est
      POOL_SIZE : constante INTEGER := 100;
      POOL : tableau(1 .. POOL_SIZE) de CHARACTER;
      COUNT : plage INTEGER 0 .. POOL_SIZE := 0;
      IN_INDEX, OUT_INDEX : plage INTEGER 1 .. POOL_SIZE := 1;
   commencer
      boucle
         sélectionner
            lorsque COUNT <POOL_SIZE =>
               accepter WRITE(C : in CHARACTER) faire
                  PISCINE(IN_INDEX) := C;
               fin;
               IN_INDEX := IN_INDEX mod POOL_SIZE + 1;
               COMPTE := COMPTE + 1 ;
         ou quand COUNT > 0 =>
               accepter READ(C : out CHARACTER) faire
                  C := PISCINE(OUT_INDEX);
               fin;
               OUT_INDEX := OUT_INDEX mod POOL_SIZE + 1 ;
               COMPTE := COMPTE - 1 ;
         ou
            mettre fin;
         fin de la sélection ; 
      terminer la boucle ;
   fin du TAMPON ;                                                      

