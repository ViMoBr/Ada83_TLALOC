 13 Clauses de repr√©sentation et fonctionnalit√©s d√©pendantes de l'impl√©mentation

Ce chapitre d√©crit les clauses de repr√©sentation, certaines mises en ≈ìuvre-
fonctionnalit√©s d√©pendantes et autres fonctionnalit√©s utilis√©es dans le syst√®me
la programmation.

13.1 Clauses de repr√©sentation

Les clauses de repr√©sentation pr√©cisent comment les types du langage doivent √™tre
mapp√© sur la machine sous-jacente. Ils peuvent √™tre fournis pour donner plus
repr√©sentation efficace ou pour s'interfacer avec des fonctionnalit√©s ext√©rieures
le domaine du langage (par exemple, le mat√©riel p√©riph√©rique).

       clause_de repr√©sentation ::=
             type_representation_clause | clause_adresse

       type_representation_clause ::= length_clause
             | clause_repr√©sentation_√©num√©ration
             |record_representation_clause

Une clause de repr√©sentation de type s'applique soit √† un type, soit √† un premier
sous-type nomm√© (c'est-√†-dire √† un sous-type d√©clar√© par une d√©claration de type,
le type de base √©tant donc anonyme). Une telle repr√©sentation
La clause s'applique √† tous les objets qui ont ce type ou ce premier nomm√©
sous-type. Au plus une clause d'√©num√©ration ou de repr√©sentation d'enregistrement est
autoris√© pour un type donn√© : une clause de repr√©sentation par √©num√©ration est uniquement
autoris√© pour un type d‚Äô√©num√©ration ; une clause de repr√©sentation record, uniquement
pour un type d'enregistrement. (D'un autre c√¥t√©, plus d'une clause de longueur
peut √™tre pr√©vu pour un type donn√© ; de plus, √† la fois une clause de longueur et
une clause d'√©num√©ration ou de repr√©sentation d'enregistrement peut √™tre fournie.)
La clause de longueur est la seule forme de clause de repr√©sentation autoris√©e pour un
type d√©riv√© d'un type parent qui a (d√©fini par l'utilisateur) d√©rivable
sous-programmes.

Une clause d'adresse s'applique soit √† un objet ; √† un sous-programme,
package ou unit√© de t√¢ches ; ou √† une entr√©e. Au plus une clause d'adresse est
autoris√© pour l‚Äôune de ces entit√©s.

Une clause de repr√©sentation et une d√©claration de l'entit√© √† laquelle le
la clause s'applique doivent toutes deux appara√Ætre imm√©diatement dans le m√™me d√©claratif
sp√©cification de pi√®ce, de package ou de t√¢che ; la d√©claration
doit intervenir avant la clause. En l'absence de repr√©sentation
clause pour une d√©claration donn√©e, une repr√©sentation par d√©faut de cette
La d√©claration est d√©termin√©e par la mise en ≈ìuvre. Un tel d√©faut
la d√©termination intervient au plus tard √† la fin de la p√©riode imm√©diatement
englobant une partie d√©clarative, une sp√©cification de package ou une t√¢che
sp√©cification. Pour une d√©claration donn√©e dans une partie d√©clarative, ceci
la d√©termination par d√©faut a lieu avant tout corps ferm√©.

Dans le cas d'un type, certaines occurrences de son nom impliquent que le
la repr√©sentation du type doit d√©j√† avoir √©t√© d√©termin√©e. 
Par cons√©quent, ces √©v√©nements forcent la d√©termination par d√©faut de tout
aspect de la repr√©sentation non d√©j√† d√©termin√© par un type ant√©rieur
clause de repr√©sentation. Cette d√©termination par d√©faut est √©galement forc√©e par
occurrences similaires du nom d'un sous-type du type, ou du
nom de tout type ou sous-type comportant des sous-composants du type. UN
une occurrence forc√©e est toute occurrence autre que dans un type ou un sous-type
d√©claration, une sp√©cification de sous-programme, une d√©claration d'entr√©e, un
d√©claration constante, un pragma ou une clause de repr√©sentation pour le type
lui-m√™me. Dans tous les cas, une occurrence au sein d‚Äôune expression est toujours for√ßante.


Une clause de repr√©sentation d'une entit√© donn√©e ne doit pas appara√Ætre apr√®s une
occurrence du nom de l'entit√© si cette occurrence force une
d√©termination par d√©faut de la repr√©sentation de l‚Äôentit√©.

Des restrictions similaires existent pour les clauses d'adresse. Pour un objet, n'importe quel
l'occurrence de son nom (apr√®s la d√©claration de l'objet) est un for√ßage
occurrence. Pour un sous-programme, un package, une unit√© de t√¢che ou une entr√©e, tout
l'occurrence d'un attribut de repr√©sentation d'une telle entit√© est une
forcer l'occurrence.

L‚Äôeffet de l‚Äô√©laboration d‚Äôune clause de repr√©sentation est de d√©finir
les aspects correspondants de la repr√©sentation.

L'interpr√©tation de certaines des expressions qui apparaissent dans
Les clauses de repr√©sentation d√©pendent de l'impl√©mentation, par exemple :
expressions sp√©cifiant des adresses. Une impl√©mentation peut limiter son
acceptation des clauses de repr√©sentation √† celles qui peuvent √™tre trait√©es
simplement par le mat√©riel sous-jacent. Si une clause de repr√©sentation est
accept√© par une impl√©mentation, le compilateur doit garantir que le
l'effet net du programme n'est pas modifi√© par la pr√©sence de la clause, sauf
pour les clauses d'adresse et pour les parties du programme qui interrogent
attributs de repr√©sentation. Si un programme contient une clause de repr√©sentation
cela n'est pas accept√©, le programme est ill√©gal. Pour chaque impl√©mentation,
les clauses de repr√©sentation autoris√©es et les conventions utilis√©es pour la mise en ≈ìuvre-
expressions d√©pendantes, doivent √™tre document√©es √† l‚ÄôAnnexe F du
Manuel de r√©f√©rence.

Alors qu'une clause de repr√©sentation est utilis√©e pour imposer certaines
caract√©ristiques de la cartographie d'une entit√© sur le sous-jacent
machine, les pragmas peuvent √™tre utilis√©s pour fournir une impl√©mentation, avec
crit√®res de s√©lection d‚Äôune telle cartographie. Le PACK pragma
pr√©cise que la minimisation du stockage doit √™tre le crit√®re principal lorsque
s√©lectionner la repr√©sentation d‚Äôun type d‚Äôenregistrement ou de tableau. Sa forme est
comme suit:

       pragma PACK (type_simple_name);

L'emballage signifie que les espaces entre les zones de stockage allou√©es √†
les composants cons√©cutifs doivent √™tre minimis√©s. Il n‚Äôest cependant pas n√©cessaire
affecter le mappage de chaque composant sur le stockage. Cette cartographie peut
√™tre lui-m√™me influenc√© par un pragma (ou contr√¥l√© par une repr√©sentation
clause) pour le composant ou le type de composant. La position d'un PACK
pragma, et les restrictions sur le type nomm√©, sont r√©gies par le
m√™mes r√®gles que pour une clause de repr√©sentation ; en particulier, le pragma
doit appara√Ætre avant toute utilisation d'un attribut de repr√©sentation du paquet
entit√©.

Le pragma PACK est le seul pragma de repr√©sentation d√©fi√© par le langage.
Des pragmas de repr√©sentation suppl√©mentaires peuvent √™tre fournis par un
mise en ≈ìuvre; ceux-ci doivent √™tre document√©s dans l'Annexe F. (contrairement
aux clauses de repr√©sentation, un pragma qui n‚Äôest pas accept√© par les
la mise en ≈ìuvre est ignor√©e).

Note:

Aucune clause de repr√©sentation n'est autoris√©e pour un type formel g√©n√©rique.

R√©f√©rences : clause d'adresse 13.5, autorisation 1.6, corps 3.9, composant 3.3,
d√©claration 3.1, partie d√©clarative 3.9, expression par d√©faut 3.2.1,
d√©claration de constante diff√©r√©e 7.4, sous-programme d√©rivable 3.4, d√©riv√©
type 3.4, entit√© 3.1, entr√©e 9.5, clause de repr√©sentation par √©num√©ration
13.3, expression 4.4, type formel g√©n√©rique 12.1.2, ill√©gal 1.6, longueur
clause 13.2, doit 1.6, nom 4.1, objet 3.2, appara√Ætre imm√©diatement dans
8.1, package 7, sp√©cification de package 7.1, type parent 3.4, pragma
2.8, clause de repr√©sentation d'enregistrement 13.4, attribut de repr√©sentation
13.7.2, 13.7.3, sous-composant 3.3, sous-programme 6, sous-type 3.3, sous-type
d√©claration 3.3.2, sp√©cification de t√¢che 9.1, unit√© de t√¢che 9, type 3.3, type
d√©claration 3.3.1


13.2 Clauses de dur√©e

Une clause de longueur sp√©cifie une quantit√© de stockage associ√©e √† un type.

length_clause ::= pour l'attribut, utilisez simple_expression ;

L'expression doit √™tre d'un type num√©rique et est √©valu√©e lors de la
√©laboration de la clause de longueur (sauf s'il s'agit d'une expression statique). Le
Le pr√©fixe de l'attribut doit d√©signer soit un type, soit un premier sous-type nomm√©. 
Le pr√©fixe est appel√© T dans ce qui suit. Le seul attribut autoris√©
les d√©signateurs dans une clause de longueur sont SIZE, STORAGE_SIZE et SMALL. L'effet
de la clause de longueur d√©pend du d√©signateur d'attribut :

(a) Sp√©cification de taille : T'SIZE

    L'expression doit √™tre une expression statique d'un type entier. Le
    la valeur de l'expression sp√©cifie une limite sup√©rieure pour le nombre de bits
    √† attribuer aux objets du type ou premier sous-type nomm√© T. Le
    les sp√©cifications de taille doivent pr√©voir suffisamment d'espace de stockage pour accueillir
    chaque valeur admissible de ces objets. Une sp√©cification de taille pour un
    le type composite peut affecter la taille des espaces entre les zones de stockage
    affect√©s √† des composants cons√©cutifs. D‚Äôun autre c√¥t√©, il n‚Äôest pas n√©cessaire
    affectent la taille de la zone de stockage allou√©e √† chaque composant.

    La sp√©cification de taille n'est autoris√©e que si les contraintes sur T et sur son
    les sous-composants (le cas √©ch√©ant) sont statiques. Dans le cas d'un sans contrainte
    type de tableau, les sous-types d‚Äôindex doivent √©galement √™tre statiques. 

(b) Sp√©cification de la taille de la collection : T'STORAGE_SIZE

    Le pr√©fixe T doit d√©signer un type d'acc√®s. L'expression doit √™tre de certains
    type entier (mais pas n√©cessairement statique) ; sa valeur pr√©cise le nombre de
    les unit√©s de stockage √† r√©server √† la collection, c'est-√†-dire les unit√©s de stockage
    espace n√©cessaire pour contenir tous les objets d√©sign√©s par les valeurs de l'acc√®s
    type et par les valeurs d'autres types d√©riv√©es du type d'acc√®s, directement
    ou indirectement. Cette forme de clause de longueur n'est pas autoris√©e pour un type
    d√©riv√© d‚Äôun type d‚Äôacc√®s.

(c) Sp√©cification du stockage pour l'activation d'une t√¢che : T'STORAGE_SIZE

    Le pr√©fixe T doit d√©signer un type de t√¢che. L'expression doit √™tre de certains
    type entier (mais pas n√©cessairement statique) ; sa valeur pr√©cise le nombre de
    unit√©s de stockage √† r√©server pour une activation (pas le code) d'une t√¢che
    du genre.

(d) Sp√©cification de small pour un type √† virgule fixe : T'SMALL

    Le pr√©fixe T doit d√©signer le premier sous-type nomm√© d'un type √† virgule fixe. 
    L'expression doit √™tre une expression statique d'un type r√©el ; Sa valeur
    doit √™tre sup√©rieur au delta du premier sous-type nomm√©. L'effet de
    la clause de longueur consiste √† utiliser cette valeur de small pour la repr√©sentation de
    valeurs de type base √† virgule fixe. (La clause de longueur ainsi √©galement
    affecte la quantit√© de stockage pour les objets de ce type).

Remarques:

Une sp√©cification de taille est autoris√©e pour un type d'acc√®s, de t√¢che ou de virgule fixe,
si une autre forme de clause de longueur est √©galement donn√©e pour le type. 

Ce qui est consid√©r√© comme faisant partie du stockage r√©serv√© √† une collection ou
car l‚Äôactivation d‚Äôune t√¢che d√©pend de l‚Äôimpl√©mentation. Le contr√¥le
offerte par les clauses de longueur est donc relative √† la mise en ≈ìuvre
conventions. Par exemple, le langage ne d√©finit pas si le stockage
r√©serv√© √† une activation d'une t√¢che inclut tout stockage n√©cessaire √† l'ex√©cution
collection associ√©e √† un type d‚Äôacc√®s d√©clar√© dans le corps de la t√¢che. 
Il ne d√©finit pas non plus la m√©thode d'allocation des objets d√©sign√©s par
valeurs d‚Äôun type d‚Äôacc√®s. Par exemple, l'espace allou√© pourrait √™tre sur un
empiler; alternativement, un sch√©ma d'aliocation dynamique g√©n√©ral ou un stockage fixe
peut √™tre utilis√©. 

Les objets allou√©s dans une collection ne doivent pas n√©cessairement avoir la m√™me taille si le
le type d√©sign√© est un type tableau sans contrainte ou un type sans contrainte avec
discriminants. Notez √©galement que l'allocateur lui-m√™me peut n√©cessiter un peu d'espace
pour les tables et liens internes. D'o√π une clause de longueur pour la collecte des
un type d'acc√®s ne donne pas toujours un contr√¥le pr√©cis sur le nombre maximum
des objets allou√©s.

Exemples:

     --d√©clarations suppos√©es :

     le type MEDIUM est la plage 0 .. 65000 ;
     le type SHORT est la plage delta 0,01 -100,0 .. 100,0 ;
     le type DEGREE est la plage delta 0,1 -360,0 .. 360,0 ;

     OCTET : constante := 8;
     PAGE : constante := 2000;

     --longueur des clauses :

     pour COLOR'SIZE, utilisez 1*BYTE ; -- voir 3.5.1
     pour MEDIUM'SIZE, utilisez 2*BYTE ;
     pour SHORT'SIZE, utilisez 15 ;

     pour l'utilisation de CAR_NAME'STORAGE_SIZE : environ 2 000 voitures
             2000*((CAR'SIZE/SYSTEM.STORAGE_UNIT) +1);

     pour KEYBOARD_DRIVERS'STORAGE_SIZE, utilisez 1*PAGE ;

pour DEGREE'SMALL, utilisez 360.0/2**(SYSTEM.STORAGE_UNIT -1);

Notes sur les exemples :

Dans la clause de longueur pour SHORT, quinze bits est le minimum n√©cessaire,
puisque la d√©finition de type n√©cessite SHORT'SMALL=2**(-7) et SHORT'MANTISSA =
14. La clause de longueur pour DEGREE force les num√©ros de mod√®le √† s'√©tendre exactement
la plage du type.

R√©f√©rences : type d'acc√®s 3.8, allocateur 4.8, autoriser 1.6, type de tableau 3.6,
attribut 4.1.4, collection 3.8, type composite 3.3, contrainte 3.3, delta
d'un type √† virgule fixe 3.5.9, type d√©riv√© 3.4, d√©signer 3.8, √©laboration
3.9, entit√© 3.1, √©valuation 4.5, expression 4.4, premier sous-type nomm√© 13.1,
type √† virgule fixe 3.5.9, sous-type d'index 3.6, type entier 3.5.4, doit 1.6,
type num√©rique 3.5, objet 3.2, type r√©el 3.5.6, type d'enregistrement 3.7, petit d'un
type √† virgule fixe 3.5.10, contrainte statique 4.9, expression statique 4.9,
sous-type statique 4.9, unit√© de stockage 13.7, sous-composant 3.3, package syst√®me
13.7, t√¢che 9, activation de t√¢che 9.3, sp√©cification de t√¢che 9.1, type de t√¢che 9.2,
type 3.3, tableau sans contrainte type 3.6          

13.3 Clauses de repr√©sentation en √©num√©ration

Une clause de repr√©sentation par √©num√©ration sp√©cifie les codes internes du
litt√©raux du type √©num√©ration nomm√© dans la clause.

     enumeration_representation_clause ::= pour l'utilisation de type_simple_name
              agr√©gat;

L'agr√©gat utilis√© pour sp√©cifier ce mappage est √©crit sous la forme d'un agr√©gat unidimensionnel.
agr√©gat, pour lequel le sous-type d'index est le type d'√©num√©ration et le
Le type de composant est universal_integer.

Tous les litt√©raux du type √©num√©ration doivent √™tre fournis avec un entier distinct
codes, et tous les choix et valeurs des composants donn√©s dans l'agr√©gat doivent √™tre
statique. Les codes entiers sp√©cifi√©s pour le type d'√©num√©ration doivent satisfaire
la relation d'ordre pr√©d√©finie du type.

Exemple:

     le type MIX_CODE est (ADD, SUB, MUL, LDA, STA, STZ) ;

     pour une utilisation MIX_CODE
        (ADD => 1, SUB =.2, MUL => 3, LDA => 8, STA => 24, STZ =>33) ;

Remarques:

Les attributs SUCC, PRED et POS sont d√©finis m√™me pour les types d'√©num√©ration
avec une repr√©sentation non contigu√´ ; leur d√©finition correspond √† la
d√©claration de type (logique) et n'est pas affect√© par l'√©num√©ration
clause de repr√©sentation. Dans l'exemple, en raison de la n√©cessit√© d'√©viter le
valeurs omises, ces fonctions sont susceptibles d'√™tre moins efficaces
mises en ≈ìuvre qu‚Äôelles ne pourraient l‚Äô√™tre en l‚Äôabsence d‚Äôune clause de repr√©sentation. 
Des consid√©rations similaires s‚Äôappliquent lorsque de tels types sont utilis√©s pour l‚Äôindexation.

R√©f√©rences : agr√©gat 4.3, agr√©gat de tableau 4.3.2, type de tableau 3.6, attribut
d'un type d'√©num√©ration 3.5.5, choix 3.7.3, composante 3.3, √©num√©ration
litt√©ral 3.5.1, type d'√©num√©ration 3.5.1, fonction 6.5, index 3.6, index
sous-type 3.6, litt√©ral 4.2, relation d'ordre d'un type d'√©num√©ration 3.5.1,
clause de repr√©sentation 13.1, nom simple 4.1, expression statique 4.9, type
3.3, d√©claration de type 3.3.1, type universal_integer 3.5.4

13.4 Clauses de repr√©sentation des dossiers

Une clause de repr√©sentation d'enregistrement sp√©cifie la repr√©sentation de stockage de
enregistrements, c'est-√†-dire l'ordre, la position et la taille des composants de l'enregistrement
(y compris les discriminants, le cas √©ch√©ant).

     record_representation_clause ::=
       pour type_simple_name, utilisez
         enregistrer [alignment_clause]
           {clause composant}
         terminer l'enregistrement ;

     alignement_clause ::= au mod static_simple_expression ;

     clause_composant ::=
       nom_composant dans la plage static_simple_expression static_range ;


L'expression simple donn√©e apr√®s les mots r√©serv√©s au mod dans un alignement
clause, ou apr√®s le mot r√©serv√© at dans une clause composante, doit √™tre un
expression statique d‚Äôun type entier. Si les limites de la port√©e d'un
clause de composant sont d√©finies par des expressions simples, puis chaque limite de la
La plage doit √™tre d√©finie par une expression statique d'un type entier, mais la
deux limites n'ont pas besoin d'avoir le m√™me type entier.

Une clause d'alignement force chaque enregistrement du type donn√© √† √™tre allou√© √†
une adresse de d√©part qui est un multiple de la valeur de l'expression donn√©e
(c'est-√†-dire que l'adresse modulo l'expression doit √™tre nulle). Un
la mise en ≈ìuvre peut imposer des restrictions sur les alignements autoris√©s.

Une clause de composant sp√©cifie l'emplacement de stockage d'un composant, par rapport √†
le d√©but du disque. L'entier d√©fini par l'expression statique d'un
La clause composant est une adresse relative exprim√©e en unit√©s de stockage. Le
range d√©finit les positions des bits de l'emplacement de stockage, par rapport au
unit√© de stockage. La premi√®re unit√© de stockage d'un enregistrement est num√©rot√©e z√©ro.
le premier bit d'une unit√© de stockage est num√©rot√© z√©ro. L'ordre des bits dans un
l'unit√© de stockage d√©pend de la machine et peut s'√©tendre aux unit√©s de stockage adjacentes
(Pour une machine sp√©cifique, la taille en bits d'une unit√© de stockage est donn√©e par le
num√©ro nomm√© SYSTEM.STORAGE_UNIT d√©pendant de la configuration.) Si un
Le composant est autoris√© √† chevaucher une limite de stockage, et si oui, comment, est-ce
d√©fini par l'impl√©mentation.

Au plus une clause de composant est autoris√©e pour chaque composant de l'enregistrement.
type, y compris pour chaque discriminant (des clauses composantes peuvent √™tre donn√©es pour
certains, tous ou aucun des composants). Si aucune clause de composant n'est donn√©e pour
un composant, alors le choix du lieu de stockage du composant est laiss√©
au compilateur. Si des clauses de composants sont donn√©es pour tous les composants, le
La clause de repr√©sentation d'enregistrement sp√©cifie compl√®tement la repr√©sentation du
type d'enregistrement et doit √™tre respect√© exactement par le compilateur.

Les emplacements de stockage au sein d'une variante d'enregistrement ne doivent pas se chevaucher, mais les
le stockage de variantes distinctes est autoris√©. Chaque clause composante doit permettre
pour suffisamment d'espace de stockage pour accueillir toutes les valeurs autoris√©es du
composant. Une clause de composant n'est autoris√©e que pour un composant, le cas √©ch√©ant.
la contrainte sur ce composant ou sur l‚Äôun de ses sous-composants est statique.

Une impl√©mentation peut g√©n√©rer des noms qui d√©signent des √©l√©ments d√©pendants de l'impl√©mentation.
composants (par exemple, un contenant le d√©calage d‚Äôun autre composant). 
De tels noms d√©pendants de l'impl√©mentation peuvent √™tre utilis√©s dans la repr√©sentation des enregistrements
clauses (ces noms ne doivent pas n√©cessairement √™tre des noms simples ; par exemple, ils pourraient √™tre
attributs d√©pendants de l'impl√©mentation).

Exemple:

     MOT : constante := 4; -- l'unit√© de stockage est un octet, 4 octets par mot

tapez STATE est (A, M, W, P);
le type MODE est (FIX, DEC, EXP, SIGNIF) ;

le type BYTE_MASK est un tableau (0.. 7) de BOOLEAN ;
le type STATE_MASK est un tableau (STATE) de BOOLEAN ;
le type MODE_MASK est un tableau (MODE) de BOOLEAN ;

tapez PROGRAM_STATUS_WORD est
 enregistrer
     SYSTEM_MASK : BYTE_MASK ;
     PROTECTION_KEY : plage INTEGER 0 .. 3 ;
     MACHINE_STATE : STATE_MASK ;
     INTERRUPT_CAUSE : INTERRUPTION_CODE;
     ILC : plage INTEGER 0 .. 3 ;
     CC : plage INTEGER 0 .. 3 ;
     PROGRAMME_MASK : MODE_MASK ;
     INST_ADDRESS : ADRESSE ;
terminer l'enregistrement ;


 pour l'utilisation de PROGRAM_STATUS_WORD
   enregistrer au mod 8 ;
       SYSTEM_MASK √† 0*WORD plage 0 .. 7 ; 
       PROTECTION_KEY √† 0*WORD plage 10 .. 11 ; -- bits 8,9 inutilis√©s
       MACHINE_STATE √† 0*WORD plage 12 .. 15 ;
       INTERRUPT_CAUSE √† 0*WORD plage 16 .. 31 ;
       ILC √† 1*WORD plage 0 .. 1 ; -- deuxi√®me mot
       CC √† 1*WORD plage 2 .. 3 ;
       PROGRAM_MASK √† 1*WORD plage 4 .. 7 ;
       INST_ADDRESS √† 1*WORD plage 8 .. 31 ;
   terminer l'enregistrement ;

 pour PROGRAM_STATUS_WORD'SIZE, utilisez 8*SYSTEM.STORAGE_UNIT ;

Remarque sur l'exemple :

La clause de repr√©sentation d'enregistrement d√©finit la pr√©sentation d'enregistrement. La dur√©e
Cette clause garantit qu‚Äôexactement huit unit√©s de stockage sont utilis√©es.

R√©f√©rences : autoriser 1.6, attribut 4.1.4, constante 3.2.1, contrainte 3.3,
discriminant 3.7.1, type entier 3.5.4, doit 1.6, nomm√© num√©ro 3.2, plage
3.5, composant d'enregistrement 3.7, type d'enregistrement 3.7, expression simple 4.4, simple
nom 4.1, contrainte statique 4.9, expression statique 4.9, unit√© de stockage 13.7,
sous-composant 3.3, package syst√®me 13.7, variante 3.7.3

13.5 Clauses d'adresse

Une clause d'adresse sp√©cifie une adresse requise en stockage pour une entit√©.

     adresse_clause ::= pour simple_name, √† utiliser sur simple_expression ;

L'expression donn√©e apr√®s le mot r√©serv√© √† doit √™tre du type ADRESSE
d√©fini dans le package SYSTEM (voir 13.7); ce paquet doit √™tre nomm√© par un
avec clause qui s'applique √† l'unit√© de compilation dans laquelle l'adresse
la clause se produit. Les conventions qui d√©finissent l'interpr√©tation d'une valeur
du type ADDRESS comme adresse, comme niveau d'interruption, ou quoi que ce soit
peuvent √™tre, d√©pendent de la mise en ≈ìuvre. Le caract√®re permis du simple
le nom et la signification de l‚Äôadresse correspondante sont les suivants :

(a) Nom d'un objet : l'adresse est celle requise pour l'objet
   (variable ou constante).

(b) Nom d'un sous-programme, d'un package ou d'une unit√© de t√¢ches : l'adresse est celle
   requis pour le code machine associ√© au corps du programme
   unit√©.

(c) Nom d'une entr√©e unique : l'adresse sp√©cifie une interruption mat√©rielle √†
   auquel l'entr√©e unique doit √™tre li√©e.

Si le nom simple est celui d‚Äôune seule t√¢che, la clause d‚Äôadresse est
compris comme faisant r√©f√©rence √† l'unit√© de t√¢che et non √† l'objet de t√¢che. Dans tout
Dans certains cas, la clause d'adresse n'est l√©gale que si exactement une d√©claration avec
cet identifiant appara√Æt plus t√¥t, imm√©diatement dans le m√™me d√©claratif
pi√®ce, sp√©cification de package ou sp√©cification de t√¢che. Un nom d√©clar√© par un
la d√©claration de renommage n‚Äôest pas autoris√©e comme nom simple. 

Les clauses d'adresse ne doivent pas √™tre utilis√©es pour r√©aliser des superpositions d'objets ou
superpositions d‚Äôunit√©s de programme. Une interruption donn√©e ne doit pas non plus √™tre li√©e √† d'autres
plus d'une entr√©e. Tout programme utilisant des clauses d'adresse pour obtenir de tels effets
est erron√©.


Exemple:

   pour une utilisation CONTROL √† 16#0020# ; -- en supposant que SYSTEM.ADDRESS est un entier
   taper

Remarques:

Les r√®gles ci-dessus impliquent que si deux sous-programmes se surchargent mutuellement et sont
visible √† un moment donn√©, une clause d'adresse pour l'un d'entre eux n'est pas l√©gale √†
ce point. De m√™me, si une sp√©cification de t√¢che d√©clare des entr√©es qui
se surchargent mutuellement, ils ne peuvent pas √™tre des entr√©es d'interruption. La syntaxe ne
autoriser une clause d'adresse pour une unit√© de biblioth√®que. Une impl√©mentation peut fournir
pragmas pour la sp√©cification des superpositions de programmes.

R√©f√©rences : adresse pr√©d√©finie de type 13.7, appliquer 10.1.1, unit√© de compilation
10.1, constante 3.2.1, entit√© 3.1, entr√©e 9.5, erron√©e 1.6, expression
4.4, unit√© de biblioth√®que 10.1, nom 4.1, objet 3.2, package 7, pragma 2.8,
unit√© de programme 6, mot r√©serv√© 2.9, expression simple 4.4, nom simple 4.1,
sous-programme 6, corps du sous-programme 6.3, package syst√®me 13.7, corps de la t√¢che 9.1, t√¢che
objet 9.2, unit√© de t√¢che 9, type 3.3, variable 3.2.1, avec clause 10.1.1

13.5.1 Interruptions

Une clause d'adresse donn√©e pour une entr√©e associe l'entr√©e √† un p√©riph√©rique
cela peut provoquer une interruption ; une telle entr√©e est mentionn√©e dans cette section
comme entr√©e d'interruption. Si des informations de contr√¥le sont fournies lors d'un
interruption, il est transmis √† une entr√©e d'interruption associ√©e sous la forme d'un ou plusieurs
param√®tres de mode en ; seuls les param√®tres de ce mode sont autoris√©s.

Une interruption agit comme un appel d'entr√©e √©mis par une t√¢che mat√©rielle dont la priorit√©
est sup√©rieur √† la priorit√© du programme principal, et √©galement sup√©rieur √† la
priorit√© de toute t√¢che d√©finie par l'utilisateur (c'est-√†-dire toute t√¢che dont le type est d√©clar√©
par une unit√© de t√¢che dans le programme). L'appel d'entr√©e peut √™tre un appel d'entr√©e ordinaire
appel d'entr√©e, un appel d'entr√©e temporis√© ou un appel d'entr√©e conditionnel, selon le
sorte d'interruption et sur la mise en ≈ìuvre. 

Si une instruction select contient √† la fois une alternative de fin et une option d'acceptation
alternative pour une entr√©e d‚Äôinterruption, alors une impl√©mentation peut imposer
d'autres exigences pour la s√©lection de l'alternative de terminaison dans
en plus de ceux donn√©s √† la section 9.4.

Exemple:

     la t√¢che INTERRUPT_HANDLER est
       entr√©e FAIT ;
       pour une utilisation DONE √† 16#40# ; en supposant que SYSTEM.ADDRESS est un entier
         taper
       terminer INTERRUPT_HANDLER ;

Remarques:

Les appels d‚Äôentr√©e par interruption doivent uniquement avoir la s√©mantique d√©crite ci-dessus ; ils
peut √™tre impl√©ment√© en demandant au mat√©riel d'ex√©cuter directement le
accepter les d√©clarations.

Les interruptions en file d'attente correspondent √† des appels d'entr√©e ordinaires. Les interruptions qui sont
Les appels perdus s'ils ne sont pas trait√©s imm√©diatement correspondent √† des appels d'entr√©e conditionnelle. Il
est une cons√©quence des r√®gles de priorit√© selon lesquelles une instruction accept ex√©cut√©e dans
la r√©ponse √† une interruption a priorit√© sur la r√©ponse ordinaire d√©finie par l'utilisateur
t√¢ches et peut √™tre ex√©cut√© sans appeler au pr√©alable une action de planification.

L'un des effets possibles d'une clause d'adresse pour une entr√©e d'interruption est
pour sp√©cifier la priorit√© de l'interruption (directement ou indirectement). Direct
les appels vers une entr√©e d‚Äôinterruption sont autoris√©s.

R√©f√©rences : accepter l'alternative 9.7.1, accepter la d√©claration 9.5, adresse
type pr√©d√©fini 13.7, autorisation 1.6, appel d'entr√©e conditionnelle 9.7.2, entr√©e 9.5,
mode 6.1, param√®tre d'un sous-programme 6.2, priorit√© d'une t√¢che 9.8, s√©lection
alternative 9.7.1, instruction select 9.7, package syst√®me 13.7, t√¢che 9,
terminer l'alternative 9.7.1, appel d'entr√©e programm√© 9.7.3

13.6 Changement de repr√©sentation

Au plus une clause de repr√©sentation est autoris√©e pour un type donn√© et un
aspect de sa repr√©sentation. Par cons√©quent, si une repr√©sentation alternative est
n√©cessaire, il faut d√©clarer un deuxi√®me type, d√©riv√© du premier,
et de sp√©cifier une repr√©sentation diff√©rente pour le deuxi√®me type.

Exemple:

 -- PACKED_DESCRIPTOR et DESCRIPTOR sont deux types diff√©rents
 -- pr√©sentant des caract√©ristiques identiques, hormis leur repr√©sentation

 le type DESCRIPTEUR est
     enregistrer
       -- composants d'un descripteur
     terminer l'enregistrement ;

 tapez PACKED_DESCRIPTOR est le nouveau DESCRIPTOR ;

 pour l'utilisation de PACKED_DESCRIPTOR
     enregistrer
       -- clauses de composants pour certains ou pour tous les composants
     terminer l'enregistrement ;

Le changement de repr√©sentation peut d√©sormais √™tre accompli par affectation avec des
conversions de types :

     D : DESCRIPTEUR ;
     P : PACKED_DESCRIPTOR;

     P := PACKED_DESCRIPTOR (D); -- paquet D
     D := DESCRIPTEUR(P); -- d√©baller P

R√©f√©rences : affectation 5.2, type d√©riv√© 3.4, type 3.3, conversion de type
4.6, d√©claration de type 3.1, clause de repr√©sentation 13.1

13.7 Le syst√®me de packages

Pour chaque impl√©mentation, il existe un package de biblioth√®que pr√©d√©fini appel√© SYSTEM
qui comprend les d√©finitions de certains param√®tres d√©pendants de la configuration
caract√©ristiques. La sp√©cification du package SYSTEM est
d√©pend de la mise en ≈ìuvre et doit √™tre donn√©e en annexe F. La partie visible
de ce package doit contenir au moins les d√©clarations suivantes.


Le package SYSTEM est
     le type ADDRESS est d√©fini par l'impl√©mentation ;
     le type NOM est mise en ≈ìuvre_d√©finie_enumeration_type ;

     SYSTEM_NAME : constante NAME := mise en ≈ìuvre_d√©finie ;

     STORAGE_UNIT : constante := mise en ≈ìuvre_d√©finie ;
     MEMORY_SIZE : constante := mise en ≈ìuvre_d√©finie ;

     --Num√©ros nomm√©s d√©pendants du syst√®me :

     MIN_INT : constante := mise en ≈ìuvre_d√©finie ;
     MAX_INT : constante := mise en ≈ìuvre_d√©finie ;
     MAX_DIGITS : constante := mise en ≈ìuvre_d√©finie ;
     MAX_MANTISSA : constante := mise en ≈ìuvre_d√©finie ;
     FINE_DELTA : constante := mise en ≈ìuvre_d√©finie ;
     TICK : constante := mise en ≈ìuvre_d√©finie ;

     --Autres d√©clarations System_Dependent

     le sous-type PRIORITY est une plage INTEGER mise en ≈ìuvre_d√©finie ;

     ...
 fin du SYST√àME ;

Le type ADDRESS est le type des adresses fournies dans les clauses d'adresse ;
c'est aussi le type du r√©sultat d√©livr√© par l'attribut ADDRESS.
Les valeurs du type d'√©num√©ration NOM sont les noms de machines alternatives
configurations g√©r√©es par l‚Äôimpl√©mentation ; l'un d'eux est la constante
SYSTEM_NAME. Le nombre nomm√© STORAGE_UNIT est le nombre de bits par
unit√© de stockage; le nombre nomm√© MEMORY_SIZE est le nombre de disponibles
unit√©s de stockage dans la configuration ; ces num√©ros nomm√©s sont du type
entier_universel.

Une forme alternative du package SYSTEM, avec des valeurs donn√©es pour l'un des
SYSTEM_NAME, STORAGE_UNIT et MEMORY_SIZE peuvent √™tre obtenus au moyen du
pragmas correspondants. Ces pragmas ne sont autoris√©s qu'au d√©but d'un
compilation, avant la premi√®re unit√© de compilation (le cas √©ch√©ant) de la compilation.

     pragma SYSTEM_NAME (enumeration_literal);

L'effet du pragma ci-dessus est d'utiliser le litt√©ral d'√©num√©ration avec le
identifiant sp√©cifi√© pour la d√©finition de la constante SYSTEM_NAME. Ce
pragma n'est autoris√© que si l'identifiant sp√©cifi√© correspond √† l'un des
les litt√©raux du type NAME.

     pragma STORAGE_UNIT (numeric_literal);

L'effet du pragma ci-dessus est d'utiliser la valeur du nombre num√©rique sp√©cifi√©
litt√©ral pour la d√©finition du num√©ro nomm√© STORAGE_UNIT.

     pragma MEMORY_SIZE (numeric_literal);

L'effet du pragma ci-dessus est d'utiliser la valeur du nombre num√©rique sp√©cifi√©
litt√©ral pour la d√©finition du nombre nomm√© MEMORY_SIZE.

La compilation de l'un de ces pragmas provoque une recompilation implicite de
le package SYST√àME. Par cons√©quent, toute unit√© de compilation qui nomme SYSTEM dans
sa clause de contexte devient obsol√®te apr√®s cette recompilation implicite. Un
la mise en ≈ìuvre peut imposer des limitations suppl√©mentaires √† l‚Äôutilisation de ces pragmas.
Par exemple, une impl√©mentation peut les autoriser uniquement au d√©but de la
premi√®re compilation, lors de la cr√©ation d'une nouvelle biblioth√®que de programmes.

Note:

C'est une cons√©quence des r√®gles de visibilit√© qu'une d√©claration faite dans le
Le package SYSTEM n'est pas visible dans une unit√© de compilation √† moins que ce package ne soit
mentionn√© par une clause with qui s'applique (directement ou indirectement) au
unit√© de compilation.

R√©f√©rences : clause d'adresse 13.5, appliquer 10.1.1, attribut 4.1.4, compilation
unit√© 10.1, doit 1.6, num√©ro nomm√© 3.2, d√©claration num√©rique 3.2.2, num√©rique
litt√©ral 2.4, package 7, sp√©cification du package 7.1, pragma 2.8, programme
biblioth√®que 10.1, type 3.3, visibilit√© 8.3, partie visible 7.2, avec clause
10.1.1

13.7.1 Num√©ros nomm√©s d√©pendants du syst√®me

Dans le package SYSTEM, les num√©ros nomm√©s suivants sont d√©clar√©s. Le
les nombres FINE_DELTA et TICK sont du type universal_real ; les autres sont
du type universal_integer.

MIN_INT La valeur la plus petite (la plus n√©gative) de tous les entiers pr√©d√©finis
            les types.

MAX_INT La valeur la plus grande (la plus positive) de tous les entiers pr√©d√©finis
            les types.

MAX_DIGITS La plus grande valeur autoris√©e pour le nombre de valeurs significatives.
            chiffres d√©cimaux dans une contrainte √† virgule flottante.

MAX_MANTISSA Le plus grand nombre possible de chiffres binaires dans la mantisse
            de num√©ros de mod√®le d'un sous-type √† virgule fixe.

FINE_DELTA Le plus petit delta autoris√© dans une contrainte de point fixe qui
            a la contrainte de plage -1.0 .. 1.0.

COCHE La p√©riode d'horloge de base, en secondes.

R√©f√©rences : autoriser 1.6, delta d'une contrainte de point fixe 3.5.9, point fixe
contrainte 3.5.9, contrainte de virgule flottante 3.5.7, type entier 3.5.4,
num√©ro de mod√®le 3.5.6, nomm√© num√©ro 3.2, package 7, contrainte de port√©e 3.5,
package syst√®me 13.7, type 3.3, universal_integer type 3.5.4, universal_real
tapez 3.5.6

13.7.2 Attributs de repr√©sentation

Les valeurs de certaines caract√©ristiques d√©pendant de l'impl√©mentation peuvent √™tre
obtenu en interrogeant les attributs de repr√©sentation appropri√©s. Ces
les attributs sont d√©crits ci-dessous.

Pour tout objet, unit√© de programme, √©tiquette ou entr√©e X :

X'ADDRESS Donne l'adresse de la premi√®re des unit√©s de stockage
              allou√© √† X. Pour un sous-programme, un package, une unit√© de t√¢che ou
              √©tiquette, cette valeur fait r√©f√©rence au code machine associ√© √†
              le corps ou la d√©claration correspondante. Pour une entr√©e pour laquelle
              une clause d'adresse a √©t√© donn√©e, la valeur fait r√©f√©rence au
              interruption mat√©rielle correspondante. La valeur de ceci
              l'attribut est du type ADDRESS d√©fini dans le package
              SYST√àME.

Pour tout type ou sous-type X ou pour tout objet X :

X'SIZE Appliqu√© √† un objet, donne le nombre de bits allou√©s √†
              tenir l'objet. Appliqu√© √† un type ou un sous-type, donne le
              nombre minimum de bits requis par l'impl√©mentation
              pour contenir tout objet possible de ce type ou sous-type. Le
              la valeur de cet attribut est du type universal_integer.

Pour les deux attributs de repr√©sentation ci-dessus, si le pr√©fixe est le nom d'un
fonction, l'attribut s'entend comme un attribut de la fonction
(pas du r√©sultat de l'appel de la fonction). De m√™me, si le type de
le pr√©fixe est un type d'acc√®s, l'attribut s'entend comme un attribut de
le pr√©fixe (pas de l'objet d√©sign√© : les attributs de ce dernier peuvent √™tre
√©crit avec un pr√©fixe se terminant par le mot r√©serv√© all).

Pour tout composant C d‚Äôun objet enregistrement R :

RC'POSITION Donne le d√©calage, √† partir du d√©but de la premi√®re unit√© de stockage
              occup√© par le dossier, de la premi√®re des unit√©s de stockage
              occup√© par C. Ce d√©calage est mesur√© en unit√©s de stockage. 
              La valeur de cet attribut est du type
              entier_universel.

RC'FIRST_BIT Renvoie le d√©calage, √† partir du d√©but du premier des
              unit√©s de stockage occup√©es par C, du dernier bit occup√© par C. 
              Ce d√©calage est mesur√© en bits. La valeur de ceci
              l'attribut est du type universal_integer.

RC'LAST_BIT Renvoie le d√©calage, √† partir du d√©but du premier des
              unit√©s de stockage occup√©es par C, du dernier bit occup√© par C. 
              Ce d√©calage est mesur√© en bits. La valeur de cet attribut
              est du type universal_integer.

Pour tout type ou sous-type d‚Äôacc√®s T :

T'STORAGE_SIZE Renvoie le nombre total d'unit√©s de stockage r√©serv√©es au
              collection associ√©e au type de base de T. La valeur de
              cet attribut est du type universal_integer.

Pour tout type de t√¢che ou objet de t√¢che T :

T'STORAGE_SIZE Renvoie le nombre d'unit√©s de stockage r√©serv√©es pour chaque
              activation d'une t√¢che de type T ou pour l'activation de
              l'objet t√¢che T. La valeur de cet attribut est de la
              tapez universal_integer.

Remarques:

Pour un objet t√¢che X, l'attribut X'SIZE donne le nombre de bits utilis√©s pour
contient l'objet X, alors que X'STORAGE_SIZE donne le nombre d'unit√©s de stockage
allou√© pour l‚Äôactivation de la t√¢che d√©sign√©e par X. Pour un
param√®tre X, si le passage du param√®tre est r√©alis√© par copie, alors l'attribut
X'ADDRESS donne l'adresse de la copie locale ; si le passage des param√®tres se fait par
r√©f√©rence, alors l‚Äôadresse est celle du param√®tre r√©el.

R√©f√©rences : sous-type d'acc√®s 3.8, type d'acc√®s 3.8, activation 9.3, r√©el
param√®tre 6.2, clause d'adresse 13.5, type d'adresse pr√©d√©fini 13.7, attribut
4.1.4, type de base 3.3, collection 3.8, composant 3.3, entr√©e 9.5, formel
param√®tre 6.1 6.2, √©tiquette 5.1, objet 3.2, package 7, corps du package 7.1,
param√®tre passant 6.2, unit√© de programme 6, objet d'enregistrement 3.7, instruction 5,
unit√© de stockage 13.7, sous-programme 6, corps du sous-programme 6.3, sous-type 3.3, syst√®me
package pr√©d√©fini 13.7, t√¢che 9, corps de t√¢che 9.1, objet de t√¢che 9.2, type de t√¢che
9.2, unit√© de t√¢che 9, type 3.3, type universal_integer 3.5.4

13.7.3 Attributs de repr√©sentation des types r√©els

Pour chaque type ou sous-type r√©el T, les √©l√©ments suivants, d√©pendants de la machine
des attributs sont d√©finis, qui ne sont pas li√©s aux num√©ros de mod√®le. 
Les programmes utilisant ces attributs peuvent ainsi exploiter des propri√©t√©s qui vont
au-del√† des propri√©t√©s minimales associ√©es au type num√©rique (voir section
4.5.7 pour les r√®gles d√©finissant la pr√©cision des op√©rations avec des valeurs r√©elles
op√©randes). Des pr√©cautions doivent donc √™tre prises lors de l'utilisation de ces machines-
attributs d√©pendants si la portabilit√© doit √™tre assur√©e.

Pour les types √† virgule flottante et √† virgule fixe :

T'MACHINE_ROUNDS Renvoie la valeur TRUE si chaque arithm√©tique pr√©d√©finie
                   l'op√©ration sur les valeurs du type de base de T renvoie soit
                   un r√©sultat exact ou effectue un arrondi ; donne la valeur
                   FAUX sinon. La valeur de cet attribut est de
                   type pr√©d√©fini BOOLEAN.

T'MACHINE_OVERFLOWS Renvoie la valeur TRUE si chaque op√©ration pr√©d√©finie sur
                   les valeurs du type de base de T fournissent soit une valeur correcte
                   r√©sultat, ou d√©clenche l'exception NUMERIC_ERROR dans
                   situations de d√©bordement (voir 4.5.7) ; donne la valeur FALSE
                   sinon. La valeur de cet attribut est de
                   type pr√©d√©fini BOOLEAN.

Pour les types √† virgule flottante, les attributs suivants fournissent des caract√©ristiques
de la repr√©sentation machine sous-jacente, en termes de forme canonique
d√©fini √† la section 3.5.7 :

T'MACHINE_RADIX Renvoie la valeur de la base utilis√©e par la machine
                   repr√©sentation du type de base de T (les chiffres sont
                   chiffres √©tendus compris entre 0 et T'MACHINE_RADIX -1).
                   La valeur de cet attribut est du type
                   entier_universel.

T'MACHINE_EMAX Donne la plus grande valeur d'exposant pour la machine
                   repr√©sentation du type de base de T. La valeur de
                   cet attribut est du type universal_integer.

T'MACHINE_EMIN Donne la valeur la plus petite (la plus n√©gative) de l'exposant
                   pour la repr√©sentation machine du type de base de T. 
                   La valeur de cet attribut est du type
                   entier_universel.

Remarque : Pour de nombreuses machines, le plus grand nombre repr√©sentable de machines de type F
est presque
     (F'MACHINE_RADIX)**(F'MACHINE_EMAX),

et le plus petit nombre repr√©sentable positif est

     F'MACHINE_RADIX** (F'MACHINE_EMIN -1)

R√©f√©rences : op√©rateur arithm√©tique 4.5, attribut 4.1.4, type de base 3.3, bool√©en
type pr√©d√©fini 3.5.3, fausse valeur bool√©enne 3.5.3, type √† virgule fixe 3.5.9,
type √† virgule flottante 3.5.7, num√©ro de mod√®le 3.5.6, type num√©rique 3.5,
exception numeric_error 11.1, op√©ration pr√©d√©finie 3.3.3, base 3.5.7, r√©el
type 3.5.6, sous-type 3.3, vraie valeur bool√©enne 3.5.3, type 3.3,
type universel_entier 3.5.4

13.8 Insertions de codes machine

Une insertion de code machine peut √™tre r√©alis√©e par un appel √† une proc√©dure dont
la s√©quence d'instructions contient des instructions de code.

     code_statement ::= type_mark'record_aggregate;

Une instruction de code n'est autoris√©e que dans la s√©quence d'instructions d'un
corps de proc√©dure. Si un corps de proc√©dure contient des instructions de code, alors dans
ce corps de proc√©dure, la seule forme d'instruction autoris√©e est une instruction de code
(√©tiquet√©s ou non), les seuls √©l√©ments d√©claratifs autoris√©s sont les clauses d'utilisation, et
aucun gestionnaire d'exception n'est autoris√© (les commentaires et les pragmas sont autoris√©s comme
habituel). 

Chaque instruction machine appara√Æt sous la forme d'un agr√©gat d'enregistrements d'un type d'enregistrement
qui d√©finit l‚Äôinstruction correspondante. Le type de base de la marque de type
d'une instruction de code doit √™tre d√©clar√©e dans le package de biblioth√®que pr√©d√©fini
appel√© MACHINE_CODE ; ce package doit √™tre nomm√© par une clause with qui
s'applique √† l'unit√© de compilation dans laquelle l'instruction de code appara√Æt. Un
la mise en ≈ìuvre n‚Äôest pas n√©cessaire pour fournir un tel package.

Une impl√©mentation est autoris√©e √† imposer des restrictions suppl√©mentaires sur l'enregistrement
agr√©gats autoris√©s dans les instructions de code. Par exemple, cela peut exiger que
les expressions contenues dans de tels agr√©gats soient des expressions statiques. 

Une impl√©mentation peut fournir des pragmas d√©pendants de la machine sp√©cifiant le registre
conventions et conventions d‚Äôappel. Ces pragmas doivent √™tre document√©s dans
Annexe F

Exemple:

     M : MASQUE
     proc√©dure SET_MASK ; pragma INLINE(SET_MASK);

     la proc√©dure SET_MASK est
       utilisez MACHINE_CODE ;
     commencer
       SI_FORMAT'(CODE => SSM, B => M'BASE_REG, D => M'DISP) ;
       -- M'BASE_REG et M'DISP sont pr√©d√©finis sp√©cifiques √† l'impl√©mentation
           les attributs
     fin;

R√©f√©rences : autoriser 1.6, appliquer 10.1.1, commentaire 2.7, unit√© de compilation 10.1,
√©l√©ment d√©claratif 3.9, gestionnaire d'exceptions 11.2, pragma en ligne 6.3.2, √©tiquet√©
instruction 5.1, unit√© de biblioth√®que 10.1, package 7, pragma 2.8, proc√©dure 6 6.1,
corps de proc√©dure 6.3, agr√©gat d'enregistrement 4.3.1, type d'enregistrement 3.7, s√©quence de
instructions 5.1, instruction 5, expression statique 4.9, utilisez la clause 5.4, avec
clause 10.1.1

13.9 Interface vers d'autres langues

Un sous-programme √©crit dans un autre langage peut √™tre appel√© depuis un programme Ada
√† condition que toutes les communications soient r√©alis√©es via des param√®tres et des fonctions
r√©sultats. Un pragme de la forme

     pragma INTERFACE (nom_langue, nom_sous-programme) ;

doit √™tre indiqu√© pour chacun de ces sous-programmes ; un nom de sous-programme est autoris√© √†
repr√©sentent plusieurs sous-programmes surcharg√©s. Ce pragma est autoris√© au
place d'une rubrique d√©clarative, et doit s'appliquer dans ce cas √† un sous-programme
d√©clar√© par un √©l√©ment d√©claratif ant√©rieur de la m√™me partie d√©clarative ou
sp√©cification du paquet. Le pragma est √©galement autoris√© pour une unit√© de biblioth√®que ; dans
dans ce cas, le pragma doit appara√Ætre apr√®s la d√©claration du sous-programme, et
avant toute unit√© de compilation ult√©rieure. Le pragma pr√©cise l'autre
langage (et donc les conventions d'appel) et informe le compilateur
qu'un module objet sera fourni pour le sous-programme correspondant. UN
body n'est pas autoris√© pour un tel sous-programme (pas m√™me sous la forme d'un corps
stub) puisque les instructions du sous-programme sont √©crites dans un autre
langue. 

Cette capacit√© n'est pas n√©cessairement fournie par toutes les mises en ≈ìuvre. Un
la mise en ≈ìuvre peut imposer des restrictions sur les formes et les lieux autoris√©s de
param√®tres et appels.

Exemple:

     le package FORT_LIB est
       la fonction SQRT (X : FLOAT) renvoie FLOAT ;
       fonction EXP (X : FLOAT) renvoie FLOAT ;
     priv√©
       pragma INTERFACE(FORTRAN, SQRT);
       pragma INTERFACE(FORTRAN, EXP);
     fin FORT_LIB ;

Remarques:

Les conventions utilis√©es par d'autres processeurs de langage qui appellent les programmes Ada
ne font pas partie de la d√©finition du langage Ada. De telles conventions doivent √™tre
d√©fini par ces autres processeurs de langage.

Le pragma INTERFACE n'est pas d√©fini pour les sous-programmes g√©n√©riques.

R√©f√©rences : autoriser 1.6, stub de corps 10.2, unit√© de compilation 10.1, d√©claration
3.1, √©l√©ment d√©claratif 3.9, partie d√©clarative 3.9, r√©sultat de la fonction 6.5,
unit√© de biblioth√®que 10.1, doit 1.6, nom 4.1, sous-programme surcharg√© 6.6, package
sp√©cification 7.1, param√®tre d'un sous-programme 6.2, pragma 2.8, sous-programme 6,
corps du sous-programme 6.3, appel du sous-programme 6.4, d√©claration du sous-programme 6.1

13.10 Programmation non coch√©e

Les sous-programmes de biblioth√®que g√©n√©rique pr√©d√©finis UNCHECKED_DEALLOCATION et
UNCHECKED_CONVERSION sont utilis√©s pour la d√©sallocation de stockage non contr√¥l√©e et pour
conversions de type non v√©rifi√©es.

     g√©n√©rique
        le type OBJECT est limit√© √† priv√© ;
        tapez NOM est acc√®s OBJET ;
     proc√©dure UNCHECKED_DEALLOCATION(X : entr√©e sortie NOM);

     g√©n√©rique
        le type SOURCE est priv√© limit√© ;
        le type TARGET est limit√© en priv√© ;
     la fonction UNCHECKED_CONVERSION(S : SOURCE) renvoie CIBLE ;

R√©f√©rences : sous-programme g√©n√©rique 12.1, unit√© biblioth√®que 10.1, type 3.3

13.10.1 D√©sallocation de stockage non contr√¥l√©e

D√©sallocation de stockage non contr√¥l√©e d'un objet d√©sign√© par une valeur d'un
Le type d'acc√®s est obtenu par un appel d'une proc√©dure obtenue par
instanciation de la proc√©dure g√©n√©rique UNCHECKED_DEALLOCATION. Pour
exemple:

     la proc√©dure FREE est nouvelle UNCHECKED_DEALLOCATION(object_type_name,
            nom_type_d'acc√®s);

Une telle proc√©dure GRATUITE a l‚Äôeffet suivant :

(a) apr√®s avoir ex√©cut√© FREE(X), la valeur de X est nulle ;

(b) FREE(X), lorsque X est d√©j√† √©gal √† null, n'a aucun effet ;

(c) FREE(X), lorsque X n'est pas √©gal √† null, est une indication que l'objet
   d√©sign√© par X n'est plus n√©cessaire, et que le stockage qu'il occupe
   est √† r√©cup√©rer.

Si X et Y d√©signent le m√™me objet, alors acc√©der √† cet objet via Y
est erron√© si cet acc√®s est effectu√© (ou tent√©) apr√®s l'appel
GRATUIT(X); l'effet de chacun de ces acc√®s n'est pas d√©fini par la langue.

Remarques:

C'est une cons√©quence des r√®gles de visibilit√© que la proc√©dure g√©n√©rique
UNCHECKED_DEALLOCATION n'est pas visible dans une unit√© de compilation sauf si
la proc√©dure g√©n√©rique est mentionn√©e par une clause with qui s'applique au
unit√© de compilation.

Si X d√©signe un objet t√¢che, l'appel FREE(X); n'a aucun effet sur la t√¢che
d√©sign√© par la valeur de cet objet t√¢che. Il en va de m√™me pour tout
sous-composant de l'objet d√©sign√© par X, si ce sous-composant est une t√¢che
objet.

R√©f√©rences : type d'acc√®s 3.8, appliquer 10.1.1, unit√© de compilation 10.1, d√©signer
3.8 9.1, erron√© 1.6, instanciation g√©n√©rique 12.3, proc√©dure g√©n√©rique 12.1,
unit√© g√©n√©rique 12, unit√© de biblioth√®que 10.1, valeur d'acc√®s nulle 3.8, objet 3.2,
proc√©dure 6, appel de proc√©dure 6.4, sous-composant 3.3, t√¢che 9, objet de t√¢che 9.2,
visibilit√© 8.3, avec clause 10.1.1

13.10.2 Conversions de types non v√©rifi√©es

Une conversion de type non contr√¥l√©e peut √™tre r√©alis√©e par un appel d'une fonction qui
est obtenu par instanciation de la fonction g√©n√©rique UNCHECKED_CONVERSION.

L'effet d'une conversion non contr√¥l√©e est de renvoyer le (non interpr√©t√©)
valeur du param√®tre en tant que valeur du type cible, c'est-√†-dire la configuration binaire
la d√©finition de la valeur source est renvoy√©e inchang√©e en tant que configuration binaire d√©finissant
une valeur du type cible. Une impl√©mentation peut imposer des restrictions sur
conversions non contr√¥l√©es, par exemple, restrictions en fonction du
tailles respectives des objets de type source et cible. Tel
les restrictions doivent √™tre document√©es √† l‚Äôannexe F.

Chaque fois que des conversions non contr√¥l√©es sont utilis√©es, c'est le programmeur
responsabilit√© de garantir que ces conversions maintiennent les propri√©t√©s
qui sont garantis par le langage pour les objets du type cible. 
Programmes qui violent ces propri√©t√©s au moyen de conversions non contr√¥l√©es
sont erron√©es.

Note:

C'est une cons√©quence des r√®gles de visibilit√© que la fonction g√©n√©rique
UNCHECKED_CONVERSION n'est pas visible dans une unit√© de compilation √† moins que cela
la fonction g√©n√©rique est mentionn√©e par une clause with qui s'applique au
unit√© de compilation.

R√©f√©rences : appliquer 10.1.1, unit√© de compilation 10.1, erron√© 1.6, g√©n√©rique
fonction 12.1, instanciation 12.3, param√®tre d'un sous-programme 6.2, type 3.3,
avec la clause 10.1.1
