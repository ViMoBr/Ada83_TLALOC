
                              5. Déclarations  

Une instruction définit une action à effectuer ; le processus par lequel un
l’instruction réalise son action est appelée exécution de l’instruction.

Ce chapitre décrit les règles générales applicables à toutes les déclarations.
Certaines déclarations spécifiques sont discutées dans les chapitres suivants. Appel de procédure
les instructions sont décrites au chapitre 6 sur les sous-programmes. Appel d'entrée, retard,
Les instructions accept, select et abort sont décrites dans le chapitre 9 sur les tâches.
Les instructions Raise sont décrites au chapitre 11 sur les exceptions et le code
déclarations au chapitre 13. Les autres formes de déclarations sont présentées
dans ce chapitre.

Références : instruction abort 9.10, instruction accept 9.5, instruction code
13.8, instruction de délai 9.6, instruction d'appel d'entrée 9.5, appel de procédure
instruction 6.4, instruction raise 11.3, instruction select 9.7   

5.1 Instructions simples et composées - Séquences d'instructions 

Une déclaration est soit simple, soit composée. Une simple déclaration ne contient aucun
autre déclaration. Une instruction composée peut contenir des instructions simples et
d'autres déclarations composées.

   séquence_of_statements ::= instruction {instruction}

   déclaration ::=
      {étiquette} simple_statement | {label} déclaration_composée

   simple_statement ::= null_statement
      | instruction_affectation | procédure_call_statement
      | déclaration_de sortie | return_statement
      | goto_statement | entrée_call_statement
      | delay_statement | abort_statement
      | raise_statement | code_statement

   déclaration_composée ::=
        if_statement | case_statement
      | déclaration_boucle | block_statement
      | accept_statement | instruction_sélection

   label ::= <<label_simple_name>>

   null_statement ::= null;  

On dit qu'une instruction est étiquetée par le nom de n'importe quelle étiquette du
déclaration. Un nom d'étiquette, et de même un nom de boucle ou de bloc, est implicitement
déclaré à la fin de la partie déclarative du bloc le plus interne
instruction, corps de sous-programme, corps de package, corps de tâche ou corps générique qui
enferme l'instruction étiquetée, l'instruction de boucle nommée ou l'instruction nommée
instruction de bloc, selon le cas. Pour une instruction de bloc sans
partie déclarative, une partie déclarative implicite (et la déclaration précédente) est
assumé.                                                                                          

Les déclarations implicites pour différents noms d'étiquettes, noms de boucles et blocs
les noms apparaissent dans le même ordre que les débuts des noms correspondants
instructions étiquetées, instructions de boucle et instructions de bloc. Distinct
Les identifiants doivent être utilisés pour tous les noms d'étiquettes, de boucles et de blocs qui sont
implicitement déclaré dans le corps d'une unité de programme, y compris dans
bloquer les instructions incluses dans ce corps, mais à l'exclusion des autres instructions incluses
unités de programme (une unité de programme est soit un sous-programme, un package, une tâche
unité ou une unité générique).

L'exécution d'une instruction nulle n'a d'autre effet que de passer à l'instruction suivante
action.

L'exécution d'une séquence d'instructions consiste en l'exécution de la
instructions individuelles successives jusqu'à ce que la séquence soit terminée, ou une
le transfert de contrôle a lieu. Un transfert de contrôle est provoqué soit par
l'exécution d'une instruction exit, return ou goto ; par la sélection d'un
mettre fin à l'alternative ; par la levée d'une exception; ou (indirectement) par
l'exécution d'une instruction d'abandon.

Exemples d'énoncés étiquetés : 

   <<ICI>> <<ICI>> <<AQUI>> <<HIER>> null;

   <<APRÈS>> X := 1;

Note:

La portée d'une déclaration commence au lieu de la déclaration elle-même
(voir 8.2). Dans le cas d'un nom d'étiquette, de boucle ou de bloc, il découle de
cette règle selon laquelle la portée de la déclaration implicite commence avant le
première occurrence explicite du nom correspondant, depuis cette occurrence
se trouve soit dans une étiquette d'instruction, soit dans une instruction de boucle, soit dans une instruction de bloc, soit dans un
aller à la déclaration. Une déclaration implicite dans une instruction block peut cacher un
déclaration donnée dans une unité de programme externe ou une instruction de bloc (selon
les règles habituelles de dissimulation expliquées à la section 8.3).

Références : instruction d'abandon 9.10, instruction d'acceptation 9.5, affectation
instruction 5.2, nom de bloc 5.6, instruction de bloc 5.6, instruction de cas 5.4,
instruction de code 13.8, déclaration 3.1, partie déclarative 3.9, instruction de retard
9.6, instruction d'appel d'entrée 9.5, exception 11, instruction de sortie 5.7, générique
corps 12.1, unité générique 12, instruction goto 5.9, masquage 8.3, identifiant 2.3,
instruction if 5.3, déclaration implicite 3.1, nom de boucle 5.5, instruction de boucle
5.5, package 7, corps du package 7.1, instruction d'appel de procédure 6.4, programme
unité 6, instruction raise 11.3, levée d'exceptions 11, instruction return
5.8, portée 8.2, instruction select 9.7, nom simple 4.1, sous-programme 6,
corps de sous-programme 6.3, tâche 9, corps de tâche 9.1, unité de tâche 9.1, terminer
alternative 9.7.1, tâche terminée 9.4   

5.2 Déclaration de cession    

Une instruction d'affectation remplace la valeur actuelle d'une variable par une nouvelle
valeur spécifiée par une expression. La variable nommée et la main droite
l'expression secondaire doit être du même type ; ce type ne doit pas être un type limité.

   instruction_affectation ::=
      nom_variable := expression ;   

Pour l'exécution d'une instruction d'affectation, le nom de la variable et le
expression sont d'abord évaluées, dans un ordre qui n'est pas défini par le
langue. On vérifie alors que la valeur de l'expression appartient à
le sous-type de la variable, sauf dans le cas d'une variable qui est un
tableau (l'affectation implique alors une conversion de sous-type comme décrit dans
paragraphe 5.2.1). Finalement, la valeur de l'expression devient la nouvelle valeur
de la variable.                                                                   

L'exception CONSTRAINT_ERROR est levée si le sous-type mentionné ci-dessus
la vérification échoue ; dans un tel cas, la valeur actuelle de la variable est laissée
inchangé. Si la variable est une sous-composante qui dépend de discriminants
d'une variable d'enregistrement sans contrainte, puis l'exécution de l'affectation
est erroné si la valeur de l’un de ces discriminants est modifiée par ce
exécution.

Exemples:

   VALEUR := MAX_VALUE - 1 ;
   TEINTE := BLEU ;

   NEXT_FRAME(F)(M, N) := 2,5; -- voir 4.1.1
   U := DOT_PRODUCT(V, W); -- voir 6.5

   WRITER := (STATUT => OUVERT, UNITÉ => IMPRIMANTE, LINE_COUNT => 60); -- voir 3.7.3
   NEXT_CAR.all := (72074, nul); -- voir 3.8.1

Exemples de contrôles de contraintes :

   I, J : plage INTEGER 1 .. 10 ;
   K : plage INTEGER 1 .. 20 ;
    ...

   Je := J; -- gammes identiques
   K :=J; -- gammes compatibles
   J := K; -- lèvera l'exception CONSTRAINT_ERROR si K > 10

Remarques:

Les valeurs des discriminants d'un objet désignées par une valeur d'accès
ne peut pas être modifié (pas même en attribuant une valeur complète à l'objet
lui-même) puisque de tels objets, créés par les allocateurs, sont toujours contraints
(voir 4.8) ; cependant, les sous-composants de ces objets peuvent être libres.

Si l'expression de droite est soit un littéral numérique, soit nommée
nombre, ou un attribut qui donne un résultat de type universal_integer ou
universal_real, alors une conversion de type implicite est effectuée, comme décrit
à la section 4.6.

La détermination du type de la variable d'une instruction d'affectation
peut nécessiter la prise en compte de l'expression si le nom de la variable peut être
interprété comme le nom d'une variable désignée par la valeur d'accès
renvoyé par un appel de fonction, et de la même manière, en tant que composant ou tranche d'un tel
une variable (voir section 8.7 pour le contexte de résolution de surcharge).

Références : type d'accès 3.8, allocateur 4.8, tableau 3.6, affectation de tableau
5.2.1, composant 3.6 3.7, exception constraint_error 11.1, désigner 3.8,
discriminant 3.7.1, erroné 1.6, évaluation 4.5, expression 4.4, fonction
appel 6.4, conversion de type implicite 4.6, nom 4.1, littéral numérique 2.4,
objet 3.2, surcharge 6.6 8.7, tranche 4.1.2, sous-composant 3.3, sous-type
3.3, conversion de sous-type 4.6, type 3.3, type universal_integer 3.5.4,
universal_real type 3.5.6, variable 3.2.1   

5.2.1 Affectations des tableaux 

Si la variable d'une instruction d'affectation est une variable tableau (y compris
une variable slice), la valeur de l'expression est implicitement convertie en
le sous-type de la variable tableau ; le résultat de cette conversion de sous-type
devient la nouvelle valeur de la variable tableau.                                              

Cela signifie que la nouvelle valeur de chaque composant de la variable tableau est
spécifié par le composant correspondant dans la valeur du tableau obtenue par
évaluation de l'expression (voir 4.5.2 pour la définition de la correspondance
Composants). La conversion de sous-type vérifie que pour chaque composant du
variable de tableau, il y a un composant correspondant dans la valeur du tableau, et vice-versa
versa. L'exception CONSTRAINT_ERROR est levée si cette vérification échoue ; dans
dans un tel cas, la valeur de chaque composant de la variable tableau est laissée
inchangé.

Exemples:

   A : CHAÎNE(1 .. 31);
   B : CHAÎNE(3 .. 33);
    ...

   UNE := B; -- même nombre de composants

   A(1 .. 9) := "sauce au goudron";
   UNE(4 .. 12) := UNE(1 .. 9); -- A(1 .. 12) = "sauce tartare"

Remarques:

L'affectation des tableaux est définie même dans le cas de tranches qui se chevauchent, car
l'expression du côté droit est évaluée avant d'effectuer toute
affectation des composants. Dans l’exemple ci-dessus, une implémentation donnant A(1
.. 12) = "tartartartar" serait incorrect.

La conversion implicite de sous-type décrite ci-dessus pour l'affectation à un tableau
la variable est effectuée uniquement pour la valeur de l'expression de droite
dans son ensemble; elle n'est pas effectuée pour les sous-composants qui sont des valeurs de tableau.

Références : tableau 3.6, affectation 5.2, exception constraint_error 11.1,
composants de tableau correspondants 4.5.2, tranche 4.1.2, conversion de sous-type 4.6, type
3.3, variable 3.2.1

5.3 Déclarations If 

Une instruction if sélectionne pour l'exécution une ou aucune des séquences incluses
d'énoncés, en fonction de la valeur (vérité) d'un ou plusieurs
conditions.

   if_statement ::=
       si condition alors
         séquence_of_statements
      {autre condition alors
         séquence_of_statements}
      [autre
         séquence_de_statements]
       fin si;   

   condition ::= expression_booléenne 

Une expression spécifiant une condition doit être de type booléen.

Pour l'exécution d'une instruction if, la condition spécifiée après if, et
toutes les conditions spécifiées après elsif, sont évaluées successivement (en traitant
une finale else comme elsif TRUE alors), jusqu'à ce que l'on évalue à TRUE ou tous
les conditions sont évaluées et donnent FAUX. Si une condition est évaluée à
TRUE, alors la séquence d'instructions correspondante est exécutée ; sinon
aucune des séquences d'instructions n'est exécutée.                                              

Exemples: 

   si MOIS = DÉCEMBRE et JOUR = 31 alors
      MOIS := JANVIER;
      JOUR := 1;
      ANNÉE := ANNÉE + 1 ;
   fin si;

   si LINE_TOO_SHORT alors
      augmenter LAYOUT_ERROR ;
   sinon LINE_FULL alors
      NOUVELLE LIGNE;
      METTRE(ARTICLE);
   autre
      METTRE(ARTICLE);
   fin si;

   si MY_CAR.OWNER.VEHICLE /= MY_CAR alors -- voir 3.8
      RAPPORT ("Données incorrectes");
   fin si;

Références : type booléen 3.5.3, évaluation 4.5, expression 4.4, séquence
des déclarations 5.1  

5.4 Énoncés de cas 

Une instruction case sélectionne pour exécution l'une des nombreuses alternatives
séquences de déclarations ; l'alternative choisie est définie par la valeur de
une expression.

   case_statement ::=
      l'expression de cas est
          case_statement_alternative
         {case_statement_alternative}
      cas final ;

   case_statement_alternative ::=
      quand choix {| choix } =>
         séquence_of_statements

L'expression doit être d'un type discret qui doit être déterminable
indépendamment du contexte dans lequel l'expression apparaît, mais en utilisant le
fait que l’expression doit être de type discret. De plus, le type de
cette expression ne doit pas être un type formel générique. Chaque choix dans un cas
l'instruction alternative doit être du même type que l'expression ; la liste
de choix précise pour quelles valeurs de l'expression l'alternative est
choisi.

Si l'expression est le nom d'un objet dont le sous-type est statique, alors
chaque valeur de ce sous-type doit être représentée une et une seule fois dans le
ensemble de choix de l'instruction case, et aucune autre valeur n'est autorisée ; ce 
Cette règle s'applique également si l'expression est une expression qualifiée ou
conversion de type dont la marque de type désigne un sous-type statique. Sinon, pour
d'autres formes d'expression, chaque valeur du type (de base) de l'expression
doit être représenté une et une seule fois dans l'ensemble des choix, et aucun autre
la valeur est autorisée.                                                                                 

Les expressions simples et les plages discrètes données comme choix dans un cas
l'instruction doit être statique. Un choix défini par une plage discrète signifie
toutes les valeurs dans la plage correspondante (aucune si plage nulle). Le choix
les autres n'est autorisé que comme dernière alternative et comme seul choix ; il
représente toutes les valeurs (éventuellement aucune) non données dans les choix précédents
alternatives. Un simple nom de composant n'est pas autorisé comme choix de cas
déclaration alternative.

L'exécution d'un exposé de cas consiste en l'évaluation du
expression suivie de l’exécution de la séquence d’instructions choisie.

Exemples:

   cas où le CAPTEUR est
      quand ELEVATION => RECORD_ELEVATION(SENSOR_VALUE);
      quand AZIMUTH => RECORD_AZIMUTH (SENSOR_VALUE) ;
      lorsque DISTANCE => RECORD_DISTANCE (SENSOR_VALUE) ;
      quand autres => null ;
   cas final ;

   le cas AUJOURD'HUI est
      quand MON => COMPUTE_INITIAL_BALANCE ;
      quand VEN => COMPUTE_CLOSING_BALANCE ;
      quand MAR .. JEU => GENERATE_REPORT(TODAY);
      quand SAT .. SUN => null ;
   cas final ;

   le cas BIN_NUMBER(COUNT) est
      quand 1 => UPDATE_BIN(1);
      quand 2 => UPDATE_BIN(2);
      quand 3 | 4 =>
         EMPTY_BIN(1);
         EMPTY_BIN(2);
      quand d'autres => déclenchent ERROR ;
   cas final ;

Remarques:

L'exécution d'un énoncé de cas choisit une et une seule alternative,
puisque les choix sont exhaustifs et mutuellement exclusifs. Qualification de
l'expression d'une instruction case par un sous-type statique peut souvent être utilisée pour
limiter le nombre de choix qui doivent être donnés explicitement.

Un autre choix est requis dans une instruction case si le type de
expression est du type universal_integer (par exemple, si l'expression est
un littéral entier), puisque c'est le seul moyen de couvrir toutes les valeurs du
tapez universal_integer.

Références : type de base 3.3, choix 3.7.3, contexte de résolution de surcharge
8.7, type discret 3.5, expression 4.4, appel de fonction 6.4, formel générique
type 12.1, conversion 4.6, type discret 3.5, littéral d'énumération 3.5.1,
expression 4.4, nom 4.1, objet 3.2.1, surcharge 6.6 8.7, qualifié
expression 4.7, séquence d'instructions 5.1, plage discrète statique 4.9,
sous-type statique 4.9, sous-type 3.3, type 3.3, conversion de type 4.6, marque de type 3.3.2                                                   

5.5 Instructions de boucle 

Une instruction de boucle comprend une séquence d'instructions qui doivent être exécutées
à plusieurs reprises, zéro ou plusieurs fois.

   déclaration_boucle ::=
      [loop_simple_name :]  
         boucle [iteration_scheme]
            séquence_of_statements
          fin de la boucle [loop_simple_name] ;

   iteration_scheme ::= condition while
      | pour boucle_paramètre_spécification

   loop_parameter_spécification ::=
      identifiant dans [reverse] discrete_range

Si une instruction de boucle a un nom de boucle simple, ce nom simple doit être donné
aussi bien au début qu'à la fin.

Une instruction de boucle sans schéma d'itération spécifie une exécution répétée
de la séquence d’énoncés. L'exécution de l'instruction de boucle est terminée
lorsque la boucle est quittée suite à l'exécution d'une sortie
déclaration, ou à la suite d’un autre transfert de contrôle (voir 5.1).

Pour une instruction de boucle avec un schéma d'itération while, la condition est
évalué avant chaque exécution de la séquence d'instructions ; si la
Si la valeur de la condition est VRAIE, la séquence d'instructions est exécutée si
FALSE l'exécution de l'instruction de boucle est terminée.

Pour une instruction de boucle avec un schéma d'itération for, le paramètre de boucle
la spécification est la déclaration du paramètre de boucle avec le paramètre donné
identifiant. Le paramètre de boucle est un objet dont le type est le type de base de
la gamme discrète (voir 3.6.1). Dans la séquence de déclarations, le
Le paramètre de boucle est une constante. Par conséquent, un paramètre de boucle n'est pas autorisé car
(côté gauche) variable d’une instruction d’affectation. De même la boucle
Le paramètre ne doit pas être donné comme paramètre out ou in out d’une procédure ou
instruction d'appel d'entrée, ou comme paramètre in out d'une instanciation générique.

Pour l'exécution d'une instruction de boucle avec un schéma d'itération for, la boucle
la spécification des paramètres est d’abord élaborée. Cette élaboration crée le
paramètre de boucle et évalue la plage discrète.

Si la plage discrète est une plage nulle, l'exécution de l'instruction de boucle  
est complet. Sinon, la séquence d'instructions est exécutée une fois pour
chaque valeur de la plage discrète (sous réserve que la boucle ne soit pas laissée en tant que
conséquence de l’exécution d’une déclaration de sortie ou à la suite de
un autre transfert de contrôle). Avant chacune de ces itérations, le
la valeur correspondante de la plage discrète est attribuée à la boucle
paramètre. Ces valeurs sont attribuées par ordre croissant sauf si
le mot réservé reverse est présent, auquel cas les valeurs sont affectées dans
ordre décroissant.   

Exemple d'instruction de boucle sans schéma d'itération :

   boucle
      OBTENIR(CURRENT_CHARACTER);
      quitter lorsque CURRENT_CHARACTER = '*' ;
   terminer la boucle ;                                                                                     

Exemple d'instruction de boucle avec un schéma d'itération while :

   while BID(N).PRICE < boucle CUT_OFF.PRICE
      RECORD_BID(BID(N).PRICE);
      N := N + 1 ;
   terminer la boucle ; 

Exemple d'instruction de boucle avec un schéma d'itération for :

   pour J dans la boucle BUFFER'RANGE -- légal même avec une plage nulle
      si TAMPON(J) /= ESPACE alors
         METTRE(TAMPON(J));
      fin si;
   terminer la boucle ; 

Exemple d'instruction de boucle avec un nom de boucle simple :

   ADDITION:
      while NEXT /= boucle HEAD -- voir 3.8
         SOMME := SOMME + VALEUR SUIVANTE ;
         SUIVANT := SUIVANT.SUCC;
      fin de la boucle SUMMATION ; 

Remarques:

La portée d'un paramètre de boucle s'étend de la spécification du paramètre de boucle
à la fin de l'instruction de boucle, et les règles de visibilité sont telles qu'un
Le paramètre de boucle n’est visible que dans la séquence d’instructions de la boucle.

La plage discrète d'une boucle for n'est évaluée qu'une seule fois. Utilisation du
le mot réservé reverse ne modifie pas la plage discrète, de sorte que le
les schémas d'itération suivants ne sont pas équivalents ; le premier a un nul
gamme.

   pour J en marche arrière 1 .. 0
   pour J en 0 .. 1

Les noms de boucles sont également utilisés dans les instructions de sortie et dans les noms développés (dans un
préfixe du paramètre de boucle). 

Références : paramètre réel 6.4.1, instruction d'affectation 5.2, type de base
3.3, limite d'un intervalle 3.5, condition 5.3, constante 3.2.1, contexte de
résolution de surcharge 8,7, conversion 4,6, déclaration 3,1, plage discrète
3.6.1, élaboration 3.1, énoncé d'appel d'entrée 9.5, évaluation 4.5, sortie
instruction 5.7, nom étendu 4.1.3, fausse valeur booléenne 3.5.3, générique
paramètre réel 12.3, instanciation générique 12.3, instruction goto 5.9,
identifiant 2.3, type entier 3.5.4, plage nulle 3.5, objet 3.2.1, préfixe
4.1, appel de procédure 6.4, levée d'exceptions 11, mot réservé 2.9,
instruction return 5.8, portée 8.2, séquence d'instructions 5.1, nom simple
4.1, terminez l'alternative 9.7.1, vraie valeur booléenne 3.5.3 3.5.4, 
visibilité 8.3                                                                                    

5.6 Instructions de bloc 

Une instruction block contient une séquence d'instructions éventuellement précédées de
une partie déclarative et éventuellement suivie de gestionnaires d'exceptions.

   block_statement ::=
      [block_simple_name :]
         [déclarer
              partie déclarative]
          commencer
              séquence_of_statements
         [exception  
              exception_handler
             {exception_handler}]
          fin [block_simple_name] ;

Si une instruction de bloc a un nom simple de bloc, ce nom simple doit être
donné au début et à la fin.

L'exécution d'une instruction de bloc consiste en l'élaboration de son
partie déclarative (le cas échéant) suivie de l'exécution de la séquence de
déclarations. Si l'instruction block comporte des gestionnaires d'exceptions, ces services
les exceptions correspondantes qui sont soulevées lors de l'exécution du
séquence d’instructions (voir 11.2).

Exemple:

   ÉCHANGER:
      déclarer
         TEMP : ENTIER;
      commencer
         TEMP := V; V := U; U := TEMP ;
      mettre fin à l'échange ;

Remarques:

Si les objets de tâche sont déclarés dans une instruction de bloc dont l'exécution est
terminée, l'instruction block n'est pas laissée jusqu'à ce que toutes ses tâches dépendantes
sont terminés (voir 9.4). Cette règle s'applique également à un achèvement provoqué par
une instruction exit, return ou goto ; ou par la levée d'une exception.

Dans une instruction de bloc, le nom du bloc peut être utilisé dans les noms développés
désignant des entités locales telles que SWAP.TEMP dans l'exemple ci-dessus (voir 4.1.3
(F)).

Références : partie déclarative 3.9, tâche dépendante 9.4, gestionnaire d'exceptions
11.2, instruction de sortie 5.7, nom étendu 4.1.3, instruction goto 5.9, augmentation
d'exceptions 11, instruction return 5.8, séquence d'instructions 5.1, simple
nom 4.1, objet de tâche 9.2      

5.7 Déclarations de sortie 

Une instruction de sortie est utilisée pour terminer l'exécution d'une boucle englobante
instruction (appelée la boucle dans ce qui suit) ; l'achèvement est conditionnel
si l'instruction de sortie inclut une condition.

   déclaration_de sortie ::=
      exit [loop_name] [quand condition] ;

Une instruction de sortie avec un nom de boucle n'est autorisée que dans la boucle nommée, 
et s'applique à cette boucle ; une instruction de sortie sans nom de boucle est seulement
autorisé dans une boucle et s'applique à la boucle englobante la plus interne (que ce soit
nommé ou non). De plus, une instruction de sortie qui s'applique à une boucle donnée
ne doit pas apparaître dans le corps d'un sous-programme, d'un package, d'une tâche, d'un corps générique.
body, ou une instruction accept, si cette construction est elle-même entourée par le
boucle donnée.

Pour l'exécution d'une instruction de sortie, la condition, si présente, est la première
évalué. La sortie de la boucle a alors lieu si la valeur est VRAIE ou si
il n'y a aucune condition.

Exemples:

   pour N en 1 .. boucle MAX_NUM_ITEMS
      GET_NEW_ITEM(NEW_ITEM);
      MERGE_ITEM(NEW_ITEM, STORAGE_FILE);
      quitter quand NEW_ITEM = TERMINAL_ITEM ;
   terminer la boucle ;

   MAIN_CYCLE :
      boucle
         -- déclarations initiales
         quitter MAIN_CYCLE lorsque TROUVÉ ;
         -- déclarations finales
      terminer la boucle MAIN_CYCLE ;

Note:

Plusieurs boucles imbriquées peuvent être quittées par une instruction exit qui nomme le
boucle externe.

Références : accepter la déclaration 9.5, condition 5.3, évaluation 4.5, générique
corps 12.1, nom de boucle 5.5, instruction de boucle 5.5, corps du package 7.1, sous-programme
corps 6.3, vraie valeur booléenne 3.5.3   

5.8 Déclarations de retour 

Une instruction return est utilisée pour terminer l'exécution de l'instruction la plus interne.
englobant une fonction, une procédure ou une instruction accept.  

   return_statement ::= return [expression];

Une instruction return n'est autorisée que dans le corps d'un sous-programme ou
sous-programme générique, ou dans une instruction accept, et s'applique au
la plus intérieure (enfermant) une telle construction ; une déclaration de retour n'est pas autorisée
dans le corps d'une unité de tâches, d'un package ou d'un package générique entouré par
cette construction (en revanche, elle est autorisée au sein d'un composé  
instruction incluse dans cette construction et, en particulier, dans un bloc
déclaration).                                                                                       

Une instruction return pour une instruction accept ou pour le corps d'une procédure
ou une procédure générique ne doit pas inclure d’expression. Une déclaration de retour
car le corps d’une fonction ou d’une fonction générique doit inclure une expression.

La valeur de l'expression définit le résultat renvoyé par la fonction.
Le type de cette expression doit être le type de base de la marque de type donnée
après le mot réservé return dans la spécification de la fonction ou
fonction générique (cette marque de type définit le sous-type du résultat).

Pour l'exécution d'une instruction return, l'expression (le cas échéant) est d'abord
évalué et une vérification est effectuée que la valeur appartient au sous-type de résultat.
L'exécution de l'instruction return est ainsi terminée si le contrôle
réussit; il en va de même pour l'exécution du sous-programme ou de l'acceptation
déclaration. L'exception CONSTRAINT_ERROR est levée à l'endroit du
return instruction si la vérification échoue.

Exemples:

   retour; -- dans une procédure
   retourner KEY_VALUE (LAST_INDEX); -- dans une fonction

Note:

Si l'expression est soit un littéral numérique, soit un nombre nommé, ou encore un
attribut qui donne un résultat de type universal_integer ou universal_real,
puis une conversion implicite du résultat est effectuée comme décrit dans
paragraphe 4.6. 

Références : accept instruction 9.5, attribut A, block instruction 5.6,
exception constraint_error 11.1, expression 4.4, corps de fonction 6.3,
appel de fonction 6.4, corps générique 12.1, conversion de type implicite 4.6, nommé  
numéro 3.2, littéral numérique 2.4, corps du package 7.1, corps de la procédure 6.3,
mot réservé 2.9, sous-type de résultat 6.1, corps du sous-programme 6.3, sous-programme
spécification 6.1, sous-type 3.3, corps de tâche 9.1, marque de type 3.3.2,
type universel_entier 3.5.4, type universel_réel 3.5.6  

5.9 Instructions Goto 

Une instruction goto spécifie un transfert explicite de contrôle depuis ce
instruction à une instruction cible nommée par une étiquette.

   goto_statement ::= goto label_name ;

La séquence d'instructions la plus interne qui entoure l'instruction cible
doit également joindre l'instruction goto (notez que l'instruction goto peut être un
énoncé d'une séquence interne). De plus, si une instruction goto est
entouré d'une instruction d'acceptation ou du corps d'une unité de programme, alors le
l'instruction target ne doit pas être en dehors de cette construction englobante ; inversement,
il découle de la règle précédente que si l'instruction cible est entourée
par une telle construction, alors l'instruction goto ne peut pas être à l'extérieur.  

L'exécution d'une instruction goto transfère le contrôle à la cible nommée
déclaration.                                                      

Note:

Les règles ci-dessus permettent le transfert de contrôle à une déclaration d'une société englobante
séquence d’instructions mais pas l’inverse. De même, ils interdisent
transferts de contrôle, par exemple entre alternatives d'un énoncé de cas, si
instruction ou instruction select ; entre les gestionnaires d'exceptions ; ou d'un
gestionnaire d'exceptions d'une trame retournant à la séquence d'instructions de ce
cadre.

Exemple: 

   <<COMPARER>>
      si A(I) < ÉLÉMENT alors
         si GAUCHE(I) /= 0 alors
            Je := GAUCHE(Je);
            allez à COMPARER ;
         fin si;
         -- quelques déclarations
      fin si; 

Références : instruction accept 9.5, instruction block 5.6, instruction case 5.4,
instruction composée 5.1, gestionnaire d'exceptions 11.2, cadre 11.2, corps générique
12.1, si l'instruction 5.3, l'étiquette 5.1, le corps du package 7.1, l'unité de programme 6, sélectionnez
instruction 9.7, séquence d'instructions 5.1, instruction 5.1, corps du sous-programme
6.3, corps de mission 9.1, transfert de contrôle 5.1                                                      

