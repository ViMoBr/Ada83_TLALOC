//  root	=>	xd_high_page	: num_val,
//		xd_user_root	: user_root,
//		xd_source_list	: Seq Of sourceline,
//		xd_err_count	: num_val,
//		spare_1 	: void;

##  root	====>									--| Action sur root
##	call	user_root	@ xd_user_root  root					--| appliquer l'action user_root sur le champ xd_user_root
--|.................................................................................................


//  user_root		=>
//  	xd_sourcename	: txtrep,
//	xd_grammar	: void,
//	xd_statelist	: void,
//	xd_structure	: compilation,
//	xd_timestamp	: Integer,
//	spare_3	: void;

##  user_root	====>								--| Action sur user_root
##	call	compilation	@ xd_structure	user_root				--| Appliquer l'action compilation sur le champ xd_structure
--|.................................................................................................


//  compilation		=>
//	as_compltn_unit_s	: compltn_unit_s;

##  compilation	====>								--| Action sur compilation
##	call	compltn_unit_s	@ as_compltn_unit_s compilation			--| Appliquer l'action compltn_unit_s sur le champ as_compltn_unit_s
--|.................................................................................................


//  compltn_unit_s		=>
//	as_list	: Seq Of compilation_unit;

##  compltn_unit_s	====>								--| ACTION SUR LA LISTE DES UNITES DE COMPILATION

##  repeat_extract	compltn_unit_s	compltn_unit					--| EXTRACTION D UN ELEMENT
##  include	    EMITS.OPEN_OUTPUT_FILE ( GET_LIB_PREFIX & PRINT_NAME ( D ( XD_LIB_NAME, COMPLTN_UNIT ) ) );
##  call	compilation_unit	compltn_unit						--| ACTION COMPILATION_UNIT SUR L UNITE EXTRAITE
##  include	    EMITS.CLOSE_OUTPUT_FILE;						--| FERMER LE FICHIER
--|.................................................................................................


//  compilation_unit	=>
//	as_context_elem_s	: context_elem_s,
//	as_all_decl	: ALL_DECL,
//	as_pragma_s	: pragma_s,
//	xd_timestamp	: Integer,
//	xd_with_list	: Seq Of trans_with,
//	xd_nbr_pages	: Integer,
//	xd_parent		: compilation_unit,
//	xd_lib_name	: symbol_rep;

##  compilation_unit	====>							--| ACTION SUR compilation_unit

##  include	EMITS.TOP_ACT := 0;							--| HAUT DE PILE A ZERO
##  include	EMITS.TOP_MAX := 0;							--| HAUT MAXIMAL DE PILE AUSSI
##  include	EMITS.OFFSET_ACT := 0;						--| DECALAGE SUR PILE A ZERO
##  include	EMITS.OFFSET_MAX := 0;						--| DECALAGE MAX AUSSI
##  include	EMITS.LEVEL := 0;							--| NIVEAU D IMBRICATION ZERO
##  include	EMITS.GENERATE_CODE := FALSE;						--| NE PAS GENERER ENCORE LE CODE
##  include	EMITS.CUR_COMP_UNIT := 2;						--| UNITE DE COMPILATION NUMERO 2 (STANDARD ET SYSTEM AVANT)
##  include	EMITS.ENCLOSING_BODY := Tree_VOID;					--| PAS D ENGLOBANT
##  call	context_elem_s	@ as_context_elem_s	compilation_unit				--| TRAITER LA LISTE DE CONTEXTE (PRAGMA ET WITH)
##  include	EMITS.CUR_COMP_UNIT := 0;						--| SE REPLACER SUR L UNITE 0 (STANDARD)
##  include	EMITS.GENERATE_CODE := TRUE;						--| GENERER LE CODE
##  call	ALL_DECL	@ as_all_decl	compilation_unit					--| APPLIQUER L ACTION ALL_DECL SUR LE CHAMP as_all_decl
##  include	EMIT ( QUIT );
--|.................................................................................................


//  context_elem_s		=>
//	as_list	: Seq Of CONTEXT_ELEM;

##  context_elem_s	====>

##	repeat_extract	context_elem_s	context_elem
##	call	CONTEXT_ELEM	context_elem
--|.................................................................................................


//  CONTEXT_ELEM		::=
//	context_pragma;
//  CONTEXT_ELEM		::=
//	with;

##  CONTEXT_ELEM	====>

##	if	context_pragma
##	call	context_pragma	CONTEXT_ELEM
##	if	with
##	call	with	CONTEXT_ELEM
--|.................................................................................................


//  context_pragma		=>
//	as_pragma	: pragma;

##  context_pragma	====>

##	include	null;
--|.................................................................................................


--|.................................................................................................
//  with		=>
//	as_name_s	: name_s,
//	as_use_pragma_s	: use_pragma_s;
--	lx_srcpos	:Source_Position

##  with	====>
##	call	name_s	@ as_NAME_S	with
--|.................................................................................................


--					---------------------
--					ALL_SOURCE > ALL_DECL
--					---------------------

//  ALL_DECL		::=
//	subunit | block_master | ITEM;
--|.................................................................................................

## ALL_DECL	====>								--| Action sur ALL_DECL

##	if_class	ITEM								--| Si dans classe ITEM
##	call	ITEM		ALL_DECL						--| Appliquer l'action sur ITEM au paramètre ALL_DECL
##	if	subunit								--| Si subunit
##	call	subunit		ALL_DECL						--| Appliquer l'action subunit au paramètre ALL_DECL
##	if	block_master							--| Si subunit
##	call	block_master	ALL_DECL						--| Appliquer l'action subunit au paramètre ALL_DECL
--|.................................................................................................

//  subunit		=>
//	as_name	: NAME,
//	as_subunit_body	: SUBUNIT_BODY;

##  subunit	====>
##	call	SUBUNIT_BODY	@ as_subunit_body	subunit
--|.................................................................................................


//  block_master		=>
//	sm_stm	: STM;
##  block_master	====>
##	include	null;
--|.................................................................................................


--					----------------------------
--					ALL_SOURCE > ALL_DECL > ITEM
--					----------------------------

//  item_s		=>
//	as_list	: Seq Of ITEM;

##  item_s	====>

##	repeat_extract	item_s	item
##	call	ITEM	item
--|.................................................................................................

//  ITEM		::=
//	 | SUBUNIT_BODY | DECL | DSCRMT_PARAM_DECL;

##  ITEM	====>									--| Action sur ITEM
##	if_class	DECL								--| Si dans classe DECL
##	call	DECL	ITEM							--| Appliquer l'action DECL au paramètre ITEM
##	if_class	SUBUNIT_BODY							--| Si dans classe SUBUNIT_BODY
##	call	SUBUNIT_BODY	ITEM						--| Appliquer l'action subunit_body au paramètre ITEM
--|.................................................................................................

//  SUBUNIT_BODY		::=
//	subprogram_body | package_body | task_body;
//  SUBUNIT_BODY		=>
//	as_source_name	: SOURCE_NAME,
//	as_body	: BODY;

##  SUBUNIT_BODY	====>

##  include	DECLARE
##  include	   POST_LBL : LABEL_TYPE;						--| ETIQUETTE EVENTUELLE POUR L APRES CORPS
##  include	BEGIN
##  include	  IF ENCLOSING_BODY /= TREE_VOID THEN					--| S IL Y A UN CORPS ENGLOBANT
##  include	    POST_LBL := NEXT_LABEL;						--| ALLOUER L ETIQUETTE DE FIN DE CORPS SOUS UNITE
##  include	    EMIT ( JMP, POST_LBL, COMMENT=> "CONTOURNEMENT" );			--| Y SAUTER
##  include	  END IF;

##  if	subprogram_body
##  call	subprogram_body	SUBUNIT_BODY

##  if	package_body
##  call	package_body	SUBUNIT_BODY

##  if	task_body
##  call	task_body	SUBUNIT_BODY

##  end_if

##  include	  IF ENCLOSING_BODY /= TREE_VOID THEN
##  include	    WRITE_LABEL ( POST_LBL, COMMENT=> "FIN DE CONTOURNEMENT" );
##  include	  END IF;
##  include	END;

--|.................................................................................................

//  subprogram_body		=>
//	as_header		: HEADER;
--	as_source_name	: SOURCE_NAME
--	as_body		: BODY
--	lx_srcpos		: Source_Position

##  subprogram_body	====>

##  include	DECLARE
##  include	   OLD_OFFSET_ACT : OFFSET_TYPE := EMITS.OFFSET_ACT;			--| GARER LES DECALAGES DE L ENGLOBANT
##  include	   OLD_OFFSET_MAX : OFFSET_TYPE := EMITS.OFFSET_MAX;
##  include	   SOURCE_NAME    : TREE := D ( AS_SOURCE_NAME, SUBPROGRAM_BODY );		--| RAMENER LE NOM DE SOUS PROGRAMME
##  include	   START_LABEL    : LABEL_TYPE := NEXT_LABEL;				--| ALLOUER UNE ETIQUETTE DE POINT D ENTREE
##  include	BEGIN
##  include	  IF EMITS.ENCLOSING_BODY = TREE_VOID THEN				--| Au niveau externe (pas d'imbrication)
##  include	    EMIT ( PRO, S=> PRINT_NAME ( D ( LX_SYMREP, SOURCE_NAME ) ) );		--| Indiquer la mention "PRO"
##  include	  END IF;
##  include	  EMITS.OFFSET_ACT := EMITS.FIRST_PARAM_OFFSET;				--| LIEU DU PREMIER PARAMETRE COMME DECALAGE ACTUEL
##  include	  EMITS.OFFSET_MAX := EMITS.OFFSET_ACT;					--| ET DECALAGE MAXIMAL ACTUEL
##  include	  INC_LEVEL;							--| NIVEAU STATIQUE SUIVANT
##  include	  DI ( CD_LABEL, SOURCE_NAME, INTEGER ( START_LABEL ) );			--| STOCKER LE NUMERO D ETIQUETTE ENTREE
##  include	  DI ( CD_LEVEL, SOURCE_NAME, EMITS.LEVEL );				--| STOCKER LE NIVEAU STATIQUE
##  include	  WRITE_LABEL ( START_LABEL );					--| EMETTRE L ETIQUETTE ENTREE
##  call	HEADER	@ as_header	subprogram_body					--| TRAITER LES PARAMETRES D APPEL
##  include	  DI ( CD_PARAM_SIZE, SOURCE_NAME, PARAM_SIZE );				--| STOCKER LA TAILLE DU PARAMETRAGE MAINTENANT CONNUE
##  include	  EMITS.OFFSET_ACT := EMITS.FIRST_LOCAL_VAR_OFFSET;			--| REPLACER LES OFFSETS SUR LA PREMIERE VARIABLE LOCALE
##  include	  EMITS.OFFSET_MAX := EMITS.OFFSET_ACT;
##  call	BODY	@ as_BODY	subprogram_body						--| TRAITER LE CORPS DE SOUS PROGRAMME
##  include	  DEC_LEVEL;							--| REVENIR AU NIVEAU PRECEDENT
##  include	  EMITS.OFFSET_MAX := OLD_OFFSET_MAX;					--| RESTAURER LES OFFSETS ANTERIEURS
##  include	  EMITS.OFFSET_ACT := OLD_OFFSET_ACT;
##  include	END;
--|.................................................................................................

//  package_body		=> ;

##  package_body	====>

##  include	EMIT ( PKB, S=> PRINT_NAME ( D ( LX_SYMREP, D ( AS_SOURCE_NAME, PACKAGE_BODY ) ) ) );
##  include	EMITS.GENERATE_CODE := FALSE;
##  call	package_spec	@ sm_spec @ as_source_name package_body
##  include	EMITS.GENERATE_CODE := TRUE;
##  include	WRITE_LABEL ( 1 );
##  call	BODY	@ as_body  package_body
--|.................................................................................................

//  task_body		=> ;

##  task_body	====>

##	include	null;
--|.................................................................................................


--					-----------------------------------
--					ALL_SOURCE > ALL_DECL > ITEM > DECL
--					-----------------------------------

//  DECL		::=
//	null_comp_decl | ID_DECL | ID_S_DECL | REP | USE_PRAGMA;
--|.................................................................................................

##  DECL	====>

##	if	null_comp_decl
##	call	null_comp_decl	DECL
##	if_class	ID_DECL
##	call	ID_DECL		DECL
##	if_class	ID_S_DECL
##	call	ID_S_DECL		DECL
##	if_class	REP
##	call	REP		DECL
##	if_class	USE_PRAGMA
##	call	USE_PRAGMA	DECL
--|.................................................................................................

//  null_comp_decl		=> ;

##  null_comp_decl	====>

##	include	null;
--|.................................................................................................


--					---------------------------------------------
--					ALL_SOURCE > ALL_DECL > ITEM > DECL > ID_DECL
--					---------------------------------------------


//  ID_DECL		::=
//	type_decl | subtype_decl | task_decl | SIMPLE_RENAME_DECL | UNIT_DECL;
//  ID_DECL		=>
//	as_source_name	: SOURCE_NAME;

##  ID_DECL	====>

##	if	type_decl
##	call	type_decl		ID_DECL
##	if	subtype_decl
##	call	subtype_decl	ID_DECL
##	if	task_decl
##	call	task_decl		ID_DECL
##	if_class	UNIT_DECL
##	call	UNIT_DECL		ID_DECL
##	if_class	SIMPLE_RENAME_DECL
##	call	SIMPLE_RENAME_DECL	ID_DECL
--|.................................................................................................

//  type_decl		=>
//	as_dscrmt_decl_s	: dscrmt_decl_s,
//	as_type_def	: TYPE_DEF;

##  type_decl	====>

## include	DECLARE
## include	  TYPE_DEF  : TREE := D ( AS_TYPE_DEF, TYPE_DECL );
## include	  TYPE_ID   : TREE := D ( AS_SOURCE_NAME, TYPE_DECL );
## include	  TYPE_SPEC : TREE := D ( SM_TYPE_SPEC, TYPE_ID );
## include	  ------------------------------------------------------------------------------
## include	  PROCEDURE COMPILE_ENUMERATION_DEF ( ENUMERATION_DEF :TREE ) IS
## include	    ENUM_LITERAL_S  : TREE     := D ( AS_ENUM_LITERAL_S, ENUMERATION_DEF );
## include	    LITERAL_SEQ     : SEQ_TYPE := LIST ( ENUM_LITERAL_S );
## include	    LITERAL         : TREE;
## include	  BEGIN
## include	    WHILE NOT IS_EMPTY ( LITERAL_SEQ ) LOOP				--| TANT QU IL Y A DES ELEMENTS
## include	      POP ( LITERAL_SEQ, LITERAL );					--| EN EXTRAIRE UN
## include	    END LOOP;
## include	    DI ( CD_LAST, ENUM_LITERAL_S, DI ( SM_REP, LITERAL ) );			--| STOCKER LA VALEUR DU DERNIER
## include	  END;
## include	  ------------------------------------------------------------------------------
## include	  PROCEDURE COMPILE_INTEGER_DEF ( INTEGER_DEF, INTEGER_SPEC :TREE ) IS
## include	    LOWER      : OFFSET_TYPE;						--| LIEU DE LA BORNE BASSE
## include	    UPPER      : OFFSET_TYPE;						--| LIEU DE LA BORNE HAUTE
## include	    INT_RANGE  : TREE := D ( AS_CONSTRAINT, INTEGER_DEF );			--| ETENDUE DU TYPE ENTIER
## include	    EXP_BORNE  : TREE;
## include	  BEGIN
## include	    ALIGN ( INTG_AL );						--| ALIGNER LE SOMMET DE PILE POUR UN ENTIER
## include	    LOWER := - EMITS.OFFSET_ACT;					--| LIEU DE LA BORNE BASSE
## include	    INC_OFFSET ( INTG_SIZE );						--| ALLER AU LIEU LIBRE SUIVANT L'ENTIER
## include	    UPPER := - EMITS.OFFSET_ACT;					--| LIEU DE LA BORNE HAUTE
## include	    INC_OFFSET ( INTG_SIZE );						--| ALLER AU LIEU LIBRE SUIVANT L'ENTIER
      
## include	    DI ( CD_OFFSET, INTEGER_SPEC, LOWER );				--| LIEU DES BORNES
## include	    DI ( CD_LEVEL, INTEGER_SPEC, EMITS.LEVEL );				--| NIVEAU STATIQUE DE LA DEFINITION
## include	    DI ( CD_COMP_UNIT, INTEGER_SPEC, CUR_COMP_UNIT );			--| UNITE PARENTE
## include	    DB ( CD_COMPILED, INTEGER_SPEC, TRUE );				--| DEFINITION TRAITEE
## include	    EXP_BORNE := D ( AS_EXP1, INT_RANGE );				--| EXPRESSION BORNE BASSE
## call	EXP	EXP_BORNE								--| GENERER LE CODE DE CALCUL DE L'EXPRESSION DE BORNE BASSE
## include	    GEN_STORE ( I, EMITS.CUR_COMP_UNIT, EMITS.LEVEL, LOWER, "BORNE BASSE" );	--| STOCKER LE RÉSULTAT DANS LA BORNE BASSE
## include	    EXP_BORNE := D ( AS_EXP2, INT_RANGE );				--| EXPRESSION BORNE HAUTE
## call	EXP	EXP_BORNE								--| GENERER LE CODE DE CALCUL DE L'EXPRESSION DE BORNE HAUTE
## include	    GEN_STORE ( I, EMITS.CUR_COMP_UNIT, EMITS.LEVEL, UPPER, "BORNE HAUTE" );	--| STOCKER LE RÉSULTAT DANS LA HAUTE
## include	  END COMPILE_INTEGER_DEF;
## include	  ------------------------------------------------------------------------------
## include	  PROCEDURE COMPILE_CONSTRAINED_ARRAY_DEF ( TYPE_DEF, TYPE_SPEC :TREE ) IS
## include	    DIMENSIONS_NBR     : NATURAL  := 0;
## include	    SUBTYPE_INDICATION : TREE     := D ( AS_SUBTYPE_INDICATION, TYPE_DEF );	--| SOUS TYPE DE L'ELEMENT
## include	    USED_NAME_ID       : TREE     := D ( AS_NAME, SUBTYPE_INDICATION );
## include	    COMP_TYPE_ID       : TREE     := D ( SM_DEFN, USED_NAME_ID );
## include	    COMP_TYPE          : TREE     := D ( SM_TYPE_SPEC, COMP_TYPE_ID );	--| TYPE_SPEC DU TYPE D'ELEMENT
## include	    INDEX_CONSTRAINT   : TREE     := D ( AS_CONSTRAINT, TYPE_DEF );		--| LA CONTRAINTE DE DEFINITION DU TYPE TABLEAU
## include	    DISCRETE_RANGE_S   : TREE     := D ( AS_DISCRETE_RANGE_S, INDEX_CONSTRAINT );
## include	    DISCRETE_RANGE_SEQ : SEQ_TYPE := LIST ( DISCRETE_RANGE_S );		--| LA SEQUENCE DES INDICAGES
         
## include	    --|-------------------------------------------------------------------------
## include	    PROCEDURE INSTALL_ARRAY_DIMENSION ( DISCRETE_RANGE_SEQ :IN OUT SEQ_TYPE ) IS
## include	      IDXFAC, FIRST, LAST : OFFSET_TYPE;
## include	      DISCRETE_RANGE      : TREE;
## include	    BEGIN
## include	      DIMENSIONS_NBR := DIMENSIONS_NBR + 1;				--| UNE DIMENSION DE PLUS
## include	      ALIGN ( INTG_AL );						--| ALIGNER LE LIEU POUR UN ENTIER
## include	      IDXFAC := - EMITS.OFFSET_ACT;					--| LIEU DU FACTEUR DE L'INDICE (POUR PASSER D'UN ÉLÉMENT AU SUIVANT)
## include	      FIRST := IDXFAC - INTG_SIZE;					--| LIEU DE L'INDICE BAS
## include	      LAST := FIRST - INTG_SIZE;					--| LIEU DE L'INDICE HAUT
## include	      INC_OFFSET ( 3*INTG_SIZE );					--| MONTER LE LIEU LIBRE A 3 ENTIERS PLUS LOIN
            
## include	      POP ( DISCRETE_RANGE_SEQ, DISCRETE_RANGE );				--| EXTRAIRE L'INDIÇAGE DE CETTE DIMENSION
## include	      IF IS_EMPTY ( DISCRETE_RANGE_SEQ ) THEN				--| C'ETAIT LE DERNIER INDICAGE (INDICE "RAPIDE")
## include	        EMITS.LOAD_TYPE_SIZE ( COMP_TYPE );				--| EMPILER LA TAILLE DE L'ELEMENT
## include	        EMIT ( DPL, I, "DUPLICATE INDEX FACTOR" );			--| GENERER UNE DUPLICATION DE CETTE TAILLE
## include	        GEN_STORE ( I, 0, EMITS.LEVEL, IDXFAC, "STORE INDEX FACTOR" );	--| LA STOCKER COMME FACTEUR DE PASSAGE D'UN ELEMENT AU SUIVANT POUR CETTE DIMENSION
## include	      ELSE							--| C'EST UN INDICAGE INTERMEDIAIRE
## include	        INSTALL_ARRAY_DIMENSION ( DISCRETE_RANGE_SEQ );			--| TRAITER LA DIMENSION SUIVANTE
## include	        EMIT ( DPL, I, "DUPLICATE INDEX FACTOR" );			--| DUPLIQUER LE FACTEUR DE PASSAGE
## include	        GEN_STORE ( I, 0, EMITS.LEVEL, IDXFAC, "STORE INDEX FACTOR" );	--| LE STOCKER DANS LE DESCRIPTEUR DU TABLEAU
## include	      END IF;
            
## include	      IF DISCRETE_RANGE.TY = DN_DISCRETE_SUBTYPE THEN
## include	        DECLARE
## include	          SUBTYPE_INDICATION : TREE := D ( AS_SUBTYPE_INDICATION, DISCRETE_RANGE );
## include	        BEGIN
## include	          DISCRETE_RANGE := D ( AS_CONSTRAINT, SUBTYPE_INDICATION );
## include	          IF DISCRETE_RANGE.TY = DN_VOID THEN
## include	            DECLARE
## include	              USED_NAME_ID : TREE := D ( AS_NAME, SUBTYPE_INDICATION );
## include	              DEF_NAME     : TREE := D ( SM_DEFN, USED_NAME_ID );
## include	              TYPE_SPEC    : TREE := D ( SM_TYPE_SPEC, DEF_NAME );
## include	            BEGIN
## include	              DISCRETE_RANGE := D ( SM_RANGE, TYPE_SPEC );
## include	            END;
## include	          END IF;
## include	        END;
## include	      END IF;
         
## include	      IF DISCRETE_RANGE.TY = DN_RANGE_ATTRIBUTE THEN			--| CAS DU "SUBTYPE'RANGE"
## include	        DECLARE
## include	          TYPE_SPEC : TREE := D ( SM_TYPE_SPEC, DISCRETE_RANGE );		--| CHERCHER LE TYPE
## include	        BEGIN
## include	          DISCRETE_RANGE := D ( SM_RANGE, TYPE_SPEC );			--| REMPLACER LE DISCRETE RANGE PAR LE RANGE DU TYPE
## include	        END;
## include	      END IF;
            
## include	      IF DISCRETE_RANGE.TY = DN_RANGE THEN
## include	        DECLARE
## include	          EXP_BORNE : TREE := D ( AS_EXP1, DISCRETE_RANGE );
## include	        BEGIN
## call	EXP	EXP_BORNE								--| GENERER LE CODE DE CALCUL DE L'EXPRESSION DE BORNE BASSE
## include	          GEN_STORE ( I, EMITS.CUR_COMP_UNIT, EMITS.LEVEL, FIRST, "FIRST" );	--| LE STOCKER DANS LE DESCRIPTEUR
## include	          EXP_BORNE := D ( AS_EXP2, DISCRETE_RANGE );
## call	EXP	EXP_BORNE								--| GENERER LE CODE DE CALCUL DE L'EXPRESSION DE BORNE HAUTE
## include	          GEN_STORE ( I, EMITS.CUR_COMP_UNIT, EMITS.LEVEL, LAST, "LAST" );
## include	        END;

## include	        GEN_LOAD_ADDR ( 0, LEVEL, FIRST, "LOAD @FIRST" );			--| GENERER L'EMPILAGE DE L'ADRESSE DE LA SECTION DU DESCRIPTEUR POUR LA DIMENSION
## include	        EMIT ( LEN, "CALCULATE LENGTH" );				--| PROCEDURE DE CALCUL DU LENGTH(DIM)
## include	        EMIT ( MUL, I, "NEXT INDEX FACTOR = LEN * PREVIOUS FACTOR" );		--| LAISSER LE FACTEUR DE PASSAGE (LENGHTH*FACTEUR PRECEDENT) SUR LA PILE
## include	      ELSIF DISCRETE_RANGE.TY = DN_RANGE_ATTRIBUTE THEN
## include	        NULL;
## include	      ELSE
## include	        NULL;    							  -- DN_RANGE_ATTRIBUTE -- DN_DISCRETE_SUBTYPE
## include	        PUT_LINE ( "!!! COMPILE_TYPE_ARRAY_DIMENSION : DISCRETE_RANGE.TY ILLICITE " & NODE_NAME'IMAGE ( DISCRETE_RANGE.TY ) );
## include	        RAISE PROGRAM_ERROR;
## include	      END IF;
## include	    END INSTALL_ARRAY_DIMENSION;
         
## include	  BEGIN
## include	    ALIGN ( INTG_AL );						--| ALIGNER LE LIEU LIBRE POUR UN ENTIER
## include	    DI ( CD_LEVEL, TYPE_SPEC, EMITS.LEVEL );				--| STOCKER LE NIVEAU STATIQUE
## include	    DI ( CD_COMP_UNIT, TYPE_SPEC, EMITS.CUR_COMP_UNIT );			--| STOCKER L'UNITE COURANTE
## include	    DB ( CD_COMPILED, TYPE_SPEC, TRUE );				--| MARQUER COMME TRAITE
## include	    DECLARE
## include	      OFFSET : INTEGER := - EMITS.OFFSET_ACT;
## include	    BEGIN
## include	      DI ( CD_OFFSET, TYPE_SPEC, OFFSET );				--| STOCKER LE LIEU DU NOMBRE DE DIMENSIONS
## include	      INC_OFFSET ( INTG_SIZE );					--| MONTER AU LIEU LIBRE SUIVANT L'ENTIER
## include	      INSTALL_ARRAY_DIMENSION ( DISCRETE_RANGE_SEQ );			--| METTRE EN PLACE LES FACTEURS D'INDEXATION ET LES LIMITES D'INDICE
## include	      GEN_STORE ( I, EMITS.CUR_COMP_UNIT, EMITS.LEVEL, OFFSET,
## include	             "STORE ARRAY SIZE (LAST INDEX FACTOR)" );			--| GENERER LE STOCKAGE EN PILE DU NOMBRE DE DIMENSIONS
## include	      DI ( CD_DIMENSIONS, TYPE_SPEC, DIMENSIONS_NBR );			--| STOCKER AUSSI DANS LE TYPE_SPEC
## include	    END;
## include	  END COMPILE_CONSTRAINED_ARRAY_DEF;
## include	  ------------------------------------------------------------------------------
## include	  PROCEDURE COMPILE_ACCESS_DEF ( ACCESS_DEF, ACCESS_SPEC :TREE ) IS
## include	    POINTED_TYPE_SPEC : TREE    := D ( SM_DESIG_TYPE, ACCESS_SPEC );
## include	    CONTRAINT         : BOOLEAN := (POINTED_TYPE_SPEC.TY IN CLASS_CONSTRAINED);
## include	  BEGIN
## include	    DB ( CD_CONSTRAINED, ACCESS_SPEC, CONTRAINT );
      
## include	    IF CONTRAINT THEN
## include	      DI ( CD_LEVEL, ACCESS_SPEC, EMITS.LEVEL );				--| STOCKER LE NIVEAU STATIQUE DE LA DEFINITION
## include	      ALIGN ( INTG_AL );						--| ALIGNER LE LIEU LIBRE POUR UN ENTIER
## include	      DECLARE
## include	        OFFSET : OFFSET_TYPE := EMITS.OFFSET_ACT;
## include	      BEGIN
## include	        DI ( CD_OFFSET, ACCESS_SPEC, OFFSET );				--| STOCKER LE LIEU
## include	        INC_OFFSET ( INTG_SIZE );					--| MONTER AU LIEU SUIVANT L'ENTIER
## include	        EMITS.LOAD_TYPE_SIZE ( POINTED_TYPE_SPEC );			--| GENERER LE CHARGEMENT DE LA TAILLE DU TYPE POINTE
## include	        GEN_STORE ( I, 0, EMITS.LEVEL, OFFSET, "STORE POINTERD TYPE SIZE" );	--| LA STOCKER DANS LE LIEU RESERVE
## include	      END;
## include	    END IF;
## include	  END;
## include	  ------------------------------------------------------------------------------

## include	BEGIN
## include	  IF EMITS.CUR_COMP_UNIT /= 1 THEN					--| PAS LE STANDARD
## include	    CASE TYPE_DEF.TY IS
            
## include	    WHEN DN_ENUMERATION_DEF =>
## include	      COMPILE_ENUMERATION_DEF ( TYPE_DEF );
                  
## include	    WHEN DN_INTEGER_DEF =>						--| TYPE TRUC IS RANGE 1..10*U;
## include	      COMPILE_INTEGER_DEF ( TYPE_DEF, TYPE_SPEC );
            
## include	    WHEN DN_FLOAT_DEF =>
## include	      NULL;
            
## include	    WHEN DN_FIXED_DEF =>
## include	      NULL;
            
## include	    WHEN DN_CONSTRAINED_ARRAY_DEF =>
## include	      COMPILE_CONSTRAINED_ARRAY_DEF ( TYPE_DEF, TYPE_SPEC );
                  
## include	    WHEN DN_RECORD_DEF =>
## include	      NULL;
            
## include	    WHEN DN_ACCESS_DEF =>
## include	      COMPILE_ACCESS_DEF ( TYPE_DEF, TYPE_SPEC );
                  
## include	    WHEN DN_DERIVED_DEF =>
## include	      NULL;
                  
## include	    WHEN OTHERS =>
## include	      NULL;							-- DN_SUBTYPE_INDICATION -- DN_L_PRIVATE_DEF -- DN_PRIVATE_DEF -- DN_UNCONSTRAINED_ARRAY_DEF
## include                PUT_LINE ( "!!! COMPILE_TYPE_DECL : TYPE_SPEC.TY ILLICITE " & NODE_NAME'IMAGE ( TYPE_SPEC.TY ) );
## include	      RAISE PROGRAM_ERROR;
## include	    END CASE;
## include	  END IF;
## include	END;
--|.................................................................................................

//  subtype_decl		=>
//	as_subtype_indication	: subtype_indication;

##  subtype_decl	====>

##	include	null;
--|.................................................................................................

//  task_decl		=>
//	as_decl_s	: decl_s;

##  task_decl	====>

##	include	null;
--|.................................................................................................


--			------------------------------------------------------------------
--			ALL_SOURCE > ALL_DECL > ITEM > DECL > ID_DECL > SIMPLE_RENAME_DECL
--			------------------------------------------------------------------


//  SIMPLE_RENAME_DECL	::=
//	renames_obj_decl | renames_exc_decl;
//  SIMPLE_RENAME_DECL	=>
//	as_name	: NAME;

##  SIMPLE_RENAME_DECL	====>

##	if	renames_obj_decl
##	call	renames_obj_decl		SIMPLE_RENAME_DECL
##	if	renames_exc_decl
##	call	renames_exc_decl		SIMPLE_RENAME_DECL
--|.................................................................................................
//  renames_obj_decl	=>
//	as_type_mark_name	: NAME;

##  renames_obj_decl	====>

##	include	null;
--|.................................................................................................
//  renames_exc_decl	=> ;

##  renames_exc_decl	====>

##	include	null;
--|.................................................................................................


--			---------------------------------------------------------
--			ALL_SOURCE > ALL_DECL > ITEM > DECL > ID_DECL > UNIT_DECL
--			---------------------------------------------------------


//  UNIT_DECL	::=	generic_decl | NON_GENERIC_DECL;
//  UNIT_DECL	=>
//		as_header	: HEADER;

## UNIT_DECL	====>								--| Action sur UNIT_DECL

##	if	generic_decl							--| Si generic_decl
##	call	generic_decl	UNIT_DECL						--| Appliquer l'action generic_decl au paramètre DECL
##	if_class	NON_GENERIC_DECL							--| Si dans classe NON_GENERIC_DECL
##	call	NON_GENERIC_DECL	UNIT_DECL						--| Appliquer l'action NON_GENERIC_DECL au paramètre DECL
--|.................................................................................................

//  generic_decl		=>
//	as_item_s	: item_s;

##  generic_decl	====>

##	include	null;
--|.................................................................................................


--		----------------------------------------------------------------------------
--		ALL_SOURCE > ALL_DECL > ITEM > DECL > ID_DECL > UNIT_DECL > NON_GENERIC_DECL
--		----------------------------------------------------------------------------


//  NON_GENERIC_DECL	::=
//	subprog_entry_decl | package_decl;
//  NON_GENERIC_DECL	=>
//	as_unit_kind	: UNIT_KIND;

##  NON_GENERIC_DECL	====>							--| Action sur NON_GENERIC_DECL

##	if	subprog_entry_decl							--| Si subprog_entry_decl
##	call	subprog_entry_decl	NON_GENERIC_DECL					--| Appliquer l'action subprog_entry_decl sur le paramètre NON_GENERIC_DECL
##	if	package_decl							--| Si package_decl
##	call	package_decl	NON_GENERIC_DECL					--| Appliquer l'action package_decl sur le paramètre NON_GENERIC_DECL
--|.................................................................................................

//  subprog_entry_decl	=>;
--	as_source_name	:SOURCE_NAME
--	as_header	:HEADER
--	as_unit_kind	:UNIT_KIND
--	lx_srcpos	:Source_Position

##  subprog_entry_decl	====>							--| DECLARATION DE SOUS PROGRAMME

##  include	DECLARE
##  include	  OLD_OFFSET_ACT : OFFSET_TYPE := EMITS.OFFSET_ACT;			--| GARER LES OFFSETS DU NIVEAU SUPERIEUR
##  include	  OLD_OFFSET_MAX : OFFSET_TYPE := EMITS.OFFSET_MAX;
##  include	  SOURCE_NAME    : TREE        := D ( AS_SOURCE_NAME, SUBPROG_ENTRY_DECL );	--| RAMENER LE NOEUD NOM DU SOUS PROGRAMME
##  include	  HEADER         : TREE        := D ( AS_HEADER, SUBPROG_ENTRY_DECL );	--| RAMENER L ENTETE DE PARAMETRAGE
##  include	BEGIN
##  include	  EMITS.OFFSET_ACT := EMITS.FIRST_PARAM_OFFSET;				--| OFFSET DU PREMIER PARAMETRE COMME OFFSET DE PILE ACTUEL
##  include	  EMITS.OFFSET_MAX := EMITS.OFFSET_ACT;					--| OFFSET MAX MIS A L OFFSET ACTUEL
##  include	  INC_LEVEL;							--| NIVEAU STATIQUE SUIVANT

##  include	  IF SOURCE_NAME.TY IN CLASS_SUBPROG_NAME THEN
##  include	    DECLARE
##  include	      LBL : LABEL_TYPE := NEXT_LABEL;					--| ALLOUER UNE ETIQUETTE POUR LE SOUS PROGRAMME
##  include	    BEGIN
##  include	      DI ( CD_LABEL, SOURCE_NAME, INTEGER ( LBL ) );			--| INTEGRER CETTE ETIQUETTE AU NOM DU SOUS PROGRAMME
##  include	      DI ( CD_LEVEL, SOURCE_NAME, EMITS.LEVEL );				--| MENTIONNER AUSSI LE NIVEAU STATIQUE
##  include	      DB ( CD_COMPILED, SOURCE_NAME, TRUE );				--| INDIQUER QUE L ON VA AVOIR COMPILE CETTE DECLARATION
##  include	      IF NOT EMITS.GENERATE_CODE THEN					--| SI PAS DE GENERATION DE CODE
##  include	        EMITS.GENERATE_CODE := TRUE;					--| LA METTRE QUAND MEME
##  include	        EMIT ( RFL, LBL );						--| POUR EMETTRE CETTE REFERENCE D ETIQUETTE
##  include	        EMITS.GENERATE_CODE := FALSE;					--| ET REMETTRE COMME AVANT
##  include	      END IF;

##  call	HEADER	@ as_header	subprog_entry_decl					--| TRAITER L ENTETE DE PARAMETRAGE

##  include	      DI ( CD_PARAM_SIZE, SOURCE_NAME, OFFSET_ACT - FIRST_PARAM_OFFSET );	--| APRES TRAITEMENT DE L ENTETE ON A LA TAILLE DU PARAMETRAGE QUE L ON STOCKE
##  include	    END;

##  include	    IF SOURCE_NAME.TY = DN_FUNCTION_ID OR SOURCE_NAME.TY = DN_OPERATOR_ID THEN	--| SI L ON A UNE FONCTION OU UN OPERATEUR (QUI ONT UN RESULTAT)
##  include	      DECLARE
##  include	        USED_OBJECT_ID   : TREE := D ( AS_NAME, HEADER );			--| RAMENER LE CHAMP AS_NAME DE L ENTETE DE PARAMETRAGE
##  include	        RESULT_TYPE_SPEC : TREE := D ( SM_EXP_TYPE, USED_OBJECT_ID );		--| RAMENER SON TYPE
##  include	      BEGIN
##  include	        DI ( CD_RESULT_SIZE, SOURCE_NAME, EMITS.TYPE_SIZE( RESULT_TYPE_SPEC ));	--| STOCKER LA TAILLE DU TYPE RESULTAT
##  include	      END;
##  include	    END IF;
##  include	  END IF;

##  include	  DEC_LEVEL;							--| REVENIR AU NIVEAU STATIQUE PRECEDENT
##  include	  EMITS.OFFSET_MAX := OLD_OFFSET_MAX;					--| REGENERER LES OFFSETS DU NIVEAU PRECEDENT
##  include	  EMITS.OFFSET_ACT := OLD_OFFSET_ACT;
##  include	END;
--|-------------------------------------------------------------------------------------------------

//  package_decl		=> ;
--	as_source_name	:SOURCE_NAME
--	as_header	:HEADER
--	as_unit_kind	:UNIT_KIND
--	lx_srcpos	:Source_Position

##  package_decl	====>

##  include	EMIT ( PKG, S=> PRINT_NAME ( D ( LX_SYMREP, D ( AS_SOURCE_NAME, PACKAGE_DECL ) ) ) );
##  include	WRITE_LABEL ( 1 );
##  include	DECLARE
##  include	  L1 : LABEL_TYPE := NEXT_LABEL;
##  include	  L2 : LABEL_TYPE := NEXT_LABEL;
##  include	BEGIN
##  include	  EMIT ( ENT, Integer( 1 ), L1 );					--| DEUX ENTER LABELS POUR LES VALEURS DE PILE MAX AFFECTEES EN FIN
##  include	  EMIT ( ENT, Integer( 2 ), L2 );
##  include	  EMITS.OFFSET_ACT := 0;						--| RAZ DES OFFSETS
##  include	  EMITS.OFFSET_MAX := 0;
##  call	HEADER	@ as_header	package_decl					--| ACTION HEADER SUR CHAMP AS_HEADER
##  include	  DECLARE
##  include	    EXC_LBL : LABEL_TYPE := NEXT_LABEL;					--| ETIQUETTE DE DEBUT DU HANDLER EXCEPTIONS
##  include	  BEGIN
##  include	    EMIT ( EXH, EXC_LBL, COMMENT=> "ETIQUETTE EXCEPTION HANDLE DU PACKAGE" );
##  include	    EMIT ( RET, RELATIVE_RESULT_OFFSET );
##  include	    WRITE_LABEL ( EXC_LBL );
##  include	  END;
##  include	  EMIT ( EEX );							--| FIN DE HANDLER EXCEPTIONS
##  include	  GEN_LBL_ASSIGNMENT ( L1, OFFSET_MAX );				--| OFFSET MAX ASSIGNE AU LABEL L1
##  include	  GEN_LBL_ASSIGNMENT ( L2, TOP_MAX + OFFSET_MAX );			--| PILE MAX ASSIGNE AU LABEL L2
##  include	END;
--|.................................................................................................


--			------------------------------------------------
--			ALL_SOURCE > ALL_DECL > ITEM > DECL > USE_PRAGMA
--			------------------------------------------------


//  USE_PRAGMA	::=
//	use | pragma;

##  USE_PRAGMA	====>

##	if	use
##	call	use	USE_PRAGMA
##	if	pragma
##	call	pragma	USE_PRAGMA
--|.................................................................................................
//  use		=>
//	as_name_s	: name_s;

##  use	====>

##	include	null;
//  pragma	=>
//	as_used_name_id	: used_name_id,
//	as_general_assoc_s	: general_assoc_s;			-- seq of EXP and/or assoc

##  pragma	====>

##	include	null;
--|.................................................................................................


--			-----------------------------------------------
--			ALL_SOURCE > ALL_DECL > ITEM > DECL > ID_S_DECL
--			-----------------------------------------------


//  ID_S_DECL		::=
//	exception_decl | deferred_constant_decl | EXP_DECL;
//  ID_S_DECL		=>
//	as_source_name_s	: source_name_s;

##  ID_S_DECL	====>

##	if_class	EXP_DECL
##	call	EXP_DECL	ID_S_DECL
##	if	exception_decl
##	call	exception_decl	ID_S_DECL
##	if	deferred_constant_decl
##	call	deferred_constant_decl	ID_S_DECL
--|.................................................................................................

//  exception_decl		=> ;
--	as_source_name_s	:source_name_s
--	lx_srcpos	:Source_Position

##  exception_decl	====>

##	call	source_name_s	@ as_source_name_s	exception_decl
--|.................................................................................................

//  deferred_constant_decl	=>
//	as_name	: NAME;

##  deferred_constant_decl	====>

##	include	null;
--|.................................................................................................


--			----------------------------------------------------------
--			ALL_SOURCE > ALL_DECL > ITEM > DECL > ID_S_DECL > EXP_DECL
--			----------------------------------------------------------


//  EXP_DECL		::=
//	OBJECT_DECL | number_decl;
//  EXP_DECL		=>
//	as_exp	: EXP;

##  EXP_DECL	====>

##	if_class	OBJECT_DECL
##	call	OBJECT_DECL	EXP_DECL
##	if	number_decl
##	call	number_decl	EXP_DECL
--|.................................................................................................

//  number_decl		=> ;

##  number_decl	====>

##	include	null;
--|.................................................................................................


		------------------------------------------------------------------------
--		ALL_SOURCE > ALL_DECL > ITEM > DECL > ID_S_DECL > EXP_DECL > OBJECT_DECL
--		------------------------------------------------------------------------


//  OBJECT_DECL		::=
//	constant_decl | variable_decl;
//  OBJECT_DECL		=>
//	as_type_def : TYPE_DEF;

##  OBJECT_DECL	====>
## include	DECLARE
## include	  SRC_NAME_SEQ : SEQ_TYPE := LIST ( D ( AS_SOURCE_NAME_S, OBJECT_DECL ) );	--| AMENER LA LISTE DES NOMS DE VAR OU CONST
## include	  SRC_NAME     : TREE;
## include	  TYPE_DEF     : TREE     := D ( AS_TYPE_DEF, OBJECT_DECL );
## include	  TYPE_NAME    : TREE     := D ( AS_NAME, TYPE_DEF );			--| NOM DU TYPE DANS LE CODE SOURCE
## include	BEGIN
## include	  EMITS.TYPE_SYMREP := D ( LX_SYMREP, TYPE_NAME );			--| REPRESENTATION DU SYMBOLE DE TYPE

## include	  WHILE NOT IS_EMPTY ( SRC_NAME_SEQ ) LOOP
## include	    POP ( SRC_NAME_SEQ, SRC_NAME );
## call	  VC_NAME	SRC_NAME			--| TRAITER LE NOM DE VAR CONST DECLARE
## include	  END LOOP;
## include	END;
--|.................................................................................................

//  constant_decl		=> ;

##  constant_decl	====>

##	include	null;

--|.................................................................................................

//  variable_decl		=> ;

##  variable_decl	====>

##	include	null;
--|.................................................................................................


			-----------------------------------------
--			ALL_SOURCE > ALL_DECL > ITEM > DECL > REP
--			-----------------------------------------


//  REP		::=
//	record_rep | NAMED_REP ;
//  REP		=>
//	as_name	: NAME;

##  REP	====>

##	if_class	NAMED_REP
##	call	NAMED_REP		REP
##	if	record_rep
##	call	record_rep	REP
--|.................................................................................................

//  record_rep		=>
//	as_alignment_clause	: ALIGNMENT_CLAUSE,
//	as_comp_rep_s	: comp_rep_s;

##  record_rep	====>

##	call	ALIGNMENT_CLAUSE	@ as_alignment_clause	record_rep
--|.................................................................................................

//  ALIGNMENT_CLAUSE	::=
//	alignment;

##  ALIGNMENT_CLAUSE	====>

##	call	alignment		ALIGNMENT_CLAUSE
--|.................................................................................................

//  alignment		=>
//	as_pragma_s	: pragma_s,
//	as_exp	: EXP;

##  alignment	====>

##	include	null;
--|.................................................................................................


--|.................................................................................................


			-----------------------------------------------------
--			ALL_SOURCE > ALL_DECL > ITEM > DECL > REP > NAMED_REP
--			-----------------------------------------------------


//  NAMED_REP		::=
//	address | length_enum_rep;
//  NAMED_REP		=>
//	as_exp	: EXP;

##  NAMED_REP	====>

##	if	address
##	call	address		NAMED_REP
##	if	length_enum_rep
##	call	length_enum_rep	NAMED_REP
--|.................................................................................................

//  address		=> ;

##  address	====>

##	include	null;
--|.................................................................................................

//  length_enum_rep		=> ;

##  length_enum_rep	====>

##	include	null;
--|.................................................................................................


			------------------------------------------------
--			ALL_SOURCE > ALL_DECL > ITEM > DSCRMT_PARAM_DECL
--			------------------------------------------------


//  DSCRMT_PARAM_DECL	::=
//	dscrmt_decl | PARAM;

//  dscrmt_decl_s		=>
//	as_list	: Seq Of dscrmt_decl;

##  dscrmt_decl_s	====>

##	repeat_extract	dscrmt_decl_s	dscrmt_decl
##	call	dscrmt_decl	dscrmt_decl
--|.................................................................................................

//  dscrmt_decl		=> ;

##  dscrmt_decl	====>

##	include	null;
--|.................................................................................................


			--------------------------------------------------------
--			ALL_SOURCE > ALL_DECL > ITEM > DSCRMT_PARAM_DECL > PARAM
--			--------------------------------------------------------


//  param_s		=>
//	as_list	: Seq Of PARAM;

##  param_s	====>

##	repeat_extract	param_s	param
##	call	PARAM	param
--|.................................................................................................

//  PARAM		::=
//	in | out | in_out;

##  PARAM	====>

##	if	in
##	call	in	PARAM
##	if	out
##	call	out	PARAM
##	if	in_out
##	call	in_out	PARAM

--|.................................................................................................
//  in		=>
//	lx_default	: BOOLEAN;
--	as_source_name_s	:source_name_s
--	as_name	:NAME
--	as_exp	:EXP
--	lx_srcpos	:Source_Position

##  in	====>
##	include	null;
--|.................................................................................................
//  in_out		=> ;

##  in_out	====>

##	include	null;

//  out		=> ;

##  out	====>

##	include	null;
--|.................................................................................................

--				FIN    ALL_SOURCE > ALL_DECL > ITEM
--				-----------------------------------



--|.................................................................................................


				-------------------
--				ALL_SOURCE > HEADER
--				-------------------

//  HEADER		::=
//	SUBP_ENTRY_HEADER | package_spec;

##  HEADER	====>
##	if_class	SUBP_ENTRY_HEADER
##	call	param_s	@ as_param_s	HEADER
##	call	SUBP_ENTRY_HEADER	HEADER
##	if	package_spec
##	call	package_spec	HEADER
--|.................................................................................................

##  package_spec	====>

##	call	decl_s	@ as_decl_s1	package_spec
--|.................................................................................................

//  decl_s		=>
//	as_list	: Seq Of DECL;

##  decl_s	====>

##	repeat_extract	decl_s	decl
##	call	DECL	decl
--|.................................................................................................

//  SUBP_ENTRY_HEADER	::=
//	procedure_spec | function_spec;
//  SUBP_ENTRY_HEADER	=>
//	as_param_s	: param_s;

##  SUBP_ENTRY_HEADER	====>

##	if	procedure_spec
##	call	procedure_spec	SUBP_ENTRY_HEADER
##	if	function_spec
##	call	function_spec	SUBP_ENTRY_HEADER
--|.................................................................................................
//  procedure_spec		=> ;
--	as_param_s	:param_s
--	lx_srcpos	:Source_Position

##  procedure_spec	====>

##  include	EMITS.PARAM_SIZE := (EMITS.OFFSET_ACT - EMITS.FIRST_PARAM_OFFSET + EMITS.RELATIVE_RESULT_OFFSET);

--|.................................................................................................
//  function_spec		=>
//	as_name	: NAME;
--	as_param_s	:param_s
--	lx_srcpos	:Source_Position

##  function_spec	====>

##  include	INC_OFFSET ( EMITS.RELATIVE_RESULT_OFFSET );
##  include	EMITS.PARAM_SIZE := ( EMITS.OFFSET_ACT - EMITS.FIRST_PARAM_OFFSET );
-- ##  include	EMITS.RESULT_SIZE := EMITS.TYPE_SIZE ( RESULT_TYPE_SPEC );		--| A VOIR
##  include	DI ( CD_RESULT_SIZE, D ( AS_NAME, FUNCTION_SPEC ), EMITS.RESULT_SIZE );
##  include	INC_OFFSET ( EMITS.RESULT_SIZE );
##  include	ALIGN ( STACK_AL );
##  include	DI ( CD_RESULT_OFFSET, FUNCTION_SPEC, EMITS.OFFSET_ACT );
##  include	EMITS.FUN_RESULT_OFFSET := EMITS.OFFSET_ACT;
--|.................................................................................................

--				FIN   ALL_SOURCE > HEADER
--				-------------------------




				----------------------
--				ALL_SOURCE > UNIT_DESC
--				----------------------

--|.................................................................................................
//  UNIT_DESC		::=
//	derived_subprog | implicit_not_eq | BODY | UNIT_KIND;


##  UNIT_DESC	====>

##	if	derived_subprog
##	call	derived_subprog	UNIT_DESC
##	if	implicit_not_eq
##	call	implicit_not_eq	UNIT_DESC
##	if_class	BODY
##	call	BODY		UNIT_DESC
##	if_class	UNIT_KIND
##	call	UNIT_KIND		UNIT_DESC
--|.................................................................................................

//  derived_subprog		=>
//	sm_derivable	: SOURCE_NAME;

##  derived_subprog	====>

##	include	null;
--|.................................................................................................

//  implicit_not_eq		=>
//	sm_equal	: SOURCE_NAME;

##  implicit_not_eq	====>

##	include	null;
--|.................................................................................................


				----------------------------------
--				ALL_SOURCE > UNIT_DESC > BODY
--				----------------------------------


//  BODY		::=
//	block_body | stub;

##  BODY	====>

##	if	block_body
##	call	block_body	BODY
##	if	stub
##	call	stub		BODY
--|.................................................................................................

//  block_body		=>
//	as_item_s	: item_s,
//	as_stm_s	: stm_s,
//	as_alternative_s	: alternative_s,
//	cd_level	: Integer,
//	cd_return_label	: Integer,
//	cd_result_offset	: Integer;

##  block_body	====>

##  include	DECLARE								--| TRAITEMENT DU CORPS DE SOUS PROGRAMME
##  include	  SAVE_ENCLOSING_BODY : TREE := ENCLOSING_BODY;
##  include	  OLD_TOP_ACT         : OFFSET_TYPE := EMITS.TOP_ACT;
##  include	  OLD_TOP_MAX         : OFFSET_TYPE := EMITS.TOP_MAX;
##  include	BEGIN
##  include	  ENCLOSING_BODY := BLOCK_BODY;					--| LE BLOC EN TRAITEMENT DEVIENT L'ENGLOBANT ACTUEL
##  include	  EMITS.TOP_ACT := 0;						--| RAZ DES TOPS PUISQUE ON A UN NOUVEAU CONTEXTE
##  include	  EMITS.TOP_MAX := 0;
##  include	  DI ( CD_LEVEL, BLOCK_BODY, INTEGER ( EMITS.LEVEL ) );			--| PLACER LE NIVEAU COURANT DANS LE CHAMP LEVEL DU BLOC
##  include	  DI ( CD_RETURN_LABEL, BLOCK_BODY, INTEGER ( NEXT_LABEL ) );		--| ALLOUER UNE ETIQUETTE ET LA PLACER DANS LE CHAMP POUR RETOUR
##  include	  DECLARE
##  include	    ENT_1_LBL : LABEL_TYPE := NEXT_LABEL;
##  include	    ENT_2_LBL : LABEL_TYPE := NEXT_LABEL;
##  include	  BEGIN
##  include	    EMIT ( ENT, INTEGER ( 1 ), ENT_1_Lbl );				--| EMETTRE LE MARQUEUR D ENTREE DE BLOC AVEC ETIQUETTE POUR OFFSET_MAX
##  include	    EMIT ( ENT, INTEGER ( 2 ), ENT_2_Lbl );				--| SECOND MARQUEUR POUR TOP + OFFSET MAXIS

##  include	    IF FUNCTION_RESULT /= TREE_VOID THEN				--| S IL Y A UN RESULTAT DE FONCTION
##  include	      IF FUNCTION_RESULT.TY = DN_ARRAY THEN				--| SI C EST UN TABLEAU INITIALISER LE DESCRIPTEUR RESULTAT
##  include	        GEN_LOAD_ADDR ( DI ( CD_COMP_UNIT, FUNCTION_RESULT ),
##  include	                        DI ( CD_LEVEL, FUNCTION_RESULT ),
##  include	                        DI ( CD_OFFSET, FUNCTION_RESULT )
##  include	            );
##  include	        EMIT ( DPL, A );						--| DUPLIQUER L ADRESSE OBTENUE
##  include	        EMIT ( STR, A, 0, FUN_RESULT_OFFSET - EMITS.ADDR_SIZE );		--| LA STOCKER
##  include	        EMIT ( IND, I, 0 );
##  include	        EMIT ( ALO, INTEGER ( -1 ) );
##  include	        EMIT ( STR, A, 0, FUN_RESULT_OFFSET );				--| STOCKER L ADRESSE DE L ALLOCATION
##  include	      END IF;
##  include	    END IF;
##  call	item_s	@ as_ITEM_S	block_body					--| TRAITER LES DECLARATIONS
##  include	    DECLARE
##  include	      EXC_LBL : LABEL_TYPE := NEXT_LABEL;				--| ALLOUER UNE ETIQUETTE POUR LE DEBUT DES HANDLERS EXCEPTION
##  include	    BEGIN
##  include	      EMIT ( EXH, EXC_LBL, COMMENT=> "EXCEPTION HANDLERS" );		--| DECLARER UNE ETIQUETTE POUR LES HANDLERS EXCEPTION (PEUT Y AVOIR DES RAISE DANS LES INSTRUCTIONS SUIVANTES)
##  call	stm_s	@ as_STM_S	block_body					--| TRAITER LES INSTRUCTIONS
##  include	      WRITE_LABEL ( LABEL_TYPE ( DI ( CD_RETURN_LABEL, BLOCK_BODY ) ) );	--| ETIQUETTE DU RETOUR
-- CG_Param.COPY_OUT_PARAMS ( params );							--| COPIER LES PARAMETRES DE SORTIE
##  include	      EMIT ( RET, PARAM_SIZE );					--| EMETTRE L INSTRUCTION RETURN
##  include	      WRITE_LABEL ( EXC_LBL );					--| PLACER L ETIQUETTE DES HANDLERS
##  include	    END;
##  include	    IF NOT IS_EMPTY ( LIST ( D ( AS_ALTERNATIVE_S, BLOCK_BODY ) ) ) THEN	--| S IL Y A UNE LISTE DE HANDLERS
##  call	alternative_s	@ as_ALTERNATIVE_S	block_body				--| TRAITER LES HANDLERS
##  include	    ELSE								--| SINON
##  include	      EMIT ( EEX );							--| SIMPLEMENT EMETTRE UN MARQUEUR DE FIN DES HANDLERS EXCEPTION
##  include	    END IF;
##  include	    GEN_LBL_ASSIGNMENT ( ENT_1_LBL, EMITS.OFFSET_MAX );			--| DONNER LES VALEURS AUX ETIQUETTES DES ENTER BLOCKS
##  include	    GEN_LBL_ASSIGNMENT ( ENT_2_LBL, EMITS.OFFSET_MAX + EMITS.TOP_MAX );
##  include	  END;
##  include	  EMITS.TOP_MAX := OLD_TOP_MAX;					--| RESTAURER LES OFFSETS ANTERIEURS
##  include	  EMITS.TOP_ACT := OLD_TOP_ACT;
##  include	  ENCLOSING_BODY := SAVE_ENCLOSING_BODY;				--| ET L ENGLOBANT PRECEDENT
##  include	END;
--|.................................................................................................

//  alternative_s		=>
//	as_list	: Seq Of ALTERNATIVE_ELEM;

##  alternative_s	====>

##	repeat_extract	alternative_s	alternative_elem
##	call	ALTERNATIVE_ELEM	alternative_elem
--|.................................................................................................

//  ALTERNATIVE_ELEM	::=
//	alternative | alternative_pragma;

##  ALTERNATIVE_ELEM	====>

##	if	alternative
##	call	alternative	ALTERNATIVE_ELEM
##	if	alternative_pragma
##	call	alternative_pragma	ALTERNATIVE_ELEM
--|.................................................................................................

//  alternative		=>
//	as_choice_s	: choice_s,
//	as_stm_s	: stm_s;

##  alternative	====>								--| UNE ALTERNATIVE DE CASE
##  include	DECLARE
##  include	  SKIP_LBL          : LABEL_TYPE := NEXT_LABEL;				--| ALLOUER UNE ETIQUETTE POUR LE SAUT POST ALTERNATIVE
##  include	  HANDLER_BEGIN_LBL : LABEL_TYPE := NEXT_LABEL;				--| ALLOUER UNE ETIQUETTE POUR LE DEBUT DES INSTRUCTIONS DE L ALTERNATIVE
##  include	  CHOICE_S          : TREE       := D ( AS_CHOICE_S, ALTERNATIVE );		--| LISTE DES ELEMENTS CONDITIONANTS
##  include	BEGIN
##  include	  DI ( CD_LABEL, CHOICE_S, INTEGER ( HANDLER_BEGIN_LBL ) );			--| STOCKER L ETIQUETTE DE DEBUT DES INSTRUCTIONS
##  call	choice_s	choice_s			--| TRAITER LES ELEMENTS DE CONDITION
##  include	  IF NOT CHOICE_OTHERS_FLAG THEN					--| SI PAS ALTERNATIVE WHEN OTHERS
##  include	    EMIT ( JMP, SKIP_LBL, COMMENT=> "SKIP ALTERNATIVE SUIVANTE"  );		--| SAUTER A L ALTERNATIVE SUIVANTE
##  include	    WRITE_LABEL ( HANDLER_BEGIN_LBL, COMMENT=> "LABEL DEBUT INSTRUCTIONS" );
##  include	  END IF;
##  call	stm_s	@ as_STM_S	alternative					--| TRAITER LES INSTRUCTIONS DE L ALTERNATIVE
-- ##  include	  PERFORM_RETURN ( ENCLOSING_BODY );			??
##  include	  IF NOT CHOICE_OTHERS_FLAG THEN					--| SI PAS ALTERNATIVE WHEN OTHERS
##  include	    WRITE_LABEL ( SKIP_LBL, COMMENT=> "ALTERNATIVE SUIVANTE" );		--| METTRE L ETIQUETTE D'ALTERNATIVE SUIVANTE
##  include	  END IF;
##  include	END;
--|.................................................................................................

//  alternative_pragma	=>
//	as_pragma	: pragma;

##  alternative_pragma	====>
##	include	null;
--|.................................................................................................

//  choice_s		=>
//	as_list	: Seq Of CHOICE,
//	cd_label	: Integer;

##  choice_s	====>

##	repeat_extract	choice_s	choice
##	call	CHOICE	choice
##	include	IF NOT CHOICE_OTHERS_FLAG THEN
##	include	   EMIT ( JMPT, LABEL_TYPE ( DI ( CD_LABEL, CHOICE_S ) ), COMMENT=> "TRAITE EXCEPTION" );
##	include	END IF;
--|.................................................................................................

//  CHOICE		::=
//	choice_exp | choice_range | choice_others;

##  CHOICE	====>

##	if	choice_exp
##	call	choice_exp	CHOICE
##	if	choice_range
##	call	choice_range	CHOICE
##	if	choice_others
##	call	choice_others	CHOICE
--|.................................................................................................

//  choice_exp		=>
//	as_exp	: EXP;
--	lx_srcpos	:Source_Position

##  choice_exp	====>

##	call	EXP	@ as_EXP	choice_exp
--|.................................................................................................

//  choice_range		=>
//	as_discrete_range	: DISCRETE_RANGE;
--	lx_srcpos	:Source_Position

##  choice_range	====>

##	include	null;
--|.................................................................................................

//  choice_others		=> ;
--	lx_srcpos	:Source_Position

##  choice_others	====>

##	include	choice_Others_Flag := true;
--|.................................................................................................

//  stub		=> ;

##  stub	====>
##	include	null;
--|.................................................................................................


				----------------------------------
--				ALL_SOURCE > UNIT_DESC > UNIT_KIND
--				----------------------------------


//  UNIT_KIND		::=
//	RENAME_INSTANT | GENERIC_PARAM;

##  UNIT_KIND	====>

##	if_class	RENAME_INSTANT
##	call	RENAME_INSTANT	UNIT_KIND
##	if_class	GENERIC_PARAM
##	call	GENERIC_PARAM	UNIT_KIND
--|.................................................................................................


				---------------------------------------------------
--				ALL_SOURCE > UNIT_DESC > UNIT_KIND > RENAME_INSTANT
--				---------------------------------------------------


//  RENAME_INSTANT		::=
//	renames_unit | instantiation;
//  RENAME_INSTANT		=>
//	as_name	: NAME;

##  RENAME_INSTANT	====>

##	if	renames_unit
##	call	renames_unit	RENAME_INSTANT
##	if	instantiation
##	call	instantiation	RENAME_INSTANT
--|.................................................................................................

//  renames_unit		=> ;

##  renames_unit	====>

##	include	null;
--|.................................................................................................

//  instantiation		=>
//	as_general_assoc_s	: general_assoc_s,
//	sm_decl_s	: decl_s;

##  instantiation	====>

##	include	null;
--|.................................................................................................


				---------------------------------------------------
--				ALL_SOURCE > UNIT_DESC > UNIT_KIND > GENERIC_PARAM
--				---------------------------------------------------


--|.................................................................................................
//  GENERIC_PARAM		::=
//	name_default | box_default | no_default;

##  GENERIC_PARAM	====>

##	if	name_default
##	call	name_default	GENERIC_PARAM
##	if	box_default
##	call	box_default	GENERIC_PARAM
##	if	no_default
##	call	no_default	GENERIC_PARAM
--|.................................................................................................

//  name_default		=>
//	as_name	: NAME;

##  name_default	====>

##	include	null;
--|.................................................................................................

//  box_default		=> ;

##  box_default	====>

##	include	null;
--|.................................................................................................

//  no_default		=> ;

##  no_default	====>

##	include	null;
--|.................................................................................................

--				FIN   ALL_SOURCE > UNIT_DESC
--				----------------------------




				---------------------
--				ALL_SOURCE > TYPE_DEF
--				---------------------

//  TYPE_DEF		::=
//	enumeration_def | record_def
//	| formal_dscrt_def | formal_integer_def | formal_fixed_def | formal_float_def;
//	| private_def | l_private_def |
//	| CONSTRAINED_DEF | ARR_ACC_DER_DEF | ;
--|.................................................................................................

//  enumeration_def		=>
//	as_enum_literal_s	: enum_literal_s;

##  enumeration_def	====>

##	call	enum_literal_s	@ as_enum_literal_s enumeration_def
--|.................................................................................................

//  enum_literal_s		=>
//	as_list	: Seq Of ENUM_LITERAL,
//	cd_alignment	: Integer,
//	cd_impl_size	: Integer,
//	cd_last	: Integer;

##  enum_literal_s	====>

##  repeat_extract	enum_literal_s	enum_literal
##  call	ENUM_LITERAL	enum_literal
--|.................................................................................................

//  ENUM_LITERAL		::=
//	enumeration_id | character_id;
//  ENUM_LITERAL		=>
//	sm_pos	: Integer,
//	sm_rep	: Integer;

##  ENUM_LITERAL	====>
##	if	enumeration_id
##	call	enumeration_id	ENUM_LITERAL
##	if	character_id
##	call	character_id	ENUM_LITERAL
--|.................................................................................................
//  enumeration_id	=> ;

##  enumeration_id	====>

##	include	null;
--|.................................................................................................
//  character_id	=> ;

##  character_id	====>

##	include	null;



--|.................................................................................................
//  formal_dscrt_def	=> ;

##  formal_dscrt_def	====>

##	include	null;
--|.................................................................................................
//  formal_fixed_def	=> ;

##  formal_fixed_def	====>

##	include	null;
--|.................................................................................................
//  formal_float_def	=> ;

##  formal_float_def	====>

##	include	null;
--|.................................................................................................
//  formal_integer_def	=> ;

##  formal_integer_def	====>

##	include	null;
--|.................................................................................................

//  record_def		=>
//	as_comp_list	: comp_list;
--|.................................................................................................
//  comp_list		=>
//	as_decl_s	: decl_s,
//	as_variant_part	: VARIANT_PART,
//	as_pragma_s	: pragma_s;
//  VARIANT_PART		::=
//	variant_part;
--|.................................................................................................
//  variant_part		=>
//	as_name	: NAME,
//	as_variant_s	: variant_s;
--|.................................................................................................
//  variant_s		=>
//	as_list	: Seq Of VARIANT_ELEM;
--|.................................................................................................
//  VARIANT_ELEM	::=
//	variant | variant_pragma;
--|.................................................................................................
//  variant		=>
//	as_choice_s	: choice_s,
//	as_comp_list	: comp_list;



//  private_def		=> ;
--|.................................................................................................
//  l_private_def		=> ;








//  txtrep	=> ;				-- representation of text
//  num_val	=> ;				-- representation of (small) integer

//  BOOLEAN	::=	false | true;
//  false	=> ;				-- used for BOOLEAN
//  true	=> ;

//  nil	=> ;				-- empty list
//  list	=>	xd_head 	: void,		-- list representation
//		xd_tail 	: void;

//  sourceline	=>	xd_number	: num_val,
//		xd_error_list	: Seq Of error;

//  error	=>	xd_srcpos	: Source_Position,
//		xd_text 	: txtrep;

//  symbol_rep	=>	xd_text 	: txtrep,
//		xd_deflist	: Seq Of DEF_NAME;

//  hash	=>	xd_list 	: Seq Of symbol_rep;

//  void	=> ;

// STANDARD_IDL	::=
//	root | txtrep | num_val | BOOLEAN | nil | list | sourceline | error | symbol_rep | hash | void;



--|.................................................................................................
//  DEF_NAME	::=	SOURCE_NAME | PREDEF_NAME;
//  DEF_NAME	=>	lx_symrep	: symbol_rep;
--|.................................................................................................
//  SOURCE_NAME	::=	OBJECT_NAME | TYPE_NAME | UNIT_NAME | LABEL_NAME;
//  SOURCE_NAME	=>	xd_region	: SOURCE_NAME;

##  SOURCE_NAME	====>
##	if_class	OBJECT_NAME
##	call	OBJECT_NAME	SOURCE_NAME
##	if_class	TYPE_NAME
##	call	TYPE_NAME	SOURCE_NAME
##	if_class	UNIT_NAME
##	call	UNIT_NAME	SOURCE_NAME
##	if_class	LABEL_NAME
##	call	LABEL_NAME	SOURCE_NAME
##	if	entry_id
##	call	entry_id	SOURCE_NAME
##	if	exception_id
##	call	exception_id	SOURCE_NAME

--|.................................................................................................
//  OBJECT_NAME	=>	sm_obj_type	: TYPE_SPEC;

##  OBJECT_NAME	====>
##	if	iteration_id
##	call	iteration_id	OBJECT_NAME
##	if_class	INIT_OBJECT_NAME
##	call	INIT_OBJECT_NAME	OBJECT_NAME
##	if_class	ENUM_LITERAL
##	call	ENUM_LITERAL	OBJECT_NAME
--|.................................................................................................
//  UNIT_NAME	=>	sm_first	: DEF_NAME;

##  UNIT_NAME	====>
##	if	task_body_id
##	call	task_body_id	UNIT_NAME
##	if_class	NON_TASK_NAME
##	call	NON_TASK_NAME	UNIT_NAME


--|.................................................................................................
//  general_assoc_s	=>
//	as_list	: Seq Of GENERAL_ASSOC;


--|-------------------------------------------------------------------------------------------------
-- Syntax 2.8.B
--  argument_association ::=
--	  [argument_identifier  =>] name
--	| [argument_identifier  =>] expression
--|.................................................................................................
//  CONSTRAINED_DEF		::=
//	subtype_indication;

--|.................................................................................................
//  OBJECT_NAME		::=
//	INIT_OBJECT_NAME;
--|.................................................................................................
//  INIT_OBJECT_NAME	::=			--| Objet var ou cst avec initialisation
//	VC_NAME;
//  INIT_OBJECT_NAME	=>
//	sm_init_exp	: EXP;			--| Attribut expression d'init
--|.................................................................................................
//  VC_NAME		::=
//	variable_id | constant_id;			--| Identificateur variable ou constante
//  VC_NAME		=>
//	sm_renames_obj	: BOOLEAN,			--| Indique un renames (pour var)
//	sm_address	: EXP,			--| EXP OU VIDE
//	cd_comp_unit	: Integer,
//	cd_level	: Integer,
//	cd_offset	: Integer,
//	cd_compiled	: BOOLEAN;

##  VC_NAME	====>
## include	DECLARE
## include	  TYPE_SPEC : TREE := D ( SM_OBJ_TYPE, VC_NAME );		--| LE TYPE ATTACHE A LA DECLARATION VAR CONST
## include	  --|---------------------------------------------------------------------------
## include	  PROCEDURE COMPILE_VC_NAME_INTEGER ( VC_NAME :TREE ) IS		--| VARIABLE DE TYPE ENTIER
## include	  BEGIN
## include	    ALIGN ( INTG_AL );			--| ALIGNER LES OFFSET POUR UN ENTIER
## include	    DECLARE
## include	      LVL      : LEVEL_TYPE    := EMITS.LEVEL;		--| NIVEAU IMBRICATION ACTUEL
## include	      OFS      : OFFSET_TYPE   := - EMITS.OFFSET_ACT;		--| DECALAGE ACTUEL ESPACE DE STOCKAGE
## include	      CPU      : COMP_UNIT_NBR := EMITS.CUR_COMP_UNIT;		--| NUMERO D UNITE ACTUEL
## include	      INIT_EXP : TREE          := D ( SM_INIT_EXP, VC_NAME );
## include	    BEGIN
## include	      DI ( CD_LEVEL, VC_NAME, LVL );			--| STOCKER LE NIVEAU
## include	      DI ( CD_OFFSET, VC_NAME, OFS );			--| LE DECALAGE
## include	      DI ( CD_COMP_UNIT, VC_NAME, CPU );		--| L UNITE
## include	      DB ( CD_COMPILED, VC_NAME, TRUE );		--| INDIQUER QUE C EST COMPILE
## include	      INC_OFFSET ( INTG_SIZE );			--| AUGMENTER LE DECALAGE
## include	      IF INIT_EXP /= TREE_VOID THEN			--| SI EXPRESSION D INITIALISATION
## call	EXP	INIT_EXP			--| EVALUER CETTE EXPRESSION
## include	        GEN_STORE ( I, CPU, LVL, OFS,			--| STOCKER SON RESULTAT COMME VALEUR INITIALE
## include	                  "STO " & PRINT_NAME ( D (LX_SYMREP, VC_NAME ) ) & " VAL INIT" );
## include	      END IF;
## include	    END;
## include	  END COMPILE_VC_NAME_INTEGER;
## include	  --|---------------------------------------------------------------------------
## include	  PROCEDURE COMPILE_VC_NAME_ENUMERATION ( VC_NAME, TYPE_SPEC :TREE ) IS
## include	    NAME             : CONSTANT STRING := PRINT_NAME ( EMITS.TYPE_SYMREP );	--| CHAINE DU NOM DE TYPE

## include	    PROCEDURE COMPILE_VC_NAME_BOOL_CHAR ( VC_NAME :TREE; CT :CODE_TYPE; SIZ, ALI :NATURAL ) IS
## include	    BEGIN
## include	      ALIGN ( ALI );
## include	      DECLARE
## include	        LVL      : LEVEL_TYPE    := EMITS.LEVEL;
## include	        OFS      : OFFSET_TYPE   := - EMITS.OFFSET_ACT;
## include	        CPU      : COMP_UNIT_NBR := EMITS.CUR_COMP_UNIT;
## include	        INIT_EXP : TREE          := D ( SM_INIT_EXP, VC_NAME );
## include	      BEGIN
## include	        DI ( CD_LEVEL, VC_NAME, LVL );			--| STOCKER LE NIVEAU
## include	        DI ( CD_OFFSET, VC_NAME, OFS );			--| LE DECALAGE
## include	        DI ( CD_COMP_UNIT, VC_NAME, CPU );		--| L UNITE
## include	        DB ( CD_COMPILED, VC_NAME, TRUE );		--| INDIQUER QUE C EST COMPILE
## include	        INC_OFFSET ( SIZ );			--| AUGMENTER LE DECALAGE
## include	        IF INIT_EXP /= TREE_VOID THEN			--| SI EXPRESSION D INITIALISATION
## call	EXP	INIT_EXP			--| EVALUER CETTE EXPRESSION
## include	        END IF;
## include	        GEN_STORE ( CT, CPU, LVL, OFS,			--| STOCKER SON RESULTAT COMME VALEUR INITIALE
## include	               PRINT_NAME ( D (LX_SYMREP, VC_NAME ) ) & " := VAL INIT" );
## include	      END;
## include	    END COMPILE_VC_NAME_BOOL_CHAR;

## include	  BEGIN
## include	    IF NAME = "BOOLEAN" THEN
## include	      COMPILE_VC_NAME_BOOL_CHAR ( VC_NAME, B, BOOL_SIZE, BOOL_AL );
## include	    ELSIF NAME = "CHARACTER" THEN
## include	      COMPILE_VC_NAME_BOOL_CHAR ( VC_NAME, C, CHAR_SIZE, CHAR_AL );
## include	    ELSE
## include	      COMPILE_VC_NAME_INTEGER ( VC_NAME );
## include	    END IF;
## include	  END COMPILE_VC_NAME_ENUMERATION;
## include	  --|---------------------------------------------------------------------------
## include	  PROCEDURE COMPILE_ACCESS_VAR ( VAR_ID, TYPE_SPEC :TREE ) IS
## include	  BEGIN
## include	    ALIGN ( ADDR_AL );
## include	    DECLARE
## include	      LVL : LEVEL_TYPE    := EMITS.LEVEL;
## include	      OFS : OFFSET_TYPE   := - EMITS.OFFSET_ACT;
## include	      CPU : COMP_UNIT_NBR := EMITS.CUR_COMP_UNIT;
## include	    BEGIN
## include	      DI ( CD_LEVEL, VAR_ID, LVL );
## include	      DI ( CD_OFFSET, VAR_ID, OFS );
## include	      DI ( CD_COMP_UNIT, VAR_ID, CPU );
## include	      DB ( CD_COMPILED, VAR_ID, TRUE );
## include	      INC_OFFSET ( ADDR_SIZE );
## include	      DECLARE
## include	        INIT_EXP : TREE := D ( SM_INIT_EXP, VAR_ID );
## include	      BEGIN
## include	        IF INIT_EXP = TREE_VOID THEN
## include	          EMIT ( LDC, A, -1, "INIT NIL DE " & PRINT_NAME ( D (LX_SYMREP, VAR_ID ) ) );
## include	        ELSE
## include	          LOAD_TYPE_SIZE ( TYPE_SPEC  );
## include	          EMIT ( ALO, LVL - DI ( CD_LEVEL, TYPE_SPEC ) );
## include	        END IF;
## include	      END;
## include	      GEN_STORE ( A, CPU, LVL, OFS,
## include	               "STO " & PRINT_NAME ( D (LX_SYMREP, VAR_ID ) ) & " VAL INIT" );
## include	    END;
## include	  END COMPILE_ACCESS_VAR;
## include	  --|---------------------------------------------------------------------------
## include	  PROCEDURE COMPILE_ARRAY_VAR ( VC_NAME, TYPE_SPEC :TREE ) IS
## include	    DESCR_PTR : OFFSET_TYPE;
## include	  BEGIN
## include	    ALIGN ( ADDR_AL );
## include	    DECLARE
## include	      LVL       : LEVEL_TYPE := EMITS.LEVEL;
## include	      VALUE_PTR : OFFSET_TYPE := - EMITS.OFFSET_ACT;
## include	      CPU       : COMP_UNIT_NBR := EMITS.CUR_COMP_UNIT;
## include	    BEGIN
## include	      DI ( CD_LEVEL, VC_NAME, LVL );
## include	      DI ( CD_OFFSET, VC_NAME, VALUE_PTR );
## include	      DI ( CD_COMP_UNIT, VC_NAME, CPU );
## include	      DB ( CD_COMPILED, VC_NAME, TRUE );
## include	      INC_OFFSET ( ADDR_SIZE );
## include	      ALIGN ( ADDR_AL );
## include	      DESCR_PTR := - EMITS.OFFSET_ACT;
## include	      INC_OFFSET ( ADDR_SIZE );
            
## include	      IF DB ( CD_COMPILED, TYPE_SPEC ) THEN
## include	        GEN_LOAD_ADDR ( DI ( CD_COMP_UNIT, TYPE_SPEC ) , DI ( CD_LEVEL, TYPE_SPEC ), DI ( CD_OFFSET, TYPE_SPEC ) );
## include	        EMIT ( DPL, A, "DUPLICATE " & PRINT_NAME ( D (LX_SYMREP, VC_NAME ) ) & " ARRAY DESCRIPTOR TYPE_SPEC" );
## include	        GEN_STORE ( A, EMITS.CUR_COMP_UNIT, EMITS.LEVEL, DESCR_PTR, "STO ADRESSE DESCRIPTEUR" );
## include	        EMIT ( IND, I, 0, "CHARGE INDEXE TAILLE TABLEAU DE DESCRIPTEUR" );
## include	        EMIT ( ALO, INTEGER ( 0 ), COMMENT=> "ALLOC TABLEAU" );
## include	        GEN_STORE ( A, EMITS.CUR_COMP_UNIT, EMITS.LEVEL, VALUE_PTR, "STO ADRESSE TABLEAU ALLOUE" );
## include	      ELSE
## include	        PUT_LINE ( "!!! COMPILE_ARRAY_VAR : TYPE_SPEC NON COMPILE" );
## include	        RAISE PROGRAM_ERROR;
## include	      END IF;
## include	    END;
## include	  END COMPILE_ARRAY_VAR;
## include	  --|---------------------------------------------------------------------------
## include	  PROCEDURE COMPILE_RECORD_VAR ( VC_NAME, TYPE_SPEC :TREE ) IS
## include	    INIT_EXP : TREE := D ( SM_INIT_EXP, VC_NAME );
## include	  BEGIN
## include	    ALIGN ( RECORD_AL );
## include	    DECLARE
## include	      LVL : LEVEL_TYPE    := EMITS.LEVEL;
## include	      OFS : OFFSET_TYPE   := - EMITS.OFFSET_ACT;
## include	      CPU : COMP_UNIT_NBR := EMITS.CUR_COMP_UNIT;
## include	    BEGIN
## include	      DI ( CD_LEVEL, VC_NAME, LVL );
## include	      DI ( CD_OFFSET, VC_NAME, OFS );
## include	      DI ( CD_COMP_UNIT, VC_NAME, CPU );
## include	      DB ( CD_COMPILED, VC_NAME, TRUE );
         
## include	      IF INIT_EXP.TY = DN_AGGREGATE THEN
## include	        DECLARE
## include	          GENERAL_ASSOC_SEQ : SEQ_TYPE := LIST ( D ( SM_NORMALIZED_COMP_S, INIT_EXP ) );
## include	          COMP_EXP          : TREE;
## include	        BEGIN
## include	          WHILE NOT IS_EMPTY ( GENERAL_ASSOC_SEQ ) LOOP
## include	            POP ( GENERAL_ASSOC_SEQ, COMP_EXP );
                    
## call	EXP	COMP_EXP
-- ## include	            GEN_STORE ( CODE_TYPE_OF ( COMP_EXP ), CPU, LVL, OFS + field_Ofs,
-- ## include	                        "STO " & PRINT_NAME ( D (LX_SYMREP, VC_NAME ) ) & " VAL INIT CHAMP" );

## include	          END LOOP;
## include	        END;
## include	      END IF;
## include	    END;
## include	  END COMPILE_RECORD_VAR;
## include	  --|---------------------------------------------------------------------------
## include	BEGIN
## include	  CASE TYPE_SPEC.TY IS
## include	  WHEN DN_INTEGER =>
## include	    COMPILE_VC_NAME_INTEGER ( VC_NAME );
               
## include	  WHEN DN_ENUMERATION =>
## include	    COMPILE_VC_NAME_ENUMERATION ( VC_NAME, TYPE_SPEC );
               
## include	  WHEN DN_ACCESS =>
## include	    COMPILE_ACCESS_VAR ( VC_NAME, TYPE_SPEC );
               
## include	  WHEN DN_CONSTRAINED_ARRAY =>
## include	    COMPILE_ARRAY_VAR ( VC_NAME, TYPE_SPEC );
         
## include	  WHEN DN_RECORD =>
## include	    COMPILE_RECORD_VAR ( VC_NAME, TYPE_SPEC );
               
## include	  WHEN OTHERS =>
## include	    PUT_LINE ( "!!! CODE_VC_NAME, TYPE_SPEC.TY = " & NODE_NAME'IMAGE ( TYPE_SPEC.TY ) );
## include	    RAISE PROGRAM_ERROR;
## include	  END CASE;
## include	END;
--|.................................................................................................
//  variable_id		=>
//	sm_is_shared	: BOOLEAN;			--| Si pragma shared applique

##  variable_id	====>
##	include	null;
--|.................................................................................................
//  constant_id		=>
//	sm_first	: DEF_NAME;

##  constant_id	====>
##	include	null;

--|.................................................................................................
//  INIT_OBJECT_NAME	::=    number_id;
--|.................................................................................................
//  number_id		=> ;

##  number_id	====>
##	include	null;


//  source_name_s	=>	    as_list : Seq Of SOURCE_NAME;
##  source_name_s	====>
##	repeat_extract	source_name_s	source_name
##	call	source_name	source_name

//  TYPE_NAME		::=
//	type_id;
//  TYPE_NAME		=>
//	sm_type_spec	: TYPE_SPEC;

##  TYPE_NAME	====>
##	if	type_id
##	call	type_id	TYPE_NAME
##	if	subtype_id
##	call	subtype_id	TYPE_NAME
##	if	private_type_id
##	call	private_type_id	TYPE_NAME
##	if	l_private_type_id
##	call	l_private_type_id	TYPE_NAME
--|.................................................................................................
//  type_id		=>
//	sm_first	: DEF_NAME;

##  type_id	====>
##	include	null;



--|-------------------------------------------------------------------------------------------------


--|.................................................................................................
//  CONSTRAINED_DEF		::=
//	integer_def | float_def | fixed_def;
--|.................................................................................................
//  ARR_ACC_DER_DEF		::=
//	constrained_array_def | unconstrained_array_def | access_def | derived_def;
//  ARR_ACC_DER_DEF		=>
//	as_subtype_indication	: subtype_indication;
--|.................................................................................................
//  TYPE_SPEC		::=
//	DERIVABLE_SPEC;
--|.................................................................................................
//  DERIVABLE_SPEC		::=
//	FULL_TYPE_SPEC | PRIVATE_SPEC;
//  DERIVABLE_SPEC		=>
//	xd_source_name	: SOURCE_NAME,
//	sm_derived	: TYPE_SPEC,
//	sm_is_anonymous	: BOOLEAN;
--|.................................................................................................
//  FULL_TYPE_SPEC		::=
//	task_spec | NON_TASK;
//  FULL_TYPE_SPEC		=>
//	cd_comp_unit	: Integer,
//	cd_level	: Integer,
//	cd_compiled	: BOOLEAN;
--|.................................................................................................
//  NON_TASK		::=
//	SCALAR | UNCONSTRAINED | CONSTRAINED;
//  NON_TASK		=>
//	sm_base_type	: TYPE_SPEC;
--|.................................................................................................
//  SCALAR		::=
//	enumeration | Integer | REAL;
//  SCALAR		=>
//	sm_range	: RANGE,
//	cd_impl_size	: Integer;
--|.................................................................................................
//  REAL		::=
//	float | fixed;
//  REAL		=>
//	sm_accuracy	: Value;
--|.................................................................................................
//  UNCONSTRAINED		::=
//	UNCONSTRAINED_COMPOSITE | access;
//  UNCONSTRAINED		=>
//	sm_size	: EXP;		-- exp or void
--|.................................................................................................
//  UNCONSTRAINED_COMPOSITE	::=
//	array | record;
//  UNCONSTRAINED_COMPOSITE	=>
//	sm_is_limited	: BOOLEAN,
//	sm_is_packed	: BOOLEAN;
--|.................................................................................................
//  CONSTRAINED		::=
//	constrained_array | constrained_record | constrained_access;
//  CONSTRAINED		=>
//	sm_depends_on_dscrmt	: BOOLEAN,
//	cd_impl_size		: Integer,
//	cd_alignment		: Integer;



--|.................................................................................................
//  TYPE_NAME		::=
//	subtype_id;
--|.................................................................................................
//  subtype_id		=> ;

##  subtype_id	====>
##	include	null;



--|.................................................................................................
//  CONSTRAINED_DEF		=>
//	as_constraint	: CONSTRAINT;
--|.................................................................................................
//  subtype_indication	=>
//	as_name	: NAME;


//  CONSTRAINT		::=
//	DISCRETE_RANGE | REAL_CONSTRAINT | index_constraint | dscrmt_constraint;


//  derived_def	=>	   	xd_derived_subprog_list: Seq Of SUBPROG_NAME;


//  DISCRETE_RANGE		::=
//	RANGE | discrete_subtype;
//  RANGE		::=
//	range | range_attribute;
//  RANGE		=>
//	sm_type_spec : TYPE_SPEC;
//  range		=>
//	as_exp1	: EXP,
//	as_exp2	: EXP;
//  range_attribute		=>
//	as_name	: NAME,
//	as_used_name_id	: used_name_id,
//	as_exp	: EXP;			-- EXP or void




//  integer_def	=> ;
--|.................................................................................................
//  Integer	=>
//	cd_offset	: Integer,
//	cd_impl_size	: Integer;


//  REAL_CONSTRAINT ::=     float_constraint
//			  | fixed_constraint;
//  REAL_CONSTRAINT	=>	    sm_type_spec : TYPE_SPEC;


//  float_def		=> ;
--|.................................................................................................
//  REAL_CONSTRAINT		=>
//	as_exp	: EXP,
//	as_range	: RANGE;
--|.................................................................................................
//  float_constraint	=> ;
--|.................................................................................................
//  float		=>
//	cd_impl_size	: Integer ;


//  fixed_def	=> ;
--|.................................................................................................
//  fixed_constraint	=> ;
--|.................................................................................................
//  fixed		=>
//	cd_impl_small	: Value,
//	cd_impl_size	: Integer;

//  constrained_array_def	=>
//	as_constraint	: CONSTRAINT;
--|.................................................................................................
//  index_constraint	=>
//	as_discrete_range_s	: discrete_range_s;
--|.................................................................................................
//  discrete_range_s	=>
//	as_list	: Seq Of DISCRETE_RANGE;
--|.................................................................................................
//  unconstrained_array_def	=>
//	as_index_s	: index_s;
--|.................................................................................................
//  scalar_s		=>
//	as_list	: Seq Of SCALAR;
--|.................................................................................................
//  array		=>
//	sm_index_s	: index_s,
//	sm_comp_type	: TYPE_SPEC;
--|.................................................................................................
//  constrained_array	=>
//	sm_index_subtype_s	: scalar_s,
//	cd_offset	: Integer,
//	cd_dimensions	: Integer;


//  index		=>
//	as_name	: NAME,
//	sm_type_spec	: TYPE_SPEC;
--|.................................................................................................
//  index_s		=>
//	as_list	: Seq Of index;




discrete_range	::=
	  range
	| name  range_constraint			====> exch_1 $2 subtype_indication $1 discrete_subtype
	%%
--|.................................................................................................
--** The name must be an expanded_name

//  discrete_subtype	=>
//	as_subtype_indication	: subtype_indication;

--|.................................................................................................


--|.................................................................................................
//  record		=>
//	sm_discriminant_s	: dscrmt_decl_s,
//	sm_comp_list	: comp_list,
//	sm_representation	: REP;			-- REP or void
--|.................................................................................................
//  constrained_record	=>
//	sm_normalized_dscrmt_s	: exp_s;

--|.................................................................................................
//  INIT_OBJECT_NAME	::=
//	COMP_NAME;
--|.................................................................................................
//  COMP_NAME	::=
//	component_id | discriminant_id;
//  COMP_NAME	=>
//	sm_comp_rep	: COMP_REP_ELEM;

##  COMP_NAME	====>
##	if	component_id
##	call	component_id	COMP_NAME
##	if	discriminant_id
##	call	discriminant_id	COMP_NAME
--|.................................................................................................
//  component_id		=> ;

##  component_id	====>
##	include	null;



--|.................................................................................................
//  DSCRMT_PARAM_DECL	::=
//	dscrmt_decl;
//  DSCRMT_PARAM_DECL	=>
//	as_source_name_s	: source_name_s,
//	as_name	: NAME,
//	as_exp	: EXP;
--|.................................................................................................
//  discriminant_id		=>
//	sm_first	: DEF_NAME;

##  discriminant_id	====>
##	include	null;


//  dscrmt_constraint	=>
//	as_general_assoc_s	: general_assoc_s;


--|.................................................................................................
//  variant_pragma	=>	    as_pragma : pragma;


--|.................................................................................................
others_s	::=
	OTHERS				====> $0 choice_others list $L choice_s
	%%
--|.................................................................................................



//  access_def	=> ;
--|.................................................................................................
//  access		=>
//	sm_storage_size	: EXP,			-- EXP or void
//	sm_is_controlled	: BOOLEAN,
//	sm_desig_type	: TYPE_SPEC,
//	sm_master	: ALL_DECL,
//	cd_offset	: Integer,
//	cd_constrained	: BOOLEAN;
--|.................................................................................................
//  constrained_access	=>
//	sm_desig_type	: TYPE_SPEC;


--|.................................................................................................
//  TYPE_SPEC ::=	    incomplete;
--|.................................................................................................
//  incomplete		=>
//	sm_discriminant_s	: dscrmt_decl_s,
//	xd_source_name	: SOURCE_NAME,
//	xd_full_type_spec	: TYPE_SPEC;
--|.................................................................................................


//  NAME		::=
//	DESIGNATOR | NAME_EXP;

##  NAME	====>
##	if_class	DESIGNATOR
##	call	DESIGNATOR	NAME
##	if_class	NAME_EXP
##	call	NAME_EXP	NAME
--|.................................................................................................
//  NAME_EXP		::=
//	NAME_VAL | indexed | slice | all;
//  NAME_EXP		=>
//	as_name	: NAME,
//	sm_exp_type	: TYPE_SPEC;

##  NAME_EXP	====>
##	if	indexed
##	call	indexed	NAME_EXP
##	if	slice
##	call	slice	NAME_EXP
##	if	all
##	call	all	NAME_EXP
--|.................................................................................................
//  NAME_VAL		::=
//	attribute | selected;
//  NAME_VAL		=>
//	sm_value	: Value;
--|.................................................................................................
//  DESIGNATOR		::=
//	USED_OBJECT | USED_NAME;
//  DESIGNATOR		=>
//	sm_defn	: DEF_NAME,
//	lx_symrep	: symbol_rep;

##  DESIGNATOR	====>
##	if_class	USED_OBJECT
##	call	USED_OBJECT	DESIGNATOR
##	if_class	USED_NAME
##	call	USED_NAME	DESIGNATOR
--|.................................................................................................
//  USED_NAME		::=
//	used_op | used_name_id;
##  USED_NAME	====>
##	if	used_op
##	call	used_op	USED_NAME
##	if	used_name_id
##	call	used_name_id	USED_NAME
--|.................................................................................................
//  used_op		=> ;

##  used_op	====>
##	include	null;
--|.................................................................................................
//  used_name_id		=> ;

##  used_name_id	====>
##  include	DECLARE
##  include	  DEFN   : TREE := D ( SM_DEFN, USED_NAME_ID );				--| RAMENER LA DEFINITION ASSOCIEE AU NOM UTILISE
##  include	  SYMREP : TREE := D ( LX_SYMREP, USED_NAME_ID );				--| RAMENER AUSSI SA REPRESENTATION
##  include	BEGIN

##  include	  IF DEFN.TY = DN_EXCEPTION_ID THEN					--| ON A NOMME UNE EXCEPTION
##  include	    DECLARE
##  include	      LABEL : TREE := D ( CD_LABEL, DEFN );				--| RAMENER LE CHAMP CD_LABEL DE L EXCEPTION
##  include	      LBL : LABEL_TYPE;
##  include	    BEGIN
##  include	      IF LABEL.TY /= DN_NUM_VAL THEN					--| AUCUN RAISE N A ETE VU PUR CETTE EXCEPTION RIEN DANS LE CHAMP CD_LABEL
##  include	        LBL := NEXT_LABEL;						--| DONC ALLOUER UNE ETIQUETTE
##  include	        DI ( CD_LABEL, DEFN, INTEGER ( LBL ) );				--| METTRE CE NUMERO D ETIQUETTE DANS LE CD_LABEL POUR REPERER L EXCEPTION
##  include	        EMIT ( EXL, LBL, S=> PRINT_NAME ( SYMREP ),			--| DECLARER CETTE ASSOCIATION
##  include		COMMENT=> "NUM D EXCEPTION EXTERNE ATTRIBUE SUR USED_NAME_ID" );
##  include	      END IF;
##  include	      EMIT ( DPL, I, COMMENT=> "CODE D EXCEPTION EMPILE" );			--| EMPILAGE DUPLICATA DU CODE ENTIER D EXCEPTION
##  include	      EMIT ( LDC, I, DI ( CD_LABEL, DEFN ), COMMENT=> "EXCEPTION " & PRINT_NAME ( SYMREP ));
##  include	      EMIT ( EQ, I );						--| 
##  include	    END;

##  include	  ELSIF DEFN.TY = DN_PACKAGE_ID THEN
##  include	    IF NOT DB ( CD_COMPILED, DEFN ) THEN				--| REFERENCE A UN PACKAGE NON COMPILE (SPEC)
##  include	      DECLARE
##  include	        PACKAGE_SPEC : TREE := D ( SM_SPEC, DEFN );			--| UN HEADER (PACKAGE SPEC)
##  include	      BEGIN
##  include	        EMIT ( RFP, EMITS.CUR_COMP_UNIT, s=> PRINT_NAME ( SYMREP ) );		--| EMETTRE UNE REFERENCE A PACKAGE
##  include	        EMITS.GENERATE_CODE := FALSE;					--| PAS DE CODE GENERE (SEULEMENT FAIRE LES OPERATIONS ETIQUETAGE PLACEMENT ETC. )
##  include	        DB ( CD_COMPILED, DEFN, TRUE );					--| INDIQUER DES A PRESENT QUE L ON A COMPILE CE PACKAGE WITHE POUR NE FAIRE CELA QU UNE SEULE FOIS

##  call	decl_s	@ as_DECL_S1 package_Spec						--| TRAITER LES DECLARATIONS DE CE PACKAGE

##  include	      END;
##  include	    END IF;
##  include	    EMITS.CUR_COMP_UNIT := CUR_COMP_UNIT + 1;				--| NUMERO D UNITE SUIVANT

##  include	  ELSIF DEFN.TY = DN_PROCEDURE_ID THEN					--| REFERENCE A UNE PROCEDURE DE LIBRAIRIE
##  include	    IF NOT DB ( CD_COMPILED, DEFN ) THEN				--| SI PAS COMPILEE
##  include	      DECLARE
##  include	        PROC_LBL : LABEL_TYPE := NEXT_LABEL;				--| ALLOCATION ETIQUETTE D ENTREE DE LA PROCEDURE REFERENCEE
##  include	      BEGIN
##  include	        EMITS.GENERATE_CODE := TRUE;					--| IL FAUT GENERER LA REFERENCE
##  include	        EMIT ( RFP, INTEGER( 0 ), s=> PRINT_NAME ( SYMREP ) );		--| REFERENCE A PROCEDURE DE LIBRAIRIE
##  include	        DI ( CD_LABEL, DEFN, INTEGER ( PROC_LBL ) );			--| STOCKER L ETIQUETTE
##  include	        DI ( CD_LEVEL, DEFN, 1 );					--| STOCKER LE NIVEAU DE LA PROCEDURE REFERENCEE (1)
##  include	        DI ( CD_PARAM_SIZE, DEFN, 0 );					--| INITIALISER LA TAILLE DU PARAMETRAGE A ZERO )
##  include	        DB ( CD_COMPILED, DEFN, TRUE );					--| INDIQUER QUE L'ON A DEJA TRAITE
##  include	        EMIT ( RFL, PROC_LBL );					--| EMETTRE L ETIQUETTE
##  include	      END;
##  include	    END IF;

##  include	  END IF;
##  include	END;
--|.................................................................................................
//  USED_OBJECT		::=
//	used_char | used_object_id;
//  USED_OBJECT		=>
//	sm_exp_type	: TYPE_SPEC,
//	sm_value	: Value;

##  USED_OBJECT	====>
##	if	used_char
##	call	used_char	USED_OBJECT
##	if	used_object_id
##	call	used_object_id	USED_OBJECT
--|.................................................................................................
//  used_char	=> ;

##  used_char	====>
##	include	null;
--|.................................................................................................
//  used_object_id	=> ;

##  used_object_id	====>
##  include	    NULL;


//  NAME_VAL		::=
//	function_call;


//  exp_s		=>
//	as_list	: Seq Of EXP;
--|.................................................................................................
//  indexed		=>
//	as_exp_s	: exp_s;

##  INDEXED	====>
##  include	DECLARE
##  include	  PROCEDURE INDEX ( EXP_SEQ :SEQ_TYPE ) IS
##  include	    EXP_S : SEQ_TYPE := EXP_SEQ;
##  include	    EXP   : TREE;
##  include	  BEGIN
##  include	    POP ( EXP_S, EXP );
##  call	    EXP	EXP
##  include	    IF IS_EMPTY ( EXP_S ) THEN					--| DERNIER INDICE
##  include	      EMIT ( AR2, "ADRESSE POUR LE DERNIER INDICE (RAPIDE)" );
##  include	    ELSE								--| INDICES INTERMEDIAIRES
##  include	      EMIT ( AR1, "ADRESSE POUR INDICE INTERMEDIAIRE" );
##  include	      EMIT ( DEC, A, 3*INTG_SIZE, "PTR DESCRIPTEUR AU TRIPLET INDICE SUIVANT" );
##  include	      INDEX ( EXP_S );
##  include	      EMIT ( ADD, I, "AJOUTER LE DECALAGE A L ADRESSE DES INDICES PRECEDENTS" );
##  include	    END IF;
##  include	  END INDEX;
      
##  include	BEGIN
##  include	  CODE_OBJECT ( D ( AS_NAME, INDEXED ) );				--| EMPILER L ADRESSE D OBJET
##  include	  EMIT ( DPL, A, "DUP ADRESS OBJET" );					--| DUPLIQUER CETTE ADRESSE
##  include	  EMIT ( IND, A, 0, "CHARGE INDEXE D ADRESSE TABLEAU" );			--| CHARGEMENT DE L ADRESSE DE TABLEAU
##  include	  EMIT ( SWP, A, "ADRESSE OBJET AU TOP" );
##  include	  EMIT ( IND, A, -addr_Size, "CHARGE INDEXE ADRESSE DU DESCRIPTEUR TABLEAU" );
##  include	  EMIT ( DEC, A, INTG_SIZE, "ADRESSE DESCRIPTEUR - TAILLE ENTIER" );
##  include	  DECLARE
##  include	    EXP_SEQ : SEQ_TYPE := LIST ( D ( AS_EXP_S, INDEXED ) );
##  include	  BEGIN
##  include	    IF NOT IS_EMPTY ( EXP_SEQ ) THEN
##  include	     INDEX ( EXP_SEQ );
##  include	    END IF;
##  include	  END;
##  include	  EMIT ( IXA, INTEGER ( 1 ) );
##  include	END;

//  slice		=>
//	as_discrete_range	: DISCRETE_RANGE;

##  slice	====>
##	include	null;


--|-------------------------------------------------------------------------------------------------
-- 4.1.3  Selected Components
-- Syntax 4.1.3
--  selected_component ::=  prefix.selector
--
--  selector ::= simple_name
--     | character_literal | operator_symbol | all
--|-------------------------------------------------------------------------------------------------


//  selected		=>
//	as_designator	: DESIGNATOR;
--|.................................................................................................
//  all		=> ;

##  all	====>
##	include	null;



//  attribute		=>
//	as_used_name_id	: used_name_id,
//	as_exp	: EXP;



//  aggregate		=>
//	as_general_assoc_s		: general_assoc_s,
//	sm_normalized_comp_s	: general_assoc_s;

##  aggregate	====>
##	include	null;

//  GENERAL_ASSOC		::=
//	NAMED_ASSOC | EXP;
--|.................................................................................................
//  NAMED_ASSOC		::=
//	named;
//  NAMED_ASSOC		=>
//	as_exp	: EXP;
--|.................................................................................................
//  named		=>
//	as_choice_s	: choice_s;



//  EXP_VAL		::=
//	short_circuit;
--|.................................................................................................
//  short_circuit		=>
//	as_exp1	: EXP,
//	as_short_circuit_op	: SHORT_CIRCUIT_OP,
//	as_exp2	: EXP;

##  short_circuit	====>
##	include	null;
--|.................................................................................................
//  SHORT_CIRCUIT_OP	::=
//	and_then | or_else;
--|.................................................................................................
//  and_then	=> ;
--|.................................................................................................
//  or_else	=> ;




membership_op	::=
	  IN				====> $0 in_op
	| NOT IN				====> $0 not_in
	%%
--|.................................................................................................

//  EXP_VAL_EXP		::=
//	MEMBERSHIP;
--|.................................................................................................
//  MEMBERSHIP		::=
//	range_membership | type_membership;
//  MEMBERSHIP		=>
//	as_membership_op	: MEMBERSHIP_OP;

##  MEMBERSHIP	====>
##	if	range_membership
##	call	range_membership	MEMBERSHIP
##	if	type_membership
##	call	type_membership	MEMBERSHIP
--|.................................................................................................
//  range_membership	=>
//	as_range	: RANGE;

##  range_membership	====>
##	include	null;

//  type_membership		=>
//	as_name	: NAME;

##  type_membership	====>
##	include	null;
--|.................................................................................................
//  MEMBERSHIP_OP		::=
//	in_op | not_in;
--|.................................................................................................
//  in_op	=> ;
--|.................................................................................................
//  not_in	=> ;

//  EXP		::=
//	NAME | EXP_EXP;

##  EXP	====>
##	if_class	NAME
##	call	NAME	EXP
##	if_class	EXP_EXP
##	call	EXP_EXP	EXP
--|.................................................................................................
//  EXP_EXP		::=
//	EXP_VAL | AGG_EXP | qualified_allocator | subtype_allocator;
//  EXP_EXP		=>
//	sm_exp_type	: TYPE_SPEC;

##  EXP_EXP	====>
##	if_class	EXP_VAL
##	call	EXP_VAL	EXP_EXP
##	if_class	AGG_EXP
##	call	AGG_EXP	EXP_EXP
##	if	qualified_allocator
##	call	qualified_allocator	EXP_EXP
##	if	subtype_allocator
##	call	subtype_allocator	EXP_EXP
--|.................................................................................................
//  EXP_VAL		::=
//	numeric_literal | null_access | EXP_VAL_EXP;
//  EXP_VAL		=>
//	sm_value	: Value;

##  EXP_VAL	====>
##	if_class	EXP_VAL_EXP
##	call	EXP_VAL_EXP	EXP_VAL
##	if	numeric_literal
##	call	numeric_literal	EXP_VAL
##	if	null_access
##	call	null_access	EXP_VAL
##	if	short_circuit
##	call	short_circuit	EXP_VAL
--|.................................................................................................
//  EXP_VAL_EXP		::=
//	QUAL_CONV | parenthesized;
//  EXP_VAL_EXP		=>
//	as_exp	: EXP;

##  EXP_VAL_EXP	====>
##	if_class	QUAL_CONV
##	call	QUAL_CONV	EXP_VAL_EXP
##	if_class	MEMBERSHIP
##	call	MEMBERSHIP	EXP_VAL_EXP
##	if	parenthesized
##	call	parenthesized	EXP_VAL_EXP
--|.................................................................................................
//  AGG_EXP		::=
//	aggregate | string_literal;
//  AGG_EXP		=>
//	sm_discrete_range	: DISCRETE_RANGE;

##  AGG_EXP	====>
##	if	aggregate
##	call	aggregate	AGG_EXP
##	if	string_literal
##	call	string_literal	AGG_EXP
--|.................................................................................................
//  parenthesized		=> ;

##  parenthesized	====>
##	include	null;
--|.................................................................................................
//  numeric_literal		=>
//	lx_numrep	: Number_Rep;

##  numeric_literal	====>
##	include	null;
--|.................................................................................................
//  string_literal		=>
//	lx_symrep	: symbol_rep;

##  string_literal	====>
##	include	null;
--|.................................................................................................
//  null_access		=> ;

##  null_access	====>
##	include	null;


//  QUAL_CONV		::=
//	conversion | qualified;
//  QUAL_CONV		=>
//	as_name	: NAME;

##  QUAL_CONV	====>
##	if	conversion
##	call	conversion	QUAL_CONV
##	if	qualified
##	call	qualified	QUAL_CONV
--|.................................................................................................
//  conversion	=> ;

##  conversion	====>
##	include	null;

//  qualified	=> ;

##  qualified	====>
##	include	null;



//  qualified_allocator	=>
//	as_qualified	: qualified;

##  qualified_allocator	====>
##	include	null;

--|.................................................................................................
//  subtype_allocator	=>
//	as_subtype_indication	: subtype_indication,
//	sm_desig_type		: TYPE_SPEC;

##  subtype_allocator	====>
##	include	null;


//  STM_ELEM	::=
//	STM | stm_pragma;
//  stm_s		=>
//	as_list	: Seq Of STM_ELEM;

##  stm_s	====>
##	repeat_extract	stm_s	stm_elem
##	call	STM_ELEM	stm_elem

##  STM_ELEM	====>
##	if_class	STM
##	call	STM	STM_ELEM
##	if	stm_pragma
##	call	stm_pragma	STM_ELEM

//  stm_pragma		=>
//	as_pragma	: pragma;

##  stm_pragma	====>
##	include	null;


//  STM		::=
//	labeled;

##  STM	====>
##	if	labeled
##	call	labeled	STM
##	if	null_stm
##	call	null_stm	STM
##	if	accept
##	call	accept	STM
##	if	terminate
##	call	terminate	STM
##	if	abort
##	call	abort	STM
##	if_class	CLAUSES_STM
##	call	CLAUSES_STM	STM
##	if_class	BLOCK_LOOP
##	call	BLOCK_LOOP	STM
##	if_class	ENTRY_STM
##	call	ENTRY_STM	STM
##	if_class	STM_WITH_NAME
##	call	STM_WITH_NAME	STM
##	if_class	STM_WITH_EXP
##	call	STM_WITH_EXP	STM
--|.................................................................................................
//  labeled		=>
//	as_source_name_s	: source_name_s,
//	as_pragma_s	: pragma_s,
//	as_stm	: STM;

##  labeled	====>
##	include	null;


//  STM		::=
//	null_stm | abort | STM_WITH_EXP | STM_WITH_NAME;
--|.................................................................................................
//  STM_WITH_EXP		::=
//	return | delay | STM_WITH_EXP_NAME;
//  STM_WITH_EXP		=>
//	as_exp	: EXP;

##  STM_WITH_EXP	====>
##	if	return
##	call	return	STM_WITH_EXP
##	if	delay
##	call	delay	STM_WITH_EXP
##	if	case
##	call	case	STM_WITH_EXP
##	if_class	STM_WITH_EXP_NAME
##	call	STM_WITH_EXP_NAME	STM_WITH_EXP
--|.................................................................................................
//  STM_WITH_EXP_NAME	::=
//	assign | exit | code;
//  STM_WITH_EXP_NAME	=>
//	as_name	: NAME;

##  STM_WITH_EXP_NAME	====>
##	if	code
##	call	code	STM_WITH_EXP_NAME
##	if	assign
##	call	assign	STM_WITH_EXP_NAME
##	if	exit
##	call	exit	STM_WITH_EXP_NAME
--|.................................................................................................
//  STM_WITH_NAME		::=
//	goto | raise;
--|.................................................................................................
//  STM_WITH_NAME		::=
//	CALL_STM;
//  STM_WITH_NAME		=>
//	as_name	: NAME;

##  STM_WITH_NAME	====>
##	if	goto
##	call	goto	STM_WITH_NAME
##	if	raise
##	call	raise	STM_WITH_NAME
##	if_class	CALL_STM
##	call	CALL_STM	STM_WITH_NAME
--|.................................................................................................
//  CALL_STM		::=
//	entry_call | procedure_call;

##  CALL_STM	====>
##	if	procedure_call
##	call	procedure_call	CALL_STM
##	if	entry_call
##	call	entry_call	CALL_STM
--|.................................................................................................


//  STM		::=
//	accept | BLOCK_LOOP | ENTRY_STM | CLAUSES_STM;
--|.................................................................................................
//  STM_WITH_EXP		::=
//	case;
--|.................................................................................................
//  CLAUSES_STM		::=
//	if | selective_wait;
//  CLAUSES_STM		=>
//	as_test_clause_elem_s	: test_clause_elem_s,
//	as_stm_s		: stm_s;

##  CLAUSES_STM	====>
##	if	if
##	call	if	CLAUSES_STM
##	if	selective_wait
##	call	selective_wait	CLAUSES_STM


//  LABEL_NAME		::=
//	label_id;
//  LABEL_NAME		=>
//	sm_stm	: STM;

##  LABEL_NAME	====>
##	if	label_id
##	call	label_id	LABEL_NAME
##	if	block_loop_id
##	call	block_loop_id	LABEL_NAME
--|.................................................................................................
//  label_id		=>
//	cd_label	: Integer;

##  label_id	====>
##	include	null;

//  null_stm		=> ;

##  null_stm	====>
##	include	null;


--|.................................................................................................
##  OBJECT	====>								--| N EST PAS UN ELEMENT SYNTAXIQUE SE RATTACHE A USED_OBJECT_ID CONTEXTUALISE
##  include	  CASE OBJECT.TY IS
##  include	   WHEN DN_VARIABLE_ID =>						--| De classe OBJECT_NAME ; INIT_OBJECT_NAME ; VC_NAME
##  include	      GEN_LOAD_ADDR ( DI (CD_COMP_UNIT, OBJECT ), DI ( CD_LEVEL, OBJECT ), DI ( CD_OFFSET, OBJECT ),
##  include	                  "EMPILE ADRESSE DE VARIABLE" );
         
##  include	   WHEN DN_IN_ID =>							--| De classe OBJECT_NAME ; INIT_OBJECT_NAME ; PARAM_NAME
##  include	     EMIT ( LDA, LEVEL - DI ( CD_LEVEL, OBJECT ), DI ( CD_OFFSET, OBJECT ),
##  include	                  "EMPILE ADRESSE DE PARAM IN" );
         
##  include	   WHEN DN_IN_OUT_ID | DN_OUT_ID =>					--| De classe OBJECT_NAME ; INIT_OBJECT_NAME ; PARAM_NAME ; PARAM_IO_O
##  include	     EMIT ( LDA, LEVEL - DI ( CD_LEVEL, OBJECT ), DI ( CD_VAL_OFFSET, OBJECT ),
##  include	                  "EMPILE ADRESSE PARAM IN_OUT/OUT" );
         
##  include	   WHEN DN_INDEXED =>						--| De classe EXP ; NAME ; NAME_EXP
##  include	     CODE_INDEXED ( OBJECT );
         
##  include	   WHEN DN_USED_OBJECT_ID =>						--| De classe EXP ; NAME ; DESIGNATOR ; USED_OBJECT
##  include	     CODE_OBJECT ( D ( SM_DEFN, OBJECT ) );				--| CHARGER L ADRESSE CONTENUE DANS LA DEFINITION
         
##  include	   WHEN OTHERS =>
##  include	     PUT_LINE ( "!!! LOAD_OBJECT_ADDRESS : OBJECT.TY ILLICITE " & NODE_NAME'IMAGE ( OBJECT.TY ) );
##  include	     RAISE PROGRAM_ERROR;
##  include	  END CASE;
--|.................................................................................................
##  ADRESSE	====>								--| N EST PAS UN ELEMENT SYNTAXIQUE SE RATTACHE AUX ACCESS
##  include	CASE ADRESSE.TY is
##  include	WHEN DN_VARIABLE_ID =>						--| UNE VARIABLE ACCESS DE CLASSE OBJECT_NAME ; INIT_OBJECT_NAME ; VC_NAME
##  include	  GEN_LOAD ( A, DI (CD_COMP_UNIT, ADRESSE ), DI ( CD_LEVEL, ADRESSE ), DI ( CD_OFFSET, ADRESSE ) );
         
##  include	WHEN DN_IN_ID =>							--| UN PARAMETRE ACCESS IN DE CLASSE OBJECT_NAME ; INIT_OBJECT_NAME ; PARAM_NAME
##  include	  GEN_LOAD ( A, 0,  DI ( CD_LEVEL, ADRESSE ), DI ( CD_OFFSET, ADRESSE ) );
         
##  include	WHEN DN_IN_OUT_ID | DN_OUT_ID =>					--| UN PARAMETRE DE CLASSE OBJECT_NAME ; INIT_OBJECT_NAME ; PARAM_NAME ; PARAM_IO_O
##  include	  GEN_LOAD ( A, 0, DI ( CD_LEVEL, ADRESSE ), DI ( CD_VAL_OFFSET, ADRESSE ) );
         
##  include	WHEN DN_INDEXED =>							--| De classe EXP ; NAME ; NAME_EXP
##  include	  CODE_INDEXED ( ADRESSE );
         
##  include	WHEN DN_USED_OBJECT_ID =>			--| De classe EXP ; NAME ; DESIGNATOR ; USED_OBJECT
##  include	  CODE_ADRESSE ( D ( SM_DEFN, ADRESSE ) );
##  include	WHEN OTHERS =>
##  include	PUT_LINE ( "!!! CODE_ADRESSE : OBJECT.TY ILLICITE " & NODE_NAME'IMAGE ( ADRESSE.TY ) );
##  include	  RAISE PROGRAM_ERROR;
##  include	END CASE;

--|.................................................................................................
//  assign		=> ;

##  assign	====>
##  include	DECLARE
##  include	  NAME : TREE := D ( AS_NAME, ASSIGN );			--| RAMENER LE NOM AFFECTE

##  include	  PROCEDURE STORE_VAL ( TYPE_SPEC :TREE ) IS
##  include	  BEGIN
##  include	    CASE TYPE_SPEC.TY IS
##  include	    WHEN DN_ACCESS =>			--| STOCKAGE D UNE VALEUR POINTEUR
##  include	      EMIT ( STO, A );			--| STOCKER L ADRESSE A L ADRESSE DONNEE
                  
##  include	    WHEN DN_ENUMERATION =>			--| STOCKAGE D UNE VALEUR ENUMEREE
##  include	      DECLARE
##  include	        TYPE_SOURCE_NAME : TREE            := D ( XD_SOURCE_NAME, TYPE_SPEC );
##  include	        TYPE_SYMREP      : TREE            := D ( LX_SYMREP, TYPE_SOURCE_NAME );
##  include	        NAME             : CONSTANT STRING := PRINT_NAME ( TYPE_SYMREP );
##  include	      BEGIN
##  include	        IF NAME = "BOOLEAN" THEN EMIT ( STO, B );		--| STOCKER LE BOOLEAN A L ADRESSE DONNEE
##  include	        ELSIF NAME = "CHARACTER" THEN EMIT ( STO, C );		--| STOCKER LE CARACTERE
##  include	        ELSE EMIT ( STO, I );			--| STOCKER L ENTIER
##  include	        END IF;
##  include	      END;
                  
##  include	    WHEN DN_INTEGER =>			--| STOCKAGE D UNE VALEUR ENTIERE
##  include	      EMIT ( STO, I );
               
##  include	    WHEN DN_UNIVERSAL_INTEGER =>
##  include	      DECLARE
##  include	        COMP_UNIT : COMP_UNIT_NBR := DI ( CD_COMP_UNIT, TYPE_SPEC );
##  include	        LVL       : LEVEL_TYPE    := DI ( CD_LEVEL, TYPE_SPEC );
##  include	        OFS       : INTEGER       := DI ( CD_OFFSET, TYPE_SPEC );
##  include	      BEGIN
##  include	        GEN_LOAD_ADDR ( COMP_UNIT, LVL, OFS );
##  include	        EMIT ( CVB );
##  include	        EMIT ( STO, I );
##  include	      END;
               
##  include	    WHEN OTHERS =>
##  include	      PUT_LINE ( "!!! STORE_VAL TYPE_SPEC.TY ILLICITE " & NODE_NAME'IMAGE ( TYPE_SPEC.TY ) );
##  include	      RAISE PROGRAM_ERROR;
##  include	    END CASE;
##  include	  END STORE_VAL;

##  include	BEGIN
##  include	  --|---------------------------------------------------------------------------
##  include	  IF NAME.TY = DN_ALL THEN			--| C EST UNE INDIRECTION QQC.ALL
##  include	    CODE_ADRESSE ( D ( AS_NAME, NAME ) );		--| ADRESSE DE QQC
##  call	EXP	@ AS_EXP	ASSIGN		--| TRAITER L EXPRESSION A AFFECTER
##  include	    STORE_VAL ( D ( SM_EXP_TYPE, NAME ) );		--| STOCKER LA VALEUR D EXPRESSION

##  include	  --|---------------------------------------------------------------------------
##  include	  ELSIF NAME.TY = DN_INDEXED THEN			--| DESTINATION CASE DE TABLEAU
##  include	    CODE_INDEXED ( NAME );			--| ELABORER L ADRESSE DESTINATION PAR CALCUL D INDEX
##  call	EXP	@ AS_EXP	ASSIGN		--| TRAITER L EXPRESSION A AFFECTER
##  include	    STORE_VAL ( D ( SM_EXP_TYPE, NAME ) );		--| STOCKER LA VALEUR D EXPRESSION

##  include	  --|---------------------------------------------------------------------------
##  include	  ELSIF NAME.TY = DN_USED_OBJECT_ID THEN		--| DESTINATION IDENTIFICATEUR D OBJET DEST :=
##  include	    DECLARE
##  include	      NAMEXP    : TREE := D ( SM_EXP_TYPE, NAME );		--| GENRE D OBJET DESTINATION
##  include	      DEFN      : TREE := D ( SM_DEFN, NAME );		--| DEFINITION DE L OBJET A AFFECTER
##  include	      COMP_UNIT : COMP_UNIT_NBR;			--| NUMERO D UNITE POUR LE STOCKAGE
##  include	      LVL       : LEVEL_TYPE;			--| NIVEAU DE STOCKAGE
##  include	      OFS       : OFFSET_TYPE;			--| DECALAGE DE STOCKAGE
##  include	    BEGIN
##  include	      --|-----------------------------------------------------------------------
##  include	      IF NAMEXP.TY = DN_ACCESS THEN			--| L OBJET DESTINATION EST UN ACCES
##  call	EXP	@ AS_EXP	ASSIGN		--| TRAITER L EXPRESSION A AFFECTER
##  include	        EMITS.GET_CLO ( DEFN, COMP_UNIT, LVL, OFS );		--| LIEU DE LA DEFINITION DESTINATION
##  include	        EMITS.GEN_STORE ( A, COMP_UNIT, LVL, OFS );		--| STOCKAGE DANS LA DESTINATION
##  include	      --|-----------------------------------------------------------------------
##  include	      ELSIF NAMEXP.TY = DN_ARRAY THEN			--| L OBJET DESTINATION EST UN TABLEAU
##  include	        CODE_OBJECT ( DEFN );			--| ADRESSE DESTINATION
##  include	        DECLARE
##  include	          EXP : TREE := D ( AS_EXP, ASSIGN );		--| EXPRESSION A DROITE DE L AFFECTATION
##  include	        BEGIN
##  include	          IF EXP.TY = DN_USED_OBJECT_ID THEN		--| IDENTIFICATEUR D OBJET DU GENRE := SRC
##  include	            CODE_OBJECT ( D ( SM_DEFN, EXP ) );		--| CHARGER L ADRESSE CONTENUE DANS LA DEFINITION
##  include	            CODE_OBJECT( EXP );			--| ADRESSE SOURCE
##  include	            EMIT ( LDC, I, NUMBER_OF_DIMENSIONS ( NAMEXP ), COMMENT=>"NB DIM" );
##  include	            EMIT ( CYA );			--| PROCEDURE STANDARD COPY ARRAY
##  include	          ELSE
##  call	EXP	@ AS_EXP	ASSIGN		--| TRAITER L EXPRESSION A AFFECTER
##  include	            EMIT ( LDC, I, NUMBER_OF_DIMENSIONS ( NAMEXP ), COMMENT=>"NB DIM" );
##  include	            EMIT ( PUA );			--| PROCEDURE STANDARD PUSH ARRAY
##  include	          END IF;
##  include	        END;
##  include	      --|-----------------------------------------------------------------------
##  include	      ELSIF NAMEXP.TY = DN_ENUMERATION THEN		--| L OBJET DESTINATION A UN TYPE ENUMERE
##  call	EXP	@ AS_EXP	ASSIGN		--| TRAITER L EXPRESSION A AFFECTER
##  include	        EMITS.GET_CLO ( DEFN, COMP_UNIT, LVL, OFS );		--| LIEU DE LA DEFINITION DESTINATION
##  include	        DECLARE
##  include	          CT : CODE_TYPE := CODE_TYPE_OF ( NAMEXP );		--| CODE BOOL OU CHAR OU INT
##  include	        BEGIN
##  include	          GEN_STORE ( CT, COMP_UNIT, LVL, OFS );		--| EMETTRE STORE EN FONCTION DU CODE TYPE
##  include	        END;
##  include	      --|-----------------------------------------------------------------------
##  include	      ELSIF NAMEXP.TY = DN_INTEGER THEN			--| L OBJET DESTINATION A UN TYPE ENTIER
##  call	EXP	@ AS_EXP	ASSIGN		--| TRAITER L EXPRESSION A AFFECTER
##  include	        IF NAMEXP.TY /= DN_UNIVERSAL_INTEGER THEN		--| UN ENTIER NON STANDARD
##  include	          EMITS.GET_CLO ( NAMEXP, COMP_UNIT, LVL, OFS );		--| LIEU DE LA SOURCE
##  include	          GEN_LOAD_ADDR ( COMP_UNIT, LVL, OFS );		--| ADRESSE DE LA SOURCE
##  include	          EMIT ( CVB );			--| EMPILEMENT DU CONVERTI
##  include	        END IF;
##  include	        EMITS.GET_CLO ( DEFN, COMP_UNIT, LVL, OFS );		--| LIEU DE LA DEFINITION DESTINATION
##  include	        EMITS.GEN_STORE ( I, COMP_UNIT, LVL, OFS );		--| STOCKAGE DU CONVERTI DANS LA DESTINATION

##  include	      END IF;
##  include	    END;
##  include	  END IF;
##  include	END;



--|-------------------------------------------------------------------------------------------------
-- 5.3	If Statements
-- Syntax 5.3.A
--  if_statement ::=
--	if condition then
--	    sequence_of_statements
--     {elsif condition then
--	    sequence_of_statements}
--     [else
--	    sequence_of_statements]
--	end if;
--|-------------------------------------------------------------------------------------------------

if_statement	::=
	  if_clause_s  END IF ;				====> nil $L stm_s $2 if
	| if_clause_s  else_clause  END IF  ; 			====> $2 if
	%%
--|.................................................................................................
if_clause	::=
	IF  condition  THEN  sequence_of_statements		====> $2 cond_clause
	%%
--|.................................................................................................
elsif_clause	::=
	ELSIF  condition  THEN  sequence_of_statements		====> $2 cond_clause
	%%
--|.................................................................................................
if_clause_s	::=
	if_clause{elsif_clause} 			====> $L test_clause_elem_s
	%%
--|.................................................................................................
else_clause	::=
	ELSE  sequence_of_statements
	%%
--|.................................................................................................
condition	::=
	expression
	%%
--|.................................................................................................


//  if		=> ;
--	as_test_clause_elem_s	:test_clause_elem_s
--	as_stm_s	:stm_s
--	lx_srcpos	:Source_Position

##  if	====>
##  include	DECLARE
##  include	  OLD_AFTER_IF_LBL : LABEL_TYPE := EMITS.AFTER_IF_LBL;		--| GARER EN CAS D IMBRICATION DE IF
##  include	BEGIN
##  include	  EMITS.AFTER_IF_LBL := NEXT_LABEL;			--| ALLOUER UNE ETIQUETTE POST FIN DU IF
##  call	test_clause_elem_s	@ as_test_clause_elem_s	if	--| TRAITER LA SEQUENCE DES IF ELSIF ELSE
##  include	  WRITE_LABEL ( EMITS.AFTER_IF_LBL, COMMENT=> "ETIQUETTE END IF" );	--| ECRIRE L ETIQUETTE POST FIN DU IF
##  include	  EMITS.AFTER_IF_LBL := OLD_AFTER_IF_LBL;		--| RESTAURER L EVENTUELLE ETIQUETTE D UN IF ENGLOBANT
##  include	END;
--|.................................................................................................
//  TEST_CLAUSE		::=
//	cond_clause;
//  TEST_CLAUSE		=>
//	as_exp	: EXP,
//	as_stm_s	: stm_s;

##  TEST_CLAUSE	====>
##	if	cond_clause
##	call	cond_clause	TEST_CLAUSE
##	if	select_alternative
##	call	select_alternative	TEST_CLAUSE

--|.................................................................................................
//  cond_clause		=> ;
--	as_exp	:EXP
--	as_stm_s	:stm_s
--	lx_srcpos	:Source_Position

##  cond_clause	====>
--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
##  include	DECLARE
##  include	  EXP : TREE := D ( AS_EXP, COND_CLAUSE );
##  include	  NEXT_CLAUSE_LBL : LABEL_TYPE;
##  include	BEGIN
##  call	exp	exp			--| EXPRESSION CONDITION
##  include	  NEXT_CLAUSE_LBL := NEXT_LABEL;			--| ALLOUER UNE ETIQUETTE POUR LA CONDITION SUIVANTE
##  include	  EMIT ( JMPF, NEXT_CLAUSE_LBL, COMMENT=> "NON CONDITION SAUT CLAUSE SUIVANTE" );
##  call	stm_s	@ as_STM_S	cond_clause		--| INSTRUCTIONS DE L ALTERNATIVE
##  include	  EMIT ( JMP, EMITS.AFTER_IF_LBL, COMMENT=> "SAUT END IF" );	--| SAUT POST IF
##  include	  WRITE_LABEL ( NEXT_CLAUSE_LBL, COMMENT=> "LBL CONDITION SUIVANTE" );
##  include	END;

//  case		=>
//	as_alternative_s	: alternative_s;

##  case	====>
##	include	null;



--|-------------------------------------------------------------------------------------------------
-- 5.5	Loop Statements
-- Syntax 5.5.A
--  loop_statement ::=
--     [loop_simple_name:]
--	    [iteration_scheme] loop
--		 sequence_of_statements
--	    end loop [loop_simple_name];
--|-------------------------------------------------------------------------------------------------

loop_statement	::=
	  loop  ;				====> void exch_2 exch_1 $V3 loop $DEF block_loop_id
	| identifier  :  loop  identifier  ;			====> check_name $V3 loop $DEF block_loop_id
	%%
--|.................................................................................................
loop	::=
	[iteration_scheme]  LOOP  sequence_of_statements  END  LOOP
	%%
--|.................................................................................................


//  BLOCK_LOOP		::=
//	loop;
//  BLOCK_LOOP		=>
//	as_source_name	: SOURCE_NAME;

##  BLOCK_LOOP	====>
##	if	loop
##	call	loop	BLOCK_LOOP
##	if	block
##	call	block	BLOCK_LOOP
--|.................................................................................................
//  LABEL_NAME		::=
//	block_loop_id;
--|.................................................................................................
//  block_loop_id		=> ;

##  block_loop_id	====>
##	include	null;
--|.................................................................................................

##  ITERATION	====>
##	if_class	FOR_REV
##	call	FOR_REV	ITERATION
##	if	while
##	call	while	ITERATION
--|.................................................................................................
//  loop		=>
//	as_iteration	: ITERATION,
//	as_stm_s	: stm_s
//	cd_level	: Integer
//	cd_after_loop	: Integer;

##  loop	====>				--| BOUCLE SIMPLE
##  include	DECLARE
##  include	  OLD_LOOP_STM_S          : TREE := EMITS.LOOP_STM_S;		--| GARER LA SEQUENCE EN CAS D IMBRICATION
##  include	  OLD_BEFORE_LOOP_LBL : LABEL_TYPE := EMITS.BEFORE_LOOP_LBL;	--| GARER CES ETIQUETTES EN CAS D IMBRICATION DE BOUCLES
##  include	  OLD_AFTER_LOOP_LBL  : LABEL_TYPE := EMITS.AFTER_LOOP_LBL;
##  include	BEGIN
##  include	  LOOP_STM_S := D ( as_STM_S, ADA_LOOP );		--| RAMENER LA SEQUENCE D'INSTRUCTIONS INTERNE A LA BOUCLE
##  include	  EMITS.BEFORE_LOOP_LBL := NEXT_LABEL;			--| ALLOUER UNE ETIQUETTE DE DEBUT DE BOUCLE
##  include	  EMITS.AFTER_LOOP_LBL := NEXT_LABEL;			--| ALLOUER UNE ETIQUETTE POST FIN DE BOUCLE
##  include	  DI ( CD_AFTER_LOOP, ADA_LOOP, INTEGER( after_Loop_Lbl) );		--| PLACER L ETIQUETTE POST BOUCLE DANS LE STM LOOP (ADA_LOOP)
##  include	  DI ( CD_LEVEL, ADA_LOOP, EMITS.LEVEL );		--| PLACER LE NIVEAU ACTUEL EGALEMENT

##  include	  DECLARE
##  include	    ITERATION : TREE := D ( AS_ITERATION, ADA_LOOP );		--| RAMENER LE SCHEMA ITERATIF EVENTUEL
##  include	  BEGIN
##  include	    IF ITERATION = TREE_VOID then			--| S IL N Y EN A PAS (LOOP instructions END LOOP)
##  include	      WRITE_LABEL ( BEFORE_LOOP_LBL );			--| ECRIRE L ETIQUETTE DE DEBUT DE BOUCLE
##  call	stm_s	LOOP_STM_S			--| COMPILER LES INSTRUCTIONS DE LA BOUCLE
##  include	      EMIT ( JMP, BEFORE_LOOP_LBL );			--| ECRIRE LE SAUT DE RETOUR DE BAS DE BOUCLE
##  include	    ELSE				--| S IL Y A UN SCHEMA ITERATIF
##  call	ITERATION	@ as_iteration	ada_loop
##  include	    END IF;
##  include	  END;
##  include	  WRITE_LABEL ( after_Loop_Lbl );			--| ECRIRE L ETIQUETTE POST BOUCLE
##  include	  EMITS.BEFORE_LOOP_LBL := OLD_BEFORE_LOOP_LBL;		--| RESTAURER LES ETIQUETTES D UNE EVENTUELLE BOUCLE EXTERNE
##  include	  EMITS.AFTER_LOOP_LBL := OLD_AFTER_LOOP_LBL;
##  include	  EMITS.LOOP_STM_S := OLD_LOOP_STM_S;
##  include	END;


--|-------------------------------------------------------------------------------------------------
-- Syntax 5.5.B
--  iteration_scheme ::=  while condition
--     | for loop_parameter_specification
--
--  loop_parameter_specification ::=
--     identifier in [reverse] discrete_range
--|-------------------------------------------------------------------------------------------------

iteration_scheme	::=
	  WHILE  condition				====> $1 while
	| FOR  iteration_id  IN  discrete_range			====> $2 for
	| FOR  iteration_id  IN  REVERSE  discrete_range		====> $2 reverse
	%%
--|.................................................................................................
iteration_id	::=
	identifier				====> $0 iteration_id lx_symrep
	%%
--|.................................................................................................


//  ITERATION		::=
//	FOR_REV;
--|.................................................................................................
//  FOR_REV		::=
//	for | reverse;
//  FOR_REV		=>
//	as_source_name	: SOURCE_NAME,
//	as_discrete_range	: DISCRETE_RANGE;

##  FOR_REV	====>				--| BOUCLE FOR OU REVERSE (LES SAUVEGARDES D ETIQUETTES SONT DEJA FAITES PAR LOOP QUI APPELLE)
##  include	DECLARE
##  include	  OLD_LOOP_OP_INC_DEC   : OP_CODE      := EMITS.LOOP_OP_INC_DEC;	--| GARER CELA EN CAS D IMBRICATION DE BOUCLES FOR REV
##  include	  OLD_LOOP_OP_GT_LT     : OP_CODE      := EMITS.LOOP_OP_GT_LT;
##  include	  COUNTER, TEMP         : INTEGER;
##  include	  OLD_OFFSET_ACT        : OFFSET_TYPE  := EMITS.OFFSET_ACT;
##  include	  ITERATION_ID          : TREE         := D ( AS_SOURCE_NAME, FOR_REV );
##  include	  aCT                   : CODE_TYPE    := EMITS.CODE_TYPE_OF ( D ( SM_OBJ_TYPE, ITERATION_ID ) );
##  include	  PROCEDURE LOAD_DSCRT_RANGE ( DSCRT_RANGE : TREE ) IS
##  include	  BEGIN
##  include	    NULL;
##  include	  END;
##  include	BEGIN
##  include	  EMITS.BEFORE_LOOP_LBL := NEXT_LABEL;			--| ALLOUER UNE ETIQUETTE DE DEBUT DE BOUCLE
##  include	  EMITS.AFTER_LOOP_LBL := NEXT_LABEL;			--| ALLOUER UNE ETIQUETTE POST FIN DE BOUCLE
##  if	for
##  call	for	FOR_REV			--| POSITIONNE LES OPERATIONS LOOP_OP INC LE
##  if	reverse
##  call	reverse	FOR_REV			--| POSITIONNE LES OPERATIONS LOOP_OP DEC GE
##  end_if
##  include	  CASE aCT IS				--| SUIVANT LE TYPE DE LA VARIABLE D ITERATION
##  include	  WHEN B =>				--| BOOLEEN (? POUR UNE BOUCLE ?)
##  include	    ALIGN ( Bool_Al );
##  include	    COUNTER := -EMITS.OFFSET_ACT;
##  include	    INC_OFFSET ( Bool_Size);
##  include	    ALIGN ( Bool_Al);
##  include	    TEMP := -EMITS.OFFSET_ACT;
##  include	    INC_OFFSET ( Bool_Size );
##  include	  WHEN C =>				--| CARACTERE
##  include	    ALIGN ( Char_Al );
##  include	    COUNTER := -EMITS.OFFSET_ACT;
##  include	    INC_OFFSET ( Char_Size );
##  include	    ALIGN ( Char_Al);
##  include	    TEMP := -EMITS.OFFSET_ACT;
##  include	    INC_OFFSET ( Char_Size );
##  include	  WHEN I =>				--| ENTIER
##  include	    ALIGN ( INTG_Al );			--| ALIGNER POUR L ENTIER VARIABLE COMPTEUR
##  include	    COUNTER := -EMITS.OFFSET_ACT;			--| OFFSET DU COMPTEUR DE BOUCLE
##  include	    INC_OFFSET ( INTG_SIZE );			--| RESERVER UNE PLACE D ENTIER COMPTEUR
##  include	    ALIGN ( INTG_Al );			--| ALIGNER POUR L ENTIER BORNE DE COMPTAGE
##  include	    TEMP := -EMITS.OFFSET_ACT;			--| OFFSET DE LA BORNE DE COMPTAGE
##  include	    INC_OFFSET ( INTG_SIZE );			--| RESERVER UNE PLACE D ENTIER BORNE
##  include	  WHEN A =>
##  include	    PUT_LINE ( "!!! compile_stm_loop_reverse aCT illicite " & Code_Type'IMAGE ( aCT ) );
##  include	    RAISE PROGRAM_ERROR;
##  include	  END CASE;

##  include	  DI ( CD_LEVEL, ITERATION_ID, EMITS.LEVEL );		--| RANGER LE NIVEAU STATIQUE DU COMPTEUR
##  include	  DI ( CD_OFFSET, ITERATION_ID, COUNTER );		--| RANGER L OFFSET DE COMPTEUR
##  include	  LOAD_DSCRT_RANGE ( D ( as_DISCRETE_RANGE, FOR_REV ) );

##  include	  EMIT ( STR, aCT, 0, TEMP );
##  include	  WRITE_LABEL ( EMITS.BEFORE_LOOP_LBL );		--| ETIQUETTE DE DEBUT DE BOUCLE
##  include	  EMIT ( STR, aCT, 0, COUNTER );			--| STOCKER LE COMPTEUR (IL EST MODIFIE EN FIN DE BOUCLE)
##  include	  EMIT ( LOD, aCT, 0, COUNTER );			--| RECHARGER LE COMPTEUR
##  include	  EMIT ( LOD, aCT, 0, TEMP );			--| CHARGER LA BORNE
##  include	  EMIT ( EMITS.LOOP_OP_GT_LT, aCT );			--| FAIRE LA COMPARAISON SUIVANT LE CAS FOR OU REVERSE
##  include	  EMIT ( JMPT, EMITS.AFTER_LOOP_LBL );			--| LE COMPTEUR DEPASSE LA BORNE SORTIE DE BOUCLE
##  call	stm_s	LOOP_STM_S			--| TRAITER LES INSTRUCTIONS DE BOUCLE
##  include	  EMIT ( LOD, aCT, 0, COUNTER );			--| CHARGER LE COMPTEUR
##  include	  EMIT ( EMITS.LOOP_OP_INC_DEC, aCT, 1 );		--| L INCREMENTER OU DECREMENTER SUIVANT LE TYPE DE BOUCLE
##  include	  EMIT ( JMP, EMITS.BEFORE_LOOP_LBL );			--| FOND DE BOUCLE SAUT AU DEBUT
##  include	  WRITE_LABEL ( EMITS.AFTER_LOOP_LBL );			--| ETIQUETTE POST BOUCLE

##  include	  EMITS.OFFSET_ACT := OLD_OFFSET_ACT;
##  include	  EMITS.LOOP_OP_INC_DEC := OLD_LOOP_OP_INC_DEC;		--| RESTAURER CES OPERATIONS D UNE EVENTUELLE BOUCLE EXTERNE FOR REV
##  include	  EMITS.LOOP_OP_GT_LT := OLD_LOOP_OP_GT_LT;
##  include	END;

--|.................................................................................................
//  for		=> ;

##  for	====>
##  include	LOOP_OP_INC_DEC := INC;			--| UNE BOUCLE FOR NORMALE INCREMENTE SON COMPTEUR
##  include	LOOP_OP_GT_LT := GT;			--| ON L ARRETE QUAND LE COMPTEUR DEPASSE LA BORNE

--|.................................................................................................
//  reverse		=> ;

##  reverse	====>
##  include	LOOP_OP_INC_DEC := DEC;			--| UNE BOUCLE FOR REVERSE DECREMENTE SON COMPTEUR
##  include	LOOP_OP_GT_LT := LT;			--| ON L ARRETE QUAND LE COMPTEUR PASSE SOUS LA BORNE
--|.................................................................................................
//  OBJECT_NAME		::=
//	iteration_id;
--|.................................................................................................
//  iteration_id		=>
//	cd_level	: Integer,
//	cd_offset	: Integer;

##  iteration_id	====>
##	include	null;
--|.................................................................................................
//  ITERATION		::=
//	while;
--|.................................................................................................
//  while		=>
//	as_exp	: EXP;

##  while	====>				--| BOUCLE WHILE (LES SAUVEGARDES D ETIQUETTES SONT DEJA FAITE PAR LOOP QUI APPELLE WHILE)
##  include	BEFORE_LOOP_LBL := NEXT_LABEL;			--| ALLOUER UNE ETIQUETTE DE DEBUT DE BOUCLE
##  include	AFTER_LOOP_LBL := NEXT_LABEL;			--| ALLOUER UNE ETIQUETTE POST FIN DE BOUCLE
##  include	WRITE_LABEL ( BEFORE_LOOP_LBL );			--| ECRIRE L ETIQUETTE ENTREE DE BOUCLE
##  call	EXP	@ as_EXP	ADA_WHILE		--| TRAITER L EXPRESSION CONDITION
##  include	EMIT ( JMPF, AFTER_LOOP_LBL );			--| SAUT POST BOUCLE SI CONDITION FAUSSE
##  call	stm_s	LOOP_STM_S			--| TRAITER LES INSTRUCTIONS DE LA BOUCLE
##  include	EMIT ( JMP, BEFORE_LOOP_LBL );			--| FOND DE BOUCLE SAUT AU DEBUT DE BOUCLE




//  BLOCK_LOOP		::=
//	block;
--|.................................................................................................
//  block		=>
//	as_block_body	: block_body;
--	as_source_name	:SOURCE_NAME
--	lx_srcpos	:Source_Position

##  block	====>
##  include	DECLARE
##  include	  AFTER_BLOCK_LBL : LABEL_TYPE := NEXT_LABEL;
##  include	  PROC_LBL        : LABEL_TYPE := NEXT_LABEL;
##  include	BEGIN
##  include	  EMIT ( MST, INTEGER ( 0 ), INTEGER( 0 ), COMMENT=> "POUR BLOC" );
##  include	  EMIT ( CALL, EMITS.RELATIVE_RESULT_OFFSET, PROC_LBL,		--| UN BLOC EST TRAITE COMME UNE PROCEDURE SANS PARAMETRE DONC APPELE
##  include	         COMMENT=> "APPEL DE BLOC" );
##  include	  EMIT ( JMP, AFTER_BLOCK_LBL, COMMENT=> "SAUT POST BLOC" );	--| AU RETOUR DU BLOC SAUTER POST BLOC
##  include	  WRITE_LABEL ( PROC_LBL);			--| ETIQUETTE DEBUT DE BLOC
##  include	  DECLARE
##  include	    OLD_OFFSET_ACT : OFFSET_TYPE := EMITS.OFFSET_ACT;		--| GARER LES OFFSETS ANTERIEURS
##  include	    OLD_OFFSET_MAX : OFFSET_TYPE := EMITS.OFFSET_MAX;
##  include	  BEGIN
##  include	    EMITS.OFFSET_ACT := FIRST_LOCAL_VAR_OFFSET;		--| METTRE LES OFFSETS SUR LA PREMIERE VARIABLE LOCALE
##  include	    EMITS.OFFSET_MAX := FIRST_LOCAL_VAR_OFFSET;
##  include	    INC_LEVEL;				--| UN NIVEAU PLUS PROFOND
##  call	block_body	@ as_block_body	block		--| TRAITER LE CORPS DU BLOC
##  include	    DEC_LEVEL;
##  include	    EMITS.OFFSET_ACT := OLD_OFFSET_ACT;			--| RESTAURER LES OFFSETS D AVANT LE BLOC
##  include	    EMITS.OFFSET_MAX := OLD_OFFSET_MAX;
##  include	  END;
##  include	  WRITE_LABEL ( AFTER_BLOCK_LBL );
##  include	END;


--|-------------------------------------------------------------------------------------------------
-- 5.7	Exit Statements
-- Syntax 5.7
--  exit_statement ::=
--     exit [loop_name] [when condition] ;
--|-------------------------------------------------------------------------------------------------

exit_statement	::= 
	EXIT  [expanded_name]  [WHEN__condition]  ;		====> exch_1 $2 exit
	%%
--|.................................................................................................
[WHEN__condition]	::=
	empty				====> void
	| WHEN  expression
	%%
--|.................................................................................................

--|.................................................................................................
//  exit		=>
//	sm_stm	: STM;
--	as_exp	:EXP
--	as_name	:NAME
--	lx_srcpos	:Source_Position

##  exit	====>

##  include	DECLARE
##  include	  LVB_LBL          : LABEL_TYPE;
##  include	  EXP              : TREE := D ( AS_EXP, ada_exit );		--| AMENER L EXPRESSION EVENTUELLE DE CONDITION DE SORTIE
##  include	  LOOP_STM         : TREE := D ( SM_STM, ada_exit );		--| AMENER L INSTRUCTION BOUCLE DONT ON SORT
##  include	  LOOP_LEVEL       : LEVEL_TYPE := DI ( CD_LEVEL, LOOP_STM );	--| LIRE SON NIVEAU STATIQUE
##  include	  AFTER_LOOP_LABEL : LABEL_TYPE := LABEL_TYPE( DI( CD_AFTER_LOOP, LOOP_STM ) );	--| REPRENDRE LE NUMERO D ETIQUETTE DE FIN DE BOUCLE
##  include	BEGIN
##  include	  IF EXP = TREE_VOID THEN			--| PAS D EXPRESSION DONC EXIT SANS CONDITION (SANS WHEN)
##  include	    IF LOOP_LEVEL /= EMITS.LEVEL THEN			--| LE NIVEAU DE LA BOUCLE DIFFERE DU NIVEAU COURANT DE L EXIT (PLUS PROFOND)
##  include	         LVB_LBL := NEXT_LABEL;			--| ALLOUER UNE ETIQUETTE
##  include	         EMIT ( LVB, LVB_LBL, COMMENT=> "NOMBRE DE NIVEAUX REMONTES" );	--| EMETTRE UN LEAVE BLOCK AVEC CETTE ETIQUETTE
##  include	         GEN_LBL_ASSIGNMENT ( LVB_LBL, EMITS.LEVEL - LOOP_LEVEL );	--| QUI A VALEUR LE NOMBRE DE NIVEAUX REMONTES
##  include	    END IF;
##  include	    EMIT ( JMP, AFTER_LOOP_LABEL, COMMENT=> "SORTIE DE BOUCLE" );	--| EMETTRE LE SAUT EN FIN DE BOUCLE

##  include	  ELSE				--| EXIT AVEC CONDITION (AVEC WHEN)
##  call	exp	exp			--| TRAITER L EXPRESSION
##  include	    IF LOOP_LEVEL /= EMITS.LEVEL THEN			--| LE NIVEAU DE LA BOUCLE DIFFERE DU NIVEAU COURANT DE L EXIT (PLUS PROFOND)
##  include	      DECLARE
##  include	        SKIP_LBL : LABEL_TYPE := NEXT_LABEL;		--| ALLOUER UNE ETIQUETTE DE SAUT POUR POURSUITE SI CONDITION FAUSSE
##  include	      BEGIN
##  include	        EMIT ( JMPF, SKIP_LBL, COMMENT=> "PAS D EXIT SI CONDITION FAUSSE" );	--| EMETTRE LE SAUT A CETTE ETIQUETTE
##  include	        LVB_LBL := NEXT_LABEL;			--| ALLOUER UNE ETIQUETTE
##  include	        EMIT ( LVB, LVB_lbl, COMMENT=> "NOMBRE DE NIVEAUX REMONTES" );	--| EMETTRE UN LEAVE BLOCK AVEC CETTE ETIQUETTE
##  include	        GEN_LBL_ASSIGNMENT ( LVB_LBL, EMITS.LEVEL - LOOP_LEVEL );	--| QUI A VALEUR LE NOMBRE DE NIVEAUX REMONTES
##  include	        EMIT ( JMP, AFTER_LOOP_LABEL, COMMENT=> "SORTIE DE BOUCLE" );	--| EMETTRE LE SAUT EN FIN DE BOUCLE
##  include	        WRITE_LABEL ( SKIP_LBL, COMMENT=> "LABEL NO EXIT" );	--| ECRIRE L ETIQUETTE DE CONTOURNEMENT
##  include	      END;
##  include	    ELSE				--| LE NIVEAU DE L EXIT EST CELUI DE LA BOUCLE
##  include	      EMIT ( JMPT, AFTER_LOOP_LABEL );			--| EMETTRE UN SIMPLE SAUT POST FIN DE BOUCLE
##  include	    END IF;
##  include	  END IF;
##  include	END;



--|-------------------------------------------------------------------------------------------------
-- 5.8	Return Statements
-- Syntax 5.8
--  return_statement ::= return [expression] ;
--|-------------------------------------------------------------------------------------------------

return_statement	::=
	RETURN  [expression]  ;			====> $1 return
	%%
--|.................................................................................................


//  return		=> ;

##  return	====>
##  include	DECLARE
##  include	  EXP : TREE := D ( AS_EXP, ADA_RETURN );		--| RAMENER L EXPRESSION RETOURNEE
##  include	BEGIN
##  include	  IF EXP /= TREE_VOID THEN			--| IL Y A UNE EXPRESSION
##  include	STORE_FUNCTION_RESULT:
##  include	    DECLARE
##  include	      ENCLOSING_LEVEL : INTEGER := DI ( CD_LEVEL, EMITS.ENCLOSING_BODY );	--| NIVEAU STATIQUE DE L ENGLOBANT
##  include	      RESULT_OFFSET : INTEGER := DI ( CD_RESULT_OFFSET, EMITS.ENCLOSING_BODY );	--| DECALAGE DU RESULTAT
##  include	      EXPR_TYPE     : TREE := D ( SM_EXP_TYPE, EXP );		--| TYPE DE L EXPRESSION
##  include	    BEGIN
##  include	      IF EXPR_TYPE.TY = DN_ARRAY THEN			--| RETOUR D'UN TABLEAU
##  include	        EMIT ( LDA, EMITS.LEVEL - ENCLOSING_LEVEL, RESULT_OFFSET );
##  call	EXP	exp			--| TRAITER L EXPRESSION
##  include	        EMIT ( LDC, I, EMITS.NUMBER_OF_DIMENSIONS ( EXP ) );	--| EMPILER LE NOMBRE DE DIMENSIONS
##  include	        EMIT ( PUA );			--| APPELER "PUT ARRAY"
                     
##  include	       ELSIF EXPR_TYPE.TY = DN_ENUM_LITERAL_S THEN		--| ENUMERE
##  call	EXP	exp			--| TRAITER L EXPRESSION
##  include	         EMIT ( STR, EMITS.CODE_TYPE_OF ( EXP ), EMITS.LEVEL - ENCLOSING_LEVEL, RESULT_OFFSET );
                     
##  include	       ELSIF EXPR_TYPE.TY = DN_INTEGER THEN
##  call	EXP	exp
##  include	         EMIT ( STR, I, EMITS.LEVEL - ENCLOSING_LEVEL, RESULT_OFFSET );
##  include	       END IF;
##  include	     END STORE_FUNCTION_RESULT;
##  include	   END IF;
##  include	   EMITS.PERFORM_RETURN ( EMITS.ENCLOSING_BODY );		--| EFFECTUER LE RETOUR PROPREMENT DIT
##  include	end;



--|-------------------------------------------------------------------------------------------------
-- 5.9	Goto Statements
-- Syntax 5.9
--  goto_statement ::= goto label_name;
--|-------------------------------------------------------------------------------------------------

goto_statement	::=
	GOTO  expanded_name  ;			====> $1 goto
	%%
--|.................................................................................................


//  goto		=> ;

##  goto	====>
##	include	null;



--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-- 6.  Subprograms
--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-- 6.1	Subprogram Declarations
-- Syntax 6.1.A
--  subprogram_declaration ::= subprogram_specification;
--|-------------------------------------------------------------------------------------------------

subprogram_declaration	::=
	subprogram_specification  ;			====> void $3 subprog_entry_decl
	%%
--|.................................................................................................
proc_id	::=
	identifier				====> $0 procedure_id lx_symrep
	%%
--|.................................................................................................
function_id	::=
	identifier				====> $0 function_id lx_symrep
	%%
--|.................................................................................................
def_op	::=
	string_literal				====> $0 operator_id lx_symrep
	%%
--|.................................................................................................
//  UNIT_NAME		::=
//	NON_TASK_NAME;
--|.................................................................................................
//  NON_TASK_NAME		::=
//	SUBPROG_PACK_NAME;
//  NON_TASK_NAME		=>
//	sm_spec	: HEADER,
//	xd_stub	: stub,
//	xd_body	: SUBUNIT_BODY;

##  NON_TASK_NAME	====>
##	if	generic_id
##	call	generic_id	NON_TASK_NAME
##	if_class	SUBPROG_PACK_NAME
##	call	SUBPROG_PACK_NAME	NON_TASK_NAME
--|.................................................................................................
//  SUBPROG_PACK_NAME	::=
//	SUBPROG_NAME;
//  SUBPROG_PACK_NAME	=>
//	sm_unit_desc	: UNIT_DESC,
//	sm_address	: EXP,
//	cd_compiled	: BOOLEAN;

##  SUBPROG_PACK_NAME	====>
##	if	package_id
##	call	package_id	SUBPROG_PACK_NAME
##	if_class	SUBPROG_NAME
##	call	SUBPROG_NAME	SUBPROG_PACK_NAME
--|.................................................................................................
//  SUBPROG_NAME		::=
//	procedure_id | function_id | operator_id;
//  SUBPROG_NAME		=>
//	sm_is_inline	: BOOLEAN,
//	sm_interface	: PREDEF_NAME,
//	cd_level	: Integer,
//	cd_label	: Integer,
//	cd_param_size	: Integer;

##  SUBPROG_NAME	====>
##	if	procedure_id
##	call	procedure_id	SUBPROG_NAME
##	if	function_id
##	call	function_id	SUBPROG_NAME
##	if	operator_id
##	call	operator_id	SUBPROG_NAME
--|.................................................................................................
//  procedure_id		=> ;

##  procedure_id	====>
##	include	null;
--|.................................................................................................
//  function_id		=>
//	cd_result_size	: Integer;

##  function_id	====>
##	include	null;
--|.................................................................................................
//  operator_id		=>
//	xd_not_equal	: operator_id;			-- "/=" corresponding to "="

##  operator_id	====>
##	include	null;
--|.................................................................................................




--|-------------------------------------------------------------------------------------------------
-- Syntax 6.1.B
--  subprogram_specification ::=
--	 procedure identifier [formal_part]
--     | function designator [formal_part] return type_mark
--
--  designator ::= identifier | operator_symbol
--
--  operator_symbol ::= string_literal
--|-------------------------------------------------------------------------------------------------

subprogram_specification	::=
	  PROCEDURE  proc_id  procedure_header
	| PROCEDURE  proc_id  nil_procedure_header
	| FUNCTION  function_id  function_header
	| FUNCTION  def_op  function_header
	%%
--|.................................................................................................
procedure_header	::=
	param_s				====> $1 procedure_spec
	%%
--|.................................................................................................
nil_procedure_header	::=
	nil_param_s				====> $1 procedure_spec
	%%
--|.................................................................................................
[param_s]	::=
	  nil_param_s
	| param_s
	%%
--|.................................................................................................
--** nil_param_s is used for generic instantiation
nil_param_s	::=
	empty				====> nil $L param_s
	%%
--|.................................................................................................
param_s	::=
	(  parameter_specification{;parameter_specification}  )		====> $L param_s
	%%
--|.................................................................................................
function_header	::=
	[param_s]  RETURN  type_mark			====> $2 function_spec
	%%
--|.................................................................................................
operator_symbol	::=
	used_string
	%%



--|.................................................................................................
//  INIT_OBJECT_NAME	::=
//	PARAM_NAME;

##  INIT_OBJECT_NAME	====>
##	if	number_id
##	call	number_id	INIT_OBJECT_NAME
##	if_class	VC_NAME
##	call	VC_NAME	INIT_OBJECT_NAME
##	if_class	COMP_NAME
##	call	COMP_NAME	INIT_OBJECT_NAME
##	if_class	PARAM_NAME
##	call	PARAM_NAME	INIT_OBJECT_NAME
--|.................................................................................................
//  PARAM_NAME		::=
//	in_id | PARAM_IO_O;
//  PARAM_NAME		=>
//	sm_first	: DEF_NAME,
//	cd_level	: Integer;

##  PARAM_NAME	====>
##	if	in_id
##	call	in_id	PARAM_NAME
##	if_class	PARAM_IO_O
##	call	PARAM_IO_O	PARAM_NAME
--|.................................................................................................
//  PARAM_IO_O		::=
//	in_out_id | out_id;
//  PARAM_IO_O		=>
//	cd_addr_offset	: Integer,
//	cd_val_offset	: Integer;

##  PARAM_IO_O	====>
##	if	in_out_id
##	call	in_out_id	PARAM_IO_O
##	if	out_id
##	call	out_id	PARAM_IO_O
--|.................................................................................................
//  in_id	=>
//	cd_offset	: Integer;

##  in_id	====>
##	include	null;
--|.................................................................................................
//  in_out_id	=> ;

##  in_out_id	====>
##	include	null;
--|.................................................................................................
//  out_id	=> ;

##  out_id	====>
##	include	null;



--|-------------------------------------------------------------------------------------------------
-- 6.3	Subprogram Bodies
-- Syntax 6.3
--  subprogram_body ::=
--	subprogram_specification is
--	    [declarative_part]
--	begin
--	    sequence_of_statements
--     [exception
--	exception_handler
--	    {exception_handler}]
--	end [designator];
--|-------------------------------------------------------------------------------------------------

subprogram_body	::=
	  PROCEDURE  proc_id  procedure_header  subprogram_block		====> exch_1 $3 subprogram_body
	| PROCEDURE  proc_id  nil_procedure_header  subprogram_block	====> exch_1 $3 subprogram_body
	| FUNCTION  function_id  function_header  subprogram_block		====> exch_1 $3 subprogram_body
	| FUNCTION  def_op  function_header  subprogram_block		====> exch_1 $3 subprogram_body
	%%
--|.................................................................................................
subprogram_block	::=
	IS  declarative_part  BEGIN  sequence_of_statements
	[EXCEPTION__exception_handler{exception_handler}]
	END__[designator]  ;			====> $3 block_body
	%%
--|.................................................................................................
END__[designator]	::=
	END
	| END  identifier				====> check_subp_name
	| END  string_literal			====> check_subp_name
	%%

//  CALL_STM		=> 
//	as_general_assoc_s		: general_assoc_s,
//	sm_normalized_param_s	: exp_s;
--|.................................................................................................
//  procedure_call		=> ;

##  procedure_call	====>
##	include	null;
--|.................................................................................................
//  function_call		=>
//	as_general_assoc_s		: general_assoc_s,
//	sm_normalized_param_s	: exp_s,
//	lx_prefix		: BOOLEAN;

##  function_call	====>
##	include	null;
--|.................................................................................................
//  NAMED_ASSOC		::=
//	assoc;
--|.................................................................................................
//  assoc		=>
//	as_used_name	: USED_NAME;


//  SUBPROG_PACK_NAME	::=
//	package_id;
--|.................................................................................................
//  package_id		=> ;

##  package_id	====>
##	include	null;

//  package_spec		=>
//	as_decl_s1	: decl_s,
//	as_decl_s2	: decl_s,
//   	xd_body_is_required	: BOOLEAN;


--|.................................................................................................
//  TYPE_NAME		::=
//	private_type_id | l_private_type_id;
--|.................................................................................................
//  private_type_id		=> ;

##  private_type_id	====>
##	include	null;
--|.................................................................................................
//  l_private_type_id	=> ;

##  l_private_type_id	====>
##	include	null;
--|.................................................................................................
//  PRIVATE_SPEC		::=
//	private | l_private;
//  PRIVATE_SPEC		=>
//	sm_discriminant_s	: dscrmt_decl_s,
//	sm_type_spec	: TYPE_SPEC;
--|.................................................................................................
//  private		=> ;
--|.................................................................................................
//  l_private		=> ;






--|.................................................................................................
//  task_spec		=>
//	sm_decl_s	: decl_s,
//	sm_body	: BODY,
//	sm_address	: EXP,
//	sm_size	: EXP,
//	sm_storage_size	: EXP,
//	xd_stub	: stub,
//	xd_body	: SUBUNIT_BODY;


--|.................................................................................................
//  UNIT_NAME		::=
//	task_body_id;
--|.................................................................................................
//  task_body_id		=>
//	sm_type_spec	: TYPE_SPEC,
//	sm_body	: BODY;

##  task_body_id	====>
##	include	null;




//  SUBP_ENTRY_HEADER	::=
//	entry;
--|.................................................................................................
//  entry		=>
//	as_discrete_range	: DISCRETE_RANGE;
--|.................................................................................................
//  SOURCE_NAME	::=
//	entry_id;
--|.................................................................................................
//  entry_id		=>
//	sm_spec	: HEADER,
//	sm_address	: EXP;

##  entry_id	====>
##	include	null;

//  entry_call		=> ;

##  entry_call	====>
##	include	null;



//  accept		=>
//	as_name	: NAME,
//	as_param_s	: param_s,
//	as_stm_s	: stm_s;

##  accept	====>
##	include	null;


//  delay		=> ;

##  delay	====>
##	include	null;


//  selective_wait		=> ;

##  selective_wait	====>
##	include	null;




//  TEST_CLAUSE_ELEM	::=
//	TEST_CLAUSE | select_alt_pragma;

##  TEST_CLAUSE_ELEM	====>
##	if_class	TEST_CLAUSE
##	call	TEST_CLAUSE	TEST_CLAUSE_ELEM
##	if	select_alt_pragma
##	call	select_alt_pragma	TEST_CLAUSE_ELEM
--|.................................................................................................
//  TEST_CLAUSE		::=
//	select_alternative;

--|.................................................................................................
//  test_clause_elem_s	=>
//	as_list	: Seq Of TEST_CLAUSE_ELEM;

##  test_clause_elem_s	====>
##	repeat_extract	test_clause_elem_s	test_clause_elem
##	call	TEST_CLAUSE_ELEM	test_clause_elem
--|.................................................................................................
//  select_alternative	=> ;

##  select_alternative	====>
##	include	null;
--|.................................................................................................
//  select_alt_pragma	=>
//	as_pragma	: pragma;

##  select_alt_pragma	====>
##	include	null;
--|.................................................................................................
//  STM		::=
//	terminate;
--|.................................................................................................
//  terminate		=> ;

##  terminate	====>
##	include	null;

//  ENTRY_STM		::=
//	cond_entry | timed_entry;
//  ENTRY_STM		=>
//	as_stm_s1	: stm_s,
//	as_stm_s2	: stm_s;

##  ENTRY_STM	====>
##	if	cond_entry
##	call	cond_entry	ENTRY_STM
##	if	timed_entry
##	call	timed_entry	ENTRY_STM
--|.................................................................................................
//  cond_entry		=> ;

##  cond_entry	====>
##	include	null;


//  timed_entry		=> ;

##  timed_entry	====>
##	include	null;

//  name_s		=>
//	as_list	: Seq Of NAME;

##  name_s	====>
##	repeat_extract	name_s	name
##	call	NAME	name
--|.................................................................................................
//  abort		=>
//	as_name_s	: name_s;

##  abort	====>
##	include	null;

--|.................................................................................................
//  pragma_s		=>
//	as_list	: Seq Of pragma;
--|.................................................................................................


--|.................................................................................................
//  use_pragma_s		=>
//	as_list	: Seq Of USE_PRAGMA;



--|.................................................................................................
//  SOURCE_NAME		::=
//	exception_id;
--|.................................................................................................
//  exception_id		=>
//	sm_renames_exc	: NAME,
//	cd_label	: Integer;

##  exception_id	====>								--| DECLARATION D IDENTIFICATEUR D EXCEPTION
##  include	DECLARE
##  include	  LBL : LABEL_TYPE := NEXT_LABEL;					--| ALLOUER UNE ETIQUETTE
##  include	BEGIN
##  include	  DI ( CD_LABEL, EXCEPTION_ID, INTEGER ( LBL ) );				--| LA STOCKER
##  include	  EMIT ( EXL, LBL, S=> PRINT_NAME ( D ( LX_SYMREP, EXCEPTION_ID ) ),
##  include	         COMMENT=> "NUMERO D EXCEPTION SUR DECLARATION" );			--| CAS NORMAL PUISQUE LA DECLARATION DOIT PRECEDER L USAGE
##  include	END;


//  raise		=> ;

##  raise	====>
##  include	DECLARE
##  include	  NAME : TREE := D ( AS_NAME, ADA_RAISE );				--| AMENER LE NOM DE L EXCEPTION LEVEE
##  include	BEGIN
##  include	  IF NAME = TREE_VOID THEN						--| PAS DE NOM (UN SIMPLE "RAISE")
##  include	    EMIT ( RAI );							--| EMETTRE LE RAISE
##  include	  ELSE								--| IL Y A UN NOM D EXCEPTION
##  include	    DECLARE
##  include	      EXCEPTION_ID : TREE := D ( SM_DEFN, NAME );				--| RAMENER LA DEFINITION DE L EXCEPTION
##  include	      LBL : LABEL_TYPE;						--| ETIQUETTE EVENTUELLE
##  include	    BEGIN
##  include	      IF D ( CD_LABEL, EXCEPTION_ID ).TY /= DN_NUM_VAL THEN			--| PAS DEJA DE VALEUR D ETIQUETTES (PAS DE RAISE ANTERIEUR)
##  include	        LBL := NEXT_LABEL;						--| ALLOUER UNE ETIQUETTE
##  include	        DI ( CD_LABEL, EXCEPTION_ID, INTEGER ( LBL ) );			--| PORTER SON NUMERO DANS L IDENTIFICATEUR
##  include	        EMIT ( EXL, LBL, S=> PRINT_NAME ( D ( LX_SYMREP, NAME ) ),		--| EMETTRE UNE ETIQUETTE EXCEPTION
##  include		COMMENT=> "NUMERO D EXCEPTION EXTERNE SUR RAISE" );		--| ME PARAIT UN CAS IMPOSSIBLE LA DECLARATION DEVANT PRECEDER
##  include	      END IF;
##  include	      EMIT ( RAI, DI ( CD_LABEL, EXCEPTION_ID ) );			--| EMETTRE LE RAISE
##  include	    END;
##  include	  END IF;
##  include	END;

//  HEADER		::=
//	package_spec;

--|.................................................................................................
//  NON_TASK_NAME		::=
//	generic_id;
--|.................................................................................................
//  generic_id		=>
//	sm_generic_param_s	: item_s,
//	sm_body	: BODY,
//	sm_is_inline	: BOOLEAN;

##  generic_id	====>
##	include	null;






//  RENAME_INSTANT		::=
//	instantiation;


//  COMP_REP_ELEM		::=
//	comp_rep | comp_rep_pragma;
--|.................................................................................................
//  comp_rep_s		=>
//	as_list	: Seq Of COMP_REP_ELEM;
--|.................................................................................................
//  comp_rep		=>
//	as_name	: NAME,
//	as_exp	: EXP,
//	as_range	: RANGE;
--|.................................................................................................
//  comp_rep_pragma		=>
//	as_pragma	: pragma;

//  code		=> ;

##  code	====>
##	include	null;


//  PREDEF_NAME		::=
//	  attribute_id | pragma_id | argument_id | bltn_operator_id;
--|.................................................................................................
//  attribute_id		=>
//	xd_pos	: Integer;			-- Predefined_Attributes'POS
--|.................................................................................................
//  TYPE_SPEC		::=
//	universal_integer | universal_fixed | universal_real;
--|.................................................................................................
//  universal_integer	=> ;
--|.................................................................................................
//  universal_fixed		=> ;
--|.................................................................................................
//  universal_real		=> ;
--|.................................................................................................
//  argument_id		=>
//	xd_pos	: Integer;			-- 'POS in appropriate enum type
--|.................................................................................................
//  bltn_operator_id	=>
//	sm_operator	: Integer;			-- (bltn_operators'POS)
--|.................................................................................................
//  pragma_id		=>
//	sm_argument_id_s	: argument_id,
//	xd_pos	: Integer;			-- Defined_Pragmas'POS
--|.................................................................................................
//  argument_id_s	=>
//	as_list	: Seq Of argument_id;
--|.................................................................................................
//  ALL_SOURCE		::=
//	  DEF_NAME	| ALL_DECL	| TYPE_DEF	| SEQUENCES
//	| STM_ELEM	| GENERAL_ASSOC	| CONSTRAINT	| CHOICE
//	| HEADER	| UNIT_DESC	| TEST_CLAUSE_ELEM
//	| MEMBERSHIP_OP	| SHORT_CIRCUIT_OP	| ITERATION
//	| ALTERNATIVE_ELEM	| COMP_REP_ELEM	| CONTEXT_ELEM
//	| VARIANT_ELEM	| ALIGNMENT_CLAUSE	| VARIANT_PART
//	| comp_list	| compilation	| compilation_unit	| index;
--|.................................................................................................
//  SEQUENCES		::=
//	  alternative_s	| argument_id_s	| choice_s
//	| comp_rep_s	| compltn_unit_s	| context_elem_s
//	| decl_s	| dscrmt_decl_s	| general_assoc_s
//	| discrete_range_s	| enum_literal_s	| exp_s	| item_s
//	| index_s | name_s	| param_s	| pragma_s	| scalar_s
//	| source_name_s	| stm_s	| test_clause_elem_s
//	| use_pragma_s	| variant_s;
--|.................................................................................................
//  ALL_SOURCE		=>
//	lx_srcpos	: Source_Position,
//	lx_comments	: comments;
--|.................................................................................................
//  NON_DIANA		::=
//	user_root;
--|.................................................................................................
//  NON_DIANA		::=
//	real_val | trans_with | lib_info;
--|.................................................................................................
//  real_val		=>			-- universal real values
//	xd_numer	: num_val,
//	xd_denom	: num_val;
--|.................................................................................................
//  trans_with		=>
//	tw_filename	: txtrep,
//	tw_comp_unit	: compilation_unit;
--|.................................................................................................
//  lib_info		=>
//	xd_short	: txtrep,
//	xd_primary	: txtrep,
//	xd_secondary	: txtrep;
--|.................................................................................................
//  any_integer     	=> ;
--|.................................................................................................
//  any_real		=> ;
--|.................................................................................................
//  any_access		=> ;
--|.................................................................................................
//  any_composite   	=> ;
--|.................................................................................................
//  any_string		=> ;
--|.................................................................................................
//  any_access_of   	=>
//	xd_item 	: ITEM;
--|.................................................................................................
//  UNSPECIFIED_TYPE	::=
//	any_access | any_composite | any_string | any_access_of | any_integer | any_real;
--|.................................................................................................
//  NON_DIANA		::=
//	def | UNSPECIFIED_TYPE;
--|.................................................................................................
//  def 		=>
//	xd_header	: HEADER,
//	xd_source_name	: SOURCE_NAME,
//	xd_region_def	: def,
//	xd_is_in_spec	: BOOLEAN,
//	xd_lex_level	: Integer,			-- 0 pour la base
//	xd_is_used	: BOOLEAN;
--|.................................................................................................
// implicit_conv    	=>
//	xd_item 	: ITEM,			-- (or type spec)
//	xd_list 	: Seq Of EXP;
--|.................................................................................................
// nullary_call     	=>
//	xd_item 	: ITEM;
--|.................................................................................................
// NON_DIANA		::=
//	implicit_conv | nullary_call;
--|.................................................................................................
// end	--| Fin de specification IDL

//  enumeration		=>
//	sm_literal_s	: enum_literal_s;
--|.................................................................................................


##  STOP										--| ARRET POUR LE GEN_CODEGEN
