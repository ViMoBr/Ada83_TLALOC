SEPARATE (IDL)--|---------------------------------------------------------------------------------------------------|
PROCEDURE TBL_PUT--|턕ROCEDURE TBL_PUT ( NOM_TEXTE :STRING ) IS     RESULT_FILE, NFILE: TEXT_IO.FILE_TYPE;  RULE_LI
STК: SEQ_TYPE;  RULE_NBRК: NATURAL:= 0;  VOID_WAS_SEENК: BOOLEAN:= FALSE;  USE INT_IO;     --|----------------
-------------------------------------------------------------------------------  --|촒ROCEDURE PROCESS_RULES  --|  PR
OCEDURE PROCESS_RULES ( CLASS_RULE :TREE ) IS          ITEM_LIST: SEQ_TYPE:= LIST ( CLASS_RULE );КК--| LISTE DES R
EGLES DEFINISSANT LES MEMBRES DE LA CLASSE    ITEMК: TREE;    RULE_NODE: TREE;          VOID_SYM: TREEК:= STORE_
SYM ( "VOID");          --|-------------------------------------------------------------------------------------------
--    --|촒ROCEDURE PUT_RULE    --|    PROCEDURE PUT_RULE ( RULE :TREE ) IS      SUBTYPE STR3촇S STRING( 1..3 );   
   --|-------------------------------------------------------------------------------------------      --|촒ROCEDURE PU
T_PROPER_ATTRS      --|      PROCEDURE PUT_PROPER_ATTRS ( TER_LIST_ARG :SEQ_TYPE; PREFIX :STR3 ) IS        TER_LIST:
 SEQ_TYPE:= TER_LIST_ARG;        TERК: TREE;        --|-------------------------------------------------------------
----------------------------        --|촒ROCEDURE PUT_ATTR        --|        PROCEDURE PUT_ATTR ( TER :TREE ) IS    
      TER_PREFIX: STRING( 1..3 ) := "???";          TER_NAME: CONSTANT STRING:= PRINT_NAME ( D ( XD_SYMREP, TER ) );
        BEGIN                         IF TER_NAME'LENGTH >= 3 THENККК--| SI LE NOM EST ASSEZ LONG            TER
_PREFIX( 1..3 ) := TER_NAME( TER_NAME'FIRST..TER_NAME'FIRST+2 );К--| EXTRAIRE LA TRANCHE DU PREFIXE          END IF;
                            IF TER_PREFIX = PREFIXККК--| SI C'EST LE PREFIXE COURANT             OR ELSE (촒REFIX 
= "   " AND TER_PREFIX /= "as_"КК--| OU SI ON A MIS "   " MAIS QUE CE N'EST PAS UN CONNU "AS_", "LX_", "SM_"         
         КAND TER_PREFIX /= "lx_" AND TER_PREFIX /= "sm_")          THEN            IF DI ( XD_ATTR_ID, TER ) < 0 THE
NККК--| ATTRIBUT DE TYPE SEQUENCE              PUT ( 'A');КККК--| METTRE A EN DEBUT DE LIGNE                   
              ELSIF PRINT_NAME ( D ( XD_ATTR_TYPE, TER ) ) = "INTEGER" THENК--| TYPAGE "INTEGER"              PUT ( 
'I');КККК--| METTRE I EN DEBUT DE LIGNE                                 ELSIF PRINT_NAME ( D ( XD_ATTR_TYPE, TER )
 ) = "BOOLEAN" THENК--| TYPAGE "BOOLEAN"              PUT ( 'B');КККК--| METTRE B EN DEBUT DE LIGNE             
                    ELSEКККК--| TOUT AUTRE ATTRIBUT              PUT ( 'A');КККК--| METTRE A EN DEBUT DE LIGN
E떰            END IF;            PUT ("   ");            PUT ( DI ( XD_ATTR_ID, TER ), 4 );ККК--| METTRE LE N D'AT
TRIBUT (POUR LE RETROUVER DANS LA LISTE DES ATTRIBUTS)            PUT ( "   ");            PUT_LINE ( PRINT_NAME (D (X
D_SYMREP, TER ) ) );КК--| METTRE LE NOM DE L'ATTRIBUT            PUT_LINE ( NFILE, ASCII.HT & "=> " & PRINT_NAME (D 
(XD_SYMREP, TER ) )К--| ATTRIBUT                              & ASCII.HT & ":" & PRINT_NAME (D (XD_ATTR_TYPE, TER ) )
--| ET TYPE AU FICHIER NOEUDS COMPLETS                        );          END IF;        END PUT_ATTR;            
      BEGIN        WHILE NOT IS_EMPTY ( TER_LIST ) LOOPККК--| TANT QU'IL Y A DES ATTRIBUTS PROPRES          POP ( T
ER_LIST, TER );ККК--| PRENDRE UN ATTRIBUT          IF TER.TY = DN_ATTR THENККК--| EN PRINCIPE L'ATTRIBUT DOIT T
RE DE CE TYPE            PUT_ATTR ( TER );КККК--| L'IMPRIMER          END IF;        END LOOP;      END PUT_PROP
ER_ATTRS;      --|-------------------------------------------------------------------------------------------      --|
촒ROCEDURE PUT_INHERITED_ATTRS      --|      PROCEDURE PUT_INHERITED_ATTRS ( CLASS_NODE :TREE; PREFIX :STR3 ) IS     
 BEGIN        IF CLASS_NODE /= TREE_VOID THEN          PUT_INHERITED_ATTRS ( D ( XD_PARENT, CLASS_NODE ), PREFIX );К
--| RECURSION AU NIVEAU SUPERIEUR          PUT_PROPER_ATTRS ( LIST ( CLASS_NODE ), PREFIX );КК--| PUIS PLACER LES AT
TRIBUTS PROPRES HERITES  CE NIVEAU        END IF;      END;      --|-------------------------------------------------
------------------------------------------             BEGIN      PUT ( "N ");КККК--| LIGNE NOEUD (PARTIE GAUCHE
 DE LA REGLE)      INT_IO.PUT ( RULE_NBR, 3 );ККК--| D'ABORD LE N DE REGLE      DI ( XD_NODE_ID, RULE, RULE_NBR );
ККК--| LE MEMORISER DANS LA REGLE      PUT_LINE ( ' ' & PRINT_NAME ( D ( XD_SYMREP, RULE ) ) );КК--| PUIS LE NOM D
E LA REGLE (DU NOEUD)      PUT_LINE ( NFILE, PRINT_NAME ( D ( XD_SYMREP, RULE ) ) & ASCII.HT & "=>" );К--| NOM DU NOEU
D AU FICHIER NOEUDS      DECLARE        PARENT: TREE:= D ( XD_PARENT, RULE );КК--| CLASSE DANS LAQUELLE EST COMPR
IS LE NOEUD DE LA REGLE      BEGIN        PUT_INHERITED_ATTRS ( PARENT, "as_" );ККК--| METTRE LES ATTRIBUTS HERITES
 DU GENRE "AS_" (SYNTAXIQUES)        PUT_PROPER_ATTRS ( LIST ( RULE ), "as_" );КК--| IMPRIMER LA LISTE DES ATTRIBUTS
 PROPRES DE LA REGLE (LES CHAMPS DU NOEUD)                    PUT_INHERITED_ATTRS ( PARENT,"lx_" );ККК--| REFAIRE E
NSUITE POUR LES "LX_" (LEXICAUX)        PUT_PROPER_ATTRS ( LIST ( RULE ),"lx_" );                    PUT_INHERITED_AT
TRS ( PARENT, "sm_" );ККК--| REFAIRE ENSUITE POUR LES "SM_" (SEMANTIQUES)        PUT_PROPER_ATTRS ( LIST ( RULE ), "
sm_" );떰        PUT_INHERITED_ATTRS (PARENT, "   " );        PUT_PROPER_ATTRS ( LIST ( RULE ), "   " );      END;   
   RULE_NBR := RULE_NBR + 1;      PUT_LINE ( NFILE, ASCII.HT & ';' );    END PUT_RULE;        BEGIN          PUT_L
INE ( "C " & PRINT_NAME ( D ( XD_SYMREP, CLASS_RULE ) ) );КК--| LIGNE DEBUT DE CLASSE          WHILE NOT IS_EMPTY ( 
ITEM_LIST ) LOOP      POP ( ITEM_LIST, ITEM );ККК--| PRENDRE UN MEMBRE DE LA CLASSE TRAITEE               IF ITEM
.TY /= DN_ATTR THENККК--| SI CE N'EST PAS UN ATTRIBUT (UN MEMBRE)        RULE_NODE := D ( XD_CLASS_NODE, ITEM );К
К--| PRENDRE SA REGLE DE DEFINITION        IF DB ( XD_IS_CLASS, RULE_NODE ) THENККК--| LA REGLE DEFINIT UN MEMBRE 
CLASSE          PROCESS_RULES ( D ( XD_CLASS_NODE, ITEM ) );        ELSEКККК--| LA REGLE DEFINIT DES ATTRIBUTS  
        IF D ( XD_SYMREP, RULE_NODE) /= VOID_SYM THENКК--| PAS LA REGLE DEFINISSANT "VOID"            PUT_RULE ( D (
 XD_CLASS_NODE, ITEM ) );КК--| IMPRIMER LA REGLE NAAA                               ELSIF NOT VOID_WAS_SEEN THENК
КК--| SI C'EST LA REGLE POUR "VOID" ET QU'ON NE L'A PAS ENCORE VUE            VOID_WAS_SEEN := TRUE;ККК--| INDIQU
ER QUE L'ON A VU CELLE-CI            PUT_RULE ( D ( XD_CLASS_NODE, ITEM ) );КК--| IMPRIMER LA REGLE          END IF
;        END IF;                  ELSEКККК--| S'IL Y A UN TERMINAL C'EST UNE PROPRIETE DE CLASSE        NULL;К
ККК--| NE RIEN IMPRIMER : LA PROPRIETE SERA COLLECTEE PAR PUT_INHERITED_ATTRS COMME ATTRIBUT HERITE      END IF;  
              END LOOP;          PUT_LINE ( "E " & PRINT_NAME ( D ( XD_SYMREP, CLASS_RULE ) ) );КК--| LIGNE FIN DE 
CLASSE  END PROCESS_RULES;   턆EGIN  OPEN_IDL_TREE_FILE ( NOM_TEXTE & ".lar" );ККК--| FICHIER D'ARBRE IDL  CREATE
 ( RESULT_FILE, OUT_FILE, NOM_TEXTE & ".tbl" );КК--| FICHIER DE SORTIE .TBL  CREATE ( NFILE, OUT_FILE, NOM_TEXTE &
 "_NODES.txt" );КК--| FICHIER DES NOEUDS COMPLETS     TEXT_IO.SET_OUTPUT ( RESULT_FILE );     RULE_LIST := LIST (
 STORE_SYM ( "STANDARD_IDL" ) );КК--| LISTE DES REGLES DONT LA PARTIE GAUCHE EST DANS LA CATEGORIE STANDARD_IDL  IF 
NOT IS_EMPTY ( RULE_LIST) THENККК--| SI NON VIDE    PROCESS_RULES ( HEAD ( RULE_LIST ) );ККК--| TRAITER  END IF
;     RULE_LIST := LIST ( STORE_SYM ( "ALL_SOURCE" ) );КК--| PAREIL POUR LA CATEGORIE ALL_SOURCE  IF NOT IS_EMPTY 
( RULE_LIST) THEN    PROCESS_RULES ( HEAD ( RULE_LIST ) );  END IF;     RULE_LIST := LIST ( STORE_SYM ( "TYPE_SPEC" 
) );КК--| PAREIL POUR LA CATEGORIE TYPE_SPEC  IF NOT IS_EMPTY ( RULE_LIST) THEN    PROCESS_RULES ( HEAD ( RULE_LIST
 ) );  END IF;     RULE_LIST := LIST ( STORE_SYM ( "NON_DIANA") );ККК--| PAREIL POUR LA CATEGORIE NON_DIANA  IF N
OT IS_EMPTY ( RULE_LIST) THEN    PROCESS_RULES ( HEAD ( RULE_LIST ) );  END IF;        TEXT_IO.SET_OUTPUT ( TEXT_IO.
STANDARD_OUTPUT );  CLOSE ( NFILE );  CLOSE ( RESULT_FILE );  CLOSE_IDL_TREE_FILE;떰  PUT_LINE ( "OK" );  NEW_LINE;
턉XCEPTION         WHEN NAME_ERROR =>    PUT_LINE ( "LE FICHIER : " & NOM_TEXTE & ".lar  EST INTROUVABLE" );        
      WHEN OTHERS =>    CLOSE ( RESULT_FILE );    CLOSE_IDL_TREE_FILE;    PUT_LINE ( "ERREUR TBL_PUT" );      --|-
------------------------------------------------------------------------------------------------턉ND TBL_PUT;
