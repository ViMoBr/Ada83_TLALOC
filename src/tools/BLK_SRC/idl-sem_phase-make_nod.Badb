------------------------------------------------------------------------------------------------------------------------
¶-- CC BY SA¬MAKE_NOD.ADB¬VINCENT MORIN¬6/5/2025¬UNIVERSITE DE BRETAGNE OCCIDENTALE¶------------------------------------
------------------------------------------------------------------------------------¶--¬1¬2¬3¬4¬5¬6¬7¬8¬9¬0¬1¬2¶¶¶SEPARA
TE ( IDL.SEM_PHASE  )¶¶¶¬¬¬¬¬--------¶package body¬¬¬¬MAKE_NOD¶is¬¬¬¬¬--------¶   ¶       package DA renames DIANA_NODE_
ATTR_CLASS_NAMES;¶¶¬¬----------------¶  function¬MAKE_VARIABLE_ID¬¬( LX_SRCPOS, LX_SYMREP, SM_OBJ_TYPE, SM_INIT_EXP :TRE
E := TREE_VOID;¶¬¬¬¬¬  SM_RENAMES_OBJ¬:BOOLEAN¬:= FALSE;¶¬¬¬¬¬  SM_ADDRESS¬:TREE¬:= TREE_VOID;¶¬¬¬¬¬  SM_IS_SHARED¬:BOOL
EAN¬:= FALSE;¶¬¬¬¬¬  XD_REGION¬:TREE¬:= TREE_VOID )¶¬¬¬¬¬return TREE¶  is¬¬----------------¶¶    NODE¬¬ :TREE¬:= MAKE( D
N_VARIABLE_ID );¶¶  begin¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    D( DA.LX_SYMREP, NODE, LX_SYMREP );¶    D( DA.SM_O
BJ_TYPE, NODE, SM_OBJ_TYPE );¶    D( DA.SM_INIT_EXP, NODE, SM_INIT_EXP );¶    DB( DA.SM_RENAMES_OBJ, NODE, SM_RENAMES_OB
J );¶    D( DA.SM_ADDRESS, NODE, SM_ADDRESS );¶    DB( DA.SM_IS_SHARED, NODE, SM_IS_SHARED );¶    D( DA.XD_REGION, NODE,
 XD_REGION );¶    return NODE;¶¶  end¬MAKE_VARIABLE_ID;¶¬----------------¶¶¶¬¬----------------¶  function¬MAKE_CONSTANT_
ID¬¬( LX_SRCPOS, LX_SYMREP, SM_OBJ_TYPE, SM_INIT_EXP :TREE := TREE_VOID;¶¬¬¬¬¬  SM_RENAMES_OBJ :BOOLEAN := FALSE;¶¬¬¬¬¬ 
 SM_ADDRESS, SM_FIRST, XD_REGION :TREE := TREE_VOID )¶¬¬¬¬¬return TREE¶  is¬¬----------------¶¶    NODE¬¬ :TREE¬:= MAKE(
 DN_CONSTANT_ID  );¶¶  begin¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    D( DA.LX_SYMREP, NODE, LX_SYMREP );¶    D( DA.S
M_OBJ_TYPE, NODE, SM_OBJ_TYPE );¶    D( DA.SM_INIT_EXP, NODE, SM_INIT_EXP );¶    DB( DA.SM_RENAMES_OBJ, NODE, SM_RENAMES
_OBJ );¶    D( DA.SM_ADDRESS, NODE, SM_ADDRESS );¶    D( DA.SM_FIRST, NODE, SM_FIRST );¶    D( DA.XD_REGION, NODE, XD_RE
GION );¶    return NODE;¶¶  end¬MAKE_CONSTANT_ID;¶¬----------------¶¶¶¬¬--------------¶  function¬MAKE_NUMBER_ID¬¬( LX_S
RCPOS, LX_SYMREP, SM_OBJ_TYPE, SM_INIT_EXP,¶¬¬¬¬¬  XD_REGION :TREE := TREE_VOID  )¶¬¬¬¬¬return TREE¶  is¬¬--------------
¶¶    NODE¬¬:TREE¬:= MAKE( DN_NUMBER_ID );¶¶  begin¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    D( DA.LX_SYMREP, NODE, L
X_SYMREP );¶    D( DA.SM_OBJ_TYPE, NODE, SM_OBJ_TYPE );¶    D( DA.SM_INIT_EXP, NODE, SM_INIT_EXP );¶    D( DA.XD_REGION,
 NODE, XD_REGION );¶    return NODE;¶¶  end¬MAKE_NUMBER_ID;¶¬--------------¶¶¶¬¬-----------------¶  function¬MAKE_COMPON
ENT_ID¬¬( LX_SRCPOS, LX_SYMREP, SM_OBJ_TYPE, SM_INIT_EXP, SM_COMP_REP,¶¬¬¬¬¬  XD_REGION :TREE := TREE_VOID  )¶¬¬¬¬¬retur
n TREE¶  is¬¬-----------------¶¶    NODE¬¬:TREE¬:= MAKE( DN_COMPONENT_ID );¶¶  begin¶    D( DA.LX_SRCPOS, NODE, LX_SRCPO
S );¶    D( DA.LX_SYMREP, NODE, LX_SYMREP );¶    D( DA.SM_OBJ_TYPE, NODE, SM_OBJ_TYPE );¶    D( DA.SM_INIT_EXP, NODE, SM
_INIT_EXP );¶    D( DA.SM_COMP_REP, NODE, SM_COMP_REP );¶    D( DA.XD_REGION, NODE, XD_REGION );¶    return NODE;¶¶  end
¬MAKE_COMPONENT_ID;¶¬-----------------¶¶¶¬¬--------------------¶  function¬MAKE_DISCRIMINANT_ID¬( LX_SRCPOS, LX_SYMREP, 
SM_OBJ_TYPE, SM_INIT_EXP, SM_COMP_REP,¶¬¬¬¬¬  SM_FIRST, XD_REGION :TREE := TREE_VOID )¶¬¬¬¬¬return TREE¶  is¬¬----------
----------¶¶         NODE :TREE := MAKE( DN_DISCRIMINANT_ID );¶¶  begin¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    D( D
A.LX_SYMREP, NODE, LX_SYMREP );¶    D( DA.SM_OBJ_TYPE, NODE, SM_OBJ_TYPE );¶    D( DA.SM_INIT_EXP, NODE, SM_INIT_EXP );¶
    D( DA.SM_COMP_REP, NODE, SM_COMP_REP );¶    D( DA.SM_FIRST, NODE, SM_FIRST );¶    D( DA.XD_REGION, NODE, XD_REGION )
;¶    return NODE;¶¶  end¬MAKE_DISCRIMINANT_ID;¶¬--------------------¶¶¶¬¬----------¶  function¬MAKE_IN_ID¬¬( LX_SRCPOS,
 LX_SYMREP, SM_OBJ_TYPE, SM_INIT_EXP, SM_FIRST,¶¬¬¬¬¬  XD_REGION¬:TREE¬:= TREE_VOID )¶¬¬¬¬¬return TREE¶  is¬¬---------¶ 
        NODE :TREE := MAKE( DN_IN_ID );¶  begin¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    D( DA.LX_SYMREP, NODE, LX_SY
MREP );¶    D( DA.SM_OBJ_TYPE, NODE, SM_OBJ_TYPE );¶    D( DA.SM_INIT_EXP, NODE, SM_INIT_EXP );¶    D( DA.SM_FIRST, NODE
, SM_FIRST );¶    D( DA.XD_REGION, NODE, XD_REGION );¶    return NODE;¶¶  end¬MAKE_IN_ID;¶¬----------¶¶¶¬¬--------------
¶  function¬MAKE_IN_OUT_ID¶¬¬    ( LX_SRCPOS :TREE := TREE_VOID;¶¬¬    LX_SYMREP :TREE := TREE_VOID;¶¬¬    SM_OBJ_TYPE :
TREE := TREE_VOID;¶¬¬    SM_INIT_EXP :TREE := TREE_VOID;¶¬¬    SM_FIRST :TREE := TREE_VOID;¶¬¬    XD_REGION :TREE := TRE
E_VOID )¶¬¬    return TREE¶  is¬¬--------------¶¶    NODE¬¬:TREE¬:= MAKE( DN_IN_OUT_ID );¶¶  begin¶    D( DA.LX_SRCPOS, 
NODE, LX_SRCPOS );¶    D( DA.LX_SYMREP, NODE, LX_SYMREP );¶    D( DA.SM_OBJ_TYPE, NODE, SM_OBJ_TYPE );¶    D( DA.SM_INIT
_EXP, NODE, SM_INIT_EXP );¶    D( DA.SM_FIRST, NODE, SM_FIRST );¶    D( DA.XD_REGION, NODE, XD_REGION );¶    return NODE
;¶¶  end¬MAKE_IN_OUT_ID;¶¬--------------¶¶¶¬¬-----------¶  function¬MAKE_OUT_ID¶¬¬    ( LX_SRCPOS :TREE := TREE_VOID;¶¬¬
    LX_SYMREP :TREE := TREE_VOID;¶¬¬    SM_OBJ_TYPE :TREE := TREE_VOID;¶¬¬    SM_INIT_EXP :TREE := TREE_VOID;¶¬¬    SM_F
IRST :TREE := TREE_VOID;¶¬¬    XD_REGION :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_OUT_I
D );¶  begin¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    D( DA.LX_SYMREP, NODE, LX_SYMREP );¶    D( DA.SM_OBJ_TYPE, NODE
, SM_OBJ_TYPE );¶    D( DA.SM_INIT_EXP, NODE, SM_INIT_EXP );¶    D( DA.SM_FIRST, NODE, SM_FIRST );¶    D( DA.XD_REGION, 
NODE, XD_REGION );¶         return NODE;¶  end¬MAKE_OUT_ID;¶   ¶  function¬MAKE_ENUMERATION_ID¶¬¬    ( LX_SRCPOS :TREE :
= TREE_VOID;¶¬¬    LX_SYMREP :TREE := TREE_VOID;¶¬¬    SM_OBJ_TYPE :TREE := TREE_VOID;¶¬¬    SM_POS :INTEGER := 0;¶¬¬   
 SM_REP :INTEGER := 0;¶¬¬    XD_REGION :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_ENUMERA
TION_ID );¶  begin¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    D( DA.LX_SYMREP, NODE, LX_SYMREP );¶    D( DA.SM_OBJ_TYPE
, NODE, SM_OBJ_TYPE );¶         DI (DA.SM_POS, NODE, SM_POS );¶         DI (DA.SM_REP, NODE, SM_REP );¶    D( DA.XD_REGI
ON, NODE, XD_REGION );¶         return NODE;¶  end¬MAKE_ENUMERATION_ID;¶   ¶  function¬MAKE_CHARACTER_ID¶¬¬    ( LX_SRCP
OS :TREE := TREE_VOID;¶¬¬    LX_SYMREP :TREE := TREE_VOID;¶¬¬    SM_OBJ_TYPE :TREE := TREE_VOID;¶¬¬    SM_POS :INTEGER :
= 0;¶¬¬    SM_REP :INTEGER := 0;¶¬¬    XD_REGION :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( 
DN_CHARACTER_ID );¶  begin¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    D( DA.LX_SYMREP, NODE, LX_SYMREP );¶    D( DA.SM_
OBJ_TYPE, NODE, SM_OBJ_TYPE );¶         DI (DA.SM_POS, NODE, SM_POS );¶         DI (DA.SM_REP, NODE, SM_REP );¶    D( DA
.XD_REGION, NODE, XD_REGION );¶         return NODE;¶  end¬MAKE_CHARACTER_ID;¶   ¶  function¬MAKE_ITERATION_ID¶¬¬    ( L
X_SRCPOS :TREE := TREE_VOID;¶¬¬    LX_SYMREP :TREE := TREE_VOID;¶¬¬    SM_OBJ_TYPE :TREE := TREE_VOID;¶¬¬    XD_REGION :
TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_ITERATION_ID );¶  begin¶    D( DA.LX_SRCPOS, NO
DE, LX_SRCPOS );¶    D( DA.LX_SYMREP, NODE, LX_SYMREP );¶    D( DA.SM_OBJ_TYPE, NODE, SM_OBJ_TYPE );¶    D( DA.XD_REGION
, NODE, XD_REGION );¶         return NODE;¶  end¬MAKE_ITERATION_ID;¶   ¶  function¬MAKE_TYPE_ID¶¬¬    ( LX_SRCPOS :TREE 
:= TREE_VOID;¶¬¬    LX_SYMREP :TREE := TREE_VOID;¶¬¬    SM_TYPE_SPEC :TREE := TREE_VOID;¶¬¬    SM_FIRST :TREE := TREE_VO
ID;¶¬¬    XD_REGION :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_TYPE_ID );¶  begin¶    D( 
DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    D( DA.LX_SYMREP, NODE, LX_SYMREP );¶    D( DA.SM_TYPE_SPEC, NODE, SM_TYPE_SPEC );¶ 
   D( DA.SM_FIRST, NODE, SM_FIRST );¶    D( DA.XD_REGION, NODE, XD_REGION );¶         return NODE;¶  end¬MAKE_TYPE_ID;¶ 
  ¶  function¬MAKE_SUBTYPE_ID¶¬¬    ( LX_SRCPOS :TREE := TREE_VOID;¶¬¬    LX_SYMREP :TREE := TREE_VOID;¶¬¬    SM_TYPE_SP
EC :TREE := TREE_VOID;¶¬¬    XD_REGION :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_SUBTYPE
_ID );¶  begin¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    D( DA.LX_SYMREP, NODE, LX_SYMREP );¶    D( DA.SM_TYPE_SPEC, N
ODE, SM_TYPE_SPEC );¶    D( DA.XD_REGION, NODE, XD_REGION );¶         return NODE;¶  end¬MAKE_SUBTYPE_ID;¶   ¶  function
¬MAKE_PRIVATE_TYPE_ID¶¬¬    ( LX_SRCPOS :TREE := TREE_VOID;¶¬¬    LX_SYMREP :TREE := TREE_VOID;¶¬¬    SM_TYPE_SPEC :TREE
 := TREE_VOID;¶¬¬    XD_REGION :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_PRIVATE_TYPE_ID
 );¶  begin¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    D( DA.LX_SYMREP, NODE, LX_SYMREP );¶    D( DA.SM_TYPE_SPEC, NODE
, SM_TYPE_SPEC );¶    D( DA.XD_REGION, NODE, XD_REGION );¶         return NODE;¶  end¬MAKE_PRIVATE_TYPE_ID;¶   ¶  functi
on¬MAKE_L_PRIVATE_TYPE_ID¶¬¬    ( LX_SRCPOS :TREE := TREE_VOID;¶¬¬    LX_SYMREP :TREE := TREE_VOID;¶¬¬    SM_TYPE_SPEC :
TREE := TREE_VOID;¶¬¬    XD_REGION :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_L_PRIVATE_T
YPE_ID );¶  begin¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    D( DA.LX_SYMREP, NODE, LX_SYMREP );¶    D( DA.SM_TYPE_SPEC
, NODE, SM_TYPE_SPEC );¶    D( DA.XD_REGION, NODE, XD_REGION );¶         return NODE;¶  end¬MAKE_L_PRIVATE_TYPE_ID;¶   ¶
  function¬MAKE_PROCEDURE_ID¶¬¬    ( LX_SRCPOS :TREE := TREE_VOID;¶¬¬    LX_SYMREP :TREE := TREE_VOID;¶¬¬    SM_FIRST :T
REE := TREE_VOID;¶¬¬    SM_SPEC :TREE := TREE_VOID;¶¬¬    SM_UNIT_DESC :TREE := TREE_VOID;¶¬¬    SM_ADDRESS :TREE := TRE
E_VOID;¶¬¬    SM_IS_INLINE :BOOLEAN := FALSE;¶¬¬    SM_INTERFACE :TREE := TREE_VOID;¶¬¬    XD_REGION :TREE := TREE_VOID;
¶¬¬    XD_STUB :TREE := TREE_VOID;¶¬¬    XD_body :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( 
DN_PROCEDURE_ID );¶  begin¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    D( DA.LX_SYMREP, NODE, LX_SYMREP );¶    D( DA.SM_
FIRST, NODE, SM_FIRST );¶    D( DA.SM_SPEC, NODE, SM_SPEC );¶    D( DA.SM_UNIT_DESC, NODE, SM_UNIT_DESC );¶    D( DA.SM_
ADDRESS, NODE, SM_ADDRESS );¶    DB( DA.SM_IS_INLINE, NODE, SM_IS_INLINE );¶    D( DA.SM_INTERFACE, NODE, SM_INTERFACE )
;¶    D( DA.XD_REGION, NODE, XD_REGION );¶    D( DA.XD_STUB, NODE, XD_STUB );¶    D( DA.XD_body, NODE, XD_body );¶      
   return NODE;¶  end¬MAKE_PROCEDURE_ID;¶   ¶  function¬MAKE_FUNCTION_ID¶¬¬    ( LX_SRCPOS :TREE := TREE_VOID;¶¬¬    LX_
SYMREP :TREE := TREE_VOID;¶¬¬    SM_FIRST :TREE := TREE_VOID;¶¬¬    SM_SPEC :TREE := TREE_VOID;¶¬¬    SM_UNIT_DESC :TREE
 := TREE_VOID;¶¬¬    SM_ADDRESS :TREE := TREE_VOID;¶¬¬    SM_IS_INLINE :BOOLEAN := FALSE;¶¬¬    SM_INTERFACE :TREE := TR
EE_VOID;¶¬¬    XD_REGION :TREE := TREE_VOID;¶¬¬    XD_STUB :TREE := TREE_VOID;¶¬¬    XD_body :TREE := TREE_VOID )¶¬¬    
return TREE is¶         NODE :TREE := MAKE( DN_FUNCTION_ID );¶  begin¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    D( DA.
LX_SYMREP, NODE, LX_SYMREP );¶    D( DA.SM_FIRST, NODE, SM_FIRST );¶    D( DA.SM_SPEC, NODE, SM_SPEC );¶    D( DA.SM_UNI
T_DESC, NODE, SM_UNIT_DESC );¶    D( DA.SM_ADDRESS, NODE, SM_ADDRESS );¶    DB( DA.SM_IS_INLINE, NODE, SM_IS_INLINE );¶ 
   D( DA.SM_INTERFACE, NODE, SM_INTERFACE );¶    D( DA.XD_REGION, NODE, XD_REGION );¶    D( DA.XD_STUB, NODE, XD_STUB );
¶    D( DA.XD_body, NODE, XD_body );¶         return NODE;¶  end¬MAKE_FUNCTION_ID;¶   ¶  function¬MAKE_OPERATOR_ID¶¬¬   
 ( LX_SRCPOS :TREE := TREE_VOID;¶¬¬    LX_SYMREP :TREE := TREE_VOID;¶¬¬    SM_FIRST :TREE := TREE_VOID;¶¬¬    SM_SPEC :T
REE := TREE_VOID;¶¬¬    SM_UNIT_DESC :TREE := TREE_VOID;¶¬¬    SM_ADDRESS :TREE := TREE_VOID;¶¬¬    SM_IS_INLINE :BOOLEA
N := FALSE;¶¬¬    SM_INTERFACE :TREE := TREE_VOID;¶¬¬    XD_REGION :TREE := TREE_VOID;¶¬¬    XD_STUB :TREE := TREE_VOID;
¶¬¬    XD_body :TREE := TREE_VOID;¶¬¬    XD_NOT_EQUAL :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := M
AKE( DN_OPERATOR_ID );¶  begin¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    D( DA.LX_SYMREP, NODE, LX_SYMREP );¶    D( DA
.SM_FIRST, NODE, SM_FIRST );¶    D( DA.SM_SPEC, NODE, SM_SPEC );¶    D( DA.SM_UNIT_DESC, NODE, SM_UNIT_DESC );¶    D( DA
.SM_ADDRESS, NODE, SM_ADDRESS );¶    DB( DA.SM_IS_INLINE, NODE, SM_IS_INLINE );¶    D( DA.SM_INTERFACE, NODE, SM_INTERFA
CE );¶    D( DA.XD_REGION, NODE, XD_REGION );¶    D( DA.XD_STUB, NODE, XD_STUB );¶    D( DA.XD_body, NODE, XD_body );¶  
  D( DA.XD_NOT_EQUAL, NODE, XD_NOT_EQUAL );¶         return NODE;¶  end¬MAKE_OPERATOR_ID;¶   ¶  function¬MAKE_package_ID
¶¬¬    ( LX_SRCPOS :TREE := TREE_VOID;¶¬¬    LX_SYMREP :TREE := TREE_VOID;¶¬¬    SM_FIRST :TREE := TREE_VOID;¶¬¬    SM_S
PEC :TREE := TREE_VOID;¶¬¬    SM_UNIT_DESC :TREE := TREE_VOID;¶¬¬    SM_ADDRESS :TREE := TREE_VOID;¶¬¬    XD_REGION :TRE
E := TREE_VOID;¶¬¬    XD_STUB :TREE := TREE_VOID;¶¬¬    XD_body :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE 
:TREE := MAKE( DN_package_ID );¶  begin¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    D( DA.LX_SYMREP, NODE, LX_SYMREP );¶
    D( DA.SM_FIRST, NODE, SM_FIRST );¶    D( DA.SM_SPEC, NODE, SM_SPEC );¶    D( DA.SM_UNIT_DESC, NODE, SM_UNIT_DESC );¶
    D( DA.SM_ADDRESS, NODE, SM_ADDRESS );¶    D( DA.XD_REGION, NODE, XD_REGION );¶    D( DA.XD_STUB, NODE, XD_STUB );¶  
  D( DA.XD_body, NODE, XD_body );¶         return NODE;¶  end¬MAKE_package_ID;¶   ¶  function¬MAKE_GENERIC_ID¶¬¬    ( LX
_SRCPOS :TREE := TREE_VOID;¶¬¬    LX_SYMREP :TREE := TREE_VOID;¶¬¬    SM_FIRST :TREE := TREE_VOID;¶¬¬    SM_SPEC :TREE :
= TREE_VOID;¶¬¬    SM_GENERIC_PARAM_S :TREE := TREE_VOID;¶¬¬    SM_body :TREE := TREE_VOID;¶¬¬    SM_IS_INLINE :BOOLEAN 
:= FALSE;¶¬¬    XD_REGION :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_GENERIC_ID );¶  begi
n¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    D( DA.LX_SYMREP, NODE, LX_SYMREP );¶    D( DA.SM_FIRST, NODE, SM_FIRST );¶
    D( DA.SM_SPEC, NODE, SM_SPEC );¶    D( DA.SM_GENERIC_PARAM_S, NODE, SM_GENERIC_PARAM_S );¶    D( DA.SM_body, NODE, S
M_body );¶    DB( DA.SM_IS_INLINE, NODE, SM_IS_INLINE );¶    D( DA.XD_REGION, NODE, XD_REGION );¶         return NODE;¶ 
 end¬MAKE_GENERIC_ID;¶   ¶  function¬MAKE_TASK_body_ID¶¬¬    ( LX_SRCPOS :TREE := TREE_VOID;¶¬¬    LX_SYMREP :TREE := TR
EE_VOID;¶¬¬    SM_FIRST :TREE := TREE_VOID;¶¬¬    SM_TYPE_SPEC :TREE := TREE_VOID;¶¬¬    SM_body :TREE := TREE_VOID;¶¬¬ 
   XD_REGION :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_TASK_body_ID );¶  begin¶    D( DA
.LX_SRCPOS, NODE, LX_SRCPOS );¶    D( DA.LX_SYMREP, NODE, LX_SYMREP );¶    D( DA.SM_FIRST, NODE, SM_FIRST );¶    D( DA.S
M_TYPE_SPEC, NODE, SM_TYPE_SPEC );¶    D( DA.SM_body, NODE, SM_body );¶    D( DA.XD_REGION, NODE, XD_REGION );¶         
return NODE;¶  end¬MAKE_TASK_body_ID;¶   ¶  function¬MAKE_LABEL_ID¶¬¬    ( LX_SRCPOS :TREE := TREE_VOID;¶¬¬    LX_SYMREP
 :TREE := TREE_VOID;¶¬¬    SM_STM :TREE := TREE_VOID;¶¬¬    XD_REGION :TREE := TREE_VOID )¶¬¬    return TREE is¶        
 NODE :TREE := MAKE( DN_LABEL_ID );¶  begin¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    D( DA.LX_SYMREP, NODE, LX_SYMREP
 );¶    D( DA.SM_STM, NODE, SM_STM );¶    D( DA.XD_REGION, NODE, XD_REGION );¶         return NODE;¶  end¬MAKE_LABEL_ID;
¶   ¶  function¬MAKE_BLOCK_LOOP_ID¶¬¬    ( LX_SRCPOS :TREE := TREE_VOID;¶¬¬    LX_SYMREP :TREE := TREE_VOID;¶¬¬    SM_ST
M :TREE := TREE_VOID;¶¬¬    XD_REGION :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_BLOCK_LO
OP_ID );¶  begin¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    D( DA.LX_SYMREP, NODE, LX_SYMREP );¶    D( DA.SM_STM, NODE,
 SM_STM );¶    D( DA.XD_REGION, NODE, XD_REGION );¶         return NODE;¶  end¬MAKE_BLOCK_LOOP_ID;¶   ¶  function¬MAKE_E
NTRY_ID¶¬¬    ( LX_SRCPOS :TREE := TREE_VOID;¶¬¬    LX_SYMREP :TREE := TREE_VOID;¶¬¬    SM_SPEC :TREE := TREE_VOID;¶¬¬  
  SM_ADDRESS :TREE := TREE_VOID;¶¬¬    XD_REGION :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( 
DN_ENTRY_ID );¶  begin¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    D( DA.LX_SYMREP, NODE, LX_SYMREP );¶    D( DA.SM_SPEC
, NODE, SM_SPEC );¶    D( DA.SM_ADDRESS, NODE, SM_ADDRESS );¶    D( DA.XD_REGION, NODE, XD_REGION );¶         return NOD
E;¶  end¬MAKE_ENTRY_ID;¶      --|---------------------------------------------------------------------------------------
----¶      --|¬FUNCTION MAKE_EXCEPTION_ID¶  function¬MAKE_EXCEPTION_ID ( LX_SRCPOS, LX_SYMREP, SM_RENAMES_EXC, XD_REGION
 :TREE := TREE_VOID  ) return TREE is¶         NODE¬ :TREE := MAKE( DN_EXCEPTION_ID  );¶  begin¶    D( DA.LX_SRCPOS, NOD
E, LX_SRCPOS );¶    D( DA.LX_SYMREP, NODE, LX_SYMREP );¶    D( DA.SM_RENAMES_EXC, NODE, SM_RENAMES_EXC );¶    D( DA.XD_R
EGION, NODE, XD_REGION );¶         return NODE;¶  end¬MAKE_EXCEPTION_ID;¶      --|--------------------------------------
-----------------------------------------------------¶      --|¬FUNCTION MAKE_ATTRIBUTE_ID¶  function¬MAKE_ATTRIBUTE_ID 
( LX_SRCPOS, LX_SYMREP :TREE := TREE_VOID; XD_POS :INTEGER  ) return TREE is¶         NODE¬ :TREE := MAKE( DN_ATTRIBUTE_
ID  );¶  begin¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS  );¶    D( DA.LX_SYMREP, NODE, LX_SYMREP  );¶         DI ( DA.XD_POS
,   NODE, XD_POS  );¶         return NODE;¶  end¬MAKE_ATTRIBUTE_ID;¶      --|-------------------------------------------
------------------------------------------------¶      --|¬FUNCTION MAKE_PRAGMA_ID¶  function¬MAKE_PRAGMA_ID ( LX_SRCPOS
, LX_SYMREP, SM_ARGUMENT_ID_S :TREE := TREE_VOID; XD_POS :INTEGER  ) return TREE is¶         NODE¬ :TREE := MAKE( DN_PRA
GMA_ID  );¶  begin¶         D  ( DA.LX_SRCPOS, NODE, LX_SRCPOS  );¶         D  ( DA.LX_SYMREP, NODE, LX_SYMREP  );¶     
    DI ( DA.XD_POS,    NODE, XD_POS  );¶         D  ( DA.SM_ARGUMENT_ID_S, NODE, SM_ARGUMENT_ID_S  );¶         return NO
DE;¶  end;¶      --|-------------------------------------------------------------------------------------------¶      --
|¬FUNCTION MAKE_ARGUMENT_ID¶  function¬MAKE_ARGUMENT_ID ( LX_SRCPOS, LX_SYMREP :TREE := TREE_VOID; XD_POS :INTEGER  ) re
turn TREE is¶         NODE¬ :TREE := MAKE( DN_ARGUMENT_ID  );¶  begin¶         D  ( DA.LX_SRCPOS, NODE, LX_SRCPOS  );¶  
       D  ( DA.LX_SYMREP, NODE, LX_SYMREP  );¶         DI ( DA.XD_POS,    NODE, XD_POS  );¶         return NODE;¶  end;¶
      --|-------------------------------------------------------------------------------------------¶      --|¬FUNCTION 
MAKE_BLTN_OPERATOR_ID¶  function¬MAKE_BLTN_OPERATOR_ID ( LX_SRCPOS, LX_SYMREP :TREE := TREE_VOID; SM_OPERATOR :INTEGER  
) return TREE is¶         NODE¬ :TREE := MAKE( DN_BLTN_OPERATOR_ID  );¶  begin¶         D  ( DA.LX_SRCPOS,   NODE, LX_SR
CPOS );¶         D  ( DA.LX_SYMREP,   NODE, LX_SYMREP );¶         DI ( DA.SM_OPERATOR, NODE, SM_OPERATOR );¶         ret
urn NODE;¶  end;¶   ¶  function¬MAKE_BLOCK_MASTER¶¬¬    ( LX_SRCPOS :TREE := TREE_VOID;¶¬¬    SM_STM :TREE := TREE_VOID 
)¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_BLOCK_MASTER );¶  begin¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶ 
   D( DA.SM_STM, NODE, SM_STM );¶         return NODE;¶  end¬MAKE_BLOCK_MASTER;¶   ¶  function¬MAKE_DSCRMT_DECL¶¬¬    ( 
AS_SOURCE_NAME_S :TREE := TREE_VOID;¶¬¬    AS_NAME :TREE := TREE_VOID;¶¬¬    AS_EXP :TREE := TREE_VOID;¶¬¬    LX_SRCPOS 
:TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_DSCRMT_DECL );¶  begin¶    D( DA.AS_SOURCE_NAM
E_S, NODE, AS_SOURCE_NAME_S );¶    D( DA.AS_NAME, NODE, AS_NAME );¶    D( DA.AS_EXP, NODE, AS_EXP );¶    D( DA.LX_SRCPOS
, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_DSCRMT_DECL;¶   ¶  function¬MAKE_IN¶¬¬    ( AS_SOURCE_NAME_S :TREE
 := TREE_VOID;¶¬¬    AS_NAME :TREE := TREE_VOID;¶¬¬    AS_EXP :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID;¶¬¬
    LX_DEFAULT :BOOLEAN := FALSE )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_IN );¶  begin¶    D( DA.AS_SOURC
E_NAME_S, NODE, AS_SOURCE_NAME_S );¶    D( DA.AS_NAME, NODE, AS_NAME );¶    D( DA.AS_EXP, NODE, AS_EXP );¶    D( DA.LX_S
RCPOS, NODE, LX_SRCPOS );¶    DB( DA.LX_DEFAULT, NODE, LX_DEFAULT );¶         return NODE;¶  end¬MAKE_IN;¶   ¶  function
¬MAKE_OUT¶¬¬    ( AS_SOURCE_NAME_S :TREE := TREE_VOID;¶¬¬    AS_NAME :TREE := TREE_VOID;¶¬¬    AS_EXP :TREE := TREE_VOID
;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_OUT );¶  begin¶    D( DA.AS_
SOURCE_NAME_S, NODE, AS_SOURCE_NAME_S );¶    D( DA.AS_NAME, NODE, AS_NAME );¶    D( DA.AS_EXP, NODE, AS_EXP );¶    D( DA
.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_OUT;¶   ¶  function¬MAKE_IN_OUT¶¬¬    ( AS_SOURCE_NAME_S
 :TREE := TREE_VOID;¶¬¬    AS_NAME :TREE := TREE_VOID;¶¬¬    AS_EXP :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VO
ID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_IN_OUT );¶  begin¶    D( DA.AS_SOURCE_NAME_S, NODE, AS_SOURCE_
NAME_S );¶    D( DA.AS_NAME, NODE, AS_NAME );¶    D( DA.AS_EXP, NODE, AS_EXP );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶
         return NODE;¶  end¬MAKE_IN_OUT;¶   ¶  function¬MAKE_CONSTANT_DECL¶¬¬    ( AS_SOURCE_NAME_S :TREE := TREE_VOID;¶
¬¬    AS_EXP :TREE := TREE_VOID;¶¬¬    AS_TYPE_DEF :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return
 TREE is¶         NODE :TREE := MAKE( DN_CONSTANT_DECL );¶  begin¶    D( DA.AS_SOURCE_NAME_S, NODE, AS_SOURCE_NAME_S );¶
    D( DA.AS_EXP, NODE, AS_EXP );¶    D( DA.AS_TYPE_DEF, NODE, AS_TYPE_DEF );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶  
       return NODE;¶  end¬MAKE_CONSTANT_DECL;¶   ¶  function¬MAKE_VARIABLE_DECL¶¬¬    ( AS_SOURCE_NAME_S :TREE := TREE_V
OID;¶¬¬    AS_EXP :TREE := TREE_VOID;¶¬¬    AS_TYPE_DEF :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    r
eturn TREE is¶         NODE :TREE := MAKE( DN_VARIABLE_DECL );¶  begin¶    D( DA.AS_SOURCE_NAME_S, NODE, AS_SOURCE_NAME_
S );¶    D( DA.AS_EXP, NODE, AS_EXP );¶    D( DA.AS_TYPE_DEF, NODE, AS_TYPE_DEF );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS 
);¶         return NODE;¶  end¬MAKE_VARIABLE_DECL;¶   ¶  function¬MAKE_NUMBER_DECL¶¬¬    ( AS_SOURCE_NAME_S :TREE := TRE
E_VOID;¶¬¬    AS_EXP :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE :
= MAKE( DN_NUMBER_DECL );¶  begin¶    D( DA.AS_SOURCE_NAME_S, NODE, AS_SOURCE_NAME_S );¶    D( DA.AS_EXP, NODE, AS_EXP )
;¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_NUMBER_DECL;¶   ¶  function¬MAKE_EXCEPTION_DE
CL¶¬¬    ( AS_SOURCE_NAME_S :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE 
:TREE := MAKE( DN_EXCEPTION_DECL );¶  begin¶    D( DA.AS_SOURCE_NAME_S, NODE, AS_SOURCE_NAME_S );¶    D( DA.LX_SRCPOS, N
ODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_EXCEPTION_DECL;¶   ¶  function¬MAKE_DEFERRED_CONSTANT_DECL¶¬¬    ( AS
_SOURCE_NAME_S :TREE := TREE_VOID;¶¬¬    AS_NAME :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return T
REE is¶         NODE :TREE := MAKE( DN_DEFERRED_CONSTANT_DECL );¶  begin¶    D( DA.AS_SOURCE_NAME_S, NODE, AS_SOURCE_NAM
E_S );¶    D( DA.AS_NAME, NODE, AS_NAME );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_DEFE
RRED_CONSTANT_DECL;¶   ¶  function¬MAKE_TYPE_DECL¶¬¬    ( AS_SOURCE_NAME :TREE := TREE_VOID;¶¬¬    AS_DSCRMT_DECL_S :TRE
E := TREE_VOID;¶¬¬    AS_TYPE_DEF :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶        
 NODE :TREE := MAKE( DN_TYPE_DECL );¶  begin¶    D( DA.AS_SOURCE_NAME, NODE, AS_SOURCE_NAME );¶    D( DA.AS_DSCRMT_DECL_
S, NODE, AS_DSCRMT_DECL_S );¶    D( DA.AS_TYPE_DEF, NODE, AS_TYPE_DEF );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶       
  return NODE;¶  end¬MAKE_TYPE_DECL;¶   ¶  function¬MAKE_SUBTYPE_DECL¶¬¬    ( AS_SOURCE_NAME :TREE := TREE_VOID;¶¬¬    A
S_SUBTYPE_INDICATION :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE :
= MAKE( DN_SUBTYPE_DECL );¶  begin¶    D( DA.AS_SOURCE_NAME, NODE, AS_SOURCE_NAME );¶    D( DA.AS_SUBTYPE_INDICATION, NO
DE, AS_SUBTYPE_INDICATION );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_SUBTYPE_DECL;¶   ¶
  function¬MAKE_TASK_DECL¶¬¬    ( AS_SOURCE_NAME :TREE := TREE_VOID;¶¬¬    AS_DECL_S :TREE := TREE_VOID;¶¬¬    LX_SRCPOS
 :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_TASK_DECL );¶  begin¶    D( DA.AS_SOURCE_NAME
, NODE, AS_SOURCE_NAME );¶    D( DA.AS_DECL_S, NODE, AS_DECL_S );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         retur
n NODE;¶  end¬MAKE_TASK_DECL;¶   ¶  function¬MAKE_GENERIC_DECL¶¬¬    ( AS_SOURCE_NAME :TREE := TREE_VOID;¶¬¬    AS_HEADE
R :TREE := TREE_VOID;¶¬¬    AS_ITEM_S :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶    
     NODE :TREE := MAKE( DN_GENERIC_DECL );¶  begin¶    D( DA.AS_SOURCE_NAME, NODE, AS_SOURCE_NAME );¶    D( DA.AS_HEADE
R, NODE, AS_HEADER );¶    D( DA.AS_ITEM_S, NODE, AS_ITEM_S );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NO
DE;¶  end¬MAKE_GENERIC_DECL;¶   ¶  function¬MAKE_SUBPROG_ENTRY_DECL¶¬¬    ( AS_SOURCE_NAME :TREE := TREE_VOID;¶¬¬    AS_
HEADER :TREE := TREE_VOID;¶¬¬    AS_UNIT_KIND :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE
 is¶         NODE :TREE := MAKE( DN_SUBPROG_ENTRY_DECL );¶  begin¶    D( DA.AS_SOURCE_NAME, NODE, AS_SOURCE_NAME );¶    
D( DA.AS_HEADER, NODE, AS_HEADER );¶    D( DA.AS_UNIT_KIND, NODE, AS_UNIT_KIND );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS )
;¶         return NODE;¶  end¬MAKE_SUBPROG_ENTRY_DECL;¶   ¶  function¬MAKE_package_DECL¶¬¬    ( AS_SOURCE_NAME :TREE := 
TREE_VOID;¶¬¬    AS_HEADER :TREE := TREE_VOID;¶¬¬    AS_UNIT_KIND :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID
  )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_package_DECL );¶  begin¶    D( DA.AS_SOURCE_NAME, NODE, AS_SOUR
CE_NAME );¶    D( DA.AS_HEADER, NODE, AS_HEADER );¶    D( DA.AS_UNIT_KIND, NODE, AS_UNIT_KIND );¶    D( DA.LX_SRCPOS, NO
DE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_package_DECL;¶   ¶  function¬MAKE_RENAMES_OBJ_DECL¶¬¬    ( AS_SOURCE_N
AME :TREE := TREE_VOID;¶¬¬    AS_NAME :TREE := TREE_VOID;¶¬¬    AS_TYPE_MARK_NAME :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :T
REE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_RENAMES_OBJ_DECL );¶  begin¶    D( DA.AS_SOURCE_
NAME, NODE, AS_SOURCE_NAME );¶    D( DA.AS_NAME, NODE, AS_NAME );¶    D( DA.AS_TYPE_MARK_NAME, NODE, AS_TYPE_MARK_NAME )
;¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_RENAMES_OBJ_DECL;¶   ¶  function¬MAKE_RENAMES
_EXC_DECL¶¬¬    ( AS_SOURCE_NAME :TREE := TREE_VOID;¶¬¬    AS_NAME :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOI
D )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_RENAMES_EXC_DECL );¶  begin¶    D( DA.AS_SOURCE_NAME, NODE, AS_
SOURCE_NAME );¶    D( DA.AS_NAME, NODE, AS_NAME );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬M
AKE_RENAMES_EXC_DECL;¶   ¶  function¬MAKE_NULL_COMP_DECL¶¬¬    ( LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶   
      NODE :TREE := MAKE( DN_NULL_COMP_DECL );¶  begin¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  e
nd¬MAKE_NULL_COMP_DECL;¶   ¶  function¬MAKE_LENGTH_ENUM_REP¶¬¬    ( AS_NAME :TREE := TREE_VOID;¶¬¬    AS_EXP :TREE := TR
EE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_LENGTH_ENUM_REP );¶  
begin¶    D( DA.AS_NAME, NODE, AS_NAME );¶    D( DA.AS_EXP, NODE, AS_EXP );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    
     return NODE;¶  end¬MAKE_LENGTH_ENUM_REP;¶   ¶  function¬MAKE_ADDRESS¶¬¬    ( AS_NAME :TREE := TREE_VOID;¶¬¬    AS_E
XP :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_ADDRESS
 );¶  begin¶    D( DA.AS_NAME, NODE, AS_NAME );¶    D( DA.AS_EXP, NODE, AS_EXP );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS )
;¶         return NODE;¶  end¬MAKE_ADDRESS;¶   ¶  function¬MAKE_RECORD_REP¶¬¬    ( AS_NAME :TREE := TREE_VOID;¶¬¬    AS_
ALIGNMENT_CLAUSE :TREE := TREE_VOID;¶¬¬    AS_COMP_REP_S :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    
return TREE is¶         NODE :TREE := MAKE( DN_RECORD_REP );¶  begin¶    D( DA.AS_NAME, NODE, AS_NAME );¶    D( DA.AS_AL
IGNMENT_CLAUSE, NODE, AS_ALIGNMENT_CLAUSE );¶    D( DA.AS_COMP_REP_S, NODE, AS_COMP_REP_S );¶    D( DA.LX_SRCPOS, NODE, 
LX_SRCPOS );¶         return NODE;¶  end¬MAKE_RECORD_REP;¶   ¶  function¬MAKE_USE¶¬¬    ( AS_NAME_S :TREE := TREE_VOID;¶
¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_USE );¶  begin¶    D( DA.AS_NA
ME_S, NODE, AS_NAME_S );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_USE;¶   ¶  function¬MA
KE_PRAGMA¶¬¬    ( AS_USED_NAME_ID :TREE := TREE_VOID;¶¬¬    AS_GENERAL_ASSOC_S :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE
 := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_PRAGMA );¶  begin¶    D( DA.AS_USED_NAME_ID, NODE, 
AS_USED_NAME_ID );¶    D( DA.AS_GENERAL_ASSOC_S, NODE, AS_GENERAL_ASSOC_S );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶   
      return NODE;¶  end¬MAKE_PRAGMA;¶   ¶  function¬MAKE_SUBPROGRAM_body¶¬¬    ( AS_SOURCE_NAME :TREE := TREE_VOID;¶¬¬ 
   AS_body :TREE := TREE_VOID;¶¬¬    AS_HEADER :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TRE
E is¶         NODE :TREE := MAKE( DN_SUBPROGRAM_body );¶  begin¶    D( DA.AS_SOURCE_NAME, NODE, AS_SOURCE_NAME );¶    D(
 DA.AS_body, NODE, AS_body );¶    D( DA.AS_HEADER, NODE, AS_HEADER );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         r
eturn NODE;¶  end¬MAKE_SUBPROGRAM_body;¶   ¶  function¬MAKE_package_body¶¬¬    ( AS_SOURCE_NAME :TREE := TREE_VOID;¶¬¬  
  AS_body :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_
package_body );¶  begin¶    D( DA.AS_SOURCE_NAME, NODE, AS_SOURCE_NAME );¶    D( DA.AS_body, NODE, AS_body );¶    D( DA.
LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_package_body;¶   ¶  function¬MAKE_TASK_body¶¬¬    ( AS_SO
URCE_NAME :TREE := TREE_VOID;¶¬¬    AS_body :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE i
s¶         NODE :TREE := MAKE( DN_TASK_body );¶  begin¶    D( DA.AS_SOURCE_NAME, NODE, AS_SOURCE_NAME );¶    D( DA.AS_bo
dy, NODE, AS_body );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_TASK_body;¶   ¶  function¬
MAKE_SUBUNIT¶¬¬    ( AS_NAME :TREE := TREE_VOID;¶¬¬    AS_SUBUNIT_body :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE
_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_SUBUNIT );¶  begin¶    D( DA.AS_NAME, NODE, AS_NAME );¶    
D( DA.AS_SUBUNIT_body, NODE, AS_SUBUNIT_body );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE
_SUBUNIT;¶   ¶  function¬MAKE_ENUMERATION_DEF¶¬¬    ( AS_ENUM_LITERAL_S :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TRE
E_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_ENUMERATION_DEF );¶  begin¶    D( DA.AS_ENUM_LITERAL_S, NO
DE, AS_ENUM_LITERAL_S );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_ENUMERATION_DEF;¶   ¶ 
 function¬MAKE_SUBTYPE_INDICATION¶¬¬    ( AS_CONSTRAINT :TREE := TREE_VOID;¶¬¬    AS_NAME :TREE := TREE_VOID;¶¬¬    LX_S
RCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_SUBTYPE_INDICATION );¶  begin¶    D( DA.
AS_CONSTRAINT, NODE, AS_CONSTRAINT );¶    D( DA.AS_NAME, NODE, AS_NAME );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶      
   return NODE;¶  end¬MAKE_SUBTYPE_INDICATION;¶   ¶  function¬MAKE_INTEGER_DEF¶¬¬    ( AS_CONSTRAINT :TREE := TREE_VOID;
¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_INTEGER_DEF );¶  begin¶    D(
 DA.AS_CONSTRAINT, NODE, AS_CONSTRAINT );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_INTEG
ER_DEF;¶   ¶  function¬MAKE_FLOAT_DEF¶¬¬    ( AS_CONSTRAINT :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬ 
   return TREE is¶         NODE :TREE := MAKE( DN_FLOAT_DEF );¶  begin¶    D( DA.AS_CONSTRAINT, NODE, AS_CONSTRAINT );¶ 
   D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_FLOAT_DEF;¶   ¶  function¬MAKE_FIXED_DEF¶¬¬    (
 AS_CONSTRAINT :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE
( DN_FIXED_DEF );¶  begin¶    D( DA.AS_CONSTRAINT, NODE, AS_CONSTRAINT );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶      
   return NODE;¶  end¬MAKE_FIXED_DEF;¶   ¶  function¬MAKE_CONSTRAINED_ARRAY_DEF¶¬¬    ( AS_SUBTYPE_INDICATION :TREE := T
REE_VOID;¶¬¬    AS_CONSTRAINT :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NOD
E :TREE := MAKE( DN_CONSTRAINED_ARRAY_DEF );¶  begin¶    D( DA.AS_SUBTYPE_INDICATION, NODE, AS_SUBTYPE_INDICATION );¶   
 D( DA.AS_CONSTRAINT, NODE, AS_CONSTRAINT );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_CO
NSTRAINED_ARRAY_DEF;¶   ¶  function¬MAKE_UNCONSTRAINED_ARRAY_DEF¶¬¬    ( AS_SUBTYPE_INDICATION :TREE := TREE_VOID;¶¬¬   
 AS_INDEX_S :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( D
N_UNCONSTRAINED_ARRAY_DEF );¶  begin¶    D( DA.AS_SUBTYPE_INDICATION, NODE, AS_SUBTYPE_INDICATION );¶    D( DA.AS_INDEX_
S, NODE, AS_INDEX_S );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_UNCONSTRAINED_ARRAY_DEF;
¶   ¶  function¬MAKE_ACCESS_DEF¶¬¬    ( AS_SUBTYPE_INDICATION :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬
¬    return TREE is¶         NODE :TREE := MAKE( DN_ACCESS_DEF );¶  begin¶    D( DA.AS_SUBTYPE_INDICATION, NODE, AS_SUBT
YPE_INDICATION );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_ACCESS_DEF;¶   ¶  function¬MA
KE_DERIVED_DEF¶¬¬    ( AS_SUBTYPE_INDICATION :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID;¶¬¬    LIST :SEQ_TYP
E := (TREE_NIL,TREE_NIL ) )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_DERIVED_DEF );¶  begin¶    D( DA.AS_SUB
TYPE_INDICATION, NODE, AS_SUBTYPE_INDICATION );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         IDL_MAN.LIST(NODE, LIST
 );¶         return NODE;¶  end¬MAKE_DERIVED_DEF;¶   ¶  function¬MAKE_RECORD_DEF¶¬¬    ( AS_COMP_LIST :TREE := TREE_VOID
;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_RECORD_DEF );¶  begin¶    D(
 DA.AS_COMP_LIST, NODE, AS_COMP_LIST );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_RECORD_
DEF;¶   ¶  function¬MAKE_PRIVATE_DEF¶¬¬    ( LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := 
MAKE( DN_PRIVATE_DEF );¶  begin¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_PRIVATE_DEF;¶  
 ¶  function¬MAKE_L_PRIVATE_DEF¶¬¬    ( LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE(
 DN_L_PRIVATE_DEF );¶  begin¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_L_PRIVATE_DEF;¶   
¶  function¬MAKE_FORMAL_DSCRT_DEF¶¬¬    ( LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAK
E( DN_FORMAL_DSCRT_DEF );¶  begin¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_FORMAL_DSCRT_
DEF;¶   ¶  function¬MAKE_FORMAL_INTEGER_DEF¶¬¬    ( LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :T
REE := MAKE( DN_FORMAL_INTEGER_DEF );¶  begin¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_F
ORMAL_INTEGER_DEF;¶   ¶  function¬MAKE_FORMAL_FIXED_DEF¶¬¬    ( LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶    
     NODE :TREE := MAKE( DN_FORMAL_FIXED_DEF );¶  begin¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  
end¬MAKE_FORMAL_FIXED_DEF;¶   ¶  function¬MAKE_FORMAL_FLOAT_DEF¶¬¬    ( LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE
 is¶         NODE :TREE := MAKE( DN_FORMAL_FLOAT_DEF );¶  begin¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return 
NODE;¶  end¬MAKE_FORMAL_FLOAT_DEF;¶   ¶  function¬MAKE_ALTERNATIVE_S¶¬¬    ( LIST :SEQ_TYPE := (TREE_NIL,TREE_NIL );¶¬¬ 
   LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_ALTERNATIVE_S );¶  begin¶        
 IDL_MAN.LIST(NODE, LIST );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_ALTERNATIVE_S;¶   ¶
  function¬MAKE_ARGUMENT_ID_S¶¬¬    ( LIST :SEQ_TYPE := (TREE_NIL,TREE_NIL );¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬   
 return TREE is¶         NODE :TREE := MAKE( DN_ARGUMENT_ID_S );¶  begin¶         IDL_MAN.LIST(NODE, LIST );¶    D( DA.L
X_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_ARGUMENT_ID_S;¶   ¶  function¬MAKE_CHOICE_S¶¬¬    ( LIST :
SEQ_TYPE := (TREE_NIL,TREE_NIL );¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE(
 DN_CHOICE_S );¶  begin¶         IDL_MAN.LIST(NODE, LIST );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE
;¶  end¬MAKE_CHOICE_S;¶   ¶  function¬MAKE_COMP_REP_S¶¬¬    ( LIST :SEQ_TYPE := (TREE_NIL,TREE_NIL );¶¬¬    LX_SRCPOS :T
REE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_COMP_REP_S );¶  begin¶         IDL_MAN.LIST(NODE
, LIST );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_COMP_REP_S;¶   ¶  function¬MAKE_COMPL
TN_UNIT_S¶¬¬    ( LIST :SEQ_TYPE := (TREE_NIL,TREE_NIL );¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶    
     NODE :TREE := MAKE( DN_COMPLTN_UNIT_S );¶  begin¶         IDL_MAN.LIST(NODE, LIST );¶    D( DA.LX_SRCPOS, NODE, LX_
SRCPOS );¶         return NODE;¶  end¬MAKE_COMPLTN_UNIT_S;¶   ¶  function¬MAKE_CONTEXT_ELEM_S¶¬¬    ( LIST :SEQ_TYPE := 
(TREE_NIL,TREE_NIL );¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_CONTEXT_
ELEM_S );¶  begin¶         IDL_MAN.LIST(NODE, LIST );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  en
d¬MAKE_CONTEXT_ELEM_S;¶   ¶  function¬MAKE_DECL_S¶¬¬    ( LIST :SEQ_TYPE := (TREE_NIL,TREE_NIL );¶¬¬    LX_SRCPOS :TREE 
:= TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_DECL_S );¶  begin¶         IDL_MAN.LIST(NODE, LIST )
;¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_DECL_S;¶   ¶  function¬MAKE_DSCRMT_DECL_S¶¬¬ 
   ( LIST :SEQ_TYPE := (TREE_NIL,TREE_NIL );¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TR
EE := MAKE( DN_DSCRMT_DECL_S );¶  begin¶         IDL_MAN.LIST(NODE, LIST );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    
     return NODE;¶  end¬MAKE_DSCRMT_DECL_S;¶   ¶  function¬MAKE_GENERAL_ASSOC_S¶¬¬    ( LIST :SEQ_TYPE := (TREE_NIL,TREE
_NIL );¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_GENERAL_ASSOC_S );¶  b
egin¶         IDL_MAN.LIST(NODE, LIST );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_GENERA
L_ASSOC_S;¶   ¶  function¬MAKE_DISCRETE_RANGE_S¶¬¬    ( LIST :SEQ_TYPE := (TREE_NIL,TREE_NIL );¶¬¬    LX_SRCPOS :TREE :=
 TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_DISCRETE_RANGE_S );¶  begin¶         IDL_MAN.LIST(NODE
, LIST );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_DISCRETE_RANGE_S;¶   ¶  function¬MAKE
_ENUM_LITERAL_S¶¬¬    ( LIST :SEQ_TYPE := (TREE_NIL,TREE_NIL );¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE i
s¶         NODE :TREE := MAKE( DN_ENUM_LITERAL_S );¶  begin¶         IDL_MAN.LIST(NODE, LIST );¶    D( DA.LX_SRCPOS, NOD
E, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_ENUM_LITERAL_S;¶   ¶  function¬MAKE_EXP_S¶¬¬    ( LIST :SEQ_TYPE := (TR
EE_NIL,TREE_NIL );¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_EXP_S );¶  
begin¶         IDL_MAN.LIST(NODE, LIST );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_EXP_S
;¶   ¶  function¬MAKE_ITEM_S¶¬¬    ( LIST :SEQ_TYPE := (TREE_NIL,TREE_NIL );¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    
return TREE is¶         NODE :TREE := MAKE( DN_ITEM_S );¶  begin¶         IDL_MAN.LIST(NODE, LIST );¶    D( DA.LX_SRCPOS
, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_ITEM_S;¶   ¶  function¬MAKE_INDEX_S¶¬¬    ( LIST :SEQ_TYPE := (TRE
E_NIL,TREE_NIL );¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_INDEX_S );¶ 
 begin¶         IDL_MAN.LIST(NODE, LIST );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_INDE
X_S;¶   ¶  function¬MAKE_NAME_S¶¬¬    ( LIST :SEQ_TYPE := (TREE_NIL,TREE_NIL );¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬ 
   return TREE is¶         NODE :TREE := MAKE( DN_NAME_S );¶  begin¶         IDL_MAN.LIST(NODE, LIST );¶    D( DA.LX_SRC
POS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_NAME_S;¶   ¶  function¬MAKE_PARAM_S¶¬¬    ( LIST :SEQ_TYPE := (
TREE_NIL,TREE_NIL );¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_PARAM_S )
;¶  begin¶         IDL_MAN.LIST(NODE, LIST );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_P
ARAM_S;¶   ¶  function¬MAKE_PRAGMA_S¶¬¬    ( LIST :SEQ_TYPE := (TREE_NIL,TREE_NIL );¶¬¬    LX_SRCPOS :TREE := TREE_VOID 
)¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_PRAGMA_S );¶  begin¶         IDL_MAN.LIST(NODE, LIST );¶    D( DA
.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_PRAGMA_S;¶   ¶  function¬MAKE_SCALAR_S¶¬¬    ( LIST :SEQ
_TYPE := (TREE_NIL,TREE_NIL );¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN
_SCALAR_S );¶  begin¶         IDL_MAN.LIST(NODE, LIST );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶ 
 end¬MAKE_SCALAR_S;¶   ¶  function¬MAKE_SOURCE_NAME_S¶¬¬    ( LIST :SEQ_TYPE := (TREE_NIL,TREE_NIL );¶¬¬    LX_SRCPOS :T
REE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_SOURCE_NAME_S );¶  begin¶         IDL_MAN.LIST(N
ODE, LIST );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_SOURCE_NAME_S;¶   ¶  function¬MAKE
_STM_S¶¬¬    ( LIST :SEQ_TYPE := (TREE_NIL,TREE_NIL );¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶       
  NODE :TREE := MAKE( DN_STM_S );¶  begin¶         IDL_MAN.LIST(NODE, LIST );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶  
       return NODE;¶  end¬MAKE_STM_S;¶   ¶  function¬MAKE_TEST_CLAUSE_ELEM_S¶¬¬    ( LIST :SEQ_TYPE := (TREE_NIL,TREE_NI
L );¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_TEST_CLAUSE_ELEM_S );¶  b
egin¶         IDL_MAN.LIST(NODE, LIST );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_TEST_C
LAUSE_ELEM_S;¶   ¶  function¬MAKE_USE_PRAGMA_S¶¬¬    ( LIST :SEQ_TYPE := (TREE_NIL,TREE_NIL );¶¬¬    LX_SRCPOS :TREE := 
TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_USE_PRAGMA_S );¶  begin¶         IDL_MAN.LIST(NODE, LIS
T );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_USE_PRAGMA_S;¶   ¶  function¬MAKE_VARIANT_
S¶¬¬    ( LIST :SEQ_TYPE := (TREE_NIL,TREE_NIL );¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NOD
E :TREE := MAKE( DN_VARIANT_S );¶  begin¶         IDL_MAN.LIST(NODE, LIST );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶   
      return NODE;¶  end¬MAKE_VARIANT_S;¶   ¶  function¬MAKE_LABELED¶¬¬    ( AS_SOURCE_NAME_S :TREE := TREE_VOID;¶¬¬    
AS_PRAGMA_S :TREE := TREE_VOID;¶¬¬    AS_STM :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE 
is¶         NODE :TREE := MAKE( DN_LABELED );¶  begin¶    D( DA.AS_SOURCE_NAME_S, NODE, AS_SOURCE_NAME_S );¶    D( DA.AS
_PRAGMA_S, NODE, AS_PRAGMA_S );¶    D( DA.AS_STM, NODE, AS_STM );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         retur
n NODE;¶  end¬MAKE_LABELED;¶   ¶  function¬MAKE_NULL_STM¶¬¬    ( LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶   
      NODE :TREE := MAKE( DN_NULL_STM );¶  begin¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAK
E_NULL_STM;¶   ¶  function¬MAKE_ABORT¶¬¬    ( AS_NAME_S :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    r
eturn TREE is¶         NODE :TREE := MAKE( DN_ABORT );¶  begin¶    D( DA.AS_NAME_S, NODE, AS_NAME_S );¶    D( DA.LX_SRCP
OS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_ABORT;¶   ¶  function¬MAKE_RETURN¶¬¬    ( AS_EXP :TREE := TREE_V
OID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_RETURN );¶  begin¶    D( 
DA.AS_EXP, NODE, AS_EXP );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_RETURN;¶   ¶  functi
on¬MAKE_DELAY¶¬¬    ( AS_EXP :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE
 :TREE := MAKE( DN_DELAY );¶  begin¶    D( DA.AS_EXP, NODE, AS_EXP );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         r
eturn NODE;¶  end¬MAKE_DELAY;¶   ¶  function¬MAKE_ASSIGN¶¬¬    ( AS_EXP :TREE := TREE_VOID;¶¬¬    AS_NAME :TREE := TREE_
VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_ASSIGN );¶  begin¶    D(
 DA.AS_EXP, NODE, AS_EXP );¶    D( DA.AS_NAME, NODE, AS_NAME );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return 
NODE;¶  end¬MAKE_ASSIGN;¶   ¶  function¬MAKE_EXIT¶¬¬    ( AS_EXP :TREE := TREE_VOID;¶¬¬    AS_NAME :TREE := TREE_VOID;¶¬
¬    LX_SRCPOS :TREE := TREE_VOID;¶¬¬    SM_STM :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( D
N_EXIT );¶  begin¶    D( DA.AS_EXP, NODE, AS_EXP );¶    D( DA.AS_NAME, NODE, AS_NAME );¶    D( DA.LX_SRCPOS, NODE, LX_SR
CPOS );¶    D( DA.SM_STM, NODE, SM_STM );¶         return NODE;¶  end¬MAKE_EXIT;¶   ¶  function¬MAKE_CODE¶¬¬    ( AS_EXP
 :TREE := TREE_VOID;¶¬¬    AS_NAME :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶       
  NODE :TREE := MAKE( DN_CODE );¶  begin¶    D( DA.AS_EXP, NODE, AS_EXP );¶    D( DA.AS_NAME, NODE, AS_NAME );¶    D( DA
.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_CODE;¶   ¶  function¬MAKE_CASE¶¬¬    ( AS_EXP :TREE := T
REE_VOID;¶¬¬    AS_ALTERNATIVE_S :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         
NODE :TREE := MAKE( DN_CASE );¶  begin¶    D( DA.AS_EXP, NODE, AS_EXP );¶    D( DA.AS_ALTERNATIVE_S, NODE, AS_ALTERNATIV
E_S );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_CASE;¶   ¶  function¬MAKE_GOTO¶¬¬    ( A
S_NAME :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_GOT
O );¶  begin¶    D( DA.AS_NAME, NODE, AS_NAME );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAK
E_GOTO;¶   ¶  function¬MAKE_RAISE¶¬¬    ( AS_NAME :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return 
TREE is¶         NODE :TREE := MAKE( DN_RAISE );¶  begin¶    D( DA.AS_NAME, NODE, AS_NAME );¶    D( DA.LX_SRCPOS, NODE, 
LX_SRCPOS );¶         return NODE;¶  end¬MAKE_RAISE;¶   ¶  function¬MAKE_ENTRY_CALL¶¬¬    ( AS_NAME :TREE := TREE_VOID;¶
¬¬    AS_GENERAL_ASSOC_S :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID;¶¬¬    SM_NORMALIZED_PARAM_S :TREE := TR
EE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_ENTRY_CALL );¶  begin¶    D( DA.AS_NAME, NODE, AS_NAME );
¶    D( DA.AS_GENERAL_ASSOC_S, NODE, AS_GENERAL_ASSOC_S );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    D( DA.SM_NORMALIZ
ED_PARAM_S, NODE, SM_NORMALIZED_PARAM_S );¶         return NODE;¶  end¬MAKE_ENTRY_CALL;¶   ¶  function¬MAKE_PROCEDURE_CA
LL¶¬¬    ( AS_NAME :TREE := TREE_VOID;¶¬¬    AS_GENERAL_ASSOC_S :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID;¶
¬¬    SM_NORMALIZED_PARAM_S :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_PROCEDURE_CALL );¶
  begin¶    D( DA.AS_NAME, NODE, AS_NAME );¶    D( DA.AS_GENERAL_ASSOC_S, NODE, AS_GENERAL_ASSOC_S );¶    D( DA.LX_SRCPO
S, NODE, LX_SRCPOS );¶    D( DA.SM_NORMALIZED_PARAM_S, NODE, SM_NORMALIZED_PARAM_S );¶         return NODE;¶  end¬MAKE_P
ROCEDURE_CALL;¶   ¶  function¬MAKE_ACCEPT¶¬¬    ( AS_NAME :TREE := TREE_VOID;¶¬¬    AS_PARAM_S :TREE := TREE_VOID;¶¬¬   
 AS_STM_S :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_
ACCEPT );¶  begin¶    D( DA.AS_NAME, NODE, AS_NAME );¶    D( DA.AS_PARAM_S, NODE, AS_PARAM_S );¶    D( DA.AS_STM_S, NODE
, AS_STM_S );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_ACCEPT;¶   ¶  function¬MAKE_LOOP¶
¬¬    ( AS_SOURCE_NAME :TREE := TREE_VOID;¶¬¬    AS_ITERATION :TREE := TREE_VOID;¶¬¬    AS_STM_S :TREE := TREE_VOID;¶¬¬ 
   LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_LOOP );¶  begin¶    D( DA.AS_SOUR
CE_NAME, NODE, AS_SOURCE_NAME );¶    D( DA.AS_ITERATION, NODE, AS_ITERATION );¶    D( DA.AS_STM_S, NODE, AS_STM_S );¶   
 D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_LOOP;¶   ¶  function¬MAKE_BLOCK¶¬¬    ( AS_SOURCE_
NAME :TREE := TREE_VOID;¶¬¬    AS_BLOCK_body :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE 
is¶         NODE :TREE := MAKE( DN_BLOCK );¶  begin¶    D( DA.AS_SOURCE_NAME, NODE, AS_SOURCE_NAME );¶    D( DA.AS_BLOCK
_body, NODE, AS_BLOCK_body );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_BLOCK;¶   ¶  func
tion¬MAKE_COND_ENTRY¶¬¬    ( AS_STM_S1 :TREE := TREE_VOID;¶¬¬    AS_STM_S2 :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := 
TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_COND_ENTRY );¶  begin¶    D( DA.AS_STM_S1, NODE, AS_STM
_S1 );¶    D( DA.AS_STM_S2, NODE, AS_STM_S2 );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_
COND_ENTRY;¶   ¶  function¬MAKE_TIMED_ENTRY¶¬¬    ( AS_STM_S1 :TREE := TREE_VOID;¶¬¬    AS_STM_S2 :TREE := TREE_VOID;¶¬¬
    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_TIMED_ENTRY );¶  begin¶    D( DA
.AS_STM_S1, NODE, AS_STM_S1 );¶    D( DA.AS_STM_S2, NODE, AS_STM_S2 );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         
return NODE;¶  end¬MAKE_TIMED_ENTRY;¶   ¶  function¬MAKE_IF¶¬¬    ( AS_TEST_CLAUSE_ELEM_S :TREE := TREE_VOID;¶¬¬    AS_S
TM_S :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_IF );
¶  begin¶    D( DA.AS_TEST_CLAUSE_ELEM_S, NODE, AS_TEST_CLAUSE_ELEM_S );¶    D( DA.AS_STM_S, NODE, AS_STM_S );¶    D( DA
.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_IF;¶   ¶  function¬MAKE_SELECTIVE_WAIT¶¬¬    ( AS_TEST_C
LAUSE_ELEM_S :TREE := TREE_VOID;¶¬¬    AS_STM_S :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TR
EE is¶         NODE :TREE := MAKE( DN_SELECTIVE_WAIT );¶  begin¶    D( DA.AS_TEST_CLAUSE_ELEM_S, NODE, AS_TEST_CLAUSE_EL
EM_S );¶    D( DA.AS_STM_S, NODE, AS_STM_S );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_S
ELECTIVE_WAIT;¶   ¶  function¬MAKE_TERMINATE¶¬¬    ( LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :
TREE := MAKE( DN_TERMINATE );¶  begin¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_TERMINATE
;¶   ¶  function¬MAKE_STM_PRAGMA¶¬¬    ( AS_PRAGMA :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return
 TREE is¶         NODE :TREE := MAKE( DN_STM_PRAGMA );¶  begin¶    D( DA.AS_PRAGMA, NODE, AS_PRAGMA );¶    D( DA.LX_SRCP
OS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_STM_PRAGMA;¶   ¶  function¬MAKE_NAMED¶¬¬    ( AS_EXP :TREE := TR
EE_VOID;¶¬¬    AS_CHOICE_S :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :
TREE := MAKE( DN_NAMED );¶  begin¶    D( DA.AS_EXP, NODE, AS_EXP );¶    D( DA.AS_CHOICE_S, NODE, AS_CHOICE_S );¶    D( D
A.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_NAMED;¶   ¶  function¬MAKE_ASSOC¶¬¬    ( AS_EXP :TREE :
= TREE_VOID;¶¬¬    AS_USED_NAME :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         N
ODE :TREE := MAKE( DN_ASSOC );¶  begin¶    D( DA.AS_EXP, NODE, AS_EXP );¶    D( DA.AS_USED_NAME, NODE, AS_USED_NAME );¶ 
   D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_ASSOC;¶   ¶  function¬MAKE_USED_CHAR¶¬¬    ( LX_
SRCPOS :TREE := TREE_VOID;¶¬¬    LX_SYMREP :TREE := TREE_VOID;¶¬¬    SM_DEFN :TREE := TREE_VOID;¶¬¬    SM_EXP_TYPE :TREE
 := TREE_VOID;¶¬¬    SM_VALUE :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_USED_CHAR );¶  b
egin¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    D( DA.LX_SYMREP, NODE, LX_SYMREP );¶    D( DA.SM_DEFN, NODE, SM_DEFN );
¶    D( DA.SM_EXP_TYPE, NODE, SM_EXP_TYPE );¶    D( DA.SM_VALUE, NODE, SM_VALUE );¶         return NODE;¶  end¬MAKE_USED
_CHAR;¶   ¶  function¬MAKE_USED_OBJECT_ID¶¬¬    ( LX_SRCPOS :TREE := TREE_VOID;¶¬¬    LX_SYMREP :TREE := TREE_VOID;¶¬¬  
  SM_DEFN :TREE := TREE_VOID;¶¬¬    SM_EXP_TYPE :TREE := TREE_VOID;¶¬¬    SM_VALUE :TREE := TREE_VOID )¶¬¬    return TRE
E is¶         NODE :TREE := MAKE( DN_USED_OBJECT_ID );¶  begin¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    D( DA.LX_SYMR
EP, NODE, LX_SYMREP );¶    D( DA.SM_DEFN, NODE, SM_DEFN );¶    D( DA.SM_EXP_TYPE, NODE, SM_EXP_TYPE );¶    D( DA.SM_VALU
E, NODE, SM_VALUE );¶         return NODE;¶  end¬MAKE_USED_OBJECT_ID;¶   ¶  function¬MAKE_USED_OP¶¬¬    ( LX_SRCPOS :TRE
E := TREE_VOID;¶¬¬    LX_SYMREP :TREE := TREE_VOID;¶¬¬    SM_DEFN :TREE := TREE_VOID )¶¬¬    return TREE is¶         NOD
E :TREE := MAKE( DN_USED_OP );¶  begin¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    D( DA.LX_SYMREP, NODE, LX_SYMREP );¶ 
   D( DA.SM_DEFN, NODE, SM_DEFN );¶         return NODE;¶  end¬MAKE_USED_OP;¶   ¶  function¬MAKE_USED_NAME_ID¶¬¬    ( LX
_SRCPOS :TREE := TREE_VOID;¶¬¬    LX_SYMREP :TREE := TREE_VOID;¶¬¬    SM_DEFN :TREE := TREE_VOID )¶¬¬    return TREE is¶
         NODE :TREE := MAKE( DN_USED_NAME_ID );¶  begin¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    D( DA.LX_SYMREP, NOD
E, LX_SYMREP );¶    D( DA.SM_DEFN, NODE, SM_DEFN );¶         return NODE;¶  end¬MAKE_USED_NAME_ID;¶   ¶  function¬MAKE_A
TTRIBUTE¶¬¬    ( AS_NAME :TREE := TREE_VOID;¶¬¬    AS_USED_NAME_ID :TREE := TREE_VOID;¶¬¬    AS_EXP :TREE := TREE_VOID;¶
¬¬    LX_SRCPOS :TREE := TREE_VOID;¶¬¬    SM_EXP_TYPE :TREE := TREE_VOID;¶¬¬    SM_VALUE :TREE := TREE_VOID )¶¬¬    retu
rn TREE is¶         NODE :TREE := MAKE( DN_ATTRIBUTE );¶  begin¶    D( DA.AS_NAME, NODE, AS_NAME );¶    D( DA.AS_USED_NA
ME_ID, NODE, AS_USED_NAME_ID );¶    D( DA.AS_EXP, NODE, AS_EXP );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    D( DA.SM_E
XP_TYPE, NODE, SM_EXP_TYPE );¶    D( DA.SM_VALUE, NODE, SM_VALUE );¶         return NODE;¶  end¬MAKE_ATTRIBUTE;¶   ¶  fu
nction¬MAKE_SELECTED¶¬¬    ( AS_NAME :TREE := TREE_VOID;¶¬¬    AS_DESIGNATOR :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE :
= TREE_VOID;¶¬¬    SM_EXP_TYPE :TREE := TREE_VOID;¶¬¬    SM_VALUE :TREE := TREE_VOID )¶¬¬    return TREE is¶         NOD
E :TREE := MAKE( DN_SELECTED );¶  begin¶    D( DA.AS_NAME, NODE, AS_NAME );¶    D( DA.AS_DESIGNATOR, NODE, AS_DESIGNATOR
 );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    D( DA.SM_EXP_TYPE, NODE, SM_EXP_TYPE );¶    D( DA.SM_VALUE, NODE, SM_VAL
UE );¶         return NODE;¶  end¬MAKE_SELECTED;¶   ¶  function¬MAKE_FUNCTION_CALL¶¬¬    ( AS_NAME :TREE := TREE_VOID;¶¬
¬    AS_GENERAL_ASSOC_S :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID;¶¬¬    LX_PREFIX :BOOLEAN := FALSE;¶¬¬   
 SM_EXP_TYPE :TREE := TREE_VOID;¶¬¬    SM_VALUE :TREE := TREE_VOID;¶¬¬    SM_NORMALIZED_PARAM_S :TREE := TREE_VOID )¶¬¬ 
   return TREE is¶         NODE :TREE := MAKE( DN_FUNCTION_CALL );¶  begin¶    D( DA.AS_NAME, NODE, AS_NAME );¶    D( DA
.AS_GENERAL_ASSOC_S, NODE, AS_GENERAL_ASSOC_S );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    DB( DA.LX_PREFIX, NODE, LX_
PREFIX );¶    D( DA.SM_EXP_TYPE, NODE, SM_EXP_TYPE );¶    D( DA.SM_VALUE, NODE, SM_VALUE );¶    D( DA.SM_NORMALIZED_PARA
M_S, NODE, SM_NORMALIZED_PARAM_S );¶         return NODE;¶  end¬MAKE_FUNCTION_CALL;¶   ¶  function¬MAKE_INDEXED¶¬¬    ( 
AS_NAME :TREE := TREE_VOID;¶¬¬    AS_EXP_S :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID;¶¬¬    SM_EXP_TYPE :TR
EE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_INDEXED );¶  begin¶    D( DA.AS_NAME, NODE, AS_NA
ME );¶    D( DA.AS_EXP_S, NODE, AS_EXP_S );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    D( DA.SM_EXP_TYPE, NODE, SM_EXP_
TYPE );¶         return NODE;¶  end¬MAKE_INDEXED;¶   ¶  function¬MAKE_SLICE¶¬¬    ( AS_NAME :TREE := TREE_VOID;¶¬¬    AS
_DISCRETE_RANGE :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID;¶¬¬    SM_EXP_TYPE :TREE := TREE_VOID )¶¬¬    ret
urn TREE is¶         NODE :TREE := MAKE( DN_SLICE );¶  begin¶    D( DA.AS_NAME, NODE, AS_NAME );¶    D( DA.AS_DISCRETE_R
ANGE, NODE, AS_DISCRETE_RANGE );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    D( DA.SM_EXP_TYPE, NODE, SM_EXP_TYPE );¶   
      return NODE;¶  end¬MAKE_SLICE;¶   ¶  function¬MAKE_ALL¶¬¬    ( AS_NAME :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE :
= TREE_VOID;¶¬¬    SM_EXP_TYPE :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_ALL );¶  begin¶
    D( DA.AS_NAME, NODE, AS_NAME );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    D( DA.SM_EXP_TYPE, NODE, SM_EXP_TYPE );¶
         return NODE;¶  end¬MAKE_ALL;¶   ¶  function¬MAKE_SHORT_CIRCUIT¶¬¬    ( AS_EXP1 :TREE := TREE_VOID;¶¬¬    AS_SHO
RT_CIRCUIT_OP :TREE := TREE_VOID;¶¬¬    AS_EXP2 :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID;¶¬¬    SM_EXP_TYP
E :TREE := TREE_VOID;¶¬¬    SM_VALUE :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_SHORT_CIR
CUIT );¶  begin¶    D( DA.AS_EXP1, NODE, AS_EXP1 );¶    D( DA.AS_SHORT_CIRCUIT_OP, NODE, AS_SHORT_CIRCUIT_OP );¶    D( D
A.AS_EXP2, NODE, AS_EXP2 );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    D( DA.SM_EXP_TYPE, NODE, SM_EXP_TYPE );¶    D( D
A.SM_VALUE, NODE, SM_VALUE );¶         return NODE;¶  end¬MAKE_SHORT_CIRCUIT;¶   ¶  function¬MAKE_NUMERIC_LITERAL¶¬¬    
( LX_SRCPOS :TREE := TREE_VOID;¶¬¬    LX_NUMREP :TREE := TREE_VOID;¶¬¬    SM_EXP_TYPE :TREE := TREE_VOID;¶¬¬    SM_VALUE
 :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_NUMERIC_LITERAL );¶  begin¶    D( DA.LX_SRCPO
S, NODE, LX_SRCPOS );¶    D( DA.LX_NUMREP, NODE, LX_NUMREP );¶    D( DA.SM_EXP_TYPE, NODE, SM_EXP_TYPE );¶    D( DA.SM_V
ALUE, NODE, SM_VALUE );¶         return NODE;¶  end¬MAKE_NUMERIC_LITERAL;¶   ¶  function¬MAKE_NULL_ACCESS¶¬¬    ( LX_SRC
POS :TREE := TREE_VOID;¶¬¬    SM_EXP_TYPE :TREE := TREE_VOID;¶¬¬    SM_VALUE :TREE := TREE_VOID )¶¬¬    return TREE is¶ 
        NODE :TREE := MAKE( DN_NULL_ACCESS );¶  begin¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    D( DA.SM_EXP_TYPE, NOD
E, SM_EXP_TYPE );¶    D( DA.SM_VALUE, NODE, SM_VALUE );¶         return NODE;¶  end¬MAKE_NULL_ACCESS;¶   ¶  function¬MAK
E_RANGE_MEMBERSHIP¶¬¬    ( AS_EXP :TREE := TREE_VOID;¶¬¬    AS_MEMBERSHIP_OP :TREE := TREE_VOID;¶¬¬    AS_RANGE :TREE :=
 TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID;¶¬¬    SM_EXP_TYPE :TREE := TREE_VOID;¶¬¬    SM_VALUE :TREE := TREE_VOID 
)¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_RANGE_MEMBERSHIP );¶  begin¶    D( DA.AS_EXP, NODE, AS_EXP );¶   
 D( DA.AS_MEMBERSHIP_OP, NODE, AS_MEMBERSHIP_OP );¶    D( DA.AS_RANGE, NODE, AS_RANGE );¶    D( DA.LX_SRCPOS, NODE, LX_S
RCPOS );¶    D( DA.SM_EXP_TYPE, NODE, SM_EXP_TYPE );¶    D( DA.SM_VALUE, NODE, SM_VALUE );¶         return NODE;¶  end¬M
AKE_RANGE_MEMBERSHIP;¶   ¶  function¬MAKE_TYPE_MEMBERSHIP¶¬¬    ( AS_EXP :TREE := TREE_VOID;¶¬¬    AS_MEMBERSHIP_OP :TRE
E := TREE_VOID;¶¬¬    AS_NAME :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID;¶¬¬    SM_EXP_TYPE :TREE := TREE_VO
ID;¶¬¬    SM_VALUE :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_TYPE_MEMBERSHIP );¶  begin¶
    D( DA.AS_EXP, NODE, AS_EXP );¶    D( DA.AS_MEMBERSHIP_OP, NODE, AS_MEMBERSHIP_OP );¶    D( DA.AS_NAME, NODE, AS_NAME
 );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    D( DA.SM_EXP_TYPE, NODE, SM_EXP_TYPE );¶    D( DA.SM_VALUE, NODE, SM_VAL
UE );¶         return NODE;¶  end¬MAKE_TYPE_MEMBERSHIP;¶   ¶  function¬MAKE_CONVERSION¶¬¬    ( AS_EXP :TREE := TREE_VOID
;¶¬¬    AS_NAME :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID;¶¬¬    SM_EXP_TYPE :TREE := TREE_VOID;¶¬¬    SM_V
ALUE :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_CONVERSION );¶  begin¶    D( DA.AS_EXP, N
ODE, AS_EXP );¶    D( DA.AS_NAME, NODE, AS_NAME );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    D( DA.SM_EXP_TYPE, NODE, 
SM_EXP_TYPE );¶    D( DA.SM_VALUE, NODE, SM_VALUE );¶         return NODE;¶  end¬MAKE_CONVERSION;¶   ¶  function¬MAKE_QU
ALIFIED¶¬¬    ( AS_EXP :TREE := TREE_VOID;¶¬¬    AS_NAME :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID;¶¬¬    S
M_EXP_TYPE :TREE := TREE_VOID;¶¬¬    SM_VALUE :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_
QUALIFIED );¶  begin¶    D( DA.AS_EXP, NODE, AS_EXP );¶    D( DA.AS_NAME, NODE, AS_NAME );¶    D( DA.LX_SRCPOS, NODE, LX
_SRCPOS );¶    D( DA.SM_EXP_TYPE, NODE, SM_EXP_TYPE );¶    D( DA.SM_VALUE, NODE, SM_VALUE );¶         return NODE;¶  end
¬MAKE_QUALIFIED;¶   ¶  function¬MAKE_PARENTHESIZED¶¬¬    ( AS_EXP :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID
;¶¬¬    SM_EXP_TYPE :TREE := TREE_VOID;¶¬¬    SM_VALUE :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := 
MAKE( DN_PARENTHESIZED );¶  begin¶    D( DA.AS_EXP, NODE, AS_EXP );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    D( DA.SM
_EXP_TYPE, NODE, SM_EXP_TYPE );¶    D( DA.SM_VALUE, NODE, SM_VALUE );¶         return NODE;¶  end¬MAKE_PARENTHESIZED;¶  
 ¶  function¬MAKE_AGGREGATE¶¬¬    ( AS_GENERAL_ASSOC_S :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID;¶¬¬    SM_
EXP_TYPE :TREE := TREE_VOID;¶¬¬    SM_DISCRETE_RANGE :TREE := TREE_VOID;¶¬¬    SM_NORMALIZED_COMP_S :TREE := TREE_VOID )
¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_AGGREGATE );¶  begin¶    D( DA.AS_GENERAL_ASSOC_S, NODE, AS_GENERA
L_ASSOC_S );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    D( DA.SM_EXP_TYPE, NODE, SM_EXP_TYPE );¶    D( DA.SM_DISCRETE_R
ANGE, NODE, SM_DISCRETE_RANGE );¶    D( DA.SM_NORMALIZED_COMP_S, NODE, SM_NORMALIZED_COMP_S );¶         return NODE;¶  e
nd¬MAKE_AGGREGATE;¶   ¶  function¬MAKE_STRING_LITERAL¶¬¬    ( LX_SRCPOS :TREE := TREE_VOID;¶¬¬    LX_SYMREP :TREE := TRE
E_VOID;¶¬¬    SM_EXP_TYPE :TREE := TREE_VOID;¶¬¬    SM_DISCRETE_RANGE :TREE := TREE_VOID )¶¬¬    return TREE is¶        
 NODE :TREE := MAKE( DN_STRING_LITERAL );¶  begin¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    D( DA.LX_SYMREP, NODE, LX_
SYMREP );¶    D( DA.SM_EXP_TYPE, NODE, SM_EXP_TYPE );¶    D( DA.SM_DISCRETE_RANGE, NODE, SM_DISCRETE_RANGE );¶         r
eturn NODE;¶  end¬MAKE_STRING_LITERAL;¶   ¶  function¬MAKE_QUALIFIED_ALLOCATOR¶¬¬    ( AS_QUALIFIED :TREE := TREE_VOID;¶
¬¬    LX_SRCPOS :TREE := TREE_VOID;¶¬¬    SM_EXP_TYPE :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := M
AKE( DN_QUALIFIED_ALLOCATOR );¶  begin¶    D( DA.AS_QUALIFIED, NODE, AS_QUALIFIED );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPO
S );¶    D( DA.SM_EXP_TYPE, NODE, SM_EXP_TYPE );¶         return NODE;¶  end¬MAKE_QUALIFIED_ALLOCATOR;¶   ¶  function¬MA
KE_SUBTYPE_ALLOCATOR¶¬¬    ( AS_SUBTYPE_INDICATION :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID;¶¬¬    SM_EXP_
TYPE :TREE := TREE_VOID;¶¬¬    SM_DESIG_TYPE :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_S
UBTYPE_ALLOCATOR );¶  begin¶    D( DA.AS_SUBTYPE_INDICATION, NODE, AS_SUBTYPE_INDICATION );¶    D( DA.LX_SRCPOS, NODE, L
X_SRCPOS );¶    D( DA.SM_EXP_TYPE, NODE, SM_EXP_TYPE );¶    D( DA.SM_DESIG_TYPE, NODE, SM_DESIG_TYPE );¶         return 
NODE;¶  end¬MAKE_SUBTYPE_ALLOCATOR;¶   ¶  function¬MAKE_RANGE¶¬¬    ( AS_EXP1 :TREE := TREE_VOID;¶¬¬    AS_EXP2 :TREE :=
 TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID;¶¬¬    SM_TYPE_SPEC :TREE := TREE_VOID )¶¬¬    return TREE is¶         NO
DE :TREE := MAKE( DN_RANGE );¶  begin¶    D( DA.AS_EXP1, NODE, AS_EXP1 );¶    D( DA.AS_EXP2, NODE, AS_EXP2 );¶    D( DA.
LX_SRCPOS, NODE, LX_SRCPOS );¶    D( DA.SM_TYPE_SPEC, NODE, SM_TYPE_SPEC );¶         return NODE;¶  end¬MAKE_RANGE;¶   ¶
  function¬MAKE_RANGE_ATTRIBUTE¶¬¬    ( AS_NAME :TREE := TREE_VOID;¶¬¬    AS_USED_NAME_ID :TREE := TREE_VOID;¶¬¬    AS_E
XP :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID;¶¬¬    SM_TYPE_SPEC :TREE := TREE_VOID )¶¬¬    return TREE is¶
         NODE :TREE := MAKE( DN_RANGE_ATTRIBUTE );¶  begin¶    D( DA.AS_NAME, NODE, AS_NAME );¶    D( DA.AS_USED_NAME_ID
, NODE, AS_USED_NAME_ID );¶    D( DA.AS_EXP, NODE, AS_EXP );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    D( DA.SM_TYPE_S
PEC, NODE, SM_TYPE_SPEC );¶         return NODE;¶  end¬MAKE_RANGE_ATTRIBUTE;¶   ¶  function¬MAKE_DISCRETE_SUBTYPE¶¬¬    
( AS_SUBTYPE_INDICATION :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TRE
E := MAKE( DN_DISCRETE_SUBTYPE );¶  begin¶    D( DA.AS_SUBTYPE_INDICATION, NODE, AS_SUBTYPE_INDICATION );¶    D( DA.LX_S
RCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_DISCRETE_SUBTYPE;¶   ¶  function¬MAKE_FLOAT_CONSTRAINT¶¬¬    
( AS_EXP :TREE := TREE_VOID;¶¬¬    AS_RANGE :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID;¶¬¬    SM_TYPE_SPEC :
TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_FLOAT_CONSTRAINT );¶  begin¶    D( DA.AS_EXP, N
ODE, AS_EXP );¶    D( DA.AS_RANGE, NODE, AS_RANGE );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    D( DA.SM_TYPE_SPEC, NOD
E, SM_TYPE_SPEC );¶         return NODE;¶  end¬MAKE_FLOAT_CONSTRAINT;¶   ¶  function¬MAKE_FIXED_CONSTRAINT¶¬¬    ( AS_EX
P :TREE := TREE_VOID;¶¬¬    AS_RANGE :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID;¶¬¬    SM_TYPE_SPEC :TREE :=
 TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_FIXED_CONSTRAINT );¶  begin¶    D( DA.AS_EXP, NODE, AS
_EXP );¶    D( DA.AS_RANGE, NODE, AS_RANGE );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    D( DA.SM_TYPE_SPEC, NODE, SM_T
YPE_SPEC );¶         return NODE;¶  end¬MAKE_FIXED_CONSTRAINT;¶   ¶  function¬MAKE_INDEX_CONSTRAINT¶¬¬    ( AS_DISCRETE_
RANGE_S :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_IN
DEX_CONSTRAINT );¶  begin¶    D( DA.AS_DISCRETE_RANGE_S, NODE, AS_DISCRETE_RANGE_S );¶    D( DA.LX_SRCPOS, NODE, LX_SRCP
OS );¶         return NODE;¶  end¬MAKE_INDEX_CONSTRAINT;¶   ¶  function¬MAKE_DSCRMT_CONSTRAINT¶¬¬    ( AS_GENERAL_ASSOC_
S :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_DSCRMT_C
ONSTRAINT );¶  begin¶    D( DA.AS_GENERAL_ASSOC_S, NODE, AS_GENERAL_ASSOC_S );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶ 
        return NODE;¶  end¬MAKE_DSCRMT_CONSTRAINT;¶   ¶  function¬MAKE_CHOICE_EXP¶¬¬    ( AS_EXP :TREE := TREE_VOID;¶¬¬ 
   LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_CHOICE_EXP );¶  begin¶    D( DA.A
S_EXP, NODE, AS_EXP );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_CHOICE_EXP;¶   ¶  functi
on¬MAKE_CHOICE_RANGE¶¬¬    ( AS_DISCRETE_RANGE :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TRE
E is¶         NODE :TREE := MAKE( DN_CHOICE_RANGE );¶  begin¶    D( DA.AS_DISCRETE_RANGE, NODE, AS_DISCRETE_RANGE );¶   
 D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_CHOICE_RANGE;¶   ¶  function¬MAKE_CHOICE_OTHERS¶¬¬
    ( LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_CHOICE_OTHERS );¶  begin¶    D
( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_CHOICE_OTHERS;¶   ¶  function¬MAKE_PROCEDURE_SPEC¶¬¬
    ( AS_PARAM_S :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MA
KE( DN_PROCEDURE_SPEC );¶  begin¶    D( DA.AS_PARAM_S, NODE, AS_PARAM_S );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶     
    return NODE;¶  end¬MAKE_PROCEDURE_SPEC;¶   ¶  function¬MAKE_FUNCTION_SPEC¶¬¬    ( AS_PARAM_S :TREE := TREE_VOID;¶¬¬ 
   AS_NAME :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN
_FUNCTION_SPEC );¶  begin¶    D( DA.AS_PARAM_S, NODE, AS_PARAM_S );¶    D( DA.AS_NAME, NODE, AS_NAME );¶    D( DA.LX_SRC
POS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_FUNCTION_SPEC;¶   ¶  function¬MAKE_ENTRY¶¬¬    ( AS_PARAM_S :TR
EE := TREE_VOID;¶¬¬    AS_DISCRETE_RANGE :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶ 
        NODE :TREE := MAKE( DN_ENTRY );¶  begin¶    D( DA.AS_PARAM_S, NODE, AS_PARAM_S );¶    D( DA.AS_DISCRETE_RANGE, N
ODE, AS_DISCRETE_RANGE );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_ENTRY;¶   ¶  function
¬MAKE_package_SPEC¶¬¬    ( AS_DECL_S1 :TREE := TREE_VOID;¶¬¬    AS_DECL_S2 :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := 
TREE_VOID;¶¬¬    XD_body_IS_REQUIRED :BOOLEAN := FALSE )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_package_SP
EC );¶  begin¶    D( DA.AS_DECL_S1, NODE, AS_DECL_S1 );¶    D( DA.AS_DECL_S2, NODE, AS_DECL_S2 );¶    D( DA.LX_SRCPOS, N
ODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_package_SPEC;¶   ¶  function¬MAKE_RENAMES_UNIT¶¬¬    ( AS_NAME :TREE 
:= TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_RENAMES_UNIT );¶
  begin¶    D( DA.AS_NAME, NODE, AS_NAME );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_REN
AMES_UNIT;¶   ¶  function¬MAKE_INSTANTIATION¶¬¬    ( AS_NAME :TREE := TREE_VOID;¶¬¬    AS_GENERAL_ASSOC_S :TREE := TREE_
VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID;¶¬¬    SM_DECL_S :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE 
:= MAKE( DN_INSTANTIATION );¶  begin¶    D( DA.AS_NAME, NODE, AS_NAME );¶    D( DA.AS_GENERAL_ASSOC_S, NODE, AS_GENERAL_
ASSOC_S );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    D( DA.SM_DECL_S, NODE, SM_DECL_S );¶         return NODE;¶  end¬M
AKE_INSTANTIATION;¶   ¶  function¬MAKE_NAME_DEFAULT¶¬¬    ( AS_NAME :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VO
ID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_NAME_DEFAULT );¶  begin¶    D( DA.AS_NAME, NODE, AS_NAME );¶  
  D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_NAME_DEFAULT;¶   ¶  function¬MAKE_BOX_DEFAULT¶¬¬ 
   ( LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_BOX_DEFAULT );¶  begin¶    D( D
A.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_BOX_DEFAULT;¶   ¶  function¬MAKE_NO_DEFAULT¶¬¬    ( LX_
SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_NO_DEFAULT );¶  begin¶    D( DA.LX_SRCP
OS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_NO_DEFAULT;¶   ¶  function¬MAKE_BLOCK_body¶¬¬    ( AS_ITEM_S :TR
EE := TREE_VOID;¶¬¬    AS_STM_S :TREE := TREE_VOID;¶¬¬    AS_ALTERNATIVE_S :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := 
TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_BLOCK_body );¶  begin¶    D( DA.AS_ITEM_S, NODE, AS_ITE
M_S );¶    D( DA.AS_STM_S, NODE, AS_STM_S );¶    D( DA.AS_ALTERNATIVE_S, NODE, AS_ALTERNATIVE_S );¶    D( DA.LX_SRCPOS, 
NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_BLOCK_body;¶   ¶  function¬MAKE_STUB¶¬¬    ( LX_SRCPOS :TREE := TREE
_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_STUB );¶  begin¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶   
      return NODE;¶  end¬MAKE_STUB;¶   ¶  function¬MAKE_IMPLICIT_NOT_EQ¶¬¬    ( LX_SRCPOS :TREE := TREE_VOID;¶¬¬    SM_E
QUAL :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_IMPLICIT_NOT_EQ );¶  begin¶    D( DA.LX_S
RCPOS, NODE, LX_SRCPOS );¶    D( DA.SM_EQUAL, NODE, SM_EQUAL );¶         return NODE;¶  end¬MAKE_IMPLICIT_NOT_EQ;¶   ¶  
function¬MAKE_DERIVED_SUBPROG¶¬¬    ( LX_SRCPOS :TREE := TREE_VOID;¶¬¬    SM_DERIVABLE :TREE := TREE_VOID )¶¬¬    return
 TREE is¶         NODE :TREE := MAKE( DN_DERIVED_SUBPROG );¶  begin¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    D( DA.SM
_DERIVABLE, NODE, SM_DERIVABLE );¶         return NODE;¶  end¬MAKE_DERIVED_SUBPROG;¶   ¶  function¬MAKE_COND_CLAUSE¶¬¬  
  ( AS_EXP :TREE := TREE_VOID;¶¬¬    AS_STM_S :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE
 is¶         NODE :TREE := MAKE( DN_COND_CLAUSE );¶  begin¶    D( DA.AS_EXP, NODE, AS_EXP );¶    D( DA.AS_STM_S, NODE, A
S_STM_S );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_COND_CLAUSE;¶   ¶  function¬MAKE_SEL
ECT_ALTERNATIVE¶¬¬    ( AS_EXP :TREE := TREE_VOID;¶¬¬    AS_STM_S :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID
 )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_SELECT_ALTERNATIVE );¶  begin¶    D( DA.AS_EXP, NODE, AS_EXP );¶
    D( DA.AS_STM_S, NODE, AS_STM_S );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_SELECT_AL
TERNATIVE;¶   ¶  function¬MAKE_SELECT_ALT_PRAGMA¶¬¬    ( AS_PRAGMA :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOI
D )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_SELECT_ALT_PRAGMA );¶  begin¶    D( DA.AS_PRAGMA, NODE, AS_PRAG
MA );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_SELECT_ALT_PRAGMA;¶   ¶  function¬MAKE_IN
_OP¶¬¬    ( LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_IN_OP );¶  begin¶    D( 
DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_IN_OP;¶   ¶  function¬MAKE_NOT_IN¶¬¬    ( LX_SRCPOS :T
REE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_NOT_IN );¶  begin¶    D( DA.LX_SRCPOS, NODE, LX_
SRCPOS );¶         return NODE;¶  end¬MAKE_NOT_IN;¶   ¶  function¬MAKE_AND_THEN¶¬¬    ( LX_SRCPOS :TREE := TREE_VOID )¶¬
¬    return TREE is¶         NODE :TREE := MAKE( DN_AND_THEN );¶  begin¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶        
 return NODE;¶  end¬MAKE_AND_THEN;¶   ¶  function¬MAKE_OR_ELSE¶¬¬    ( LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE 
is¶         NODE :TREE := MAKE( DN_OR_ELSE );¶  begin¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  en
d¬MAKE_OR_ELSE;¶   ¶  function¬MAKE_FOR¶¬¬    ( AS_SOURCE_NAME :TREE := TREE_VOID;¶¬¬    AS_DISCRETE_RANGE :TREE := TREE
_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_FOR );¶  begin¶    D( D
A.AS_SOURCE_NAME, NODE, AS_SOURCE_NAME );¶    D( DA.AS_DISCRETE_RANGE, NODE, AS_DISCRETE_RANGE );¶    D( DA.LX_SRCPOS, N
ODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_FOR;¶   ¶  function¬MAKE_REVERSE¶¬¬    ( AS_SOURCE_NAME :TREE := TREE
_VOID;¶¬¬    AS_DISCRETE_RANGE :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NO
DE :TREE := MAKE( DN_REVERSE );¶  begin¶    D( DA.AS_SOURCE_NAME, NODE, AS_SOURCE_NAME );¶    D( DA.AS_DISCRETE_RANGE, N
ODE, AS_DISCRETE_RANGE );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_REVERSE;¶   ¶  functi
on¬MAKE_WHILE¶¬¬    ( AS_EXP :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE
 :TREE := MAKE( DN_WHILE );¶  begin¶    D( DA.AS_EXP, NODE, AS_EXP );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         r
eturn NODE;¶  end¬MAKE_WHILE;¶   ¶  function¬MAKE_ALTERNATIVE¶¬¬    ( AS_CHOICE_S :TREE := TREE_VOID;¶¬¬    AS_STM_S :TR
EE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_ALTERNATIVE )
;¶  begin¶    D( DA.AS_CHOICE_S, NODE, AS_CHOICE_S );¶    D( DA.AS_STM_S, NODE, AS_STM_S );¶    D( DA.LX_SRCPOS, NODE, L
X_SRCPOS );¶         return NODE;¶  end¬MAKE_ALTERNATIVE;¶   ¶  function¬MAKE_ALTERNATIVE_PRAGMA¶¬¬    ( AS_PRAGMA :TREE
 := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_ALTERNATIVE_PRA
GMA );¶  begin¶    D( DA.AS_PRAGMA, NODE, AS_PRAGMA );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  e
nd¬MAKE_ALTERNATIVE_PRAGMA;¶   ¶  function¬MAKE_COMP_REP¶¬¬    ( AS_NAME :TREE := TREE_VOID;¶¬¬    AS_EXP :TREE := TREE_
VOID;¶¬¬    AS_RANGE :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE :
= MAKE( DN_COMP_REP );¶  begin¶    D( DA.AS_NAME, NODE, AS_NAME );¶    D( DA.AS_EXP, NODE, AS_EXP );¶    D( DA.AS_RANGE,
 NODE, AS_RANGE );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_COMP_REP;¶   ¶  function¬MAK
E_COMP_REP_PRAGMA¶¬¬    ( AS_PRAGMA :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶      
   NODE :TREE := MAKE( DN_COMP_REP_PRAGMA );¶  begin¶    D( DA.AS_PRAGMA, NODE, AS_PRAGMA );¶    D( DA.LX_SRCPOS, NODE, 
LX_SRCPOS );¶         return NODE;¶  end¬MAKE_COMP_REP_PRAGMA;¶   ¶  function¬MAKE_CONTEXT_PRAGMA¶¬¬    ( AS_PRAGMA :TRE
E := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_CONTEXT_PRAGMA
 );¶  begin¶    D( DA.AS_PRAGMA, NODE, AS_PRAGMA );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬
MAKE_CONTEXT_PRAGMA;¶   ¶  function¬MAKE_WITH¶¬¬    ( AS_NAME_S :TREE := TREE_VOID;¶¬¬    AS_USE_PRAGMA_S :TREE := TREE_
VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_WITH );¶  begin¶    D( D
A.AS_NAME_S, NODE, AS_NAME_S );¶    D( DA.AS_USE_PRAGMA_S, NODE, AS_USE_PRAGMA_S );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS
 );¶         return NODE;¶  end¬MAKE_WITH;¶   ¶  function¬MAKE_VARIANT¶¬¬    ( AS_CHOICE_S :TREE := TREE_VOID;¶¬¬    AS_
COMP_LIST :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_
VARIANT );¶  begin¶    D( DA.AS_CHOICE_S, NODE, AS_CHOICE_S );¶    D( DA.AS_COMP_LIST, NODE, AS_COMP_LIST );¶    D( DA.L
X_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_VARIANT;¶   ¶  function¬MAKE_VARIANT_PRAGMA¶¬¬    ( AS_PRA
GMA :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_VARIAN
T_PRAGMA );¶  begin¶    D( DA.AS_PRAGMA, NODE, AS_PRAGMA );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE
;¶  end¬MAKE_VARIANT_PRAGMA;¶   ¶  function¬MAKE_ALIGNMENT¶¬¬    ( AS_PRAGMA_S :TREE := TREE_VOID;¶¬¬    AS_EXP :TREE :=
 TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_ALIGNMENT );¶  beg
in¶    D( DA.AS_PRAGMA_S, NODE, AS_PRAGMA_S );¶    D( DA.AS_EXP, NODE, AS_EXP );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );
¶         return NODE;¶  end¬MAKE_ALIGNMENT;¶   ¶  function¬MAKE_VARIANT_PART¶¬¬    ( AS_NAME :TREE := TREE_VOID;¶¬¬    
AS_VARIANT_S :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( 
DN_VARIANT_PART );¶  begin¶    D( DA.AS_NAME, NODE, AS_NAME );¶    D( DA.AS_VARIANT_S, NODE, AS_VARIANT_S );¶    D( DA.L
X_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_VARIANT_PART;¶   ¶  function¬MAKE_COMP_LIST¶¬¬    ( AS_DEC
L_S :TREE := TREE_VOID;¶¬¬    AS_VARIANT_PART :TREE := TREE_VOID;¶¬¬    AS_PRAGMA_S :TREE := TREE_VOID;¶¬¬    LX_SRCPOS 
:TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_COMP_LIST );¶  begin¶    D( DA.AS_DECL_S, NODE
, AS_DECL_S );¶    D( DA.AS_VARIANT_PART, NODE, AS_VARIANT_PART );¶    D( DA.AS_PRAGMA_S, NODE, AS_PRAGMA_S );¶    D( DA
.LX_SRCPOS, NODE, LX_SRCPOS );¶         return NODE;¶  end¬MAKE_COMP_LIST;¶   ¶  function¬MAKE_COMPILATION¶¬¬    ( AS_CO
MPLTN_UNIT_S :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( 
DN_COMPILATION );¶  begin¶    D( DA.AS_COMPLTN_UNIT_S, NODE, AS_COMPLTN_UNIT_S );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS )
;¶         return NODE;¶  end¬MAKE_COMPILATION;¶   ¶  function¬MAKE_COMPILATION_UNIT¶¬¬    ( AS_CONTEXT_ELEM_S :TREE := 
TREE_VOID;¶¬¬    AS_ALL_DECL :TREE := TREE_VOID;¶¬¬    AS_PRAGMA_S :TREE := TREE_VOID;¶¬¬    LX_SRCPOS :TREE := TREE_VOI
D;¶¬¬    XD_TIMESTAMP :INTEGER := 0;¶¬¬    LIST :SEQ_TYPE := (TREE_NIL,TREE_NIL );¶¬¬    XD_NBR_PAGES :INTEGER := 0;¶¬¬ 
   XD_LIB_NAME :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_COMPILATION_UNIT );¶  begin¶   
 D( DA.AS_CONTEXT_ELEM_S, NODE, AS_CONTEXT_ELEM_S );¶    D( DA.AS_ALL_DECL, NODE, AS_ALL_DECL );¶    D( DA.AS_PRAGMA_S, 
NODE, AS_PRAGMA_S );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶         DI (DA.XD_TIMESTAMP, NODE, XD_TIMESTAMP );¶       
  IDL_MAN.LIST(NODE, LIST );¶         DI (DA.XD_NBR_PAGES, NODE, XD_NBR_PAGES );¶    D( DA.XD_LIB_NAME, NODE, XD_LIB_NAM
E );¶         return NODE;¶  end¬MAKE_COMPILATION_UNIT;¶   ¶  function¬MAKE_INDEX¶¬¬    ( AS_NAME :TREE := TREE_VOID;¶¬¬
    LX_SRCPOS :TREE := TREE_VOID;¶¬¬    SM_TYPE_SPEC :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MA
KE( DN_INDEX );¶  begin¶    D( DA.AS_NAME, NODE, AS_NAME );¶    D( DA.LX_SRCPOS, NODE, LX_SRCPOS );¶    D( DA.SM_TYPE_SP
EC, NODE, SM_TYPE_SPEC );¶         return NODE;¶  end¬MAKE_INDEX;¶   ¶  function¬MAKE_TASK_SPEC¶¬¬    ( SM_DERIVED :TREE
 := TREE_VOID;¶¬¬    SM_IS_ANONYMOUS :BOOLEAN := FALSE;¶¬¬    SM_DECL_S :TREE := TREE_VOID;¶¬¬    SM_body :TREE := TREE_
VOID;¶¬¬    SM_ADDRESS :TREE := TREE_VOID;¶¬¬    SM_SIZE :TREE := TREE_VOID;¶¬¬    SM_STORAGE_SIZE :TREE := TREE_VOID;¶¬
¬    XD_SOURCE_NAME :TREE := TREE_VOID;¶¬¬    XD_STUB :TREE := TREE_VOID;¶¬¬    XD_body :TREE := TREE_VOID )¶¬¬    retur
n TREE is¶         NODE :TREE := MAKE( DN_TASK_SPEC );¶  begin¶    D( DA.SM_DERIVED, NODE, SM_DERIVED );¶    DB( DA.SM_I
S_ANONYMOUS, NODE, SM_IS_ANONYMOUS );¶    D( DA.SM_DECL_S, NODE, SM_DECL_S );¶    D( DA.SM_body, NODE, SM_body );¶    D(
 DA.SM_ADDRESS, NODE, SM_ADDRESS );¶    D( DA.SM_SIZE, NODE, SM_SIZE );¶    D( DA.SM_STORAGE_SIZE, NODE, SM_STORAGE_SIZE
 );¶    D( DA.XD_SOURCE_NAME, NODE, XD_SOURCE_NAME );¶    D( DA.XD_STUB, NODE, XD_STUB );¶    D( DA.XD_body, NODE, XD_bo
dy );¶         return NODE;¶  end¬MAKE_TASK_SPEC;¶   ¶  function¬MAKE_ENUMERATION¶¬¬    ( SM_DERIVED :TREE := TREE_VOID;
¶¬¬    SM_IS_ANONYMOUS :BOOLEAN := FALSE;¶¬¬    SM_BASE_TYPE :TREE := TREE_VOID;¶¬¬    SM_RANGE :TREE := TREE_VOID;¶¬¬  
  SM_LITERAL_S :TREE := TREE_VOID;¶¬¬    XD_SOURCE_NAME :TREE := TREE_VOID;¶¬¬    CD_IMPL_SIZE :INTEGER := 0 )¶¬¬    ret
urn TREE is¶         NODE :TREE := MAKE( DN_ENUMERATION );¶  begin¶    D( DA.SM_DERIVED, NODE, SM_DERIVED );¶    DB( DA.
SM_IS_ANONYMOUS, NODE, SM_IS_ANONYMOUS );¶    D( DA.SM_BASE_TYPE, NODE, SM_BASE_TYPE );¶    D( DA.SM_RANGE, NODE, SM_RAN
GE );¶    D( DA.SM_LITERAL_S, NODE, SM_LITERAL_S );¶    D( DA.XD_SOURCE_NAME, NODE, XD_SOURCE_NAME );¶         DI (DA.CD
_IMPL_SIZE, NODE, CD_IMPL_SIZE );¶         return NODE;¶  end¬MAKE_ENUMERATION;¶      --|-------------------------------
------------------------------------------------------------¶      --|¬FUNCTION MAKE_INTEGER¶  function¬MAKE_INTEGER ( S
M_DERIVED, SM_BASE_TYPE, SM_RANGE, XD_SOURCE_NAME :TREE := TREE_VOID;¶          ¬¬CD_IMPL_SIZE :INTEGER := 0; SM_IS_ANON
YMOUS :BOOLEAN := FALSE¶                ¬ ) return TREE is¶         NODE¬ :TREE := MAKE( DN_INTEGER  );¶  begin¶    D( D
A.SM_DERIVED, NODE, SM_DERIVED );¶    DB( DA.SM_IS_ANONYMOUS, NODE, SM_IS_ANONYMOUS );¶    D( DA.SM_BASE_TYPE, NODE, SM_
BASE_TYPE );¶    D( DA.SM_RANGE, NODE, SM_RANGE );¶    D( DA.XD_SOURCE_NAME, NODE, XD_SOURCE_NAME );¶         DI (DA.CD_
IMPL_SIZE, NODE, CD_IMPL_SIZE );¶         return NODE;¶  end;¶      --|-------------------------------------------------
------------------------------------------¶      --|¬FUNCTION MAKE_FLOAT¶  function¬MAKE_FLOAT¶¬¬    ( SM_DERIVED :TREE 
:= TREE_VOID;¶¬¬    SM_IS_ANONYMOUS :BOOLEAN := FALSE;¶¬¬    SM_BASE_TYPE :TREE := TREE_VOID;¶¬¬    SM_RANGE :TREE := TR
EE_VOID;¶¬¬    SM_ACCURACY :TREE := TREE_VOID;¶¬¬    XD_SOURCE_NAME :TREE := TREE_VOID;¶¬¬    CD_IMPL_SIZE :INTEGER := 0
 )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_FLOAT );¶  begin¶    D( DA.SM_DERIVED, NODE, SM_DERIVED );¶    D
B( DA.SM_IS_ANONYMOUS, NODE, SM_IS_ANONYMOUS );¶    D( DA.SM_BASE_TYPE, NODE, SM_BASE_TYPE );¶    D( DA.SM_RANGE, NODE, 
SM_RANGE );¶    D( DA.SM_ACCURACY, NODE, SM_ACCURACY );¶    D( DA.XD_SOURCE_NAME, NODE, XD_SOURCE_NAME );¶         DI (D
A.CD_IMPL_SIZE, NODE, CD_IMPL_SIZE );¶         return NODE;¶  end¬MAKE_FLOAT;¶   ¶  function¬MAKE_FIXED¶¬¬    ( SM_DERIV
ED :TREE := TREE_VOID;¶¬¬    SM_IS_ANONYMOUS :BOOLEAN := FALSE;¶¬¬    SM_BASE_TYPE :TREE := TREE_VOID;¶¬¬    SM_RANGE :T
REE := TREE_VOID;¶¬¬    SM_ACCURACY :TREE := TREE_VOID;¶¬¬    XD_SOURCE_NAME :TREE := TREE_VOID;¶¬¬    CD_IMPL_SIZE :INT
EGER := 0;¶¬¬    CD_IMPL_SMALL :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_FIXED );¶  begi
n¶    D( DA.SM_DERIVED, NODE, SM_DERIVED );¶    DB( DA.SM_IS_ANONYMOUS, NODE, SM_IS_ANONYMOUS );¶    D( DA.SM_BASE_TYPE,
 NODE, SM_BASE_TYPE );¶    D( DA.SM_RANGE, NODE, SM_RANGE );¶    D( DA.SM_ACCURACY, NODE, SM_ACCURACY );¶    D( DA.XD_SO
URCE_NAME, NODE, XD_SOURCE_NAME );¶         DI (DA.CD_IMPL_SIZE, NODE, CD_IMPL_SIZE );¶    D( DA.CD_IMPL_SMALL, NODE, CD
_IMPL_SMALL );¶         return NODE;¶  end¬MAKE_FIXED;¶   ¶  function¬MAKE_ARRAY¶¬¬    ( SM_DERIVED :TREE := TREE_VOID;¶
¬¬    SM_IS_ANONYMOUS :BOOLEAN := FALSE;¶¬¬    SM_BASE_TYPE :TREE := TREE_VOID;¶¬¬    SM_SIZE :TREE := TREE_VOID;¶¬¬    
SM_IS_LIMITED :BOOLEAN := FALSE;¶¬¬    SM_IS_PACKED :BOOLEAN := FALSE;¶¬¬    SM_INDEX_S :TREE := TREE_VOID;¶¬¬    SM_COM
P_TYPE :TREE := TREE_VOID;¶¬¬    XD_SOURCE_NAME :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( D
N_ARRAY );¶  begin¶    D( DA.SM_DERIVED, NODE, SM_DERIVED );¶    DB( DA.SM_IS_ANONYMOUS, NODE, SM_IS_ANONYMOUS );¶    D(
 DA.SM_BASE_TYPE, NODE, SM_BASE_TYPE );¶    D( DA.SM_SIZE, NODE, SM_SIZE );¶    DB( DA.SM_IS_LIMITED, NODE, SM_IS_LIMITE
D );¶    DB( DA.SM_IS_PACKED, NODE, SM_IS_PACKED );¶    D( DA.SM_INDEX_S, NODE, SM_INDEX_S );¶    D( DA.SM_COMP_TYPE, NO
DE, SM_COMP_TYPE );¶    D( DA.XD_SOURCE_NAME, NODE, XD_SOURCE_NAME );¶         return NODE;¶  end¬MAKE_ARRAY;¶   ¶  func
tion¬MAKE_RECORD¶¬¬    ( SM_DERIVED :TREE := TREE_VOID;¶¬¬    SM_IS_ANONYMOUS :BOOLEAN := FALSE;¶¬¬    SM_BASE_TYPE :TRE
E := TREE_VOID;¶¬¬    SM_SIZE :TREE := TREE_VOID;¶¬¬    SM_IS_LIMITED :BOOLEAN := FALSE;¶¬¬    SM_IS_PACKED :BOOLEAN := 
FALSE;¶¬¬    SM_DISCRIMINANT_S :TREE := TREE_VOID;¶¬¬    SM_COMP_LIST :TREE := TREE_VOID;¶¬¬    SM_REPRESENTATION :TREE 
:= TREE_VOID;¶¬¬    XD_SOURCE_NAME :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_RECORD );¶ 
 begin¶    D( DA.SM_DERIVED, NODE, SM_DERIVED );¶    DB( DA.SM_IS_ANONYMOUS, NODE, SM_IS_ANONYMOUS );¶    D( DA.SM_BASE_
TYPE, NODE, SM_BASE_TYPE );¶    D( DA.SM_SIZE, NODE, SM_SIZE );¶    DB( DA.SM_IS_LIMITED, NODE, SM_IS_LIMITED );¶    DB(
 DA.SM_IS_PACKED, NODE, SM_IS_PACKED );¶    D( DA.SM_DISCRIMINANT_S, NODE, SM_DISCRIMINANT_S );¶    D( DA.SM_COMP_LIST, 
NODE, SM_COMP_LIST );¶    D( DA.SM_REPRESENTATION, NODE, SM_REPRESENTATION );¶    D( DA.XD_SOURCE_NAME, NODE, XD_SOURCE_
NAME );¶         return NODE;¶  end¬MAKE_RECORD;¶   ¶  function¬MAKE_ACCESS¶¬¬    ( SM_DERIVED :TREE := TREE_VOID;¶¬¬   
 SM_IS_ANONYMOUS :BOOLEAN := FALSE;¶¬¬    SM_BASE_TYPE :TREE := TREE_VOID;¶¬¬    SM_SIZE :TREE := TREE_VOID;¶¬¬    SM_ST
ORAGE_SIZE :TREE := TREE_VOID;¶¬¬    SM_IS_CONTROLLED :BOOLEAN := FALSE;¶¬¬    SM_DESIG_TYPE :TREE := TREE_VOID;¶¬¬    S
M_MASTER :TREE := TREE_VOID;¶¬¬    XD_SOURCE_NAME :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE(
 DN_ACCESS );¶  begin¶    D( DA.SM_DERIVED, NODE, SM_DERIVED );¶    DB( DA.SM_IS_ANONYMOUS, NODE, SM_IS_ANONYMOUS );¶   
 D( DA.SM_BASE_TYPE, NODE, SM_BASE_TYPE );¶    D( DA.SM_SIZE, NODE, SM_SIZE );¶    D( DA.SM_STORAGE_SIZE, NODE, SM_STORA
GE_SIZE );¶    DB( DA.SM_IS_CONTROLLED, NODE, SM_IS_CONTROLLED );¶    D( DA.SM_DESIG_TYPE, NODE, SM_DESIG_TYPE );¶    D(
 DA.SM_MASTER, NODE, SM_MASTER );¶    D( DA.XD_SOURCE_NAME, NODE, XD_SOURCE_NAME );¶         return NODE;¶  end¬MAKE_ACC
ESS;¶   ¶  function¬MAKE_CONSTRAINED_ARRAY¶¬¬    ( SM_DERIVED :TREE := TREE_VOID;¶¬¬    SM_IS_ANONYMOUS :BOOLEAN := FALS
E;¶¬¬    SM_BASE_TYPE :TREE := TREE_VOID;¶¬¬    SM_DEPENDS_ON_DSCRMT :BOOLEAN := FALSE;¶¬¬    SM_INDEX_SUBTYPE_S :TREE :
= TREE_VOID;¶¬¬    XD_SOURCE_NAME :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_CONSTRAINED_
ARRAY );¶  begin¶    D( DA.SM_DERIVED, NODE, SM_DERIVED  );¶    DB( DA.SM_IS_ANONYMOUS, NODE, SM_IS_ANONYMOUS  );¶    D(
 DA.SM_BASE_TYPE, NODE, SM_BASE_TYPE  );¶    DB( DA.SM_DEPENDS_ON_DSCRMT, NODE, SM_DEPENDS_ON_DSCRMT  );¶    D( DA.SM_IN
DEX_SUBTYPE_S, NODE, SM_INDEX_SUBTYPE_S  );¶    D( DA.XD_SOURCE_NAME, NODE, XD_SOURCE_NAME  );¶    DB( DA.CD_COMPILED, N
ODE, FALSE  );¶         return NODE;¶  end¬MAKE_CONSTRAINED_ARRAY;¶   ¶  function¬MAKE_CONSTRAINED_RECORD¶¬¬    ( SM_DER
IVED :TREE := TREE_VOID;¶¬¬    SM_IS_ANONYMOUS :BOOLEAN := FALSE;¶¬¬    SM_BASE_TYPE :TREE := TREE_VOID;¶¬¬    SM_DEPEND
S_ON_DSCRMT :BOOLEAN := FALSE;¶¬¬    SM_NORMALIZED_DSCRMT_S :TREE := TREE_VOID;¶¬¬    XD_SOURCE_NAME :TREE := TREE_VOID 
)¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_CONSTRAINED_RECORD );¶  begin¶    D( DA.SM_DERIVED, NODE, SM_DERI
VED );¶    DB( DA.SM_IS_ANONYMOUS, NODE, SM_IS_ANONYMOUS );¶    D( DA.SM_BASE_TYPE, NODE, SM_BASE_TYPE );¶    DB( DA.SM_
DEPENDS_ON_DSCRMT, NODE, SM_DEPENDS_ON_DSCRMT );¶    D( DA.SM_NORMALIZED_DSCRMT_S, NODE, SM_NORMALIZED_DSCRMT_S );¶    D
( DA.XD_SOURCE_NAME, NODE, XD_SOURCE_NAME );¶         return NODE;¶  end¬MAKE_CONSTRAINED_RECORD;¶   ¶  function¬MAKE_CO
NSTRAINED_ACCESS¶¬¬    ( SM_DERIVED :TREE := TREE_VOID;¶¬¬    SM_IS_ANONYMOUS :BOOLEAN := FALSE;¶¬¬    SM_BASE_TYPE :TRE
E := TREE_VOID;¶¬¬    SM_DEPENDS_ON_DSCRMT :BOOLEAN := FALSE;¶¬¬    SM_DESIG_TYPE :TREE := TREE_VOID;¶¬¬    XD_SOURCE_NA
ME :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_CONSTRAINED_ACCESS );¶  begin¶    D( DA.SM_
DERIVED, NODE, SM_DERIVED );¶    DB( DA.SM_IS_ANONYMOUS, NODE, SM_IS_ANONYMOUS );¶    D( DA.SM_BASE_TYPE, NODE, SM_BASE_
TYPE );¶    DB( DA.SM_DEPENDS_ON_DSCRMT, NODE, SM_DEPENDS_ON_DSCRMT );¶    D( DA.SM_DESIG_TYPE, NODE, SM_DESIG_TYPE );¶ 
   D( DA.XD_SOURCE_NAME, NODE, XD_SOURCE_NAME );¶         return NODE;¶  end¬MAKE_CONSTRAINED_ACCESS;¶   ¶  function¬MAK
E_PRIVATE¶¬¬    ( SM_DERIVED :TREE := TREE_VOID;¶¬¬    SM_IS_ANONYMOUS :BOOLEAN := FALSE;¶¬¬    SM_DISCRIMINANT_S :TREE 
:= TREE_VOID;¶¬¬    SM_TYPE_SPEC :TREE := TREE_VOID;¶¬¬    XD_SOURCE_NAME :TREE := TREE_VOID )¶¬¬    return TREE is¶    
     NODE :TREE := MAKE( DN_PRIVATE );¶  begin¶    D( DA.SM_DERIVED, NODE, SM_DERIVED );¶    DB( DA.SM_IS_ANONYMOUS, NOD
E, SM_IS_ANONYMOUS );¶    D( DA.SM_DISCRIMINANT_S, NODE, SM_DISCRIMINANT_S );¶    D( DA.SM_TYPE_SPEC, NODE, SM_TYPE_SPEC
 );¶    D( DA.XD_SOURCE_NAME, NODE, XD_SOURCE_NAME );¶         return NODE;¶  end¬MAKE_PRIVATE;¶   ¶  function¬MAKE_L_PR
IVATE¶¬¬    ( SM_DERIVED :TREE := TREE_VOID;¶¬¬    SM_IS_ANONYMOUS :BOOLEAN := FALSE;¶¬¬    SM_DISCRIMINANT_S :TREE := T
REE_VOID;¶¬¬    SM_TYPE_SPEC :TREE := TREE_VOID;¶¬¬    XD_SOURCE_NAME :TREE := TREE_VOID )¶¬¬    return TREE is¶        
 NODE :TREE := MAKE( DN_L_PRIVATE );¶  begin¶    D( DA.SM_DERIVED, NODE, SM_DERIVED );¶    DB( DA.SM_IS_ANONYMOUS, NODE,
 SM_IS_ANONYMOUS );¶    D( DA.SM_DISCRIMINANT_S, NODE, SM_DISCRIMINANT_S );¶    D( DA.SM_TYPE_SPEC, NODE, SM_TYPE_SPEC )
;¶    D( DA.XD_SOURCE_NAME, NODE, XD_SOURCE_NAME );¶         return NODE;¶  end¬MAKE_L_PRIVATE;¶   ¶  function¬MAKE_INCO
MPLETE¶¬¬    ( SM_DISCRIMINANT_S :TREE := TREE_VOID;¶¬¬    XD_SOURCE_NAME :TREE := TREE_VOID;¶¬¬    XD_FULL_TYPE_SPEC :T
REE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_INCOMPLETE );¶  begin¶    D( DA.SM_DISCRIMINANT_
S, NODE, SM_DISCRIMINANT_S );¶    D( DA.XD_SOURCE_NAME, NODE, XD_SOURCE_NAME );¶    D( DA.XD_FULL_TYPE_SPEC, NODE, XD_FU
LL_TYPE_SPEC );¶         return NODE;¶  end¬MAKE_INCOMPLETE;¶   ¶  function¬MAKE_UNIVERSAL_INTEGER¶¬¬    ( XD_SOURCE_NAM
E :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_UNIVERSAL_INTEGER );¶  begin¶    D( DA.XD_SO
URCE_NAME, NODE, XD_SOURCE_NAME );¶         return NODE;¶  end¬MAKE_UNIVERSAL_INTEGER;¶   ¶  function¬MAKE_UNIVERSAL_FIX
ED¶¬¬    ( XD_SOURCE_NAME :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_UNIVERSAL_FIXED );¶ 
 begin¶    D( DA.XD_SOURCE_NAME, NODE, XD_SOURCE_NAME );¶         return NODE;¶  end¬MAKE_UNIVERSAL_FIXED;¶   ¶  functio
n¬MAKE_UNIVERSAL_REAL¶¬¬    ( XD_SOURCE_NAME :TREE := TREE_VOID )¶¬¬    return TREE is¶         NODE :TREE := MAKE( DN_U
NIVERSAL_REAL );¶  begin¶    D( DA.XD_SOURCE_NAME, NODE, XD_SOURCE_NAME );¶         return NODE;¶  end¬MAKE_UNIVERSAL_RE
AL;¶   ¶¶end¬¬MAKE_NOD;¶¬¬--------¶¶--¬1¬2¬3¬4¬5¬6¬7¬8¬9¬0¬1¬2¶---------------------------------------------------------
---------------------------------------------------------------¶
