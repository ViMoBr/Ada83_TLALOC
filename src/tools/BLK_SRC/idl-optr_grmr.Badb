SEPARATE( IDL )--|----------------------------------------------------------------------------------------------------
|КOPTR_GRMR--|--------------------------------------------------------------------------------------------------턕ROCE
DURE OPTR_GRMR ( NOM_TEXTE :STRING ) IS  GRAMMARК: TREE;  GR_RULE_S: SEQ_TYPE;     TYPE RTBL_TYPE촇S RECORD땝  RU
LEК: TREE;ККК--| ACCS  UNE RGLE땝  REPLACEMENT: TREE;ККК--| RGLE REMPLAANTE땝  USE_COUNT: INTEGER;КК--| NO
MBRE D'USAGES DE LA RGLE땝  IS_ONE_ALT: BOOLEAN;КК--| RGLE  UNE SEULE ALTERNATIVE땝촃ND RECORD;  RTBLК: ARRAY( 1 
.. 350) OF RTBL_TYPE;КК--| TABLE D'ACCS AUX RGLES ET INFORMATIONS  LAST_RULE_NBR: INTEGER:= 0;ККК--| NOMBRE DE
 RGLES    --|-----------------------------------------------------------------------------------------------  --|촒RO
CEDURE FIRST_PASS  PROCEDURE FIRST_PASS ISКККК--| REMPLACE LES RGLES MONO-ALTERNATIVE ET MONO-SYLLABES PAR LA RGLE 
VENTUELLE DE LA SYLLABE    RULE_S: SEQ_TYPE:= GR_RULE_S;    RULEК: TREE;          --|----------------------------
------------------------------------------------------------    --|촒ROCEDURE PROPAGATE_REPLACEMENT    PROCEDURE PROPA
GATE_REPLACEMENT ( I, LIM :INTEGER ) IS    BEGIN      IF LIM <= 0 THENКККК--| SI L'ON A CELA C'EST QUE L'ON A PLUS
 DE REMPLAANTES DE REMPLAANTE QUE DE RGLES !        ERROR( D( LX_SRCPOS, RTBL( I ).RULE ), "CIRCULAR REPLACEMENT" );К
--| DONC ON TOURNE EN ROND      ELSE        IF RTBL( I ).REPLACEMENT.TY = DN_RULE THEN          DECLARE            J
 : INTEGER := DI( XD_RULEINFO, RTBL( I ).REPLACEMENT );К--| NUMRO DE LA RGLE REMPLAANTE          BEGIN            I
F RTBL( J ).REPLACEMENT.TY = DN_RULE THENКК--| SI LA REMPLAANTE A AUSSI UNE REMPLAANTE              PROPAGATE_REPLAC
EMENT( J, LIM - 1 );КК--| ALLER CHERCHER PLUS LOIN (EN INDIQUANT LE NOMBRE DE FOIS MAX O L'ON PEUT FAIRE CELA)      
        RTBL( I ).REPLACEMENT := RTBL( J ).REPLACEMENT;КК--| METTRE LA REMPLAANTE DE LA REMPLAANTE COMME REMPLAANTE (!
)            END IF;          END;        END IF;      END IF;    END;        BEGIN    WHILE NOT IS_EMPTY( RULE_
S ) LOOPККК--| TANT QU'IL Y A DES RGLES      POP( RULE_S, RULE );КККК--| EN EXTRAIRE UNE      LAST_RULE_NBR :=
 LAST_RULE_NBR + 1;ККК--| UNE RGLE DE PLUS      DI( XD_RULEINFO, RULE, LAST_RULE_NBR );ККК--| STOCKER LE NUMRO DE
 RGLE                  DECLARE        ALTERNATIVE_S: SEQ_TYPE:=  LIST( RULE );        IS_ONE_ALTК: BOOLEAN:= IS_
EMPTY( TAIL( ALTERNATIVE_S ) );К--| INDIQUE SI NE CONTIENT QU'UNE ALTERNATIVE (QUEUE DE LA LISTE D'ALTERNATIVES VIDE)
      BEGIN        RTBL( LAST_RULE_NBR ) := (땝КRULEК=> RULE,КК--| STOCKER L'ACCS  CETTE RGLE DANS LA TABLE DES RG
LES땝КREPLACEMENT=> TREE_VOID,КК--| PAS DE REMPLAANTE땝КUSE_COUNTК=> 0,КК--| PAS D'USAGE땝КIS_ONE_ALT=> IS_ON
E_ALTКК--| INDIQUE SI NE CONTIENT QU'UNE ALTERNATIVE땝К);                    IF IS_ONE_ALT THENКККК--| ON NE CO
NSIDRE QUE LA CAS MONO ALTERNATIVE          DECLARE            SYLLABE_S: SEQ_TYPE:= LIST( HEAD( ALTERNATIVE_S ) );
--| LISTE DES SYLLABES DE L'UNIQUE ALTERNATIVE          BEGIN            IF NOT IS_EMPTY( SYLLABE_S )ККК--| S'IL Y
 A DES SYLLABES               AND THEN IS_EMPTY( TAIL( SYLLABE_S ) )КК--| ET S'IL N'Y EN A QU'UNE               AND
 THEN IS_EMPTY( LIST( D( XD_SEMANTICS, HEAD( ALTERNATIVE_S ) ) ) )К--| ET ELLE N'A PAS D'ACTION SMANTIQUE            T
HEN              DECLARE                SYLLABE: TREE:= HEAD( SYLLABE_S );              BEGIN                IF SY
LLABE.TY /= DN_TERMINAL THENККК--| LA SYLLABE EST TERMINALE                  DECLARE                    DEF_LIST : 
SEQ_TYPE:= LIST( D( XD_SYMREP, SYLLABE ) );К--| LISTE DES UTILISATIONS DU SYMBOLE DE SYLLABE                  BEGIN
                    WHILE NOT IS_EMPTY( DEF_LIST )КК--| TANT QU'IL Y A DES UTIISATIONS                          AND 
THEN HEAD( DEF_LIST ).TY /= DN_RULE LOOPК--| ET QUE CE N'EST PAS LA RGLE DE DFINITION                      DEF_LIST :
= TAIL( DEF_LIST );КК--| AVANCER SUR LA LISTE DES UTILISATIONS                    END LOOP;                    IF N
OT IS_EMPTY( DEF_LIST ) THENКК--| SI L'ON A TROUV UNE RGLE DE DFINITION                      RTBL( LAST_RULE_NBR ).R
EPLACEMENT := HEAD( DEF_LIST );К--| METTRE CETTE RGLE COMME REMPLAANTE DE LA RGLE MONO-ALTERNATIVE MONO-SYLLABE      
                D( XD_RULE, SYLLABE, HEAD( DEF_LIST ) );КК--| MENTIONNER AUSSI DANS LA SYLLABE                    ELS
E                      D( XD_RULE, SYLLABE, TREE_VOID );КК--| S'IL N'Y A PAS DE RGLE DE DFINITION, METTRE UN ACCS VI
DE                    END IF;                  END;                END IF;              END;            END IF;   
       END;        END IF;      END;    END LOOP;             FOR I IN 1 .. LAST_RULE_NBR LOOPККК--| BALAYER TO
UTES LES RGLES      PROPAGATE_REPLACEMENT( I, LAST_RULE_NBR );ККК--| POUR PRENDRE LES REMPLAANTES DE REMPLAANTES   
 END LOOP;  END FIRST_PASS;  --|--------------------------------------------------------------------------------------
---------  --|촒ROCEDURE SECOND_PASS  PROCEDURE SECOND_PASS ISКККК--| CHANGE LA DFINITION D'UNE SYLLABE SI CELLE-C
I EST REMPLACE  BEGIN    FOR I IN 1 .. LAST_RULE_NBR LOOPККК--| PASSER EN REVUE TOUTES LES RGLES      DECLARE   
     RTBL_I: RTBL_TYPE RENAMES RTBL( I );      BEGIN        IF RTBL_I.REPLACEMENT.TY /= DN_RULE THENККК--| LA RGLE
 N'A PAS DE REMPLAANTE (PAS TRAITE  LA PASSE 1)          DECLARE            ALTERNATIVE_S: SEQ_TYPE:= LIST( RTBL_I.R
ULE );К--| PRENDRE SA LISTE D'ALTERNATIVES            ALTERNATIVE: TREE;            SYLLABE_S: SEQ_TYPE;         
   SYLLABE: TREE;          BEGIN            WHILE NOT IS_EMPTY( ALTERNATIVE_S ) LOOPКК--| S'IL Y A DES ALTERNATIVE
S              POP( ALTERNATIVE_S, ALTERNATIVE );ККК--| EXTRAIRE LA LISTE DE SES SYLLABES              SYLLABE_S :=
 LIST( ALTERNATIVE );                                   WHILE NOT IS_EMPTY( SYLLABE_S ) LOOPКК--| TANT QU'IL Y A DE
S SYLLABES                POP( SYLLABE_S, SYLLABE );ККК--| EN EXTRAIRE UNE                IF SYLLABE.TY = DN_NONTER
MINAL THENКК--| SI C'EST UNE NON TERMINALE                  DECLARE                    RULE: TREE:= TREE_VOID;  
                BEGIN                    DECLARE                      DEFLIST : SEQ_TYPE  := LIST( D( XD_SYMREP, SYLLA
BE ) );К--| PRENDRE LA LISTE DES UTILISATIONS DE SON SYMBOLE                    BEGIN                      WHILE NOT
 IS_EMPTY( DEFLIST )КК--| TANT QU'IL Y A DES UTILISATIONS                        AND THEN HEAD( DEFLIST).TY /= DN_RU
LE LOOPКК--| ET QUE CE N'EST PAS UNE RGLE DE DFINITION                        DEFLIST := TAIL( DEFLIST );КК--| AVA
NCER SUR LA LISTE DES UTILISATIONS                      END LOOP;                                                    
   IF NOT IS_EMPTY( DEFLIST ) THENКК--| SI L'ON A TROUV UNE RGLE DE DFINITION                        RULE := HEAD( D
EFLIST );ККК--| PRENDRE CETTE RGLE DE DFINITION                      END IF;                    END;              
      D( XD_RULE, SYLLABE, RULE );ККК--| MENTIONNER LA RGLE (OU LE VIDE) DE DFINITION DE LA SYLLABE                 
   IF RULE.TY /= DN_VOID THENККК--| S'IL Y A EFFECTIVEMENT UNE RGLE DE DFINITION                      DECLARE      
                  J      : INTEGER:= DI( XD_RULEINFO, RULE );К--| PRENDRE SON NUMRO                        RTBL_J : 
RTBL_TYPE촔ENAMES RTBL( J );                      BEGIN                        IF RTBL_J.REPLACEMENT.TY /= DN_VOID THE
NКК--| SI LA RGLE DE DFINITION A UNE REMPLAANTE                          D( XD_SYMREP, SYLLABE, D( XD_NAME, RTBL_J.RE
PLACEMENT ) );К--| METTRE LE SYMBOLE DE CETTE REMPLAANTE COMME SYMBOLE DE LA SYLLABE                          D( XD_RU
LE, SYLLABE, RTBL_J.REPLACEMENT );КК--| METTRE LA RGLE REMPLAANTE COMME DFINITION DE LA SYLLABE                      
    DECLARE                            K : INTEGER := DI( XD_RULEINFO, RTBL_J.REPLACEMENT );                          
BEGIN                            RTBL( K ).USE_COUNT := RTBL( K ).USE_COUNT + 1;К--| INDIQUER QUE LA REMPLAANTE EST U
TILISE UNE FOIS DE PLUS                          END;                        ELSE                          RTBL_J.USE
_COUNT := RTBL_J.USE_COUNT + 1;                        END IF;                      END;                    END IF; 
                 END;                END IF;              END LOOP;                                 END LOOP;      
    END;        END IF;      END;    END LOOP;  END SECOND_PASS;  --|----------------------------------------------
-------------------------------------------------  --|КPROCEDURE THIRD_PASS  PROCEDURE THIRD_PASS IS             --
|---------------------------------------------------------------------------------------------    --|КPROCEDURE REPLAC
E_ALTS    PROCEDURE REPLACE_ALTS ( ALTERNATIVE_S :IN OUT SEQ_TYPE ) IS      ALTERNATIVEК: TREE;      SYLLABE_SК: SE
Q_TYPE;      SYLLABEК: TREE;      RULEК: TREE;               --|--------------------------------------------------
-----------------------------------------      --|КFUNCTION CATENATE      FUNCTION CATENATE ( A,B: SEQ_TYPE) RETURN S
EQ_TYPE IS      BEGIN        IF IS_EMPTY( B ) THEN          RETURN A;        ELSIF IS_EMPTY( A ) THEN          RETU
RN B;        ELSE          RETURN INSERT( CATENATE( TAIL( A ), B ), HEAD( A ) );        END IF;    END CATENATE;   
        BEGIN    IF IS_EMPTY ( ALTERNATIVE_S ) THEN      RETURN;    END IF;    ALTERNATIVE := HEAD ( ALTERNATIVE_S 
);КК--| EXTRAIRE UNE ALTERNATIVE    SYLLABE_S := LIST ( ALTERNATIVE);ККК--| EXTRAIRE LA ISTE DE SES SYLLABES    
IF NOT IS_EMPTY ( SYLLABE_S )ККК--| S'IL Y A DES SYLLABES       AND THEN IS_EMPTY( TAIL( SYLLABE_S ) )КК--| ET UN
E SEULE       AND THEN IS_EMPTY( LIST( D( XD_SEMANTICS, ALTERNATIVE ) ) )К--| ET SANS ACTION SMANTIQUE    THEN     
 SYLLABE := HEAD( SYLLABE_S);      IF SYLLABE.TY = DN_NONTERMINAL THEN        RULE := D( XD_RULE, SYLLABE);        IF
 RULE /= TREE_VOID THEN                                        -- IT IS DEFINED (ELSE ERR IN INITGRMR)                
                        --@       PUT("CHECKING: "); PUT_LINE(PRINTNAME(D ( XD_NAME,RULE)));          DECLARE         
   RTBL_I: RTBL_TYPE RENAMES RTBL( DI( XD_RULEINFO, RULE ) );          BEGIN            IF RTBL_I.USE_COUNT = 1 THEN
                                                        -- IT IS USED ONCE              RTBL_I.REPLACEMENT := TREE_FALS
E;                                                        -- MARK REPLACED              ALTERNATIVE_S := CATENATE( LIS
T( RTBL_I.RULE ), TAIL( ALTERNATIVE_S ) );              REPLACE_ALTS( ALTERNATIVE_S);              RETURN;           
 END IF;          END;        END IF;      END IF;    END IF;                -- DID NOT REPLACE; CHECK TAIL    DEC
LARE      ALTERNATIVE_S_TAIL: SEQ_TYPE := TAIL( ALTERNATIVE_S );      NEW_ALTERNATIVE_S_TAIL: SEQ_TYPE:= ALTERNATI
VE_S_TAIL;    BEGIN      REPLACE_ALTS( NEW_ALTERNATIVE_S_TAIL );      IF ALTERNATIVE_S_TAIL = NEW_ALTERNATIVE_S_TAIL 
THEN        RETURN;      END IF;      ALTERNATIVE_S := INSERT( NEW_ALTERNATIVE_S_TAIL, HEAD( ALTERNATIVE_S ) );    E
ND;  END REPLACE_ALTS;              BEGIN    FOR I IN 1 .. LAST_RULE_NBR LOOPККК--| POUR TOUTES LES RGLES     
 DECLARE        RTBL_IК: RTBL_TYPE RENAMES RTBL( I );        ALTERNATIVE_S: SEQ_TYPE;      BEGIN        IF RTBL_I.
REPLACEMENT.TY /= DN_RULE THENККК--| SI LA RGLE N'A PAS DE REMPLAANTE          ALTERNATIVE_S := LIST( RTBL_I.RULE );
ККК--| PRENDRE SA LISTE D'ALTERNATIVES          REPLACE_ALTS( ALTERNATIVE_S );ККК--| MODIFIER CETTE LISTE D'ALTER
NATIVES          LIST( RTBL_I.RULE, ALTERNATIVE_S );ККК--| REPLACER LA LISTE MODIFIE        END IF;      END;    
END LOOP;  END THIRD_PASS;  --|---------------------------------------------------------------------------------------
--------  --|КPROCEDURE REWRITE  PROCEDURE REWRITE IS    NEW_RULE_COUNTК: INTEGER:= 0;    ONE_USE_COUNTК: INTEGE
R:= 0;    RULE_SК: SEQ_TYPE:= (TREE_NIL,TREE_NIL);  BEGIN    FOR I IN 1 .. LAST_RULE_NBR LOOP      DECLARE      
  RTBL_I : RTBL_TYPE RENAMES RTBL( I );      BEGIN        IF RTBL_I.REPLACEMENT = TREE_VOID THEN          NEW_RULE_CO
UNT := NEW_RULE_COUNT + 1;          RULE_S := APPEND( RULE_S, RTBL_I.RULE );          IF RTBL_I.USE_COUNT = 1 THEN   
         ONE_USE_COUNT := ONE_USE_COUNT + 1;          END IF;        END IF;      END;    END LOOP;    LIST( GRAMMA
R, RULE_S );ККК--| REMPLACE LA LISTE DE REGLES    PUT ( "RULES:" );    INT_IO.PUT( LAST_RULE_NBR );    INT_IO.PUT
( NEW_RULE_COUNT );    NEW_LINE;    INT_IO.PUT( ONE_USE_COUNT, 1 );    PUT_LINE  ( " RULES WITH ONE USE." );  END RE
WRITE;      턆EGIN  PUT_LINE ( "OPTR_GRMR" );  DECLARE    USER_ROOT: TREE;  BEGIN    OPEN_IDL_TREE_FILE( NOM_TEX
TE & ".lar" );    USER_ROOT := D( XD_USER_ROOT, TREE_ROOT );    GRAMMAR   := D( XD_GRAMMAR, USER_ROOT );  END;  GR_R
ULE_S := LIST( GRAMMAR );ККК--| LA LISTE DES RGLES DE GRAMMAIRE  PUT_LINE ( "FIRST PASS." );  FIRST_PASS;  PUT_LI
NE ( "SECOND PASS." );  SECOND_PASS;  PUT_LINE ( "THIRD PASS." );  THIRD_PASS;  PUT_LINE ( "REWRITE." );  REWRITE;
  CLOSE_IDL_TREE_FILE;--|---------------------------------------------------------------------------------------------
-----턉ND OPTR_GRMR;
