separate (IDL.SEM_PHASE)--|--------------------------------------------------------------------------------------------
----|     AGGRESO--|----------------------------------------------------------------------------------------------턯ac
kage body AGGRESO is  use EXP_TYPE, EXPRESO;  use VIS_UTIL;  use DEF_UTIL;  use REQ_UTIL;떰  type ASSOC_CURSOR_TYPE 
is record    ASSOC_LIST  : SEQ_TYPE;    ASSOC       : TREE;    EXP         : TREE;    CHOICE_LIST : SEQ_TYPE;    CH
OICE      : TREE;    COUNT       : Natural;    FIRST_COUNT : Positive;  end record;떰  procedure INIT_ASSOC_CURSOR (A
SSOC_CURSOR : out ASSOC_CURSOR_TYPE; ASSOC_LIST : SEQ_TYPE);  procedure ADVANCE_ASSOC_CURSOR (ASSOC_CURSOR : in out ASS
OC_CURSOR_TYPE);  function VALUE_IS_IN_CHOICE_S (VALUE : TREE; CHOICE_S : TREE) return Boolean;  procedure RESOLVE_REC
ORD_AGGREGATE (EXP : TREE; TYPE_STRUCT : TREE);  procedure RESOLVE_ERRONEOUS_AGGREGATE (EXP : TREE);  procedure RESOLV
E_ARRAY_SUBAGGREGATE (EXP : TREE; COMP_TYPE : TREE; INDEX_LIST : SEQ_TYPE; SCALAR_LIST : in out SEQ_TYPE; NAMED_OTHERS_O
K : Boolean := False);  procedure RESOLVE_STRING_SUBAGGREGATE (EXP : TREE; COMP_TYPE : TREE; INDEX : TREE; SCALAR_LIST 
: in out SEQ_TYPE);  procedure MAKE_NORMALIZED_LIST (AGGREGATE_ARRAY : in out AGGREGATE_ARRAY_TYPE; NORMALIZED_LIST : o
ut SEQ_TYPE);떰        -- $$$$ SHOULDN'T BE HERE  function GET_SUBTYPE_OF_ID (ID : TREE) return TREE is               
 -- GETS SUBTYPE CORRESPONDING TO COMPONENT ID    RESULT : TREE := D (SM_OBJ_TYPE, ID);  begin    if RESULT.TY in DN_
PRIVATE .. DN_L_PRIVATE then      RESULT := D (SM_TYPE_SPEC, RESULT);    elsif RESULT.TY = DN_INCOMPLETE and then D (X
D_FULL_TYPE_SPEC, RESULT) /= TREE_VOID then      RESULT := D (XD_FULL_TYPE_SPEC, RESULT);    end if;    return RESULT
;  end GET_SUBTYPE_OF_ID;--|------------------------------------------------------------------------------------------
-------      --|  procedure INIT_ASSOC_CURSOR (ASSOC_CURSOR : out ASSOC_CURSOR_TYPE; ASSOC_LIST : SEQ_TYPE) is       
         -- INITIALIZE CUMULATIVE FIELDS OF ASSOC_CURSOR RECORD  begin    ASSOC_CURSOR.ASSOC_LIST  := ASSOC_LIST;    
ASSOC_CURSOR.CHOICE_LIST := (TREE_NIL, TREE_NIL);    ASSOC_CURSOR.COUNT       := 0;  end INIT_ASSOC_CURSOR;떰  procedu
re ADVANCE_ASSOC_CURSOR (ASSOC_CURSOR : in out ASSOC_CURSOR_TYPE) is                -- ADVANCE ASSOC_CURSOR TO NEXT CHO
ICE  begin떰                -- IF THERE ARE REMAINING CHOICES IN CURRENT CHOICE LIST    if not IS_EMPTY (ASSOC_CURSOR.
CHOICE_LIST) then떰                        -- STEP TO THE NEXT ONE      POP (ASSOC_CURSOR.CHOICE_LIST, ASSOC_CURSOR.CHO
ICE);      ASSOC_CURSOR.COUNT := ASSOC_CURSOR.COUNT + 1;떰                        -- ELSE IF THERE ARE REMAINING ASSOCI
ATIONS    elsif not IS_EMPTY (ASSOC_CURSOR.ASSOC_LIST) then떰                        -- STEP TO THE NEXT ASSOCIATION  
    POP (ASSOC_CURSOR.ASSOC_LIST, ASSOC_CURSOR.ASSOC);      ASSOC_CURSOR.COUNT       := ASSOC_CURSOR.COUNT + 1;      A
SSOC_CURSOR.FIRST_COUNT := ASSOC_CURSOR.COUNT;떰                        -- IF IT IS A NAMED ASSOCIATION      if ASSOC_C
URSOR.ASSOC.TY = DN_NAMED then떰                                -- SAVE THE EXPRESSION        ASSOC_CURSOR.EXP := D (AS
_EXP, ASSOC_CURSOR.ASSOC);떰                                -- GET THE LIST OF CHOICES        ASSOC_CURSOR.CHOICE_LIST 
:= LIST (D (AS_CHOICE_S, ASSOC_CURSOR.ASSOC));떰                                -- STEP TO THE FIRST CHOICE        POP 
(ASSOC_CURSOR.CHOICE_LIST, ASSOC_CURSOR.CHOICE);떰                                -- ELSE -- SINCE IT IS NOT A NAMED ASS
OCIATION      else떰                                -- SAVE THE EXPRESSION        ASSOC_CURSOR.EXP := ASSOC_CURSOR.ASS
OC;떰                                -- SET CHOICE TO VOID        ASSOC_CURSOR.CHOICE := TREE_VOID;떰                  
              -- ELSE -- SINCE THERE ARE NO MORE ASSOCIATIONS      end if;    else떰                        -- SET THE
 .ASSOC FIELD TO VOID TO INDICATE TERMINATION      ASSOC_CURSOR.ASSOC := TREE_VOID;    end if;  end ADVANCE_ASSOC_CUR
SOR;      --||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||      --|  fu
nction COUNT_AGGREGATE_CHOICES (ASSOC_S : TREE) return Natural is                -- COUNT THE NUMBER OF DISTINCT CHOICE
S IN A LIST OF ASSOCIATIONS                -- ... (EITHER IN A DISCRIMINANT CONSTRAINT OR AN AGGREGATE)떰    ASSOC_CURS
OR : ASSOC_CURSOR_TYPE;  begin떰                -- STEP THROUGH CHOICES    INIT_ASSOC_CURSOR (ASSOC_CURSOR, LIST (ASSO
C_S));    loop      ADVANCE_ASSOC_CURSOR (ASSOC_CURSOR);      exit when ASSOC_CURSOR.ASSOC = TREE_VOID;    end loop;
떰                -- RETURN THE COUNT FROM THE CURSOR    return ASSOC_CURSOR.COUNT;  end COUNT_AGGREGATE_CHOICES;    
  --||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||      --|  procedure S
PREAD_ASSOC_S (ASSOC_S : TREE; AGGREGATE_ARRAY : in out AGGREGATE_ARRAY_TYPE) is                -- SPREAD ELEMENTS OF A
N ASSOC_S FOR AN AGGREGATE INTO                -- ... AN AGGREGATE ARRAY (WHICH IS KNOWN TO BE OF CORRECT SIZE).떰    A
SSOC_CURSOR : ASSOC_CURSOR_TYPE;  begin떰                -- FOR EACH ARRAY ELEMENT AND CORRESPONDING CHOICE    INIT_AS
SOC_CURSOR (ASSOC_CURSOR, LIST (ASSOC_S));    for I in AGGREGATE_ARRAY'RANGE loop      ADVANCE_ASSOC_CURSOR (ASSOC_CUR
SOR);떰                        -- FILL IN FIELDS OF AGGREGATE_ARRAY      AGGREGATE_ARRAY (I).FIRST    := ASSOC_CURSOR.F
IRST_COUNT;      AGGREGATE_ARRAY (I).CHOICE   := ASSOC_CURSOR.CHOICE;      AGGREGATE_ARRAY (I).SEEN     := False;    
  AGGREGATE_ARRAY (I).RESOLVED := False;      AGGREGATE_ARRAY (I).ID       := TREE_VOID;떰                        -- FI
LL IN EXP AND EVALUATE TYPES FOR FIRST CHOICE OF ASSOC      if I = ASSOC_CURSOR.FIRST_COUNT then        AGGREGATE_ARRA
Y (I).ASSOC := ASSOC_CURSOR.ASSOC;        AGGREGATE_ARRAY (I).EXP   := ASSOC_CURSOR.EXP;        EVAL_EXP_TYPES (AGGREG
ATE_ARRAY (I).EXP, AGGREGATE_ARRAY (I).TYPESET);      end if;    end loop;떰  end SPREAD_ASSOC_S;      --||||||||||||
||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||      --|  procedure WALK_RECORD_DECL_
S (EXP : TREE; DECL_S : TREE; AGGREGATE_ARRAY : in out AGGREGATE_ARRAY_TYPE; NORMALIZED_LIST : in out SEQ_TYPE; LAST_POS
ITIONAL : in out Natural) is                -- WALK ONE SEQUENCE OF COMPONENT DECLARATIONS FOR A RECORD               
 -- (THERE IS ONE SUCH FOR DISCRIMINANTS AND ONE FOR COMP_LIST)떰    PARAM_CURSOR : PARAM_CURSOR_TYPE;    NAMED_SUB    
: Natural;    CHOICE       : TREE;  begin떰                -- FOR EACH COMPONENT DECLARED IN THE DECL_S    INIT_PARAM
_CURSOR (PARAM_CURSOR, LIST (DECL_S));    loop      ADVANCE_PARAM_CURSOR (PARAM_CURSOR);      exit when PARAM_CURSOR.
ID = TREE_VOID;떰                        -- IF IT MATCHES A POSITIONAL PARAMETER      if LAST_POSITIONAL < AGGREGATE_AR
RAY'LAST and then AGGREGATE_ARRAY (LAST_POSITIONAL + 1).CHOICE = TREE_VOID then떰                                -- MARK
 POSITIONAL PARAMETER SEEN        LAST_POSITIONAL                            := LAST_POSITIONAL + 1;        AGGREGATE_
ARRAY (LAST_POSITIONAL).SEEN     := True;        AGGREGATE_ARRAY (LAST_POSITIONAL).RESOLVED := True;        AGGREGATE_
ARRAY (LAST_POSITIONAL).ID       := PARAM_CURSOR.ID;떰                                -- CHECK TYPE AND RESOLVE EXPRESSI
ON        REQUIRE_TYPE (GET_BASE_TYPE (PARAM_CURSOR.ID), AGGREGATE_ARRAY (LAST_POSITIONAL).EXP, AGGREGATE_ARRAY (LAST_P
OSITIONAL).TYPESET);        AGGREGATE_ARRAY (LAST_POSITIONAL).EXP := RESOLVE_EXP_OR_AGGREGATE (AGGREGATE_ARRAY (LAST_PO
SITIONAL).EXP, GET_SUBTYPE_OF_ID (PARAM_CURSOR.ID), NAMED_OTHERS_OK => True);떰                                -- ADD EX
PRESSION TO NORMALIZED LIST        NORMALIZED_LIST := APPEND (NORMALIZED_LIST, AGGREGATE_ARRAY (LAST_POSITIONAL).EXP);
                                -- ELSE -- SINCE NO MORE POSITIONAL PARAMETERS      else떰                            
    -- SEARCH FOR MATCHING NAME        NAMED_SUB := LAST_POSITIONAL;        loop          NAMED_SUB := NAMED_SUB + 1;
          exit when NAMED_SUB > AGGREGATE_ARRAY'LAST;          CHOICE := AGGREGATE_ARRAY (NAMED_SUB).CHOICE;         
 exit when CHOICE.TY = DN_CHOICE_OTHERS;          exit when not AGGREGATE_ARRAY (NAMED_SUB).SEEN and then CHOICE.TY = D
N_CHOICE_EXP and then D (AS_EXP, CHOICE).TY in CLASS_DESIGNATOR and then D (LX_SYMREP, D (AS_EXP, CHOICE)) = D (LX_SYMRE
P, PARAM_CURSOR.ID);        end loop;떰                                -- IF MATCH WAS FOUND        if NAMED_SUB <= AG
GREGATE_ARRAY'LAST then떰                                        -- MARK NAMED PARAMETER SEEN          AGGREGATE_ARRAY 
(NAMED_SUB).SEEN := True;          AGGREGATE_ARRAY (NAMED_SUB).ID   := PARAM_CURSOR.ID;떰                              
          -- REPLACE CHOICE_EXP EXPRESSION WITH USED_NAME_ID          if AGGREGATE_ARRAY (NAMED_SUB).CHOICE.TY = DN_CHO
ICE_EXP then            D (AS_EXP, AGGREGATE_ARRAY (NAMED_SUB).CHOICE, MAKE_USED_NAME_ID_FROM_OBJECT (D (AS_EXP, AGGREG
ATE_ARRAY (NAMED_SUB).CHOICE)));            D (SM_DEFN, D (AS_EXP, AGGREGATE_ARRAY (NAMED_SUB).CHOICE), PARAM_CURSOR.ID
);          end if;떰                                        -- CHECK TYPE (FOR FIRST CHOICE OF AN ASSOCIATION)       
                                 -- ... (NOTE. GIVES ERROR IF CONFLICTING TYPES IN ASSOC)          NAMED_SUB := AGGREGA
TE_ARRAY (NAMED_SUB).FIRST;          REQUIRE_TYPE (GET_BASE_TYPE (PARAM_CURSOR.ID), AGGREGATE_ARRAY (NAMED_SUB).EXP, AG
GREGATE_ARRAY (NAMED_SUB).TYPESET);떰                                        -- RESOLVE, IF THIS EXP NOT ALREADY RESOLVE
D          if not AGGREGATE_ARRAY (NAMED_SUB).RESOLVED then            AGGREGATE_ARRAY (NAMED_SUB).EXP      := RESOLVE
_EXP_OR_AGGREGATE (AGGREGATE_ARRAY (NAMED_SUB).EXP, GET_SUBTYPE_OF_ID (PARAM_CURSOR.ID), NAMED_OTHERS_OK => True);     
       AGGREGATE_ARRAY (NAMED_SUB).RESOLVED := True;          end if;떰                                        -- ADD E
XPRESSION TO NORMALIZED LIST          NORMALIZED_LIST := APPEND (NORMALIZED_LIST, AGGREGATE_ARRAY (NAMED_SUB).EXP);떰  
                                      -- ELSE -- SINCE NO MATCH WAS FOUND        else떰                                
        -- INDICATE ERROR          ERROR (D (LX_SRCPOS, EXP), "NO VALUE FOR COMPONENT - " & PRINT_NAME (D (LX_SYMREP, P
ARAM_CURSOR.ID)));        end if;      end if;    end loop;  end WALK_RECORD_DECL_S;      --|||||||||||||||||||||||
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||      --|  procedure RESOLVE_RECORD_ASSOC_S (ASSO
C_S : TREE; AGGREGATE_ARRAY : in out AGGREGATE_ARRAY_TYPE) is                -- RESOLVE ELEMENTS OF AN ASSOC_S FOR AN A
GGREGATE                -- ... (INDIVIDUAL EXPRESSIONS HAVE BEEN RESOLVED)떰    NEW_ASSOC      : TREE;    NEW_ASSOC_LI
ST : SEQ_TYPE := (TREE_NIL, TREE_NIL);  begin떰                -- FOR EACH ARRAY ELEMENT AND CORRESPONDING CHOICE    f
or I in AGGREGATE_ARRAY'RANGE loop떰                        -- IF ELEMENT IS FIRST CHOICE OF AN ASSOCIATION      if I =
 AGGREGATE_ARRAY (I).FIRST then떰                                -- MAKE SURE THAT EXPRESSION HAS BEEN RESOLVED        
if not AGGREGATE_ARRAY (I).RESOLVED then          AGGREGATE_ARRAY (I).EXP := RESOLVE_EXP (AGGREGATE_ARRAY (I).EXP, TREE
_VOID);떰                                        -- REPLACE RESOLVED EXPRESSION        end if;        if AGGREGATE_ARR
AY (I).CHOICE = TREE_VOID then          NEW_ASSOC := AGGREGATE_ARRAY (I).EXP;        else          NEW_ASSOC := AGGRE
GATE_ARRAY (I).ASSOC;          D (AS_EXP, NEW_ASSOC, AGGREGATE_ARRAY (I).EXP);        end if;떰                       
         -- ADD ASSOCIATION TO NEW LIST;        NEW_ASSOC_LIST := APPEND (NEW_ASSOC_LIST, NEW_ASSOC);      end if;떰  
                      -- CHECK THAT CHOICE EXISTED IN TYPE      if not AGGREGATE_ARRAY (I).SEEN then        if AGGREGA
TE_ARRAY (I).CHOICE = TREE_VOID then          ERROR (D (LX_SRCPOS, NEW_ASSOC), "NO MATCHING COMPONENT");        elsif 
AGGREGATE_ARRAY (I).CHOICE.TY = DN_CHOICE_EXP then          if D (AS_EXP, AGGREGATE_ARRAY (I).CHOICE).TY = DN_USED_OBJE
CT_ID then            ERROR (D (LX_SRCPOS, AGGREGATE_ARRAY (I).CHOICE), "NO MATCHING COMPONENT FOR - " & PRINT_NAME (D 
(LX_SYMREP, D (AS_EXP, AGGREGATE_ARRAY (I).CHOICE))));          else            ERROR (D (LX_SRCPOS, AGGREGATE_ARRAY (
I).CHOICE), "SIMPLE NAME REQUIRED");          end if;        elsif AGGREGATE_ARRAY (I).CHOICE.TY = DN_CHOICE_EXP then
          ERROR (D (LX_SRCPOS, AGGREGATE_ARRAY (I).CHOICE), "RANGE NOT ALLOWED");        else -- SINCE KIND(...) = DN_C
HOICE_OTHERS          ERROR (D (LX_SRCPOS, AGGREGATE_ARRAY (I).CHOICE), "NO MATCHING COMPONENT FOR OTHERS");        en
d if;      end if;    end loop;떰                -- INSERT RESOLVED LIST IN ASSOC_S    LIST (ASSOC_S, NEW_ASSOC_LIST)
;  end RESOLVE_RECORD_ASSOC_S;      --||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
||||||||||||      --|  function RESOLVE_EXP_OR_AGGREGATE (EXP : TREE; SUBTYPE_SPEC : TREE; NAMED_OTHERS_OK : Boolean) 
return TREE is    SCALAR_LIST : SEQ_TYPE := (TREE_NIL, TREE_NIL);  begin    if SUBTYPE_SPEC.TY = DN_CONSTRAINED_ARRAY
 then                        -- $$$$ NEED TO PASS SUBTYPES OF INDEXES      if EXP.TY = DN_AGGREGATE then        RESOL
VE_ARRAY_SUBAGGREGATE (EXP, D (SM_COMP_TYPE, GET_BASE_STRUCT (SUBTYPE_SPEC)), LIST (D (SM_INDEX_S, GET_BASE_STRUCT (SUBT
YPE_SPEC))), SCALAR_LIST, NAMED_OTHERS_OK);        D (SM_EXP_TYPE, EXP, SUBTYPE_SPEC);      elsif EXP.TY = DN_STRING_L
ITERAL then        RESOLVE_STRING_SUBAGGREGATE (EXP, D (SM_COMP_TYPE, GET_BASE_STRUCT (SUBTYPE_SPEC)), HEAD (LIST (D (S
M_INDEX_S, GET_BASE_STRUCT (SUBTYPE_SPEC)))), SCALAR_LIST);        D (SM_EXP_TYPE, EXP, SUBTYPE_SPEC);      else     
   return RESOLVE_EXP (EXP, GET_BASE_TYPE (SUBTYPE_SPEC));      end if;    else      return RESOLVE_EXP (EXP, GET_BAS
E_TYPE (SUBTYPE_SPEC));    end if;    return EXP;  end RESOLVE_EXP_OR_AGGREGATE;      --||||||||||||||||||||||||||||
||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||      --|  procedure RESOLVE_AGGREGATE (EXP : TREE; TY
PE_SPEC : TREE) is    TYPE_STRUCT : TREE     := GET_BASE_STRUCT (TYPE_SPEC);    SCALAR_LIST : SEQ_TYPE := (TREE_NIL, T
REE_NIL);  begin    if TYPE_STRUCT.TY = DN_RECORD then      RESOLVE_RECORD_AGGREGATE (EXP, TYPE_STRUCT);      D (SM_
EXP_TYPE, EXP, TYPE_SPEC);    elsif TYPE_STRUCT.TY = DN_ARRAY then      RESOLVE_ARRAY_SUBAGGREGATE (EXP, D (SM_COMP_TY
PE, GET_BASE_STRUCT (TYPE_SPEC)), LIST (D (SM_INDEX_S, GET_BASE_STRUCT (TYPE_SPEC))), SCALAR_LIST);      D (SM_EXP_TYPE
, EXP, TYPE_SPEC);    else      RESOLVE_ERRONEOUS_AGGREGATE (EXP);    end if;  end RESOLVE_AGGREGATE;      --||||||
||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||      --|  procedure RESOLVE_STR
ING (EXP : TREE; TYPE_SPEC : TREE) is    SCALAR_LIST : SEQ_TYPE := (TREE_NIL, TREE_NIL);    TYPE_STRUCT : TREE     := 
GET_BASE_TYPE (TYPE_SPEC);    COMP_TYPE   : TREE     := TREE_VOID;    INDEX_TYPE  : TREE     := TREE_VOID;  begin   
 if TYPE_STRUCT /= TREE_VOID then      COMP_TYPE  := D (SM_COMP_TYPE, TYPE_STRUCT);      INDEX_TYPE := HEAD (LIST (D (
SM_INDEX_S, TYPE_STRUCT)));    end if;    RESOLVE_STRING_SUBAGGREGATE (EXP, GET_BASE_TYPE (COMP_TYPE), INDEX_TYPE, SCA
LAR_LIST);  end RESOLVE_STRING;--|------------------------------------------------------------------------------------
-------------      --|  procedure RESOLVE_ERRONEOUS_AGGREGATE (EXP : TREE) is                -- TYPE WRONG FOR AGGREG
ATE OR UNRESOLVED                -- CHECK EXPRESSIONS ANYWAY    GENERAL_ASSOC_S : constant TREE := D (AS_GENERAL_ASSOC
_S, EXP);    ASSOC_COUNT     : Natural       := COUNT_AGGREGATE_CHOICES (GENERAL_ASSOC_S);    AGGREGATE_ARRAY : AGGREG
ATE_ARRAY_TYPE (1 .. ASSOC_COUNT);    TEMP_EXP        : TREE;  begin    D (SM_EXP_TYPE, EXP, TREE_VOID);    SPREAD_A
SSOC_S (GENERAL_ASSOC_S, AGGREGATE_ARRAY);    for I in AGGREGATE_ARRAY'RANGE loop      if AGGREGATE_ARRAY (I).FIRST = 
I then        TEMP_EXP := RESOLVE_EXP (AGGREGATE_ARRAY (I).EXP, TREE_VOID);      end if;    end loop;  end RESOLVE_E
RRONEOUS_AGGREGATE;--|-------------------------------------------------------------------------------------------------
--|  procedure RESOLVE_RECORD_AGGREGATE (EXP : TREE; TYPE_STRUCT : TREE) is    GENERAL_ASSOC_S : constant TREE := D (
AS_GENERAL_ASSOC_S, EXP);    ASSOC_COUNT     : Natural       := COUNT_AGGREGATE_CHOICES (GENERAL_ASSOC_S);    AGGREGAT
E_ARRAY : AGGREGATE_ARRAY_TYPE (1 .. ASSOC_COUNT);    LAST_POSITIONAL : Natural       := 0;    COMP_LIST       : TREE 
         := D (SM_COMP_LIST, TYPE_STRUCT);    VARIANT_PART    : TREE;    NORMALIZED_LIST : SEQ_TYPE      := (TREE_NIL,
 TREE_NIL);  begin    D (SM_DISCRETE_RANGE, EXP, TREE_VOID);떰    SPREAD_ASSOC_S (GENERAL_ASSOC_S, AGGREGATE_ARRAY); 
   WALK_RECORD_DECL_S (EXP, D (SM_DISCRIMINANT_S, TYPE_STRUCT), AGGREGATE_ARRAY, NORMALIZED_LIST, LAST_POSITIONAL);    
while COMP_LIST /= TREE_VOID loop      WALK_RECORD_DECL_S (EXP, D (AS_DECL_S, COMP_LIST), AGGREGATE_ARRAY, NORMALIZED_L
IST, LAST_POSITIONAL);      VARIANT_PART := D (AS_VARIANT_PART, COMP_LIST);      COMP_LIST    := TREE_VOID;      if V
ARIANT_PART /= TREE_VOID then        declare          DSCRMT_ID    : constant TREE := D (SM_DEFN, D (AS_NAME, VARIANT_
PART));          DSCRMT_EXP   : TREE          := TREE_VOID;          DSCRMT_VALUE : TREE;          VARIANT_LIST : SEQ
_TYPE      := LIST (D (AS_VARIANT_S, VARIANT_PART));          VARIANT      : TREE;        begin          for I in AGG
REGATE_ARRAY'RANGE loop            if (DSCRMT_ID = AGGREGATE_ARRAY (I).ID and then DSCRMT_ID /= TREE_VOID) or else AGGR
EGATE_ARRAY (I).CHOICE.TY = DN_CHOICE_OTHERS then              DSCRMT_EXP := AGGREGATE_ARRAY (AGGREGATE_ARRAY (I).FIRST
).EXP;              exit;            end if;          end loop;          if DSCRMT_EXP = TREE_VOID then            
ERROR (D (LX_SRCPOS, EXP), "$$$$ DSCRMT VALUE NOT FOUND");            exit;          end if;          DSCRMT_VALUE :=
 GET_STATIC_VALUE (DSCRMT_EXP);          if DSCRMT_VALUE = TREE_VOID then            ERROR (D (LX_SRCPOS, EXP), "DSCRM
T VALUE MUST BE STATIC (LRM 4.3.1 #2)");            exit;          end if;          while not IS_EMPTY (VARIANT_LIST)
 loop            POP (VARIANT_LIST, VARIANT);            if VARIANT.TY = DN_VARIANT then              if VALUE_IS_IN_
CHOICE_S (DSCRMT_VALUE, D (AS_CHOICE_S, VARIANT)) then                COMP_LIST := D (AS_COMP_LIST, VARIANT);         
       exit;              end if;            end if;          end loop;          if COMP_LIST = TREE_VOID then     
       ERROR (D (LX_SRCPOS, EXP), "NO VARIANT FOR DSCRMT VALUE " & PRINT_NAME (D (LX_SYMREP, DSCRMT_EXP)));            
exit;          end if;        end;      end if;    end loop;    RESOLVE_RECORD_ASSOC_S (GENERAL_ASSOC_S, AGGREGATE_
ARRAY);떰    declare      GAS : TREE := MAKE (DN_GENERAL_ASSOC_S);    begin      LIST (GAS, NORMALIZED_LIST);      D
 (LX_SRCPOS, GAS, TREE_VOID);      D (SM_NORMALIZED_COMP_S, EXP, GAS);    end;떰  end RESOLVE_RECORD_AGGREGATE;--|---
------------------------------------------------------------------------------------------------|  function VALUE_IS_I
N_CHOICE_S (VALUE : TREE; CHOICE_S : TREE) return Boolean is떰    use UARITH;떰    CHOICE_LIST : SEQ_TYPE := LIST (CHOIC
E_S);    CHOICE      : TREE;  begin    while not IS_EMPTY (CHOICE_LIST) loop      POP (CHOICE_LIST, CHOICE);      c
ase CHOICE.TY is        when DN_CHOICE_EXP =>          if U_EQUAL (GET_STATIC_VALUE (D (AS_EXP, CHOICE)), VALUE) then
            return True;          end if;        when DN_CHOICE_RANGE =>          if U_MEMBER (VALUE, D (AS_DISCRETE_
RANGE, CHOICE)) then            return True;          end if;        when DN_CHOICE_OTHERS =>          return True;
        when others =>          null;      end case;    end loop;    return False;  end VALUE_IS_IN_CHOICE_S;--|--
-----------------------------------------------------------------------------------------------      --|  procedure RE
SOLVE_ARRAY_SUBAGGREGATE (EXP : TREE; COMP_TYPE : TREE; INDEX_LIST : SEQ_TYPE; SCALAR_LIST : in out SEQ_TYPE; NAMED_OTHE
RS_OK : Boolean := False) is    GENERAL_ASSOC_S : TREE     := D (AS_GENERAL_ASSOC_S, EXP);    INDEX           : TREE  
   := HEAD (INDEX_LIST);    INDEX_TAIL      : SEQ_TYPE := TAIL (INDEX_LIST);    ASSOC_COUNT     : Natural  := COUNT_AG
GREGATE_CHOICES (GENERAL_ASSOC_S);    AGGREGATE_ARRAY : AGGREGATE_ARRAY_TYPE (1 .. ASSOC_COUNT);    TYPESET         : 
TYPESET_TYPE;    NEW_ASSOC_LIST  : SEQ_TYPE := (TREE_NIL, TREE_NIL);    CHOICE          : TREE;    INDEX_TYPE      : 
TREE;    POSITIONAL_SEEN : Boolean  := False;    NAMED_SEEN      : Boolean  := False;    OTHERS_SEEN     : Boolean  :
= False;    IS_RANGE        : Boolean;  begin떰    D (SM_EXP_TYPE, EXP, TREE_VOID);    D (SM_DISCRETE_RANGE, EXP, TRE
E_VOID);떰                -- SPREAD AGGREGATE INTO ARRAY    SPREAD_ASSOC_S (GENERAL_ASSOC_S, AGGREGATE_ARRAY);떰       
         -- RESOLVE SUBEXPRESSIONS    if IS_EMPTY (INDEX_TAIL) then      for I in AGGREGATE_ARRAY'RANGE loop        i
f AGGREGATE_ARRAY (I).FIRST = I then          TYPESET := AGGREGATE_ARRAY (I).TYPESET;          REQUIRE_TYPE (GET_BASE_
TYPE (COMP_TYPE), AGGREGATE_ARRAY (I).EXP, TYPESET);          AGGREGATE_ARRAY (I).EXP := RESOLVE_EXP_OR_AGGREGATE (AGGR
EGATE_ARRAY (I).EXP, COMP_TYPE, NAMED_OTHERS_OK => True);        end if;      end loop;    else      for I in AGGREG
ATE_ARRAY'RANGE loop        if AGGREGATE_ARRAY (I).FIRST = I then          if AGGREGATE_ARRAY (I).EXP.TY = DN_AGGREGAT
E then            RESOLVE_ARRAY_SUBAGGREGATE (AGGREGATE_ARRAY (I).EXP, COMP_TYPE, INDEX_TAIL, SCALAR_LIST, NAMED_OTHERS
_OK);          elsif AGGREGATE_ARRAY (I).EXP.TY = DN_STRING_LITERAL and then IS_EMPTY (TAIL (INDEX_TAIL)) and then (IS_
CHARACTER_TYPE (GET_BASE_TYPE (COMP_TYPE)) or else COMP_TYPE = TREE_VOID) then            RESOLVE_STRING_SUBAGGREGATE (
AGGREGATE_ARRAY (I).EXP, COMP_TYPE, HEAD (INDEX_TAIL), SCALAR_LIST);          else            ERROR (D (LX_SRCPOS, AGG
REGATE_ARRAY (I).EXP), "INVALID FORM FOR SUBAGGREGATE");            EVAL_EXP_TYPES (AGGREGATE_ARRAY (I).EXP, TYPESET);
            AGGREGATE_ARRAY (I).EXP := RESOLVE_EXP (AGGREGATE_ARRAY (I).EXP, TREE_VOID);          end if;        end i
f;      end loop;    end if;떰                -- CONSTRUCT NEW ASSOC LIST    for I in AGGREGATE_ARRAY'RANGE loop    
  if AGGREGATE_ARRAY (I).FIRST = I then        if AGGREGATE_ARRAY (I).CHOICE = TREE_VOID then          AGGREGATE_ARRAY
 (I).ASSOC := AGGREGATE_ARRAY (I).EXP;          POSITIONAL_SEEN           := True;        else          D (AS_EXP, AG
GREGATE_ARRAY (I).ASSOC, AGGREGATE_ARRAY (I).EXP);          if AGGREGATE_ARRAY (I).CHOICE.TY = DN_CHOICE_OTHERS then  
          OTHERS_SEEN := True;          else            NAMED_SEEN := True;          end if;        end if;        
NEW_ASSOC_LIST := APPEND (NEW_ASSOC_LIST, AGGREGATE_ARRAY (I).ASSOC);      end if;    end loop;떰                -- RE
PLACE LIST IN GENERAL_ASSOC_S WITH RESOLVED LIST    if POSITIONAL_SEEN then      LIST (GENERAL_ASSOC_S, NEW_ASSOC_LIST
);    end if;떰                -- IF A NAMED ASSOCIATION WAS SEEN    if NAMED_SEEN then떰      if POSITIONAL_SEEN then
        ERROR (D (LX_SRCPOS, EXP), "POSITIONAL AND NAMED ASSOCIATIONS NOT ALLOWED");      elsif not NAMED_OTHERS_OK an
d OTHERS_SEEN then        ERROR (D (LX_SRCPOS, EXP), "NAMED ASSOCIATIONS NOT ALLOWED WITH OTHERS");      end if;떰    
                    -- EVALUATE CHOICES      if INDEX.TY = DN_INDEX then                                -- (NOTE.  ANO
N INDEX BASE TYPE MAY HAVE VOID EXPRESSION)        INDEX_TYPE := D (SM_TYPE_SPEC, INDEX);      else        INDEX_TYPE
 := INDEX;      end if;      INDEX_TYPE := GET_BASE_TYPE (INDEX_TYPE);      for I in AGGREGATE_ARRAY'RANGE loop     
   CHOICE := AGGREGATE_ARRAY (I).CHOICE;        case CHOICE.TY is          when DN_CHOICE_EXP =>            EVAL_EXP_
SUBTYPE_TYPES (D (AS_EXP, CHOICE), TYPESET, IS_RANGE);            REQUIRE_TYPE (INDEX_TYPE, D (AS_EXP, CHOICE), TYPESET
);            if IS_RANGE then떰              declare                NEW_CHOICE : TREE := MAKE (DN_CHOICE_RANGE);    
          begin                D (AS_DISCRETE_RANGE, NEW_CHOICE, RESOLVE_DISCRETE_RANGE (D (AS_EXP, CHOICE), GET_THE_TY
PE (TYPESET)));                D (LX_SRCPOS, NEW_CHOICE, D (LX_SRCPOS, CHOICE));                CHOICE := NEW_CHOICE;
              end;떰              AGGREGATE_ARRAY (I).CHOICE := CHOICE;              if AGGREGATE_ARRAY (I).FIRST = I a
nd then IS_EMPTY (TAIL (LIST (D (AS_CHOICE_S, AGGREGATE_ARRAY (I).ASSOC)))) then                                       
                         -- REPLACE SINGLETON LIST                LIST (D (AS_CHOICE_S, AGGREGATE_ARRAY (I).ASSOC), SIN
GLETON (CHOICE));              end if;            else              D (AS_EXP, CHOICE, RESOLVE_EXP (D (AS_EXP, CHOICE
), TYPESET));            end if;          when DN_CHOICE_RANGE =>            EVAL_DISCRETE_RANGE (D (AS_DISCRETE_RANG
E, CHOICE), TYPESET);            REQUIRE_TYPE (INDEX_TYPE, D (AS_DISCRETE_RANGE, CHOICE), TYPESET);            D (AS_D
ISCRETE_RANGE, CHOICE, RESOLVE_DISCRETE_RANGE (D (AS_DISCRETE_RANGE, CHOICE), GET_THE_TYPE (TYPESET)));          when D
N_CHOICE_OTHERS =>            null;          when others =>            null;        end case;      end loop;      
MAKE_NORMALIZED_LIST (AGGREGATE_ARRAY, NEW_ASSOC_LIST);      GENERAL_ASSOC_S := COPY_NODE (GENERAL_ASSOC_S);      LIST
 (GENERAL_ASSOC_S, NEW_ASSOC_LIST);    end if;떰    D (SM_NORMALIZED_COMP_S, EXP, GENERAL_ASSOC_S);떰  end RESOLVE_ARRA
Y_SUBAGGREGATE;--|-------------------------------------------------------------------------------------------------   
   --|  procedure RESOLVE_STRING_SUBAGGREGATE (EXP : TREE; COMP_TYPE : TREE; INDEX : TREE; SCALAR_LIST : in out SEQ_TYP
E) is  begin    D (SM_EXP_TYPE, EXP, TREE_VOID);    D (SM_DISCRETE_RANGE, EXP, TREE_VOID);    null;  end RESOLVE_ST
RING_SUBAGGREGATE;--|-------------------------------------------------------------------------------------------------
      --|  procedure MAKE_NORMALIZED_LIST (AGGREGATE_ARRAY : in out AGGREGATE_ARRAY_TYPE; NORMALIZED_LIST : out SEQ_TYP
E) is                -- MAKES NORMALIZED LIST FOR ARRAY AGGREGATE    AGGREGATE_ITEM      : AGGREGATE_ITEM_TYPE;    NE
W_NORMALIZED_LIST : SEQ_TYPE := (TREE_NIL, TREE_NIL);    NON_STATIC_SEEN     : Boolean  := False;    CHOICE           
   : TREE;    RANGE_NODE          : TREE;  begin    NORMALIZED_LIST := (TREE_NIL, TREE_NIL);떰                -- FOR 
EACH CHOICE    for II in AGGREGATE_ARRAY'RANGE loop떰                        -- MAKE SURE IT HAS ITS OWN 'NAMED' NODE W
HICH CAN BE                        -- MODIFIED IF NECESSARY      if AGGREGATE_ARRAY (II).FIRST = II then              
        --| PREMIER CHOICE떰        if II < AGGREGATE_ARRAY'LAST and then AGGREGATE_ARRAY (II + 1).FIRST = II then    --
| PREMIER MAIS PAS SEUL          declare            CHOICE_S : TREE := MAKE (DN_CHOICE_S);            NAMED    : TREE
 := MAKE (DN_NAMED);          begin            LIST (CHOICE_S, SINGLETON (AGGREGATE_ARRAY (II).CHOICE));            D
 (LX_SRCPOS, CHOICE_S, D (LX_SRCPOS, AGGREGATE_ARRAY (II).CHOICE));            D (AS_EXP, NAMED, D (AS_EXP, AGGREGATE_A
RRAY (II).ASSOC));            D (AS_CHOICE_S, NAMED, CHOICE_S);            D (LX_SRCPOS, NAMED, D (LX_SRCPOS, AGGREGAT
E_ARRAY (II).ASSOC));            AGGREGATE_ARRAY (II).ASSOC := NAMED;          end;떰        elsif                    
        --| PAS PREMIER        AGGREGATE_ARRAY (II).CHOICE.TY = DN_CHOICE_RANGE and then D (AS_DISCRETE_RANGE, AGGREGAT
E_ARRAY (II).CHOICE).TY = DN_DISCRETE_SUBTYPE then          AGGREGATE_ARRAY (II).ASSOC := COPY_NODE (AGGREGATE_ARRAY (I
I).ASSOC);       --| POURRAIT CHANGER DE TYPE DISCRET  RANGE        end if;떰      else                                
        --| PAS LE PREMIER CHOICE        declare          CHOICE_S : TREE := MAKE (DN_CHOICE_S);          NAMED    : 
TREE := MAKE (DN_NAMED);        begin          LIST (CHOICE_S, SINGLETON (AGGREGATE_ARRAY (II).CHOICE));          D (
LX_SRCPOS, CHOICE_S, D (LX_SRCPOS, AGGREGATE_ARRAY (II).CHOICE));          D (AS_EXP, NAMED, D (AS_EXP, AGGREGATE_ARRAY
 (AGGREGATE_ARRAY (II).FIRST).ASSOC));          D (AS_CHOICE_S, NAMED, CHOICE_S);          D (LX_SRCPOS, NAMED, D (LX_
SRCPOS, AGGREGATE_ARRAY (II).CHOICE));          AGGREGATE_ARRAY (II).ASSOC := NAMED;        end;      end if;떰      
                  -- REUSE EXP AS VALUE OF STATIC CHOICE                        -- COMPUTE FIRST STATIC VALUE FOR CHOIC
E      CHOICE := AGGREGATE_ARRAY (II).CHOICE;      if CHOICE.TY = DN_CHOICE_EXP then                                -
- (IT'S A CHOICE_EXP)        AGGREGATE_ARRAY (II).EXP := GET_STATIC_VALUE (D (AS_EXP, CHOICE));      elsif CHOICE.TY =
 DN_CHOICE_RANGE then                                -- (IT'S A CHOICE_RANGE)        AGGREGATE_ARRAY (II).EXP := TREE_
VOID;        RANGE_NODE               := D (AS_DISCRETE_RANGE, CHOICE);        if RANGE_NODE.TY = DN_DISCRETE_SUBTYPE 
then                                        -- (RANGE GIVEN AS DISCRETE SUBTYPE -- FIND RANGE)          RANGE_NODE := 
D (AS_SUBTYPE_INDICATION, RANGE_NODE);          if D (AS_CONSTRAINT, RANGE_NODE) /= TREE_VOID then            RANGE_NO
DE := D (AS_CONSTRAINT, RANGE_NODE);          else            RANGE_NODE := D (AS_NAME, RANGE_NODE);            if RA
NGE_NODE.TY = DN_SELECTED then              RANGE_NODE := D (AS_DESIGNATOR, RANGE_NODE);            end if;          
  RANGE_NODE := D (SM_DEFN, RANGE_NODE);            if RANGE_NODE.TY in CLASS_TYPE_NAME then              RANGE_NODE :
= D (SM_TYPE_SPEC, RANGE_NODE);            end if;            if RANGE_NODE.TY in CLASS_SCALAR then              RANG
E_NODE := D (SM_RANGE, RANGE_NODE);            end if;          end if;떰          if RANGE_NODE.TY = DN_RANGE and the
n GET_STATIC_VALUE (D (AS_EXP1, RANGE_NODE)) /= TREE_VOID and then GET_STATIC_VALUE (D (AS_EXP2, RANGE_NODE)) /= TREE_VO
ID then            CHOICE := COPY_NODE (CHOICE);                    --| LE SOUS TYPE DISCRET EST STATIQUE, REMPLACER PA
R UNE RANGE            declare              CHOICE_S : TREE := MAKE (DN_CHOICE_S);            begin              LIS
T (CHOICE_S, SINGLETON (CHOICE));              D (LX_SRCPOS, CHOICE_S, TREE_VOID);              D (AS_CHOICE_S, AGGREG
ATE_ARRAY (II).ASSOC, CHOICE_S);            end;            D (AS_DISCRETE_RANGE, CHOICE, RANGE_NODE);          end i
f;        end if;                                -- GET STATIC VALUE FOR FIRST ELEMENT OF RANGE        if RANGE_NODE.
TY = DN_RANGE then          AGGREGATE_ARRAY (II).EXP := GET_STATIC_VALUE (D (AS_EXP1, RANGE_NODE));        else      
    AGGREGATE_ARRAY (II).EXP := TREE_VOID;        end if;      elsif CHOICE.TY = DN_CHOICE_OTHERS then        AGGREGA
TE_ARRAY (II).EXP := TREE_VOID;      else                                -- (NOT CHOICE_ANYTHING; ERROR MUST HAVE BEEN
 REPORTED)        return;      end if;떰                        -- CHECK FOR ILLEGAL NON-STATIC      if AGGREGATE_ARR
AY (II).EXP = TREE_VOID and CHOICE.TY /= DN_CHOICE_OTHERS and AGGREGATE_ARRAY'LENGTH > 1 then        NON_STATIC_SEEN :=
 True;        ERROR (D (LX_SRCPOS, CHOICE), "CHOICE MUST BE STATIC");      end if;떰    end loop;떰    if NON_STATIC_S
EEN then      return;    end if;떰                -- SORT THE ENTRIES    for II in AGGREGATE_ARRAY'FIRST + 1 .. AGGRE
GATE_ARRAY'LAST loop      exit when AGGREGATE_ARRAY (II).EXP = TREE_VOID;                        -- OTHERS      for J
J in reverse AGGREGATE_ARRAY'FIRST .. II - 1 loop        exit when UARITH."<=" (AGGREGATE_ARRAY (JJ).EXP, AGGREGATE_ARR
AY (JJ + 1).EXP);        AGGREGATE_ITEM           := AGGREGATE_ARRAY (JJ);        AGGREGATE_ARRAY (JJ)     := AGGREGAT
E_ARRAY (JJ + 1);        AGGREGATE_ARRAY (JJ + 1) := AGGREGATE_ITEM;      end loop;    end loop;떰                -- 
CONSTRUCT THE NEW LIST    for II in AGGREGATE_ARRAY'RANGE loop      NEW_NORMALIZED_LIST := APPEND (NEW_NORMALIZED_LIST
, AGGREGATE_ARRAY (II).ASSOC);    end loop;떰    NORMALIZED_LIST := NEW_NORMALIZED_LIST;  end MAKE_NORMALIZED_LIST;떰-
-|-------------------------------------------------------------------------------------------------턤nd AGGRESO;
