------------------------------------------------------------------------------------------------------------------------
¶-- CC BY SA¬EXPANDER-UTILS.ADB¬¬VINCENT MORIN¬6/5/2025¬UNIVERSITE DE BRETAGNE OCCIDENTALE¶-----------------------------
-------------------------------------------------------------------------------------------¶--¬1¬2¬3¬4¬5¬6¬7¬8¬9¬0¬1¶¶se
parate ( EXPANDER )¶--with DIANA_NODE_ATTR_CLASS_NAMES;¶--use  DIANA_NODE_ATTR_CLASS_NAMES;¶¶¬¬¬¬-----¶package body¬¬¬UT
ILS¶is¬¬¬¬-----¶¶ ¶  INACTIVE¬: BOOLEAN renames TRUE;¶¶  INT_LABEL¬: LABEL_TYPE¬:= 1;¶  FS¬¬: FILE_TYPE;¶¶¶¬¬¬--^^^^^^^^
^^^^--¶  procedure¬¬OPEN_OUTPUT_FILE¬¬( FILE_NAME :STRING )¶  is¬¬¬----------------¶¶  begin¶    CREATE ( FS, OUT_FILE, 
FILE_NAME( FILE_NAME'FIRST .. FILE_NAME'LAST-4 ) & ".FINC" );¬¬¬¬-- FASM INCLUDE¶    SET_OUTPUT ( FS );¬¬¬¬¬¬¬¬¬¬-- CODA
GE SUR SORTIE STANDARD¶    INT_LABEL := 1;¶¶  end¬OPEN_OUTPUT_FILE;¶¬----------------¶¶¶¬¬¬--^^^^^^^^^^^^^--¶  procedure
¬¬CLOSE_OUTPUT_FILE¶  is¬¬¬-----------------¶¶  begin¶    SET_OUTPUT ( STANDARD_OUTPUT );¶    CLOSE ( FS );¶¶  end¬CLOSE
_OUTPUT_FILE;¶¬-----------------¶¶¶  package INT_IO¬is new INTEGER_IO ( INTEGER ); use INT_IO;¶  package LBL_IO¬is new I
NTEGER_IO ( LABEL_TYPE ); use LBL_IO;¶¶¶¬¬¬--^^^^^--¶  function¬¬NEW_LABEL¬¬¬¬¬¬return LABEL_TYPE¶  is¬¬¬---------¶¶    
LBL¬: LABEL_TYPE¬:= INT_LABEL;¶¶  begin¶    INT_LABEL := INT_LABEL + 1;¶    return LBL;¶¶  end¬NEW_LABEL;¶¬---------¶¶¶¬
¬¬--^^^^^--¶  function¬¬NEW_LABEL¬¬¬¬¬¬return STRING¶  is¬¬¬---------¶¶    LSTR¬:constant STRING¬:= LABEL_TYPE'IMAGE( IN
T_LABEL );¶¶  begin¶    INT_LABEL := INT_LABEL + 1;¶    return 'L' & LSTR( LSTR'FIRST+1 .. LSTR'LAST );¶¶  end¬NEW_LABEL
;¶¬---------¶¶¶¬¬¬--^^^^^--¶  function¬¬LABEL_STR¬¬¬( LBL : LABEL_TYPE )¬return STRING¶  is¬¬¬---------¶¶    LSTR¬:const
ant STRING¬:= LABEL_TYPE'IMAGE( LBL );¶¶  begin¶    return 'L' & LSTR( LSTR'FIRST+1 .. LSTR'LAST );¶¶  end¬LABEL_STR;¶¬-
--------¶¶¶¬¬¬--^^^^^--¶  procedure¬¬INC_LEVEL¶  is¬¬¬---------¶  begin¶    CUR_LEVEL := CUR_LEVEL + 1;¶¶--    if DEBUG 
then put_line( "inc lvl cur= " & LEVEL_NUM'IMAGE( CUR_LEVEL ) ); end if;¶¶--   exception¶--     when CONSTRAINT_ERROR =>
 raise STATIC_LEVEL_OVERFLOW;¶¶  end¬INC_LEVEL;¶¬--=====--¶¶¶¬¬¬--^^^^^--¶  procedure¬¬DEC_LEVEL¶  is¬¬¬---------¶¶  beg
in¶    CUR_LEVEL := CUR_LEVEL - 1;¶¶--    if DEBUG then put_line( "dec lvl cur= " & LEVEL_NUM'IMAGE( CUR_LEVEL ) ); end 
if;¶¶--   exception¶--     when CONSTRAINT_ERROR => raise STATIC_LEVEL_UNDERFLOW;¶-- ¶  end¬DEC_LEVEL;¶¬---------¶¶¶¬¬¬-
-^^^^^--¶  function¬¬TYPE_SIZE¬¬¬( TYPE_SPEC :TREE )¬¬return NATURAL¶  is¬¬¬---------¶¶  begin¶    case TYPE_SPEC.TY is¶
    when DN_ACCESS¬¬¬=> return ADDR_SIZE;¶    when DN_ARRAY¬¬¬=> return 2 * ADDR_SIZE;¶    when DN_ENUMERATION | DN_INTE
GER¬=> return INTG_SIZE;¶    when DN_L_PRIVATE¬¬=> return TYPE_SIZE( D( SM_TYPE_SPEC, TYPE_SPEC ) );¶    when others =>¶
      PUT_LINE( "CODAGE_INTERMEDIAIRE.TYPE_SIZE : TYPE_SPEC.TY ILLICITE " & NODE_NAME'IMAGE( TYPE_SPEC.TY ) );¶--      r
aise PROGRAM_ERROR;¶    end case;¶    return 0;¶¶  end¬TYPE_SIZE;¶¬---------¶¶¶¶¬¬¬--^^^^^^^^^^^^^--¶  function¬¬CODE_DA
TA_TYPE_OF¬¬( EXP_OR_TYPE_SPEC :TREE )¬return CHARACTER¶  is¬¬¬-----------------¶¶  begin¶    if  EXP_OR_TYPE_SPEC.TY in
 CLASS_EXP  then¶      declare¶        EXP¬: TREE¬renames EXP_OR_TYPE_SPEC;¶¶      begin¶        case EXP.TY is¶        
when DN_FUNCTION_CALL | DN_PARENTHESIZED | DN_USED_OBJECT_ID =>¶          return CODE_DATA_TYPE_OF( D( SM_EXP_TYPE, EXP 
) );¶                     ¶        when others =>¶          PUT_LINE( "ERREUR CODE_DATA_TYPE_OF : EXP.TY ILLICITE " & NO
DE_NAME'IMAGE( EXP.TY ) );¶          raise PROGRAM_ERROR;¶        end case;¶¶      end;¶            ¶    elsif  EXP_OR_T
YPE_SPEC.TY in CLASS_TYPE_SPEC  then¶      declare¶        TYPE_SPEC¬: TREE¬renames EXP_OR_TYPE_SPEC;¶¶      begin¶     
   case TYPE_SPEC.TY is¶        when DN_ACCESS =>¶          return 'A';¶                  ¶        when DN_ENUMERATION =
>¶          declare¶            TYPE_SOURCE_NAME¬: TREE¬¬:= D( XD_SOURCE_NAME, TYPE_SPEC );¶            TYPE_SYMREP¬: TR
EE¬¬:= D( LX_SYMREP, TYPE_SOURCE_NAME );¶            NAME¬¬: constant STRING¬:= PRINT_NAME( TYPE_SYMREP );¶¶¬begin¶     
       if NAME = "BOOLEAN" then¶              return 'B';¶            elsif NAME = "CHARACTER" then¶              return
 'B';¶            else¶              return 'I';¶            end if;¶          end;¶                  ¶        when DN_I
NTEGER | DN_NUMERIC_LITERAL =>¶          return 'I';¶                  ¶        when others =>¶          PUT_LINE( "ERRE
UR CODE_DATA_TYPE_OF : TYPE_SPEC.TY ILLICITE " & NODE_NAME'IMAGE( TYPE_SPEC.TY ) );¶          raise PROGRAM_ERROR;¶     
   end case;¶      end;¶            ¶    else¶      PUT_LINE ( "!!! CODE_DATA_TYPE_OF : EXP_OR_TYPE_SPEC.TY ILLICITE " &
 NODE_NAME'IMAGE ( EXP_OR_TYPE_SPEC.TY ) );¶      raise PROGRAM_ERROR;¶    end if;¶¶  end¬CODE_DATA_TYPE_OF;¶   ¬-------
----------¶¶¶¬¬¬--^^^^^^^^^^^^^^^^--¶  function¬¬NUMBER_OF_DIMENSIONS¬( EXP :TREE )¬return NATURAL¶  is¬¬¬--------------
------¶¶  begin¶    if  EXP.TY in CLASS_CONSTRAINED  then¶      return NUMBER_OF_DIMENSIONS( D( SM_BASE_TYPE, EXP ) );¶ 
           ¶    elsif  EXP.TY = DN_FUNCTION_CALL or EXP.TY = DN_USED_OBJECT_ID  then¶      return NUMBER_OF_DIMENSIONS( 
D( SM_EXP_TYPE, EXP ) );¶            ¶    elsif  EXP.TY = DN_ARRAY  then¶      return DI( CD_DIMENSIONS, EXP );¶        
    ¶    else¶      PUT_LINE( "ERREUR NUMBER_OF_DIMENSIONS : TYPE EXPRESSION ILLICITE" & NODE_NAME'IMAGE( EXP.TY ) );¶  
    raise PROGRAM_ERROR;¶    end if;¶¶  end¬NUMBER_OF_DIMENSIONS;¶¬--------------------¶¶¶¬¬¬--^^^^^^^--¶  function¬¬CON
STRAINED¬¬( TYPE_SPEC :TREE )¬¬return BOOLEAN¶  is¬¬¬-----------¶¶  begin¶    return not ( TYPE_SPEC.TY in CLASS_UNCONST
RAINED );¶¶  end¬CONSTRAINED;¶¬--=======--¶¶¶¶¬¬¬--^^^^^^^^^^--¶  procedure¬¬LOAD_TYPE_SIZE¬¬( TYPE_SPEC :TREE )¶  is¬¬¬
--------------¶¶  begin¶    if  CONSTRAINED( TYPE_SPEC )  then¶      PUT_LINE( ASCII.HT & "LI" & ASCII.HT &  INTEGER'IMA
GE( TYPE_SIZE( TYPE_SPEC ) ) );¶¶    else¶      PUT_LINE( "ERREUR LOAD_TYPE_SIZE : TYPE_SPEC NON CONTRAINT" );¶      rai
se PROGRAM_ERROR;¶¶    end if;¶¶  end¬LOAD_TYPE_SIZE;¶¬--------------¶¶¶¬¬¬--^^^^^^^^^--¶  function¬¬OPER_SIZ_CHAR¬¬( DE
FN :TREE )¬¬return CHARACTER¶  is¬¬¬-------------¶¶    SIZ¬¬: NATURAL¬¬:= DI( CD_IMPL_SIZE, DEFN );¶¶  begin¶    if     
SIZ <= 8¬¬then return 'b';¶    elsif  SIZ <= 16¬then return 'w';¶    elsif  SIZ <= 32¬then return 'd';¶    elsif  SIZ <=
 64¬then return 'q';¶    else return 'v';¶    end if;¶¶  end¬OPER_SIZ_CHAR;¶¬-------------¶¶¶¬¬¬--^^^^^^^^^--¶  function
¬¬EXP_TYPE_CHAR¬¬( EXP :TREE )¬return CHARACTER¶  is¬¬¬-------------¶¶    SIZ¬¬: NATURAL¬¬:= DI( CD_IMPL_SIZE, D( SM_EXP
_TYPE, EXP ) );¶¶  begin¶    if     SIZ <= 8¬¬then return 'b';¶    elsif  SIZ <= 16¬then return 'w';¶    elsif  SIZ <= 3
2¬then return 'd';¶    elsif  SIZ <= 64¬then return 'q';¶    else return 'v';¶    end if;¶¶  end¬EXP_TYPE_CHAR;¶¬-------
------¶¶¶¬¬¬--^^^^--¶  procedure¬¬LOAD_MEM¬¬¬( DEFN :TREE )¶  is¬¬¬--------¶¶  begin¶    if  DEFN.TY in CLASS_PARAM_NAME
  then¬¬¬¬¬¬¬¬-- in_id in_out_id out_id¶      if  (DEFN.TY = DN_IN_ID) and (D( SM_OBJ_TYPE, DEFN ).TY in CLASS_SCALAR)  
then¶¶        declare¶¬SIZ_CHAR¬: CHARACTER¬:= OPER_SIZ_CHAR( D( SM_OBJ_TYPE, DEFN ) );¶¶        begin¶¬PUT( tab & "L" &
 SIZ_CHAR & ' ' & INTEGER'IMAGE( DI( CD_LEVEL, DEFN ) ) & ',' & tab );¶¬PUT( '-' & PRINT_NAME( D( LX_SYMREP, DEFN ) ) );
¬¬¬¬¬¬¬-- ATTENTION signe offset de params oppos aux vars¶¬PUT_LINE( "_ofs" );¬¬¬¬¬¬¬¬¬¬-- offset de parametre scalaire¶
        end;¶¶      else¬¬¬¬¬¬¬¬¬¬¬-- pas scalaire ou out in/out¶        PUT( tab & "La " & INTEGER'IMAGE( DI( CD_LEVEL,
 DEFN ) ) & ',' & tab );¶        PUT( '-' & PRINT_NAME( D( LX_SYMREP, DEFN ) ) );¬¬¬¬¬¬¬-- ATTENTION signe offset de par
ams oppos aux vars¶        PUT_LINE( "_ofs" );¬¬¬¬¬¬¬¬¬¬-- offset de parametre adresse¶¶      end if;¶¶    else¶      if
  D( SM_OBJ_TYPE, DEFN ).TY in CLASS_SCALAR  then¶        declare¶¬SIZ_CHAR¬: CHARACTER¬:= OPER_SIZ_CHAR( D( SM_OBJ_TYPE
, DEFN ) );¶¶        begin¶¬PUT( tab & "L" & SIZ_CHAR & ' ' & INTEGER'IMAGE( DI( CD_LEVEL, DEFN ) ) & ',' & tab );¶¬PUT_
LINE( PRINT_NAME( D( LX_SYMREP, DEFN ) ) & "_disp" );¬¬¬¬¬¬-- deplacement de variable locale¶        end;¶¶     else¬¬¬¬
¬¬¬¬¬¬¬¬-- variable non scalaire¶        PUT( tab & "LVa " & INTEGER'IMAGE( DI( CD_LEVEL, DEFN ) ) & ',' & tab );¶      
  PUT_LINE( PRINT_NAME( D( LX_SYMREP, DEFN ) )  & "_disp" );¶¶     end if;¶¶    end if;¶¶  end¬LOAD_MEM;¶¬--------¶¶¶¬¬¬
--^--¶  procedure¬¬STORE¬¬¬( DEST_DEFN¬:TREE )¶  is¬¬¬-----¶¶    SIZ_CHAR¬: CHARACTER¬:= OPER_SIZ_CHAR( D( SM_OBJ_TYPE, 
DEST_DEFN ) );¶¶  begin¶    if  DEST_DEFN.TY = DN_OUT_ID  or  DEST_DEFN.TY = DN_IN_OUT_ID  then¶      PUT_LINE( tab & "S
I" & SIZ_CHAR & ' ' & INTEGER'IMAGE( DI( CD_LEVEL, DEST_DEFN ) ) & ',' & tab & '-' & PRINT_NAME( D( LX_SYMREP, DEST_DEFN
 ) ) & "_ofs" );¶    else¶      PUT_LINE( tab & "S" & SIZ_CHAR & ' ' & INTEGER'IMAGE( DI( CD_LEVEL, DEST_DEFN ) ) & ',' 
& tab & PRINT_NAME( D( LX_SYMREP, DEST_DEFN ) ) & "_disp" );¶    end if;¶¶  end¬STORE; ¶¬-----¶¶¶¬¬¬--^--¶  function¬¬TA
B50¬¬¬return STRING¶  is¬¬¬-----¶¶    NTABS¬¬: INTEGER¬¬:= (50 - NATURAL(TEXT_IO.COL) ) / 10;¶¶  begin¶    if  NTABS < 0
  then  NTABS := 1;  else  NTABS := NTABS + 1;  end if;¶    declare¶      ESPACEMENT¬: STRING( 1.. NATURAL(NTABS) )¬:= (
others => tab );¶¶    begin¶      return ESPACEMENT;¶    end;¶¶  end¬TAB50;¶¬-----¶¶¶¬¬¬--^--¶  function¬¬IMAGE¬¬¬( I : 
NATURAL )¬return STRING¶  is¬¬¬-----¶¶    STR¬:constant STRING¬:= NATURAL'IMAGE( I );¶¶  begin¶    return STR( STR'FIRST
+1 .. STR'LAST );¶¶  end¬IMAGE;¶¬-----¶¶¶¬¬¬--^^^^^^^^--¶  procedure¬¬REGIONS_PATH¬¬( ID : TREE; WITH_DOT :BOOLEAN := TR
UE )¶  is¬¬¬------------¶¶    REGION¬: TREE¬¬:= D( XD_REGION, ID );¶    RGN_NAME¬:constant STRING¬:= PRINT_NAME( D( LX_S
YMREP, REGION ) );¶¶  begin¶    if  RGN_NAME = "STANDARD"  then¶      PUT( "STANDARD." );¶¶    else¶      REGIONS_PATH( 
REGION );¶      PUT( RGN_NAME );¶      if  REGION.TY = DN_PROCEDURE_ID  then¶        PUT( '_' & LABEL_STR( LABEL_TYPE( D
I( CD_LABEL, REGION ) ) ) );¶      end if;¶      if  WITH_DOT  then PUT( '.' ); end if;¶¶    end if;¶¶  end¬REGIONS_PATH
;¶¬------------¶¶¶end¬UTILS;¶¬-----¶¶-----------------------------------------------------------------------------------
--------------------------------------¶--¬1¬2¬3¬4¬5¬6¬7¬8¬9¬0¬1¬2¶
