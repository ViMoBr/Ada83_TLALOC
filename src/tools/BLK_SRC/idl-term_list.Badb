SEPARATE( IDL )--|---------------------------------------------------------------------------------------------------|
КPACKAGE TERM_LIST--|-------------------------------------------------------------------------------------------------
턕ACKAGE BODY TERM_LIST IS     --|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|||||||||||  --|КFUNCTION SAME  FUNCTION SAME ( L1, L2 :SEQ_TYPE ) RETURN BOOLEAN IS  BEGIN    RETURN L1.FIRST = L2
.FIRST;  END;  --||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||  --
|КFUNCTION UNION  FUNCTION UNION ( L1 :SEQ_TYPE; V :TREE ) RETURN SEQ_TYPE IS  BEGIN    IF IS_EMPTY( L1 ) THENККК
К--| LA LISTE EST VIDE      RETURN INSERT( L1, V );КККК--| RETOURNER UNE LISTE AVEC L'LMENT INSR    ELSE      DE
CLARE        H1: TREE:= HEAD( L1 );ККК--| TTE DE LA LISTE        N1: INTEGER:= DI( XD_TER_NBR, H1 );КК--| N 
DE TERMINAL DE LA TTE        NV: INTEGER:= DI( XD_TER_NBR, V );КК--| N DE TERMINAL DE L'LMENT      BEGIN        
IF N1 = NV THENКККК--| SI MME N          RETURN L1;КККК--| RETOURNER LA LISTE INCHANGE        ELSIF N1 < NV TH
ENКККК--| N DIFFRENTS, CELUI DE LA LISTE STRICTEMENT INFRIEUR          DECLARE            T1: SEQ_TYPE:= TAIL( L
1 );КК--| PRENDRE LA SUITE DE LISTE            L: SEQ_TYPE:= UNION( T1, V );КК--| RETENTER L'UNION AVEC LE REST
E DE LISTE          BEGIN            IF SAME( T1, L ) THENККК--| LA LISTE EST INCHANGE PAR UNION SUR LE RESTE (LME
NT REPR DANS LE RESTE)              RETURN L1;КККК--| RETOURNER LA LISTE INITIALE INCHANGE            ELSEКККК
--| LE RESTE A T CHANG              RETURN INSERT( L, H1 );ККК--| METTRE LA TTE DEVANT LA NOUVELLE LISTE RESTE   
         END IF;          END;        ELSEКККК--| N DIFFRENTS CELUI DE LA LISTE STRICTEMENT SUPRIEUR          RE
TURN INSERT( L1, V );ККК--| INSRER L'LMENT EN TTE (PLUS PETITS N EN TTE)        END IF;      END;    END IF;  EN
D UNION;  --||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||  --|КFUN
CTION UNION  FUNCTION UNION ( L1 :SEQ_TYPE; L2 :SEQ_TYPE ) RETURN SEQ_TYPE IS  BEGIN    IF IS_EMPTY( L1 ) THEN      
RETURN L2;    ELSIF IS_EMPTY( L2 ) OR ELSE SAME( L1, L2 ) THEN      RETURN L1;    ELSE      DECLARE        H1: TRE
EК:= HEAD( L1 );        H2: TREEК:= HEAD( L2 );        N1: INTEGERК:= DI( XD_TER_NBR, H1 );КК--| N DE TERMINAL 
DE LA TTE 1        N2: INTEGERК:= DI( XD_TER_NBR, H2 );КК--| N DE TERMINAL DE LA TTE 2        T1, T2, L: SEQ_TYPE
;      BEGIN        IF N1 = N2 THENКККК--| MMES N DE TTES          T1 := TAIL( L1 );КККК--| PRENDRE LE RESTE 
1          T2 := TAIL( L2 );КККК--| LE RESTE 2          L := UNION( T1, T2 );ККК--| RETENTER L'OPRATION SUR LE
S RESTES          IF SAME( L, T1 ) THENККК--| L'UNION DES RESTES EST LE RESTE 1 (LE RESTE 1 CONTIENT LE RESTE 2)  
          RETURN L1;КККК--| RENDRE LA LISTE 1          ELSIF SAME( L, T2 ) THENККК--| L'UNION DES RESTES EST LE
 RESTE 2 (LE RESTE 2 CONTIENT LE RESTE 1)            RETURN L2;КККК--| RENDRE LA LISTE 2          ELSEКККК--|
 L'UNION DES RESTES DIFFRE DES DEUX RESTES (CHAQUE RESTE A DES LMENTS NON CONTENUS DANS L'AUTRE)            RETURN INSE
RT( L, H1 );ККК--| PRFIXER LA TTE COMMUNE  LA LISTE UNION DES RESTES          END IF;                          EL
SIF N1 > N2 THENКККК--| LA TTE 1 EST APRS LA TTE 2          RETURN UNION( L2, L1 );ККК--| RETENTER L'UNION EN P
ERMUTANT LES LISTES (POUR VENIR AU CAS SUIVANT)        ELSEКККК--| LA TTE 2 EST APRS LA TTE 1          T1 := TAIL
( L1 );КККК--| PRENDRE LE RESTE DE LA LISTE  TTE ANTRIEURE          L := UNION( T1, L2 );ККК--| RETENTER L'UNIO
N SUR LE RESTE ET LA LISTE 2 INITIALE          IF SAME( L, T1 ) THENККК--| SI L'UNION EST LE RESTE INCHANG (LE REST
E DE 1 CONTENAIT LA LISTE 2)            RETURN L1;КККК--| RENDRE LA LISTE 1          ELSEКККК--| L'UNION DU R
ESTE 1 ET DE LA LISTE 2 EST ORIGINAL            RETURN INSERT( L, H1 );ККК--| PRFIXER LA TTE 1  LA NOUVELLE LISTE U
NION          END IF;        END IF;      END;    END IF;  END UNION;  --|||||||||||||||||||||||||||||||||||||||||
|||||||||||||||||||||||||||||||||||||||||||||||||||||||  --|КFUNCTION MEMBER  FUNCTION MEMBER ( L1 :SEQ_TYPE; V :TREE
 ) RETURN BOOLEAN IS  BEGIN    IF IS_EMPTY( L1 ) THENКККК--| SI LA LISTE EST VIDE      RETURN FALSE;КККК--| 
L'LMENT N'Y EST PAS (!)    ELSE      DECLARE        H1: TREEК:= HEAD( L1 );КК--| TTE DE LISTE        N1: INTEG
ERК:= DI( XD_TER_NBR, H1 );КК--| N DE LA TTE        NV: INTEGERК:= DI( XD_TER_NBR, V );КК--| N DE L'LMENT      
BEGIN        IF N1 = NV THENКККК--| N IDENTIQUES          RETURN TRUE;КККК--| L'LMENT EST DANS LA LISTE      
  ELSIF NV < N1 THENКККК--| N D'LMENT INFRIEUR          RETURN FALSE;КККК--| L'LMENT N'EST PAS DANS LA LISTE (O
RDONNE CROISSANTE)        ELSEКККК--| LE N D'LMENT EST POSTRIEUR          RETURN MEMBER( TAIL( L1 ), V );ККК--
| REFAIRE L'OPRATION SUR LE RESTE DE LA LISTE        END IF;      END;    END IF;  END MEMBER;  --|||||||||||||||||
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||  --|КFUNCTION R_UNION  FUNCTION R_UNI
ON ( L1 :SEQ_TYPE; V :TREE ) RETURN SEQ_TYPE IS  BEGIN    IF IS_EMPTY( L1 ) THENКККК--| LISTE VIDE      RETURN IN
SERT( L1, V );КККК--| RETOURNER LA LISTE AVEC L'LMENT EN TTE    ELSEККККК--| LISTE NON VIDE      DECLARE    
    H1: TREE:= HEAD( L1 );ККК--| LIRE LA TTE DE LISTE      BEGIN        IF H1 = V THENКККК--| SI C'EST L'LMEN
T          RETURN L1;КККК--| RETOURNER LA LISTE        END IF;        DECLARE          N1 : INTEGER:= DI( XD_RU
LE_NBR, D( XD_RULEINFO, H1 ) );К--| PRENDRE LE N DE RGLE TTE DE LISTE          NV : INTEGER:= DI( XD_RULE_NBR, D( XD
_RULEINFO, V ) );К--| PRENDRE LE N DE RGLE LMENT        BEGIN          IF N1 < NV THENКККК--| LA TTE EST ANTRIEU
RE            DECLARE              T1 : SEQ_TYPE:= TAIL( L1 );ККК--| PRENDRE LE RESTE DE LISTE              L  : 
SEQ_TYPE:= R_UNION( T1, V );КК--| RETENTER L'OPRATION            BEGIN              IF SAME( T1, L ) THENККК--
| LE RESTE DE LISTE EST INCHANG (CONTENAIT L'LMENT)                RETURN L1;КККК--| RETOURNER LA LISTE           
   ELSEКККК--| L'UNION EST ORIGINALE                RETURN INSERT( L, H1 );ККК--| RETOURNER UNE LISTE AVEC LA 
TTE 1 PRFIXE              END IF;            END;          ELSEКККК--| L'LMENT EST ANTRIEUR            RETURN I
NSERT( L1, V );ККК--| RETOURNER UNE LISTE AVEC L'LMENT PRFIX          END IF;        END;      END;    END IF; 
 END R_UNION;  --||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||  --|
КFUNCTION R_UNION  FUNCTION R_UNION ( L1 :SEQ_TYPE; L2 :SEQ_TYPE ) RETURN SEQ_TYPE IS  BEGIN    IF IS_EMPTY( L1 ) TH
ENКККК--| LISTE 1 VIDE      RETURN L2;КККК--| RETOURNER LA LISTE 2 COMME UNION    ELSIF IS_EMPTY( L2 ) OR ELS
E SAME( L1, L2 ) THENКК--| LISTE 2 VIDE OU IDENTIQUE  LA LISTE 1      RETURN L1;КККК--| RETOURNER LA LISTE 1 CO
MME UNION    ELSE      DECLAREКККК--| CAS GNRAL        H1: TREE:= HEAD( L1 );ККК--| PRENDRE LA TTE DE LISTE
 1        H2: TREE:= HEAD( L2 );ККК--| ET LA TTE DE LISTE 1        T1, T2: SEQ_TYPE;      BEGIN        IF H1 = 
H2 THENКККК--| SI TTES IDENTIQUES          T1 := TAIL( L1 );КККК--| PRENDRE LE RESTE 1          T2 := TAIL( L2
 );КККК--| ET LE RESTE 2          DECLARE            L : SEQ_TYPE:= R_UNION( T1, T2 );КК--| FAIRE L'UNION DES 
RESTES          BEGIN            IF SAME( L, T1 ) THENККК--| UNION CORRESPONDANT AU RESTE 1 (QUI CONTIENT LE RESTE
 2)              RETURN L1;КККК--| RETOURNER LA LISTE 1            ELSIF SAME( L, T2 ) THENККК--| UNION CORRES
PONDANT AU RESTE 2 (QUI CONTIENT LE RESTE 1)              RETURN L2;КККК--| RETOURNER LA LISTE 2            ELSE 
             RETURN INSERT( L, H1 );ККК--| PRFIXER LA TTE COMMUNE  L'UNION ORIGINALE DES RESTES            END IF;
          END;        ELSEКККК--| LES TTES DIFFRENT          IF DI( XD_RULE_NBR, D( XD_RULEINFO, H1 ) )КК--| L
E N DE TTE 1           К> DI( XD_RULE_NBR, D( XD_RULEINFO,H2 ) ) THENК--| EST POSTRIEUR AU N DE TTE 2            RE
TURN R_UNION( L2, L1 );ККК--| RETENTER L'UNION EN PERMUTANT LES LISTES (POUR TOMBER AU CAS SUIVANT)          ELSEК
ККК--| LE N DE TTE 1 EST ANTRIEUR AU N DE TTE 2            T1 := TAIL( L1 );КККК--| PRENDRE LE RESTE 1        
    DECLARE              L: SEQ_TYPE:= R_UNION( T1, L2 );КК--| UNIR LE RESTE 1  LA LISTE 2            BEGIN      
        IF SAME( L, T1 ) THENККК--| SI UNION CORRESPONDANT AU RESTE 1 (QUI CONTIENT LA LISTE 2)                RETU
RN L1;КККК--| RETOURNER LA LISTE 1              ELSEКККК--| UNION ORIGINALE                RETURN INSERT( L, 
H1 );ККК--| RETOURNER UNE LISTE AVEC LA TTE 1 PRFIXE  L'UNION ORIGINALE              END IF;            END;     
     END IF;        END IF;      END;    END IF;  END R_UNION;   --|----------------------------------------------
----------------------------------------------------턉ND TERM_LIST;
