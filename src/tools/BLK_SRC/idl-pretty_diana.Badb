--¬Vincent MORIN¬Universite de Bretagne Occidentale¬janvier 2025¬Licence CC BY-SA 4.0¶--¬1¬2¬3¬4¬5¬6¬7¬8¬9¬10¬11¬12¶¶¶se
parate( IDL )¶¬¬¬¬¬------------¶procedure¬¬¬¬¬PRETTY_DIANA¬¬( OPTION :CHARACTER := 'U' )¶¬¬¬¬¬------------¶is¶  OFILE¬¬:
 FILE_TYPE;¬¬¬¬¬¬¬¬¬--| LE FICHIER DE SORTIE IMPRESSION¶¶  DEBUG_PRETTY¬: BOOLEAN¬¬:= FALSE;¶¶¶¬¬¬¬-------¶  procedure¬¬
¬IMPRIME¶  is¬¬¬¬-------¶      ¶    LAST_PAGE¬¬¬: VPG_IDX¬:= VPG_IDX( DI( XD_HIGH_PAGE, TREE_ROOT ) );¶         ¶    typ
e STATUS¬¬¬is ( PRINT, PRINT_AS, NO_PRINT );¬¬¬¬¬--| MARQUAGE DE LIGNE DE PAGE : IMPRIMER, IMPRIMER COMME ALL_SOURCE, LA
ISSER¶    type PRINT_STATUS_VECTOR¬¬is array( LINE_IDX ) of STATUS;¬¬¬¬¬--| VECTEUR MARQUAGE D UNE PAGE¶    type PRINT_S
TATUS_ARRAY¬¬is array( 1 .. LAST_PAGE ) of PRINT_STATUS_VECTOR;¬¬¬--| MARQUAGE DE TOUS LES TREES DU FICHIER ARBRE (INDIC
AGE PAR PAGE ET LIGNE)¶      ¶    PRINT_STATUS¬¬¬: PRINT_STATUS_ARRAY¬:= (others => (others => PRINT) );¶    USER_ROOT¬¬
¬: TREE¬¬¬:= D( XD_USER_ROOT, TREE_ROOT );¶    COMPLTN_STRUCT¬¬¬: TREE¬¬¬:= D( XD_STRUCTURE, USER_ROOT );¶¶¶¶¬¬¬¬------¶
    procedure¬¬¬INDENT¬¬¬( IND :INTEGER )¶¬¬¬¬------¶    is¶      I¬¬: INTEGER¬¬:= IND;¶    begin¶      NEW_LINE;¬¬¬¬¬¬¬
¬¬¬¬--| SE FAIT SUR UNE NOUVELLE LIGNE¶      while I >= 8 loop¶        PUT( "      | " );¬¬¬¬¬¬¬¬¬¬--| UNE SUITE DE 8 CA
RACTERES AVEC UN | A 7¶        I := I - 8;¬¬¬¬¬¬¬¬¬¬¬--| 8 DE MOINS¶      end loop;¶      for N in 1 .. I loop PUT( ' ' 
); end loop;¬¬¬¬¬¬¬¬--| RELIQUAT DE BLANCS¶¶    end¬INDENT;¶¬------¶¶¶¬¬¬¬-----------¶    procedure¬¬¬MARK_STRUCT¬¬( T :
TREE )¬¬¬¬--| MARQUE EN PRINT_AS LES TREES DE LA CATEGORIE "ALL_SOURCE"¶¬¬¬¬-----------¶    is¶    begin¶      if  T = T
REE_VOID  or else  T = TREE_NIL  or else  T = TREE_VIRGIN¬¬¬¬¬--| TREE VERS UN NOEUD SANS ATTRIBUT¶¬or else  T.PT = HI¬¬
¬¬¬¬¬¬¬¬--| TREE REPRESENTANT UN ENTIER 16 BITS NEGATIF OU UNE POSITION SOURCE¶¬or else  ( (T.PT=P or T.PT=L)  and then 
 PRINT_STATUS( T.PG )( T.LN ) /= PRINT )¬¬¬--| DEJA MARQUE¶      then¶        return;¬¬¬¬¬¬¬¬¬¬¬--| NE RIEN FAIRE¶      
end if;¶¶      if  (T.PT = P  or  T.PT = L) and then  T.TY in CLASS_ALL_SOURCE¬¬¬¬¬¬-- POINTEUR OU ATTRIBUT LISTE DANS L
A CLASSE ELEMENTS DE CODE SOURCE¶      then¶        PRINT_STATUS( T.PG )( T.LN ) := PRINT_AS;¬¬¬¬¬¬¬¬--| INITIALISER EN 
MARQUER EN A IMPRIMER ELEMENT "AS_"¶¶        if  ARITY( T ) = ARBITRARY  then¬¬¬¬¬¬¬¬--| ARITE QUELCONQUE : LISTE¶¬decla
re¶¬  ITEM_LIST¬: SEQ_TYPE¬:= LIST( T );¬¬¬¬¬¬--| AMENER LA LISTE POINTEE¶¬  ITEM¬¬: TREE;¶¬begin¶¬  while  not IS_EMPTY
( ITEM_LIST )  loop¬¬¬¬¬¬¬--| TANT QUE PAS VIDE¶¬    POP( ITEM_LIST, ITEM );¬¬¬¬¬¬¬¬¬--| EXTRAIRE UN POINTEUR DE LA LIST
E¶¬    MARK_STRUCT( ITEM );¬¬¬¬¬¬¬¬¬--| FAIRE LE MARQUAGE EN SUIVANT CE POINTEUR¶¬  end loop;¶¬end;¶¬        ¶        el
se¬¬¬¬¬¬¬¬¬¬¬--| ARITE DEFINIE¶¬for  I in 1 .. ATTR_NBR( ARITIES'POS( ARITY( T ) ) )  loop¬¬¬¬¬¬--| POUR TOUS LES CHAMPS
¶¬  MARK_STRUCT( DABS( I, T ) );¬¬¬¬¬¬¬¬--| FAIRE LE MARQUAGE EN SUIVANT LE POINTEUR DU CHAMP¶¬end loop;¶        end if;
¶      end if;¶¶    end¬MARK_STRUCT;¶¬-----------¶¶¶¬¬¬¬-----------¶    procedure¬¬¬PRINT_DIANA¬¬( T :TREE; IND :NATURAL
; PARENT :TREE )¶¬¬¬¬-----------¶    is¶      A_SUB¬: INTEGER;¶    begin¶      if  DEBUG_PRETTY  then PUT_LINE( "PRINT_D
IANA" ); end if;¶¶--..................................................................................................¶¶
--¬¬IMPRESSION AU BESOIN DU POINTEUR DE NOEUD¶¶--.......................................................................
...........................¶      PRINT_NOD.PRINT_TREE( T );¬¬¬¬¬¬¬¬¬--| IMPRIMER LE POINTEUR D'ARBRE¶¬  ¶      if  T = 
TREE_VOID  or else  T = TREE_NIL  or else  T = TREE_VIRGIN¶¬or else  T.PT = HI  or else T.PT = S¶      then return;¬¬¬¬¬
¬¬¬¬¬¬--| FINI¶      end if;¶         ¶      A_SUB := N_SPEC( T.TY ).NS_FIRST_A;¶      if  T.TY in CLASS_ALL_SOURCE  the
n¬¬¬¬¬¬¬¬--| NOEUD "ALL_SOURCE"¶¶¬¬¬¬-----------------------¶¬¬¬¬IMPRIME_POSITION_SOURCE:¶        declare¶¬SPOS¬: TREE¬:
= D( LX_SRCPOS, T );¬  ¬¬¬¬--| POSITION SOURCE : (LIGNE,COL)¶        begin¶¬PUT( " SLOC(" );¶¬if  SPOS.PT = S  and then 
 SPOS.COL in 1 .. 254  then¶¬  declare¶¬    IML : constant STRING¬:= INTEGER'IMAGE( DI( XD_NUMBER, GET_SOURCE_LINE( SPOS
 ) ) );¶¬    IMC : constant STRING¬:= SRCCOL_IDX'IMAGE( GET_SOURCE_COL( SPOS ) );¶¬  begin¶¬    PUT( IML( 2 .. IML'LENGT
H ) & "," & IMC( 2 .. IMC'LENGTH ) );¶¬  end;¶¬else¶¬  PRINT_TREE( SPOS );¶¬end if;¶¬PUT( ')' );¶        end¬IMPRIME_POS
ITION_SOURCE;¶¬¬-----------------------¶¶¶        if  T.TY in CLASS_SOURCE_NAME  then¬¬¬¬¬¬¬¬--| CHOSES QUI ONT UN SYMBO
LE ASSOCIE¶¬¬¬-------------------¶¬¬¬NODE_WITH_IDENTIFER:¶¬declare¶¬  SYMREP¬¬: TREE¬¬:= D( LX_SYMREP, T );¶¬  DEFLIST¬¬
: SEQ_TYPE;¶¬  DEF¬¬: TREE;¶¬begin¶¬  if  SYMREP.TY = DN_SYMBOL_REP  then¶¬    DEFLIST := LIST( SYMREP );¶¬    while  no
t IS_EMPTY( DEFLIST )  loop¶¬      POP( DEFLIST, DEF );¶¬      if  DEF.TY = DN_DEF  and then  D( XD_SOURCE_NAME, DEF ) =
 T  then¶¬        PUT( ' ' ); PRINT_TREE( DEF );¶¬        PUT( ' ' ); PRINT_TREE( D( XD_REGION_DEF, DEF ) );¶¬        ex
it;¶¬      end if;¶¬    end loop;¶¬  end if;¶¬end¬NODE_WITH_IDENTIFER;¶¬¬-------------------¶        end if;¶¬     ¶    
  end if;¶--..................................................................................................¶¶--¬¬IMPR
ESSION EVENTUELLE DU CORPS DE NOEUD¶¶--.................................................................................
.................¶      if  PRINT_STATUS( T.PG )( T.LN ) = NO_PRINT¬¬¬¬¬¬¬¬--| PAS D'IMPRESSION DU NOEUD, RETOUR¶      t
hen return;¶      end if;¶¬     ¶      PRINT_STATUS( T.PG )( T.LN ) := NO_PRINT;¬¬¬¬¬¬¬¬--| MENTIONNER NE PLUS IMPRIMER 
A L AVENIR¶¶¶      if  T.TY = DN_COMPILATION_UNIT  then¬¬¬¬¬¬¬¬--| CAS SPECIAL DE L'UNITE DE COMPILATION¶¬¬¬¬¬----------
-------------------¶¬¬¬¬¬COMPILATION_UNIT_SPECIAL_CASE:¶        declare¶¬TRANS_WITH_LIST¬: SEQ_TYPE¬:= LIST( T );¬¬¬¬¬¬-
-| LISTE DES WITH¶¬TRANS_WITH¬: TREE;¶¬COMP_UNIT¬¬: TREE;¶        begin¶¬if  TRANS_WITH_LIST.FIRST /= TREE_VIRGIN  then¬
¬¬¬¬¬¬--| TETE DE LISTE NON INITIALISEE : LIB_PHASE NON FAITE¶¶¬  if DEBUG_PRETTY then PUT_LINE( "dn_compilation_unit tr
ans_with_list" ); end if;¶¶¬  while  not IS_EMPTY( TRANS_WITH_LIST )  loop¶¬    POP( TRANS_WITH_LIST, TRANS_WITH );¬¬¬¬¬
¬¬¬--| EXTRAIRE UN ELEMENT DE LISTE WITH¶¬ ¬¶¬    COMP_UNIT := D( TW_COMP_UNIT, TRANS_WITH );¶¬    if D( XD_NBR_PAGES, C
OMP_UNIT ) /= TREE_VIRGIN then¶¬      for  I in COMP_UNIT.PG .. COMP_UNIT.PG + PAGE_IDX( DI( XD_NBR_PAGES, COMP_UNIT ) )
 - 1  loop¶¬        declare¶¬          PS : STATUS := NO_PRINT;¶¬        begin¶¬          if  OPTION = 'P'  then PS := P
RINT_AS; elsif  OPTION = 'A'  then PS := PRINT; end if;¶¬          PRINT_STATUS( I ) := (others => PS);¬¬¬¬¬¬¬--| IMPRIM
ER SUIVANT OPTION¶¬        end;¶¬      end loop;¶¬    end if;¶¬  end loop;¶¶¬end if;¶        end¬COMPILATION_UNIT_SPECIA
L_CASE;¶¬¬-----------------------------¶      end if;¶¶¬¬¬¬¬-----------------------¶¬¬¬¬¬TRAITER_LES_DESCENDANTS:¶      
declare¶        NB_STRUC_CHILD¬: ATTR_NBR¬:= 0;¶¬     ¶¬¬¬---------------------¶        procedure¬¬PRINT_NON_STRUCT_ATTR
¬( A_SUB :INTEGER; T :TREE; IND :INTEGER; PARENT :TREE)¬--| IMPRESSION SANS DETAIL DES SOUS ARBRES (PRINT_TREE)¶¬¬¬-----
----------------¶        is¶        begin¶¬if  DEBUG_PRETTY  then PUT_LINE( "print_non_struct_attr" ); end if;¶¶¬if  T =
 TREE_VOID  or else  T = TREE_VIRGIN  then¶--¬  PUT( "^" & NODE_NAME'IMAGE( T.TY ) );¶¶--PUT( " " & ATTRIBUTE_NAME'IMAGE
( A_SPEC( A_SUB ).ATTR ) );¶return;¶¶¬end if;¶¬if  T.PT = S  then PUT( "c" & SRCCOL_IDX'IMAGE( T.COL ) ); return; end if
;¶¬if  T.PT = HI then PUT( "#" & NODE_NAME'IMAGE( T.NOTY ) ); return; end if;¶¶¬INDENT( IND );¶¬PUT( ATTRIBUTE_NAME'IMAG
E( A_SPEC( A_SUB ).ATTR ) );¶¬     ¶¬if  not A_SPEC( A_SUB ).IS_LIST  and then  T.TY /= DN_LIST  then¬¬¬¬¬--| PAS UNE LI
STE¶¬  PUT(": ");¶¬  if  T.PG > 0  and then  T.TY = DN_REAL_VAL  then¶¬    PRINT_TREE( D( XD_NUMER,T ) ); PUT( '/' ); PR
INT_TREE( D( XD_DENOM, T ) );¶¬  else¶¬    PRINT_TREE( T );¶¬  end if;¶¶¬  if  T.PG > 0  and then  T.TY = DN_SYMBOL_REP 
 then¶¬    PUT( ' ' & PRINT_NAME( T ) );¶¬  end if;¶¶¬else¬¬¬-----------------¬¬¬¬¬¬¬--| UNE LISTE¶¬¬¬¬IMPRIME_UNE_LISTE
:¶¬  declare¶¬    SQ¬:  SEQ_TYPE¬:= ( FIRST=> T, NEXT=> TREE_NIL );¶¬    E¬: TREE;¶¬  begin¶¬    PUT( ": { " ); ¶¬    wh
ile  not IS_EMPTY( SQ )  loop¶¬      POP( SQ, E ); INDENT( IND ); PRINT_TREE( E );¶¬    end loop;¶¬    PUT( " }" );¶¶¬  
end¬IMPRIME_UNE_LISTE;¶¬¬-----------------¶¬end if;¶        end¬PRINT_NON_STRUCT_ATTR;¶¬¬---------------------¶¶¶¬¬¬¬---
--------------¶        procedure¬¬¬PRINT_STRUCT_ATTR¬¬( A_SUB : INTEGER; T : TREE; IND :INTEGER; PARENT : TREE )¬--| IMP
RESSION AVEC DETAIL DES SOUS ARBRES (PRINT_DIANA)¶¬¬¬¬-----------------¶        is¶¬ATNBR¬: ATTRIBUTE_NAME¬:= A_SPEC( A_
SUB ).ATTR;¶        begin¶¶¬if  T = TREE_VOID  or else  T = TREE_VIRGIN  then¶--¬  PUT( "^" & NODE_NAME'IMAGE( T.TY ) );
¶--PUT( " " & ATTRIBUTE_NAME'IMAGE( ATNBR ) );¶return;¶¬end if;¶¶¬if  T.PT = S  then PUT( "c" & SRCCOL_IDX'IMAGE( T.COL 
) ); return; end if;¶¬if  T.PT = HI then PUT( "#" & NODE_NAME'IMAGE( T.NOTY ) ); return; end if;¶¶¬if  DEBUG_PRETTY  the
n PUT_LINE( "print_struct_attr" ); end if;¶¶¬if  T.PT = P  and then  T.TY in CLASS_STANDARD_IDL  and then  not A_SPEC( A
_SUB ).IS_LIST¶¬then¶¬  PRINT_NON_STRUCT_ATTR( A_SUB, T, IND, PARENT );¶¬  return;¶¬elsif  T.PT = P  and then  T.TY = DN
_REAL_VAL  then¶¬  PRINT_NON_STRUCT_ATTR( A_SUB, T, IND, PARENT );¶¬  return;¶¬end if;¶¬     ¶¬INDENT( IND );¶¬PUT( ATTR
IBUTE_NAME'IMAGE( ATNBR ) );¶¶¬if  not A_SPEC( A_SUB ).IS_LIST  then¬¬¬¬¬¬¬¬--| PAS UNE LISTE¶¬  if  T.PT = S  then¶¬   
 PUT( ": " ); PRINT_TREE( T );¶¬  else¶¬    PUT( ": ") ; PRINT_DIANA( T, IND+2, PARENT );¶¬  end if;¶¶¬else¶¬¬¬¬¬-------
----------------¶¬¬¬¬¬IMPRIME_LISTE_DETAILLEE:¬¬¬¬¬--| UNE LISTE¶¬  declare¶¬    SQ¬: SEQ_TYPE¬:= ( FIRST=> T, NEXT=> TR
EE_NIL );¶¬  begin¶¬    if  IS_EMPTY( SQ )  then PUT( ": {}" );¬¬¬¬¬¬¬--| LISTE VIDE¶¬    else¶¬¬¬--------------¶¬¬¬NON_
EMPTY_LIST:¶¬      declare¶¬        HD¬: TREE¬:= HEAD( SQ );¶¬      begin¶¬        if  IS_EMPTY( TAIL( SQ ) )  then¬¬¬¬¬
¬¬--| SINGLETON¶¬¬PUT( ": { " ); PRINT_DIANA( HD, IND+2, PARENT ); PUT( " }" );¶¬        else¬¬¬¬¬¬¬¬¬¬--| LISTE GENERAL
E¶¬ ¬PUT( ':' );¶¬ ¬INDENT( IND );¶¬ ¬PUT( "{ " );¶¬ ¬PRINT_DIANA( HD, IND+4, PARENT );¶¬ ¬SQ := TAIL( SQ );¶¬ ¬while  n
ot IS_EMPTY( SQ )  loop¶¬ ¬  INDENT( IND + 2 );¶¬ ¬  PRINT_DIANA( HEAD( SQ ), IND+4, PARENT );¶¬ ¬  SQ := TAIL( SQ );¶¬¬
end loop;¶¬ ¬PUT( " }" );¶¬        end if;¶¬      end¬NON_EMPTY_LIST;¶¬¬--------------¶¶¬    end if;¶¬  end¬¬IMPRIME_LIS
TE_DETAILLEE;¶¬¬¬-----------------------¶¬end if;¶¶        end¬PRINT_STRUCT_ATTR;¶¬¬-----------------¶¶¶¬¬¬¬------------
---------¶        procedure¬¬¬MAYBE_NON_STRUCT_ATTR¬¬( A_SUB : INTEGER; T : TREE;¶¬¬¬¬¬¬¬¬  IND   : INTEGER; PARENT, GRA
ND_PARENT : TREE )¶        is¶        begin¶¬if  T.PT = S  or  T.PT = HI  then return; end if;¶¶¬if  DEBUG_PRETTY  then¶
¬  PUT( "maybe_non_struct_attr (" & "P" & VPG_IDX'IMAGE( T.PG ) & " L" & LINE_IDX'IMAGE( T.LN ) & ") " );¶¬  if  T.PG /=
 0  then PUT( " status=" & STATUS'IMAGE( PRINT_STATUS( T.PG )( T.LN ) ) ); end if;¶¬  NEW_LINE;¶¬end if;¶¶¬if  T.PG = 0 
 or else  PRINT_STATUS( T.PG )( T.LN ) = NO_PRINT  then¶¬  PRINT_NON_STRUCT_ATTR ( A_SUB, T, IND, PARENT );¶¬else¶¬  PRI
NT_STRUCT_ATTR( A_SUB, T, IND, PARENT );¶¬end if;¶¶        end¬MAYBE_NON_STRUCT_ATTR;¶¬¬---------------------¶¶¶¬¬¬¬----
-------------------¶        procedure¬¬¬PRINT_IF_NOT_STRUCTURAL ( A_SUB : INTEGER; T : TREE; IND : INTEGER; PARENT, GRAN
D_PARENT : TREE )¶¬¬¬¬-----------------------¶        is¶        begin¶¶¬if  T.PT = HI  then¶¬  INDENT( IND );¶¬  PUT( A
TTRIBUTE_NAME'IMAGE( A_SPEC( A_SUB ).ATTR ) );¶¬  PUT( ": HI noty=" & NODE_NAME'IMAGE( T.NOTY ) & " abss=" & POSITIVE_SH
ORT'IMAGE( T.ABSS ) & " nsiz=" & ATTR_NBR'IMAGE( T.NSIZ ) );¶¬  return;¶¬end if;¶¶¬if  T.PT = S  or else  T.PG = 0  then
¬¬¬¬¬¬¬¬--| S NIL VOID VIRGIN¶¬  return;¶¬end if;¶¶¬if  DEBUG_PRETTY  then PUT_LINE( "print_if_not_structural" ); end if
;¶¶¬if  PRINT_STATUS( T.PG )( T.LN ) /= PRINT  then¶¬  PRINT_NON_STRUCT_ATTR( A_SUB, T, IND, PARENT );¶¬else¶¬  MAYBE_NO
N_STRUCT_ATTR( A_SUB, T, IND, PARENT, GRAND_PARENT );¶¬end if;¶¶        end¬PRINT_IF_NOT_STRUCTURAL;¶¬¬-----------------
------¶¶      begin¶        if  DEBUG_PRETTY  then PUT_LINE( "traiter_les_descendants" ); end if;¶¶        if  (T.PT = P
  or  T.PT = L)  and then  T.TY in CLASS_ALL_SOURCE  then¶¬if  ARITY( T ) = ARBITRARY  then¬¬¬¬¬¬¬¬--| UN ELEMENT DE LIS
TE¶¬  NB_STRUC_CHILD := 1;¬¬¬¬¬¬¬¬¬--| UN SEUL ELEMENT STRUCTUREL D'ARBRE SYNTAXIQUE¶¬else¶¬  NB_STRUC_CHILD := ARITIES'
POS( ARITY( T ) );¬¬¬¬¬¬¬--| AUTANT D'ELEMENTS STRUCTURELS QUE L'ARITE L'INDIQUE¶¬end if;¶        end if;¶¬  ¶        fo
r  I in 1 .. NB_STRUC_CHILD  loop¬¬¬¬¬¬¬¬--| S'OCCUPER DES DESCENDANTS DE STRUCTURE SYNTAXIQUE (EVENTUELLEMENT)¶¬if  A_S
PEC( A_SUB + INTEGER(I) - 1 ).ATTR /= LX_SRCPOS  then¬¬¬¬¬--| SI PAS UN SRCPOS¶¬  MAYBE_NON_STRUCT_ATTR( A_SUB + INTEGER
( I ) - 1, DABS ( I, T ), IND, T, PARENT );¶¬end if;¶        end loop;¶¬ ¶        for  I in NB_STRUC_CHILD + 1 .. N_SPEC
( T.TY ).NS_SIZE  loop¬¬¬¬¬¬--| APRES LES CHAMPS COMPRIS DANS L'ARITE SYNTAXIQUE D'AUTRE CHAMPS EVENTUELS¶¬if  A_SPEC( A
_SUB + INTEGER( I ) - 1 ).ATTR /= LX_SRCPOS  then¬¬¬¬¬--| SI PAS UN SRCPOS¶¬  PRINT_IF_NOT_STRUCTURAL( A_SUB + INTEGER( 
I ) - 1, DABS ( I, T ), IND, T, PARENT );¶¬end if;¶        end loop;¶¶      end¬¬¬TRAITER_LES_DESCENDANTS;¶¬¬¬----------
-------------¶         ¶      if  DEBUG_PRETTY  then PUT_LINE( "print_diana ok" ); end if;¶¶    end¬PRINT_DIANA;¶¬------
-----¶      ¶  begin¶¶    PUT_LINE( "TREE_ROOT=" );    print_node( TREE_ROOT );¶    PUT_LINE( "USER_ROOT=" );    print_n
ode( USER_ROOT );¶¶    MARK_STRUCT( COMPLTN_STRUCT );¬¬¬¬¬¬¬--| MARQUER LES NOEUDS DE CLASS_ALL_SOURCE¶    PRINT_DIANA( 
COMPLTN_STRUCT, 0, TREE_VOID );¶    NEW_LINE;¶¶  end¬IMPRIME;¶¬-------¶¶begin¶  OPEN_IDL_TREE_FILE( IDL.LIB_PATH( 1..LIB
_PATH_LENGTH ) & "$$$.TMP" );¬¬¬--| OUVRIR LE FICHIER ARBRE TEMPORAIRE¶  CREATE( OFILE, OUT_FILE,"$$$_TREE.TXT" );¬¬¬¬¬¬
--| CREER LE FICHIER IMPRESSION DE L'ARBRE¶  SET_OUTPUT( OFILE );¬¬¬¬¬¬¬¬--| REDIRIGER LA SORTIE STANDARD VERS LE FICHIE
R IMPRESSION¶  IMPRIME;¬¬¬¬¬¬¬¬¬--| IMPRIMER L'ARBRE¶  SET_OUTPUT( STANDARD_OUTPUT );¬¬¬¬¬¬¬--| REPOSITIONNER LA SORTIE 
STANDARD¶  CLOSE( OFILE );¬¬¬¬¬¬¬¬¬--| FERMER LE FICHIER IMPRESSION¶  CLOSE_IDL_TREE_FILE;¬¬¬¬¬¬¬¬--| FERMER LE FICHIER 
ARBRE¶      ¶exception¶  when others => ¬¬¬¬¬¬¬¬¬--| POUR TOUT PROBLEME¶    SET_OUTPUT( STANDARD_OUTPUT );¬¬¬¬¬¬¬--| REP
OSITIONNER LA SORTIE STANDARD¶    CLOSE( OFILE );¬¬¬¬¬¬¬¬¬--| FERMER LE FICHIER IMPRESSION¶    CLOSE_IDL_TREE_FILE;¬¬¬¬¬
¬¬¬--| FERMER LE FICHIER ARBRE¶    raise;¶end PRETTY_DIANA;¶
