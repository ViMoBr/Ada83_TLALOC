separate (IDL.SEM_PHASE)¶    --|----------------------------------------------------------------------------------------
------¶    --| STM_WALK¶    --|-----------------------------------------------------------------------------------------
-----¶package body STM_WALK is¶  use DEF_UTIL;¶  use VIS_UTIL;¶  use SET_UTIL;¶  use REQ_UTIL;¶  use EXP_TYPE, EXPRESO;¶
  use SEM_GLOB;¶  use NOD_WALK;¶  use MAKE_NOD;¶  use RED_SUBP;¶  use DEF_WALK;¶¶        -- COUNT USED TO GENERATE UNIQU
E NAMES FOR BLOCKS AND LOOPS WITHOUT NAMES¶  GEN_BLOCK_LOOP_COUNT : Natural := 0;¶¶        -----------------------------
-------------------------------------------¶        --              DECLARE_LABEL_BLOCK_LOOP_IDS                        
      --¶        ------------------------------------------------------------------------¶¶  procedure DECLARE_ONE_LABEL
_BLOCK_LOOP_ID (SOURCE_NAME : TREE; STM : TREE; H : H_TYPE);¶¶  procedure CHECK_DUMMY_BLOCK_LOOP_NAME (ID : TREE; PREFIX
_TEXT : String);¶  function TRIM (A : String) return String;¶¶  procedure DECLARE_LABEL_BLOCK_LOOP_IDS (STM_S : TREE; H 
: H_TYPE) is¶                -- FOR A SEQUENCE OF STATEMENTS, SCAN FOR LABEL_ID'S AND¶                -- ... BLOCK_LOOP_
ID'S AND CREATE DEF NODES FOR THEM. (LABEL_IS'S¶                -- ... AND BLOCK_LOOP_ID'S ARE IMPLICITLY DECLARED AT TH
E END¶                -- ... OF THE DECLARATIVE PART OF A BLOCK OR UNIT)¶¶    STM_LIST : SEQ_TYPE := LIST (STM_S);¶    S
TM      : TREE;¶  begin¶¶                -- FOR EACH STATEMENT IN THE STM_S¶    while not IS_EMPTY (STM_LIST) loop¶     
 POP (STM_LIST, STM);¶¶                        -- IF THIS STATEMENT HAS LABELS¶      if STM.TY = DN_LABELED then¶       
 declare¶          SOURCE_NAME_S : constant TREE := D (AS_SOURCE_NAME_S, STM);¶          STM_NODE      : constant TREE :
= D (AS_STM, STM);¶¶          SOURCE_NAME_LIST : SEQ_TYPE := LIST (SOURCE_NAME_S);¶          SOURCE_NAME      : TREE;¶  
      begin¶                                        -- FOR EACH LABEL ON THIS STATEMENT¶          while not IS_EMPTY (SO
URCE_NAME_LIST) loop¶            POP (SOURCE_NAME_LIST, SOURCE_NAME);¶¶                                                -
- DEFINE THE LABEL¶            DECLARE_ONE_LABEL_BLOCK_LOOP_ID (SOURCE_NAME, STM_NODE, H);¶          end loop;¶¶        
                                -- STRIP LABELS FROM THE STATEMENT¶          STM := STM_NODE;¶        end;¶      end if;
¶¶                        -- STM NOW HAS LABELS STRIPPED OFF¶                        -- DEFINE BLOCK AND LOOP NAMES¶    
                    --       AND SCAN SUBORDINATE STATEMENTS FOR LABELS AND NAMES¶¶      case STM.TY is¶¶               
                 -- FOR A CASE STATEMENT¶        when DN_CASE =>¶          declare¶            ALTERNATIVE_S : constant 
TREE := D (AS_ALTERNATIVE_S, STM);¶¶            ALTERNATIVE_LIST : SEQ_TYPE := LIST (ALTERNATIVE_S);¶            ALTERNA
TIVE      : TREE;¶          begin¶¶                                                -- FOR EACH ALTERNATIVE¶            w
hile not IS_EMPTY (ALTERNATIVE_LIST) loop¶              POP (ALTERNATIVE_LIST, ALTERNATIVE);¶¶                          
                              -- IF IT IS AN ALTERNATIVE (RATHER THAN A PRAGMA)¶              if ALTERNATIVE.TY = DN_ALT
ERNATIVE then¶¶                                                                -- SCAN FOR LABELS IN THE SEQUENCE OF STA
TEMENTS¶                DECLARE_LABEL_BLOCK_LOOP_IDS (D (AS_STM_S, ALTERNATIVE), H);¶              end if;¶            e
nd loop;¶          end;¶¶                                -- FOR AN ACCEPT STATEMENT¶        when DN_ACCEPT =>¶          
declare¶            STM_S : constant TREE := D (AS_STM_S, STM);¶          begin¶                                        
        -- SCAN FOR LABELS IN THE SEQUENCE OF STATEMENTS¶            DECLARE_LABEL_BLOCK_LOOP_IDS (STM_S, H);¶          
end;¶¶                                -- FOR A LOOP STATEMENT¶        when DN_LOOP =>¶          declare¶            SOUR
CE_NAME : constant TREE := D (AS_SOURCE_NAME, STM);¶            SOURCE_DEF  : TREE;¶            STM_S       : constant T
REE := D (AS_STM_S, STM);¶          begin¶                                                -- MAKE SURE THERE IS A NAME¶ 
           CHECK_DUMMY_BLOCK_LOOP_NAME (SOURCE_NAME, "LOOP__");¶¶                                                -- DEFI
NE THE LABEL¶            DECLARE_ONE_LABEL_BLOCK_LOOP_ID (SOURCE_NAME, STM, H);¶            SOURCE_DEF := GET_DEF_FOR_ID
 (SOURCE_NAME);¶¶                                                -- SCAN FOR LABELS IN THE SEQUENCE OF STATEMENTS¶      
      DECLARE_LABEL_BLOCK_LOOP_IDS (STM_S, H);¶          end;¶¶                                -- FOR A BLOCK STATEMENT¶
        when DN_BLOCK =>¶          declare¶            SOURCE_NAME : constant TREE := D (AS_SOURCE_NAME, STM);¶         
   BLOCK_BODY  : constant TREE := D (AS_BLOCK_BODY, STM);¶          begin¶                                              
  -- MAKE SURE THERE IS A NAME¶            CHECK_DUMMY_BLOCK_LOOP_NAME (SOURCE_NAME, "BLOCK__");¶¶                      
                          -- DEFINE THE LABEL¶            DECLARE_ONE_LABEL_BLOCK_LOOP_ID (SOURCE_NAME, STM, H);¶       
   end;¶¶                                -- FOR A CONDITIONAL ENTRY CALL OR TIMED ENTRY CALL¶        when DN_COND_ENTRY 
| DN_TIMED_ENTRY =>¶          declare¶            STM_S1 : constant TREE := D (AS_STM_S1, STM);¶            STM_S2 : con
stant TREE := D (AS_STM_S2, STM);¶          begin¶                                                -- SCAN FOR LABELS IN 
BOTH SEQUENCES OF STATEMENTS¶            DECLARE_LABEL_BLOCK_LOOP_IDS (STM_S1, H);¶            DECLARE_LABEL_BLOCK_LOOP_
IDS (STM_S2, H);¶          end;¶¶                                -- FOR AN IF STATEMENT OR A SELECTIVE WAIT STATEMENT¶  
      when DN_IF | DN_SELECTIVE_WAIT =>¶          declare¶            TEST_CLAUSE_ELEM_S : constant TREE := D (AS_TEST_C
LAUSE_ELEM_S, STM);¶            STM_S              : constant TREE := D (AS_STM_S, STM);¶¶            TEST_CLAUSE_ELEM_L
IST : SEQ_TYPE := LIST (TEST_CLAUSE_ELEM_S);¶            TEST_CLAUSE_ELEM      : TREE;¶          begin¶¶                
                                -- FOR EACH TEST_CLAUSE_ELEM¶            while not IS_EMPTY (TEST_CLAUSE_ELEM_LIST) loop
¶              POP (TEST_CLAUSE_ELEM_LIST, TEST_CLAUSE_ELEM);¶¶                                                        -
- IF IT IS A TEST_CLAUSE (RATHER THAN A PRAGMA)¶              if TEST_CLAUSE_ELEM.TY in CLASS_TEST_CLAUSE then¶¶        
                                                        -- SCAN FOR LABELS IN THE SEQUENCE OF STATEMENTS¶               
 DECLARE_LABEL_BLOCK_LOOP_IDS (D (AS_STM_S, TEST_CLAUSE_ELEM), H);¶              end if;¶            end loop;¶¶        
                                        -- SCAN FOR LABELS IN THE IF/WAIT SEQUENCE OF STATEMENTS¶            DECLARE_LAB
EL_BLOCK_LOOP_IDS (STM_S, H);¶          end;¶¶        when others =>¶          null;¶      end case;¶    end loop;¶  end
 DECLARE_LABEL_BLOCK_LOOP_IDS;¶¶  procedure DECLARE_ONE_LABEL_BLOCK_LOOP_ID (SOURCE_NAME : TREE; STM : TREE; H : H_TYPE)
 is¶                -- (CALLED ONLY BY DECLARE_LABEL_BLOCK_LOOP_IDS)¶                -- CREATES DEF NODE FOR THE SOURCE 
NAME AND SETS ITS SM_STM¶                -- ... ATTRIBUTE TO THE STATEMENT REFERRED TO¶¶    SOURCE_DEF : TREE := MAKE_DE
F_FOR_ID (SOURCE_NAME, H);¶  begin¶    MAKE_DEF_VISIBLE (SOURCE_DEF);¶    D (SM_STM, SOURCE_NAME, STM);¶  end DECLARE_ON
E_LABEL_BLOCK_LOOP_ID;¶¶  procedure CHECK_DUMMY_BLOCK_LOOP_NAME (ID : TREE; PREFIX_TEXT : String) is¶  begin¶    if D (L
X_SYMREP, ID) = TREE_VOID then¶      GEN_BLOCK_LOOP_COUNT := GEN_BLOCK_LOOP_COUNT + 1;¶      D (LX_SYMREP, ID, STORE_SYM
 (PREFIX_TEXT & TRIM (Integer'IMAGE (GEN_BLOCK_LOOP_COUNT))));¶    end if;¶  end CHECK_DUMMY_BLOCK_LOOP_NAME;¶¶  functio
n TRIM (A : String) return String is¶    FIRST : Natural := A'FIRST;¶    LAST  : Natural := A'LAST;¶  begin¶    while LA
ST > 0 and then (A (LAST) = ' ' or A (LAST) = ASCII.HT) loop¶      LAST := LAST - 1;¶    end loop;¶    if LAST >= FIRST 
then¶      while A (FIRST) = ' ' or A (FIRST) = ASCII.HT loop¶        FIRST := FIRST + 1;¶      end loop;¶    end if;¶  
  declare¶      RESULT : String (1 .. LAST - FIRST + 1) := A (FIRST .. LAST);¶    begin¶      return RESULT;¶    end;¶  
end TRIM;¶¶        ------------------------------------------------------------------------¶        --              WALK
_STM_S                                                --¶        -------------------------------------------------------
-----------------¶¶  procedure WALK_STM_S (STM_S : TREE; H : H_TYPE) is¶    STM_LIST : SEQ_TYPE := LIST (STM_S);¶    STM
      : TREE;¶¶    NEW_STM_LIST : SEQ_TYPE := (TREE_NIL, TREE_NIL);¶  begin¶                -- FOR EACH STM IN THE SEQUE
NCE OF STATEMENTS¶    while not IS_EMPTY (STM_LIST) loop¶      POP (STM_LIST, STM);¶¶                        -- WALK THE
 STATEMENT AND ADD TO NEW STATEMENT LIST¶      NEW_STM_LIST := APPEND (NEW_STM_LIST, WALK_STM (STM, H));¶    end loop;¶¶
                -- REPLACE STATEMENT LIST WITH NEW STATEMENT LIST¶    LIST (STM_S, NEW_STM_LIST);¶  end WALK_STM_S;¶¶   
     ------------------------------------------------------------------------¶        --              WALK_ALTERNATIVE_S
                                        --¶        ---------------------------------------------------------------------
---¶¶  procedure WALK_ALTERNATIVE_S (ALTERNATIVE_S : TREE; H : H_TYPE) is¶    ALTERNATIVE_LIST : SEQ_TYPE;¶    ALTERNATI
VE_ELEM : TREE;¶¶    CHOICE_S    : TREE;¶    CHOICE_LIST : SEQ_TYPE;¶    CHOICE      : TREE;¶    CHOICE_EXP  : TREE;¶   
 STM_S       : TREE;¶  begin¶                -- IF THERE IS NO EXCEPTION PART¶    if ALTERNATIVE_S = TREE_VOID then¶¶   
                     -- DO NOTHING AND RETURN¶      return;¶    end if;¶¶                -- FOR EACH ELEMENT OF THE ALTE
RNATIVE LIST¶    ALTERNATIVE_LIST := LIST (ALTERNATIVE_S);¶    while not IS_EMPTY (ALTERNATIVE_LIST) loop¶      POP (ALT
ERNATIVE_LIST, ALTERNATIVE_ELEM);¶¶                        -- IF IT IS AN ALTERNATIVE¶      if ALTERNATIVE_ELEM.TY = DN_
ALTERNATIVE then¶¶                                -- FOR EACH CHOICE¶        CHOICE_S    := D (AS_CHOICE_S, ALTERNATIVE_
ELEM);¶        CHOICE_LIST := LIST (CHOICE_S);¶        while not IS_EMPTY (CHOICE_LIST) loop¶          POP (CHOICE_LIST,
 CHOICE);¶¶                                        -- IF IT IS AN OTHERS CHOICE¶          if CHOICE.TY = DN_CHOICE_OTHER
S then¶¶                                                -- NOTHING TO DO¶            null;¶¶                            
                    -- ELSE IF IT IS AN EXPRESSION CHOICE¶          elsif CHOICE.TY = DN_CHOICE_EXP then¶¶              
                                  -- RESOLVE EXCEPTION NAME¶            CHOICE_EXP := D (AS_EXP, CHOICE);¶            CH
OICE_EXP := WALK_NAME (DN_EXCEPTION_ID, CHOICE_EXP);¶            D (AS_EXP, CHOICE, CHOICE_EXP);¶¶                      
                          -- ELSE¶          else¶¶                                                -- IT CANNOT BE A VALI
D CHOICE¶            ERROR (D (LX_SRCPOS, CHOICE), "INVALID CHOICE");¶          end if;¶¶                               
         -- WALK THE STATEMENT SEQUENCE¶        end loop;¶        STM_S := D (AS_STM_S, ALTERNATIVE_ELEM);¶        WALK_
STM_S (STM_S, H);¶¶                                -- ELSE -- SINCE IT MUST BE A PRAGMA¶      else¶¶                    
            -- WALK THE PRAGMA¶        WALK (D (AS_PRAGMA, ALTERNATIVE_ELEM), H);¶¶      end if;¶    end loop;¶¶  end WA
LK_ALTERNATIVE_S;¶¶        ------------------------------------------------------------------------¶        --          
    WALK_STM                                                  --¶        -----------------------------------------------
-------------------------¶¶  function WALK_STM (STM_IN : TREE; H : H_TYPE) return TREE is¶    STM      : TREE      := ST
M_IN;¶    STM_KIND : NODE_NAME := STM.TY;¶  begin¶¶    if STM_KIND not in CLASS_STM_ELEM then¶      Put_Line ("WALK_STM:
 NOT A STM_ELEM NODE");¶      raise Program_Error;¶    end if;¶¶    case CLASS_STM_ELEM'(STM_KIND) is¶¶                 
       -- FOR TERMINATE OR NULL STATEMENT¶      when DN_TERMINATE | DN_NULL_STM =>¶¶                                -- N
OTHING NEEDS TO BE DONE¶        null;¶¶                        -- FOR A LABELED STATEMENT¶      when DN_LABELED =>¶     
   declare¶                                        --SOURCE_NAME_S: CONSTANT TREE := D(AS_SOURCE_NAME_S, STM);¶         
 PRAGMA_S : constant TREE := D (AS_PRAGMA_S, STM);¶          STM_NODE : TREE          := D (AS_STM, STM);¶        begin¶
                                        -- $$$$ NEED TO CHECK FOR DUPLICATE DEF IN UNIT¶                                
        --WALK(SOURCE_NAME_S, H);¶¶                                        -- WALK PRAGMAS BETWEEN THE LABELS AND THE ST
ATEMENT¶          WALK_ITEM_S (PRAGMA_S, H);¶¶                                        -- WALK THE STATEMENT¶          ST
M_NODE := WALK_STM (STM_NODE, H);¶          D (AS_STM, STM, STM_NODE);¶        end;¶¶                        -- FOR AN A
BORT STATEMENT¶      when DN_ABORT =>¶        declare¶          NAME_S : constant TREE := D (AS_NAME_S, STM);¶¶         
 NAME_LIST     : SEQ_TYPE := LIST (NAME_S);¶          NAME          : TREE;¶          TYPESET       : TYPESET_TYPE;¶    
      NEW_NAME_LIST : SEQ_TYPE := (TREE_NIL, TREE_NIL);¶        begin¶                                        -- FOR EAC
H NAME IN THE SEQUENCE OF NAMES¶          while not IS_EMPTY (NAME_LIST) loop¶            POP (NAME_LIST, NAME);¶¶      
                                          -- PROCESS THE NAME¶            EVAL_EXP_TYPES (NAME, TYPESET);¶            RE
QUIRE_TASK_TYPE (NAME, TYPESET);¶            REQUIRE_UNIQUE_TYPE (NAME, TYPESET);¶            NAME := RESOLVE_EXP (NAME,
 TYPESET);¶¶                                                -- ADD TO NEW NAME LIST¶            NEW_NAME_LIST := APPEND 
(NEW_NAME_LIST, NAME);¶¶                                                -- REPLACE NAME LIST WITH NEW NAME LIST¶        
  end loop;¶          LIST (NAME_S, NEW_NAME_LIST);¶        end;¶¶                        -- FOR A RETURN STATEMENT¶    
  when DN_RETURN =>¶        declare¶          EXP : TREE := D (AS_EXP, STM);¶¶          TYPESET : TYPESET_TYPE;¶        
begin¶¶                                        -- IF AN EXPRESSION IS GIVEN¶          if EXP /= TREE_VOID then¶¶        
                                        -- $$$$ CHECK THAT IT IS WITHIN A FUNCTION¶¶                                    
            -- RESOLVE THE EXPRESSION¶            EVAL_EXP_TYPES (EXP, TYPESET);¶            REQUIRE_TYPE (H.RETURN_TYPE
, EXP, TYPESET);¶            EXP := RESOLVE_EXP (EXP, TYPESET);¶            D (AS_EXP, STM, EXP);¶¶                     
                           -- $$$$ ELSE -- SINCE THERE IS NO EXPRESSION GIVEN¶¶                                         
       -- $$$$ CHECK THAT IT IS NOT WITHIN A FUNCTION¶¶          end if;¶        end;¶¶                        -- FOR A 
DELAY STATEMENT¶      when DN_DELAY =>¶        declare¶          EXP : TREE := D (AS_EXP, STM);¶¶          TYPESET : TYP
ESET_TYPE;¶        begin¶¶                                        -- REQUIRE EXPRESSION TO BE OF TYPE DURATION¶         
 EVAL_EXP_TYPES (EXP, TYPESET);¶          REQUIRE_TYPE (GET_BASE_TYPE (PREDEFINED_DURATION), EXP, TYPESET);¶          EX
P := RESOLVE_EXP (EXP, TYPESET);¶          D (AS_EXP, STM, EXP);¶        end;¶¶                        -- FOR AN ASSIGNM
ENT STATEMENT¶      when DN_ASSIGN =>¶        declare¶          EXP  : TREE := D (AS_EXP, STM);¶          NAME : TREE :=
 D (AS_NAME, STM);¶¶          NAME_TYPESET : TYPESET_TYPE;¶          EXP_TYPESET  : TYPESET_TYPE;¶          TYPESET     
 : TYPESET_TYPE;¶        begin¶                                        -- REQUIRE SAME NONLIMITED TYPE¶          EVAL_EX
P_TYPES (NAME, NAME_TYPESET);¶          EVAL_EXP_TYPES (EXP, EXP_TYPESET);¶          REQUIRE_NONLIMITED_TYPE (NAME, NAME
_TYPESET);¶          REQUIRE_SAME_TYPES (NAME, NAME_TYPESET, EXP, EXP_TYPESET, TYPESET);¶¶                              
          -- RESOLVE EXP¶          EXP := RESOLVE_EXP (EXP, TYPESET);¶          D (AS_EXP, STM, EXP);¶¶                 
                       -- RESOLVE NAME¶          NAME := RESOLVE_EXP (NAME, TYPESET);¶          D (AS_NAME, STM, NAME);¶
¶                                        -- $$$$ NEED TO CHECK THAT NAME CAN BE ASSIGNED TO¶        end;¶¶              
          -- FOR AN EXIT STATEMENT¶      when DN_EXIT =>¶        declare¶          EXP  : TREE := D (AS_EXP, STM);¶     
     NAME : TREE := D (AS_NAME, STM);¶¶          TYPESET : TYPESET_TYPE;¶          LOOP_ID : TREE;¶        begin¶       
                                 -- IF AN EXPRESSION IS GIVEN¶          if EXP /= TREE_VOID then¶¶                      
                          -- REQUIRE SOME BOOLEAN TYPE¶            EVAL_EXP_TYPES (EXP, TYPESET);¶            REQUIRE_BO
OLEAN_TYPE (EXP, TYPESET);¶            EXP := RESOLVE_EXP (EXP, TYPESET);¶            D (AS_EXP, STM, EXP);¶          en
d if;¶¶                                        -- IF A LOOP NAME IS GIVEN¶          if NAME /= TREE_VOID then¶¶         
                                       -- REQUIRE A BLOCK_LOOP_ID FOR ENCLOSING LOOP¶            NAME    := WALK_NAME (D
N_BLOCK_LOOP_ID, NAME);¶            LOOP_ID := D (SM_DEFN, NAME);¶¶                                                -- $$
$$ CHECK THAT IT IS AN ENCLOSING LOOP¶¶                                                -- ELSE -- SINCE NO LOOP NAME IS 
GIVEN¶          else¶¶                                                -- USE ID OF ENCLOSING LOOP¶            LOOP_ID :=
 H.ENCLOSING_LOOP_ID;¶¶                                                -- CHECK THAT THERE IS ONE¶            if LOOP_ID
 = TREE_VOID then¶              ERROR (D (LX_SRCPOS, STM), "EXIT STATEMENT NOT IN A LOOP");¶            end if;¶        
  end if;¶¶                                        -- IF THE PROPER ENCLOSING LOOP HAS BEEN FOUND¶          if LOOP_ID /
= TREE_VOID then¶¶                                                -- COPY POINTER TO THE LOOP STM INTO THE EXIT STM¶    
        D (SM_STM, STM, D (SM_STM, LOOP_ID));¶          end if;¶        end;¶¶                        -- FOR A CODE STAT
EMENT¶      when DN_CODE =>¶        declare¶        begin¶null;¶                                        -- ERROR -- NOT 
SUPPORTED¶--          ERROR (D (LX_SRCPOS, STM), "CODE STATEMENT NOT SUPPORTED");¶        end;¶¶                        
-- FOR A CASE STATEMENT¶      when DN_CASE =>¶        declare¶          EXP           : TREE          := D (AS_EXP, STM)
;¶          ALTERNATIVE_S : constant TREE := D (AS_ALTERNATIVE_S, STM);¶¶          TYPESET       : TYPESET_TYPE;¶       
   REQUIRED_TYPE : TREE;¶¶          ALTERNATIVE_LIST : SEQ_TYPE := LIST (ALTERNATIVE_S);¶          ALTERNATIVE      : TR
EE;¶¶        begin¶¶                                        -- RESOLVE CASE EXPRESSION (A COMPLETE CONTEXT)¶          EV
AL_EXP_TYPES (EXP, TYPESET);¶          REQUIRE_DISCRETE_TYPE (EXP, TYPESET);¶                                        -- 
$$$$ REQUIRE_NOT_GENERIC_FORMAL_TYPE(EXP, TYPESET);¶                                        -- ???? IS THIS USED IN OVER
LOAD RESOLUTION?¶          REQUIRE_UNIQUE_TYPE (EXP, TYPESET);¶          REQUIRED_TYPE := GET_THE_TYPE (TYPESET);¶      
    EXP           := RESOLVE_EXP (EXP, REQUIRED_TYPE);¶          D (AS_EXP, STM, EXP);¶¶                                
        -- FOR EACH ELEMENT OF THE ALTERNATIVE LIST¶          while not IS_EMPTY (ALTERNATIVE_LIST) loop¶            POP
 (ALTERNATIVE_LIST, ALTERNATIVE);¶¶                                                -- IF IT IS A PRAGMA¶            if A
LTERNATIVE.TY = DN_ALTERNATIVE_PRAGMA then¶¶                                                        -- WALK THE PRAGMA¶ 
             WALK (D (AS_PRAGMA, ALTERNATIVE), H);¶¶                                                        -- ELSE -- S
INCE IT MUST BE AN ALTERNATIVE¶            else¶¶                                                        -- WALK THE LIS
T OF CHOICES¶              WALK_DISCRETE_CHOICE_S (D (AS_CHOICE_S, ALTERNATIVE), REQUIRED_TYPE);¶¶                      
                                  -- WALK THE SEQUENCE OF STATEMENTS FOR THIS CHOICE¶              WALK_STM_S (D (AS_STM
_S, ALTERNATIVE), H);¶            end if;¶          end loop;¶¶                                        -- $$$$ CHECK THA
T CHOICES ARE COMPLETE AND NOT OVERLAPPING¶        end;¶¶                        -- FOR A GOTO STATEMENT¶      when DN_G
OTO =>¶        declare¶          NAME : TREE := D (AS_NAME, STM);¶¶        begin¶¶                                      
  -- EVALUATE THE LABEL NAME¶          NAME := WALK_NAME (DN_LABEL_ID, NAME);¶          D (AS_NAME, STM, NAME);¶¶       
                                 -- $$$$ CHECK THAT GOTO TARGET IS LEGAL¶        end;¶¶                        -- FOR A 
RAISE STATEMENT¶      when DN_RAISE =>¶        declare¶          NAME : TREE := D (AS_NAME, STM);¶        begin¶¶       
                                 -- IF AN EXCEPTION NAME IS GIVEN¶          if NAME /= TREE_VOID then¶¶                 
                               -- EVALUATE THE EXCEPTION NAME¶            NAME := WALK_NAME (DN_EXCEPTION_ID, NAME);¶   
         D (AS_NAME, STM, NAME);¶          end if;¶        end;¶¶                        -- FOR AN ENTRY CALL OR A PROCE
DURE CALL¶      when DN_PROCEDURE_CALL | DN_ENTRY_CALL =>¶        declare¶          NAME            : TREE          := D
 (AS_NAME, STM);¶          GENERAL_ASSOC_S : constant TREE := D (AS_GENERAL_ASSOC_S, STM);¶¶          INDEX_LIST     : S
EQ_TYPE;¶          INDEX          : TREE := TREE_VOID;¶          INDEX_TYPESET  : TYPESET_TYPE;¶          DISCRETE_RANGE
 : TREE;¶¶          NAME_DEFSET : DEFSET_TYPE;¶          NAME_ID     : TREE;¶        begin¶                             
           -- IF CALL IS OF THE FORM ...(...)(...)¶          if NAME.TY = DN_FUNCTION_CALL then¶¶                       
                         -- SYNTAX ONLY ALLOWS CALL OF MEMBER OF ENTRY FAMILY¶                                          
      -- SEPARATE THE INDEX FROM THE NAME¶            INDEX_LIST := LIST (D (AS_GENERAL_ASSOC_S, NAME));¶            POP
 (INDEX_LIST, INDEX);¶            NAME := D (AS_NAME, NAME);¶¶                                                -- IF THE 
INDEX HAS NAMED NOTATION¶            if INDEX.TY = DN_ASSOC then¶¶                                                      
  -- REPORT ERROR¶              ERROR (D (LX_SRCPOS, INDEX), "NAMED NOTATION FOR INDEX");¶¶                             
                           -- EVALUATE EXPRESSION TYPES ANYWAY¶              INDEX := D (AS_EXP, INDEX);¶              E
VAL_EXP_TYPES (INDEX, INDEX_TYPESET);¶¶                                                        -- AND THROW AWAY ALL INT
ERPRETATIONS OF THE INDEX¶              INDEX_TYPESET := EMPTY_TYPESET;¶¶                                               
         -- ELSE -- SINCE INDEX DOES NOT HAVE NAMED NOTATION¶            else¶¶                                         
               -- EVALUATE EXPRESSION TYPES¶              EVAL_EXP_TYPES (INDEX, INDEX_TYPESET);¶            end if;¶¶  
                                              -- IF THERE IS MORE THAN ONE INDEX EXPRESSION¶            if not IS_EMPTY 
(INDEX_LIST) then¶¶                                                        -- REPORT ERROR¶              ERROR (D (LX_SR
CPOS, INDEX), "MORE THAN ONE ENTRY INDEX");¶¶                                                        -- AND THROW AWAY A
LL INTERPRETATIONS OF THE INDEX¶              INDEX_TYPESET := EMPTY_TYPESET;¶            end if;¶¶                     
                           -- SAVE INDEX INTERPRETATIONS¶            STASH_TYPESET (INDEX, INDEX_TYPESET);¶          end
 if;¶¶                                        -- GET VISIBLE PROCEDURE OR ENTRY NAMES¶          FIND_VISIBILITY (NAME, N
AME_DEFSET);¶          if STM.TY = DN_ENTRY_CALL or INDEX /= TREE_VOID then¶            REQUIRE_ENTRY_DEF (NAME, NAME_DE
FSET);¶          else¶            REQUIRE_PROC_OR_ENTRY_DEF (NAME, NAME_DEFSET);¶          end if;¶¶                    
                    -- CHECK PARAMETERS OF VISIBLE NAMES¶          REDUCE_APPLY_NAMES (NAME, NAME_DEFSET, GENERAL_ASSOC_
S, INDEX);¶¶                                        -- REQUIRE UNIQUE NAME¶          REQUIRE_UNIQUE_DEF (NAME, NAME_DEFS
ET);¶          NAME_ID := GET_THE_ID (NAME_DEFSET);¶¶                                        -- IF IT IS AN ENTRY NAME¶ 
         if NAME_ID.TY = DN_ENTRY_ID then¶¶                                                -- FORCE STATEMENT TO BE AN E
NTRY CALL¶            if STM.TY /= DN_ENTRY_CALL then¶              STM := MAKE_ENTRY_CALL (LX_SRCPOS => D (LX_SRCPOS, S
TM), AS_NAME => NAME, AS_GENERAL_ASSOC_S => GENERAL_ASSOC_S);¶            end if;¶¶                                     
           -- IF IT IS THE NAME OF AN ENTRY FAMILY¶            DISCRETE_RANGE := D (AS_DISCRETE_RANGE, D (SM_SPEC, NAME_
ID));¶            if DISCRETE_RANGE /= TREE_VOID then¶¶                                                        -- IF THE
RE WAS NOT AN EXPLICIT PARAMETER LIST¶              if INDEX = TREE_VOID then¶¶                                         
                       -- THE (ONLY) PARAMETER IS THE INDEX¶                INDEX := HEAD (LIST (GENERAL_ASSOC_S));¶    
            LIST (GENERAL_ASSOC_S, (TREE_NIL, TREE_NIL));¶              end if;¶¶                                       
                 -- RESOLVE THE INDEX¶              INDEX := RESOLVE_EXP (INDEX, GET_BASE_TYPE (DISCRETE_RANGE));¶      
      end if;¶          end if;¶¶                                        -- RESOLVE THE NAME¶          if NAME_ID.TY = D
N_ENTRY_ID and then NAME.TY = DN_SELECTED and then D (XD_REGION, NAME_ID).TY = DN_TYPE_ID and then DI (XD_LEX_LEVEL, GET
_DEF_FOR_ID (NAME_ID)) > 0 then¶                                                -- DO NOT USE RESOLVE_NAME BECAUSE PREFI
X MIGHT BE A¶                                                -- FUNCTION CALL, INDICATING A MEMBER OF AN ARRAY OF TASKS¶
            declare¶              PREFIX        : TREE         := D (AS_NAME, NAME);¶              DESIGNATOR    : TREE 
        := D (AS_DESIGNATOR, NAME);¶              TASK_SPEC     : TREE         := D (SM_TYPE_SPEC, D (XD_REGION, NAME_ID
));¶              TYPESET       : TYPESET_TYPE := FETCH_TYPESET (PREFIX);¶              TYPEINTERP    : TYPEINTERP_TYPE;
¶              PREFIX_STRUCT : TREE;¶              NEW_TYPESET   : TYPESET_TYPE := EMPTY_TYPESET;¶            begin¶    
          while not IS_EMPTY (TYPESET) loop¶                POP (TYPESET, TYPEINTERP);¶                PREFIX_STRUCT := 
GET_BASE_STRUCT (GET_TYPE (TYPEINTERP));¶                if PREFIX_STRUCT = TASK_SPEC or else (¶PREFIX_STRUCT.TY = DN_AC
CESS and then GET_BASE_STRUCT (D (SM_DESIG_TYPE, PREFIX_STRUCT)) = TASK_SPEC) then¶                  ADD_TO_TYPESET (NEW
_TYPESET, TYPEINTERP);¶                end if;¶              end loop;¶              REQUIRE_UNIQUE_TYPE (PREFIX, NEW_TY
PESET);¶              PREFIX := RESOLVE_EXP (PREFIX, NEW_TYPESET);¶              D (AS_NAME, NAME, PREFIX);¶            
  DESIGNATOR := RESOLVE_NAME (DESIGNATOR, NAME_ID);¶              D (AS_DESIGNATOR, NAME, DESIGNATOR);¶              D (
SM_EXP_TYPE, NAME, TREE_VOID);¶            end;¶          else¶            NAME := RESOLVE_NAME (NAME, NAME_ID);¶       
   end if;¶¶          if INDEX /= TREE_VOID then¶            NAME := MAKE_INDEXED (AS_NAME => NAME, AS_EXP_S => MAKE_EXP
_S (LIST => SINGLETON (INDEX), LX_SRCPOS => D (LX_SRCPOS, INDEX)), SM_EXP_TYPE => TREE_VOID, LX_SRCPOS => D (LX_SRCPOS, 
NAME));¶          end if;¶          D (AS_NAME, STM, NAME);¶¶                                        -- RESOLVE PARAMETE
RS AND STORE NORMALIZED LIST¶          if IS_EMPTY (NAME_DEFSET) then¶            RESOLVE_ERRONEOUS_PARAM_S (GENERAL_ASS
OC_S);¶          else¶            D (SM_NORMALIZED_PARAM_S, STM, RESOLVE_SUBP_PARAMETERS (GET_DEF (HEAD (NAME_DEFSET)), 
GENERAL_ASSOC_S));¶          end if;¶        end;¶¶                        -- FOR AN ACCEPT STATEMENT¶      when DN_ACCE
PT =>¶        declare¶          NAME    : constant TREE := D (AS_NAME, STM);¶          PARAM_S : TREE          := D (AS_
PARAM_S, STM);¶          STM_S   : constant TREE := D (AS_STM_S, STM);¶¶          DESIGNATOR     : TREE := NAME;¶       
   INDEX          : TREE := TREE_VOID;¶          INDEX_TYPESET  : TYPESET_TYPE;¶          TEMP_ENTRY_DEF : TREE;¶       
   UNIT_DEF       : TREE := H.REGION_DEF;¶¶          PRIOR_ENTRY_DEF : TREE;¶¶          H : H_TYPE := WALK_STM.H;¶      
    S : S_TYPE;¶        begin¶                                        -- $$$$ MAKE SURE THERE IS A PARAM_S (SHOULD CHANG
E diana.idl)¶          if PARAM_S = TREE_VOID then¶            PARAM_S := MAKE_PARAM_S (LIST => (TREE_NIL, TREE_NIL));¶ 
           D (AS_PARAM_S, STM, PARAM_S);¶          end if;¶¶          if NAME.TY = DN_INDEXED then¶            INDEX := 
HEAD (LIST (D (AS_EXP_S, NAME)));¶            D (SM_EXP_TYPE, NAME, TREE_VOID);¶            DESIGNATOR := D (AS_NAME, NA
ME);¶            EVAL_EXP_TYPES (INDEX, INDEX_TYPESET);¶          end if;¶¶          while D (XD_SOURCE_NAME, UNIT_DEF).
TY = DN_BLOCK_LOOP_ID or else D (XD_SOURCE_NAME, UNIT_DEF).TY = DN_ENTRY_ID loop¶            UNIT_DEF := D (XD_REGION_DE
F, UNIT_DEF);¶          end loop;¶¶          H.REGION_DEF   := UNIT_DEF;¶          TEMP_ENTRY_DEF := MAKE_DEF_FOR_ID (MA
KE_ENTRY_ID (LX_SYMREP => D (LX_SYMREP, DESIGNATOR)), H);¶          ENTER_REGION (TEMP_ENTRY_DEF, H, S);¶               
                         --WALK_ITEM_S(PARAM_S, H);¶          FINISH_PARAM_S (PARAM_S, H);¶          if INDEX = TREE_VOI
D then¶            PRIOR_ENTRY_DEF := GET_PRIOR_HOMOGRAPH_DEF (TEMP_ENTRY_DEF, PARAM_S);¶          else¶            PRIO
R_ENTRY_DEF := GET_PRIOR_DEF (TEMP_ENTRY_DEF);¶            if PRIOR_ENTRY_DEF /= TREE_VOID and then D (XD_SOURCE_NAME, P
RIOR_ENTRY_DEF).TY = DN_ENTRY_ID then¶              declare¶                SOURCE_NAME    : TREE := D (XD_SOURCE_NAME, 
PRIOR_ENTRY_DEF);¶                DISCRETE_RANGE : TREE := D (AS_DISCRETE_RANGE, D (SM_SPEC, SOURCE_NAME));¶            
  begin¶                if DISCRETE_RANGE /= TREE_VOID then¶                  REQUIRE_TYPE (GET_BASE_TYPE (DISCRETE_RANG
E), INDEX, INDEX_TYPESET);¶                  INDEX := RESOLVE_EXP (INDEX, INDEX_TYPESET);¶                else¶         
         ERROR (D (LX_SRCPOS, INDEX), "ENTRY MUST BE AN ENTRY FAMILY");¶                  INDEX := RESOLVE_EXP (INDEX, T
REE_VOID);¶                end if;¶              end;¶              LIST (D (AS_EXP_S, NAME), SINGLETON (INDEX));¶      
      else¶              PRIOR_ENTRY_DEF := TREE_VOID;¶            end if;¶          end if;¶          if PRIOR_ENTRY_DE
F = TREE_VOID or else D (XD_SOURCE_NAME, PRIOR_ENTRY_DEF).TY /= DN_ENTRY_ID then¶            ERROR (D (LX_SRCPOS, DESIGN
ATOR), "NO ENTRY FOR ACCEPT");¶            MAKE_DEF_IN_ERROR (TEMP_ENTRY_DEF);¶            PRIOR_ENTRY_DEF := TEMP_ENTRY
_DEF;¶          elsif D (SM_SPEC, (D (XD_SOURCE_NAME, PRIOR_ENTRY_DEF))) = TREE_VOID then¶            WARNING (D (LX_SRC
POS, STM), "$$$$ SM-SPEC IS VOID - " & NODE_REP (D (XD_SOURCE_NAME, PRIOR_ENTRY_DEF)));¶            REMOVE_DEF_FROM_ENVI
RONMENT (TEMP_ENTRY_DEF);¶          else¶            D (SM_DEFN, DESIGNATOR, D (XD_SOURCE_NAME, PRIOR_ENTRY_DEF));¶     
       CONFORM_PARAMETER_LISTS (D (AS_PARAM_S, D (SM_SPEC, D (XD_SOURCE_NAME, PRIOR_ENTRY_DEF))), PARAM_S);¶            
REMOVE_DEF_FROM_ENVIRONMENT (TEMP_ENTRY_DEF);¶          end if;¶          LEAVE_REGION (TEMP_ENTRY_DEF, S);¶          H 
:= WALK_STM.H;¶¶          ENTER_BODY (PRIOR_ENTRY_DEF, H, S);¶          WALK_STM_S (STM_S, H);¶          LEAVE_BODY (PRI
OR_ENTRY_DEF, S);¶        end;¶¶                        -- FOR A LOOP STATEMENT¶      when DN_LOOP =>¶        declare¶  
        SOURCE_NAME : constant TREE := D (AS_SOURCE_NAME, STM);¶          ITERATION   : constant TREE := D (AS_ITERATION
, STM);¶          STM_S       : constant TREE := D (AS_STM_S, STM);¶¶          SOURCE_DEF : TREE := GET_DEF_FOR_ID (SOUR
CE_NAME);¶¶          H : H_TYPE := WALK_STM.H;¶          S : S_TYPE;¶        begin¶¶                                    
    -- $$$$ CHECK THAT LABEL IS NOT DUPLICATE IN UNIT¶¶          ENTER_BODY (SOURCE_DEF, H, S);¶          H.RETURN_TYPE 
:= WALK_STM.H.RETURN_TYPE;¶          if ITERATION.TY in CLASS_FOR_REV then¶            declare¶              ITERATION_I
D   : TREE := D (AS_SOURCE_NAME, ITERATION);¶              DISCRETE_RANGE : TREE := D (AS_DISCRETE_RANGE, ITERATION);¶¶ 
             ITERATION_ID_DEF : TREE := MAKE_DEF_FOR_ID (ITERATION_ID, H);¶              RANGE_TYPESET    : TYPESET_TYPE
;¶            begin¶              EVAL_NON_UNIVERSAL_DISCRETE_RANGE (DISCRETE_RANGE, RANGE_TYPESET);¶              DISCR
ETE_RANGE := RESOLVE_DISCRETE_RANGE (DISCRETE_RANGE, GET_THE_TYPE (RANGE_TYPESET));¶              D (AS_DISCRETE_RANGE, 
ITERATION, DISCRETE_RANGE);¶¶              if not IS_EMPTY (RANGE_TYPESET) then¶                MAKE_DEF_VISIBLE (ITERAT
ION_ID_DEF);¶                D (SM_OBJ_TYPE, ITERATION_ID, GET_SUBTYPE_OF_DISCRETE_RANGE (DISCRETE_RANGE));¶            
  else¶                MAKE_DEF_IN_ERROR (ITERATION_ID_DEF);¶              end if;¶            end;¶¶          elsif ITE
RATION.TY = DN_WHILE then¶            declare¶              EXP         : TREE := D (AS_EXP, ITERATION);¶              E
XP_TYPESET : TYPESET_TYPE;¶            begin¶              EVAL_EXP_TYPES (EXP, EXP_TYPESET);¶              REQUIRE_BOOL
EAN_TYPE (EXP, EXP_TYPESET);¶              REQUIRE_UNIQUE_TYPE (EXP, EXP_TYPESET);¶              EXP := RESOLVE_EXP (EXP
, GET_THE_TYPE (EXP_TYPESET));¶              D (AS_EXP, ITERATION, EXP);¶            end;¶          end if;¶¶           
                             -- MAKE THIS THE ENCLOSING LOOP STATEMENT¶          H.ENCLOSING_LOOP_ID := SOURCE_NAME;¶¶  
                                      -- WALK THE SEQUENCE OF STATEMENTS¶          WALK_STM_S (STM_S, H);¶¶             
                           -- LEAVE THE DECLARATIVE REGION¶          LEAVE_BODY (SOURCE_DEF, S);¶        end;¶¶         
               -- FOR A BLOCK STATEMENT¶      when DN_BLOCK =>¶        declare¶          SOURCE_NAME : constant TREE := 
D (AS_SOURCE_NAME, STM);¶          BLOCK_BODY  : constant TREE := D (AS_BLOCK_BODY, STM);¶¶          ITEM_S           : 
TREE := D (AS_ITEM_S, BLOCK_BODY);¶          STM_S            : TREE := D (AS_STM_S, BLOCK_BODY);¶          ALTERNATIVE_
S    : TREE := D (AS_ALTERNATIVE_S, BLOCK_BODY);¶          ALTERNATIVE_LIST : SEQ_TYPE;¶          ALTERNATIVE      : TRE
E;¶¶          SOURCE_DEF : TREE   := GET_DEF_FOR_ID (SOURCE_NAME);¶          H          : H_TYPE := WALK_STM.H;¶        
  S          : S_TYPE;¶        begin¶                                        -- $$$$ CHECK THAT LABEL IS NOT DUPLICATE I
N UNIT¶¶          ENTER_BODY (SOURCE_DEF, H, S);¶          H.RETURN_TYPE := WALK_STM.H.RETURN_TYPE;¶          WALK_ITEM_
S (ITEM_S, H);¶          if STM_S /= TREE_VOID then¶            DECLARE_LABEL_BLOCK_LOOP_IDS (STM_S, H);¶          end i
f;¶          if ALTERNATIVE_S = TREE_VOID then¶            ALTERNATIVE_LIST := (TREE_NIL, TREE_NIL);¶          else¶    
        ALTERNATIVE_LIST := LIST (ALTERNATIVE_S);¶          end if;¶          while not IS_EMPTY (ALTERNATIVE_LIST) loop
¶            POP (ALTERNATIVE_LIST, ALTERNATIVE);¶            if ALTERNATIVE.TY = DN_ALTERNATIVE then¶              DECL
ARE_LABEL_BLOCK_LOOP_IDS (D (AS_STM_S, ALTERNATIVE), H);¶            end if;¶          end loop;¶          if STM_S /= T
REE_VOID then¶            WALK_STM_S (STM_S, H);¶          end if;¶          WALK_ALTERNATIVE_S (ALTERNATIVE_S, H);¶    
      LEAVE_BODY (SOURCE_DEF, S);¶        end;¶¶                        -- FOR A CONDITIONAL ENTRY CALL OR A TIMED ENTRY
 CALL¶      when DN_COND_ENTRY | DN_TIMED_ENTRY =>¶        declare¶          STM_S1 : constant TREE := D (AS_STM_S1, STM
);¶          STM_S2 : constant TREE := D (AS_STM_S2, STM);¶        begin¶                                        -- WALK
 THE TWO SEQUENCES OF STATEMENTS¶          WALK_STM_S (STM_S1, H);¶          WALK_STM_S (STM_S2, H);¶        end;¶¶     
                   -- FOR AN IF STATEMENT¶      when DN_IF =>¶        declare¶          TEST_CLAUSE_ELEM_S : constant TR
EE := D (AS_TEST_CLAUSE_ELEM_S, STM);¶          STM_S              : constant TREE := D (AS_STM_S, STM);¶¶          COND
_CLAUSE_LIST : SEQ_TYPE := LIST (TEST_CLAUSE_ELEM_S);¶          COND_CLAUSE      : TREE;¶          EXP              : TR
EE;¶          TYPESET          : TYPESET_TYPE;¶        begin¶                                        -- FOR EACH COND_CL
AUSE¶          while not IS_EMPTY (COND_CLAUSE_LIST) loop¶            POP (COND_CLAUSE_LIST, COND_CLAUSE);¶¶            
                                    -- RESOLVE THE CONDITIONAL EXPRESSION¶            EXP := D( AS_EXP, COND_CLAUSE );¶ 
           EVAL_EXP_TYPES( EXP, TYPESET );¶            REQUIRE_BOOLEAN_TYPE( EXP, TYPESET );¶            REQUIRE_UNIQUE_
TYPE ( EXP, TYPESET );¶            EXP := RESOLVE_EXP ( EXP, GET_THE_TYPE( TYPESET ) );¶            D( AS_EXP, COND_CLAU
SE, EXP );¶¶                                                -- WALK THE SEQUENCE OF STATEMENTS¶            WALK_STM_S( D
( AS_STM_S, COND_CLAUSE ), H );¶¶                                                -- WALK THE (ELSE) SEQUENCE OF STATEMEN
TS¶          end loop;¶          WALK_STM_S (STM_S, H);¶        end;¶¶                        -- FOR A SELECTIVE WAIT¶  
    when DN_SELECTIVE_WAIT =>¶        declare¶          TEST_CLAUSE_ELEM_S : constant TREE := D (AS_TEST_CLAUSE_ELEM_S, 
STM);¶          STM_S              : TREE          := D (AS_STM_S, STM);¶¶          TEST_CLAUSE_LIST     : SEQ_TYPE := L
IST (TEST_CLAUSE_ELEM_S);¶          TEST_CLAUSE          : TREE;¶          NEW_TEST_CLAUSE_LIST : SEQ_TYPE := (TREE_NIL,
 TREE_NIL);¶          EXP                  : TREE;¶          TYPESET              : TYPESET_TYPE;¶          SELECT_ALT_P
RAGMA    : TREE;¶        begin¶                                        -- FOR EACH TEST_CLAUSE¶          while not IS_EM
PTY (TEST_CLAUSE_LIST) loop¶            POP (TEST_CLAUSE_LIST, TEST_CLAUSE);¶¶                                          
      -- IF IT IS A SELECT ALTERNATIVE¶            if TEST_CLAUSE.TY = DN_SELECT_ALTERNATIVE then¶¶                     
                                   -- IF THERE IS A WHEN CLAUSE¶              EXP := D (AS_EXP, TEST_CLAUSE);¶          
    if EXP /= TREE_VOID then¶¶                                                                -- RESOLVE THE CONDITIONAL
 EXPRESSION¶                EVAL_EXP_TYPES (EXP, TYPESET);¶                REQUIRE_BOOLEAN_TYPE (EXP, TYPESET);¶        
        REQUIRE_UNIQUE_TYPE (EXP, TYPESET);¶                EXP := RESOLVE_EXP (EXP, GET_THE_TYPE (TYPESET));¶          
      D (AS_EXP, TEST_CLAUSE, EXP);¶              end if;¶¶                                                        -- WA
LK THE SEQUENCE OF STATEMENTS¶              WALK_STM_S (D (AS_STM_S, TEST_CLAUSE), H);¶¶                                
                        -- ADD SELECT_ALTERNATIVE TO NEW LIST¶              NEW_TEST_CLAUSE_LIST := APPEND (NEW_TEST_CLA
USE_LIST, TEST_CLAUSE);¶¶                                                        -- ELSE -- SINCE IT IS A STM PRAGMA¶   
         else¶¶                                                        -- NOTE: PARSER GENERATES STM_PRAGMA INSTEAD¶    
                                                    -- ... OF SELECT_ALT PRAGMA TO AVOID LR(1) CONFLICT¶¶               
                                         -- CHANGE THE STM_PRAGMA TO A SELECT_ALT_PRAGMA¶              SELECT_ALT_PRAGMA
 := MAKE_SELECT_ALT_PRAGMA (LX_SRCPOS => D (LX_SRCPOS, TEST_CLAUSE), AS_PRAGMA => D (AS_PRAGMA, TEST_CLAUSE));¶¶        
                                                -- PROCESS THE PRAGMA¶              WALK (D (AS_PRAGMA, SELECT_ALT_PRAGM
A), H);¶¶                                                        -- ADD SELECT_ALT_PRAGMA TO NEW LIST¶              NEW_
TEST_CLAUSE_LIST := APPEND (NEW_TEST_CLAUSE_LIST, SELECT_ALT_PRAGMA);¶            end if;¶¶                             
                   -- REPLACE TEST_CLAUSE_LIST WITH NEW LIST¶          end loop;¶          LIST (TEST_CLAUSE_ELEM_S, NEW
_TEST_CLAUSE_LIST);¶¶                                        -- WALK THE (ELSE) SEQUENCE OF STATEMENTS¶          WALK_ST
M_S (STM_S, H);¶        end;¶¶                        -- FOR A PRAGMA IN A SEQUENCE OF STATEMENTS¶      when DN_STM_PRAG
MA =>¶        declare¶          PRAGMA_NODE : constant TREE := D (AS_PRAGMA, STM);¶        begin¶¶                      
                  -- WALK THE PRAGMA¶          WALK (PRAGMA_NODE, H);¶        end;¶¶      when others =>¶        Put_Lin
e ("INVALID AS STM NODE");¶        raise Program_Error;¶    end case;¶¶                -- RETURN THE NEW STATEMENT (MAYB
E PROCEDURE CHANGED TO ENTRY)¶    return STM;¶  end WALK_STM;¶¶   --|---------------------------------------------------
-------------------------------------------¶end STM_WALK;¶
