WITH GRMR_OPS, GRMR_TBL;턚SE  GRMR_OPS, GRMR_TBL;턘EPARATE( IDL )--|---------------------------------------------------
------------------------------------------------|촒ROCEDURE CHECK_GRMR--|---------------------------------------------
----------------------------------------------------턕ROCEDURE CHECK_GRMR ( NOM_TEXTE :STRING ) IS  USER_ROOTК: TREE;
  GR_STATE_SEQК: SEQ_TYPE;     STATEК: TREE;  STATE_NBRК: INTEGER;  TER_GO_COUNTК: INTEGER;  NONTER_GO_COUNTК
: INTEGER;  REDUCE_COUNTК: INTEGER;     REDUCE_NBR_TERSК: ARRAY (1 .. 6) OF INTEGER;  REDUCE_ITEMК: ARRAY (1 .. 6
) OF TREE;     TYPE SYLTBL_TYPEКIS RECORD땝К  STATE_NBR: INTEGER;땝К  REDUCEК: BOOLEAN;땝КEND RECORD;떰  SYLTBL
К: ARRAY (- INTEGER(170) .. 350) OF SYLTBL_TYPE;     ALT_SEM_TBLК: ARRAY (0 .. 700) OF INTEGER;        -- SEMANTICS
 FOR ALT (OR 0)     --|-----------------------------------------------------------------------------------------------
  --|촄UNCTION INTEGER_IMAGE  FUNCTION INTEGER_IMAGE ( V :INTEGER ) RETURN STRING IS  BEGIN    IF V < 0 THEN      R
ETURN '-' & INTEGER_IMAGE(- V);    ELSIF V >= 10 THEN      RETURN INTEGER_IMAGE ( V / 10 ) & INTEGER_IMAGE ( V MOD 10 
);    ELSE      RETURN "" & CHARACTER'VAL ( CHARACTER'POS ( '0' ) + V );    END IF;  END INTEGER_IMAGE;  --|-------
----------------------------------------------------------------------------------------  --|촒ROCEDURE SCAN_GRAMMAR  
PROCEDURE SCAN_GRAMMAR IS    STATE_SEQК: SEQ_TYPE:= GR_STATE_SEQ;    TER_GO_SUMК: INTEGERК:= 0;    NONTER_GO_SUM
: INTEGERК:= 0;    REDUCE_SUMК: INTEGERК:= 0;             --|----------------------------------------------------
-----------------------------------------    --|촒ROCEDURE SCAN_STATE    PROCEDURE SCAN_STATE IS      ITEM_SEQК: SEQ
_TYPE:= LIST ( STATE );      ITEMК: TREE;      SYL_SEQК: SEQ_TYPE;      SYLК: TREE;      SYL_NBRК: INTEGER;  
    RULEК: TREE;      GOTO_STATEК: TREE;               --|---------------------------------------------------------
----------------------------------      --|촒ROCEDURE CHECK_REDUCE      PROCEDURE CHECK_REDUCE ( ITEM :TREE ) IS     
           -- MARK SYMBOLS USED FOR REDUCE; CHECK FOR REDUCE-REDUCE CONFLICT        NBR_TERSК: INTEGERК:= 0;        
FOLLOW_SEQК: SEQ_TYPE:= LIST( D( XD_FOLLOW, ITEM ) );        TERК: TREE;        TER_NBRК: INTEGER;      BEGIN   
     WHILE NOT IS_EMPTY( FOLLOW_SEQ ) LOOP          TER := HEAD( FOLLOW_SEQ ); FOLLOW_SEQ := TAIL( FOLLOW_SEQ );      
    TER_NBR := DI( XD_TER_NBR, TER );          IF SYLTBL( -TER_NBR ).STATE_NBR /= STATE_NBR THEN            SYLTBL( -T
ER_NBR ).STATE_NBR := STATE_NBR;          ELSIF SYLTBL( -TER_NBR ).REDUCE THEN            ERROR( D( LX_SRCPOS, D( XD_A
LTERNATIVE, ITEM ) ),                   "RED/RED CONF STATE " & INTEGER_IMAGE( STATE_NBR )                            
            & " - " & PRINT_NAME( D( XD_SYMREP, TER ) ) );          END IF;          SYLTBL( -TER_NBR ).REDUCE := TRUE
;          NBR_TERS := NBR_TERS + 1;        END LOOP;        REDUCE_NBR_TERS( REDUCE_COUNT ) := NBR_TERS;        RED
UCE_ITEM( REDUCE_COUNT ) := ITEM;      END CHECK_REDUCE;      --|-----------------------------------------------------
-----------------------------------------      --|КFUNCTION REDUCE_ACTION      FUNCTION REDUCE_ACTION ( ITEM :TREE ) 
RETURN INTEGER IS        ALTК: TREE:= D ( XD_ALTERNATIVE, ITEM );        ALT_NBRК: INTEGER:= DI( XD_ALT_NBR, ALT )
;        ALT_SEMК: INTEGER:= ALT_SEM_TBL( ALT_NBR );                -- 0 OR ACTION ENTRY        SEM_SК: SEQ_TYPE;
        SEMК: TREE;        SEM_OP_POSК: INTEGER;        SEM_OP_KIND: GRMR_OP;        CODEК: INTEGER;        TXT
: TREE;                    --|---------------------------------------------------------------------------------------
----        --|촒ROCEDURE REDUCE_CODE        FUNCTION REDUCE_CODE ( ALT :TREE ) RETURN INTEGER IS          NBR_POPS:
 INTEGER:= 0;          SYL_LIST: SEQ_TYPE:= LIST ( ALT );        BEGIN          WHILE NOT IS_EMPTY( SYL_LIST ) LOO
P            SYL_LIST := TAIL( SYL_LIST );            NBR_POPS := NBR_POPS + 1;          END LOOP;          RETURN -
 ( 10_000 + NBR_POPS * 1000 + DI ( XD_RULE_NBR, D ( XD_RULEINFO, D ( XD_RULE, ALT ) ) )                   );        EN
D REDUCE_CODE;                  BEGIN        IF ALT_SEM /= 0 THEN          RETURN ALT_SEM; -- ALREADY COMPUTED     
   END IF;                    SEM_S := LIST( D( XD_SEMANTICS, ALT ) );        IF IS_EMPTY( SEM_S ) THENККК-- NO S
EMANTICS, JUST USE REDUCE CODE          ALT_SEM := REDUCE_CODE( ALT );        ELSEКККК-- SEMANTICS, INDIRECT INTO
 REST OF ALT TBL          ALT_SEM := - (GRMR.AC_TBL_LAST + 1);ККК-- BRANCH TO WHERE SEMANTICS WILL START          W
HILE NOT IS_EMPTY( SEM_S) LOOP            POP( SEM_S, SEM );            GRMR.AC_TBL_LAST := GRMR.AC_TBL_LAST + 1;    
        SEM_OP_POS       := DI( XD_SEM_OP, SEM );            SEM_OP_KIND      := GRMR_OP'VAL( SEM_OP_POS );           
 CODE             := 1000 * SEM_OP_POS;            IF SEM_OP_KIND IN GRMR_OP_NODE THEN              CODE := CODE + DI(
 XD_KIND, SEM );            ELSIF SEM_OP_KIND IN GRMR_OP_QUOTE THEN              TXT  := D( XD_KIND, SEM );          
    CODE := CODE + INTEGER( TXT.PG );              GRMR.AC_TBL( GRMR.AC_TBL_LAST ) := AC_SHORT( CODE );              G
RMR.AC_TBL_LAST := GRMR.AC_TBL_LAST + 1;              CODE := INTEGER( TXT.LN );            END IF;            GRMR.A
C_TBL( GRMR.AC_TBL_LAST ) := AC_SHORT( CODE );          END LOOP;          GRMR.AC_TBL_LAST := GRMR.AC_TBL_LAST + 1; 
         GRMR.AC_TBL( GRMR.AC_TBL_LAST ) := AC_SHORT( REDUCE_CODE ( ALT ) );        END IF;                -- SAVE COM
PUTED VALUE AND RETURN        ALT_SEM_TBL( ALT_NBR ) := ALT_SEM;        RETURN ALT_SEM;                  END REDUCE_
ACTION;      --|-------------------------------------------------------------------------------------------      --|촒
ROCEDURE GEN_TER_INFO      PROCEDURE GEN_TER_INFO IS                -- FILL IN INFO FOR TERMINALS AND DONT CARE IN ACT
ION TABLE        ITEM_SEQК: SEQ_TYPE;        ITEMК: TREE;        GOTO_STATEК: TREE;        TEMP_INTEGER: INTEGER
;        TEMP_TREEК: TREE;        SYL_LISTК: SEQ_TYPE;        SYLК: TREE;        SYL_NBRК: INTEGER;      BEGIN
             -- WRITE TER GOTO ACTIONS        IF TER_GO_COUNT > 0 THEN          ITEM_SEQ := LIST( STATE );          W
HILE NOT IS_EMPTY( ITEM_SEQ ) LOOP            ITEM := HEAD( ITEM_SEQ ); ITEM_SEQ := TAIL( ITEM_SEQ );            GOTO_
STATE := D( XD_GOTO, ITEM);            IF GOTO_STATE.TY /= DN_VOID THEN              SYL := HEAD( LIST( ITEM ) );    
          IF SYL.TY = DN_TERMINAL THEN                SYL_NBR := DI ( XD_TER_NBR, SYL );                IF SYLTBL(- SY
L_NBR).STATE_NBR = STATE_NBR THEN                  SYLTBL(- SYL_NBR).STATE_NBR := 0;                  GRMR.AC_SYM_LAST
 := GRMR.AC_SYM_LAST + 1;                  GRMR.AC_SYM( GRMR.AC_SYM_LAST ) := AC_BYTE( SYL_NBR );                  GRM
R.AC_TBL( GRMR.AC_SYM_LAST ) := AC_SHORT( DI ( XD_STATE_NBR, GOTO_STATE ) );                END IF;              END I
F;            END IF;          END LOOP;        END IF;                            -- WRITE NON-DEFAULT REDUCE ACTI
ONS                -- FIRST MAKE #1 LONGEST REDUCE (IT WILL BE DONT CARE)        FOR I IN 2 .. REDUCE_COUNT LOOP     
     IF REDUCE_NBR_TERS (I) > REDUCE_NBR_TERS (1) THEN            TEMP_INTEGER := REDUCE_NBR_TERS(1);            TEMP_
TREE := REDUCE_ITEM(1);            REDUCE_NBR_TERS(1) := REDUCE_NBR_TERS(I);            REDUCE_ITEM(1) := REDUCE_ITEM(
I);            REDUCE_NBR_TERS(I) := TEMP_INTEGER;            REDUCE_ITEM(I) := TEMP_TREE;          END IF;         
                              -- NOW COMPUTE REDUCE ACTION AND PUT OUT FOR EACH TER          TEMP_INTEGER := REDUCE_AC
TION( REDUCE_ITEM(I) );          SYL_LIST := LIST ( D ( XD_FOLLOW, REDUCE_ITEM( I ) ) );          WHILE NOT IS_EMPTY (
 SYL_LIST ) LOOP            GRMR.AC_SYM_LAST := GRMR.AC_SYM_LAST + 1;            GRMR.AC_SYM( GRMR.AC_SYM_LAST ) := AC
_BYTE( DI ( XD_TER_NBR, HEAD ( SYL_LIST ) ) );            GRMR.AC_TBL( GRMR.AC_SYM_LAST ) := AC_SHORT( TEMP_INTEGER );
            SYL_LIST := TAIL ( SYL_LIST );          END LOOP;        END LOOP;                            -- NOW PUT
 OUT DONT CARE ACTION        GRMR.AC_SYM_LAST := GRMR.AC_SYM_LAST + 1;        GRMR.AC_SYM( GRMR.AC_SYM_LAST ) := 0;  
      IF REDUCE_COUNT > 0 THEN          GRMR.AC_TBL( GRMR.AC_SYM_LAST ) := AC_SHORT( REDUCE_ACTION ( REDUCE_ITEM( 1 ) )
 );        ELSE          GRMR.AC_TBL( GRMR.AC_SYM_LAST ) := 0;        END IF;      END GEN_TER_INFO;             B
EGIN      WHILE NOT IS_EMPTY( ITEM_SEQ) LOOP        POP( ITEM_SEQ, ITEM );        SYL_SEQ := LIST( ITEM );        IF
 IS_EMPTY( SYL_SEQ) THEN          REDUCE_COUNT := REDUCE_COUNT + 1;          CHECK_REDUCE( ITEM );        ELSE      
    SYL := HEAD( SYL_SEQ );          IF SYL.TY = DN_TERMINAL THEN            SYL_NBR := - DI ( XD_TER_NBR, SYL );    
        IF SYLTBL( SYL_NBR ).STATE_NBR /= STATE_NBR THEN              TER_GO_COUNT := TER_GO_COUNT + 1;              S
YLTBL( SYL_NBR ).STATE_NBR := STATE_NBR;              SYLTBL( SYL_NBR ).REDUCE := FALSE;            END IF;          
ELSE            RULE := D( XD_RULE, SYL );            IF RULE.TY /= DN_VOID THEN              SYL_NBR := DI( XD_RULE_
NBR, D( XD_RULEINFO, RULE ) );              IF SYLTBL( SYL_NBR ).STATE_NBR /= STATE_NBR THEN                NONTER_GO_
COUNT := NONTER_GO_COUNT + 1;                SYLTBL( SYL_NBR ).STATE_NBR := STATE_NBR;                SYLTBL( SYL_NBR 
).REDUCE := FALSE;              END IF;            END IF;          END IF;        END IF;      END LOOP;         
                -- CHECK FOR SHIFT-REDUCE CONFLICTS      IF REDUCE_COUNT > 0 THEN        ITEM_SEQ := LIST ( STATE );
        WHILE NOT IS_EMPTY ( ITEM_SEQ ) LOOP          POP ( ITEM_SEQ, ITEM );          SYL_SEQ := LIST ( ITEM );     
     IF NOT IS_EMPTY ( SYL_SEQ ) THEN            SYL := HEAD ( SYL_SEQ );            IF SYL.TY = DN_TERMINAL THEN    
          SYL_NBR := - DI ( XD_TER_NBR, SYL );              IF SYLTBL( SYL_NBR ).REDUCE THEN                ERROR ( D 
( LX_SRCPOS, SYL ), "SHIFT/RED CONF STATE " & INTEGER_IMAGE ( STATE_NBR )                              & " - " & PRINT_
NAME ( D ( XD_SYMREP, SYL ) ) );              END IF;            END IF;          END IF;        END LOOP;      END
 IF;                         -- WRITE NONTER ACTIONS      IF NONTER_GO_COUNT > 0 THEN        ITEM_SEQ := LIST( STATE
 );        WHILE NOT IS_EMPTY( ITEM_SEQ ) LOOP          POP( ITEM_SEQ, ITEM );          GOTO_STATE := D ( XD_GOTO, IT
EM );          IF GOTO_STATE.TY /= DN_VOID THEN            SYL := HEAD( LIST ( ITEM ) );            IF SYL.TY = DN_NO
NTERMINAL THEN              SYL_NBR := DI( XD_RULE_NBR, D( XD_RULEINFO, D( XD_RULE, SYL ) ) );              IF SYLTBL(
 SYL_NBR ).STATE_NBR = STATE_NBR THEN                SYLTBL( SYL_NBR ).STATE_NBR := 0;                GRMR.AC_SYM_LAST
 := GRMR.AC_SYM_LAST + 1;                GRMR.AC_SYM( GRMR.AC_SYM_LAST ) := AC_BYTE( SYL_NBR );                GRMR.AC
_TBL( GRMR.AC_SYM_LAST ) := AC_SHORT( DI( XD_STATE_NBR, GOTO_STATE ) );              END IF;            END IF;      
    END IF;        END LOOP;      END IF;                         -- WRITE STATE TABLE ENTRY      GRMR.ST_TBL_LAST 
:= GRMR.ST_TBL_LAST + 1;                -- ASSUME NO SEMANTICS FOR NOW !!!!      IF TER_GO_COUNT = 0 AND THEN NONTER_G
O_COUNT = 0 AND THEN REDUCE_COUNT = 1 THEN        GRMR.ST_TBL( GRMR.ST_TBL_LAST ) := REDUCE_ACTION( ITEM );      ELSE
        GRMR.ST_TBL( GRMR.ST_TBL_LAST ) := GRMR.AC_SYM_LAST + 1;        GEN_TER_INFO;      END IF;    END SCAN_STATE;
떰  BEGIN    WHILE NOT IS_EMPTY ( STATE_SEQ ) LOOP      POP ( STATE_SEQ, STATE );      STATE_NBR := DI ( XD_STATE_NBR
, STATE );      TER_GO_COUNT := 0;      NONTER_GO_COUNT := 0;      REDUCE_COUNT := 0;      SCAN_STATE;      INT_IO.
PUT ( STATE_NBR );      INT_IO.PUT ( TER_GO_COUNT );      INT_IO.PUT ( NONTER_GO_COUNT );      INT_IO.PUT ( REDUCE_CO
UNT );      NEW_LINE;      NONTER_GO_SUM := NONTER_GO_SUM + NONTER_GO_COUNT;      TER_GO_SUM := TER_GO_SUM + TER_GO_C
OUNT;      REDUCE_SUM := REDUCE_SUM + REDUCE_COUNT;    END LOOP;    PUT ( "******" );    INT_IO.PUT ( TER_GO_SUM );
    INT_IO.PUT ( NONTER_GO_SUM );    INT_IO.PUT ( REDUCE_SUM );    NEW_LINE;  END SCAN_GRAMMAR;  --|----------------
-------------------------------------------------------------------------------  --|촒ROCEDURE WRITE_TABLES  PROCEDURE
 WRITE_TABLES IS    OFILEК: FILE_TYPE;    STATE_INDК: INTEGER:= 1;    RULE_LISTК: SEQ_TYPE;    RULEК: TREE; 
   AC_SUBК: INTEGER;    TXT_LNК: INTEGER;  BEGIN    CREATE( OFILE, OUT_FILE, "parse.tbl" );    PUT( "NBR OF STATES
 IS" );    INT_IO.PUT( GRMR.ST_TBL_LAST );    PUT( " - MAX");    INT_IO.PUT( GRMR.ST_TBL'LAST );    NEW_LINE;    PU
T( "NBR OF ACTION SYMBOLS IS" );    INT_IO.PUT( GRMR.AC_SYM_LAST );    PUT( " - MAX" );    INT_IO.PUT( GRMR.AC_SYM'LA
ST );    NEW_LINE;    PUT( "LAST ACTION ENTRY IS" );    INT_IO.PUT( GRMR.AC_TBL_LAST );    PUT( " - MAX" );    INT_
IO.PUT( GRMR.AC_TBL'LAST );    NEW_LINE;    FOR I IN 1 .. GRMR.AC_SYM_LAST LOOP      WHILE STATE_IND <= GRMR.ST_TBL_L
AST AND THEN GRMR.ST_TBL( STATE_IND ) <= I LOOP        PUT( OFILE, 'S' );        INT_IO.PUT( OFILE, STATE_IND, 4 );  
      INT_IO.PUT( OFILE, GRMR.ST_TBL( STATE_IND ) );        NEW_LINE( OFILE );        STATE_IND := STATE_IND + 1;    
  END LOOP;      PUT( OFILE, 'T' );      INT_IO.PUT( OFILE, I, 5 );      INT_IO.PUT( OFILE, INTEGER( GRMR.AC_TBL( I )
 ) );      INT_IO.PUT( OFILE, INTEGER( GRMR.AC_SYM( I ) ) );      NEW_LINE( OFILE );    END LOOP;    WHILE STATE_IND
 <= GRMR.ST_TBL_LAST LOOP      PUT ( OFILE, 'S' );      INT_IO.PUT( OFILE, STATE_IND, 4 );      INT_IO.PUT( OFILE, GR
MR.ST_TBL( STATE_IND ) );      NEW_LINE( OFILE );      STATE_IND := STATE_IND + 1;    END LOOP;          PUT ( "NUM
BER OF ACTION ENTRIES IS" );    INT_IO.PUT( GRMR.AC_TBL_LAST );    NEW_LINE;         AC_SUB := GRMR.AC_SYM'LAST;   
 WHILE AC_SUB < GRMR.AC_TBL_LAST LOOP      AC_SUB := AC_SUB + 1;      PUT( OFILE, 'A' );      INT_IO.PUT( OFILE, AC_S
UB, 5 );      DECLARE        DATAК: INTEGERК:= INTEGER( GRMR.AC_TBL( AC_SUB ) );        DATA_KINDК: GRMR_OP;     
   TXTК: TREE;      BEGIN        IF DATA < 1000 THEN          INT_IO.PUT ( OFILE, DATA );        ELSIF (DATA / 1000
) > GRMR_OP'POS ( GRMR_OP'LAST ) THEN          INT_IO.PUT ( OFILE, DATA );          PUT( OFILE, "###############");  
        PUT_LINE( "##### ERROR IN TABLE");        ELSE          DATA_KIND := GRMR_OP'VAL( DATA / 1000 );          IF 
DATA_KIND NOT IN GRMR_OP_QUOTE THEN            INT_IO.PUT( OFILE, DATA );          ELSE            INT_IO.PUT( OFILE,
 GRMR_OP'POS( DATA_KIND ) * 1000 );            AC_SUB := AC_SUB + 1;            TXT_LN := INTEGER( GRMR.AC_TBL( AC_SUB
 ) );            IF TXT_LN IN 0..INTEGER( LINE_NBR'LAST ) THEN              TXT := (P, PG=> PAGE_IDX( DATA MOD 1000 ),
 TY=> DN_SYMBOL_REP, LN=> LINE_IDX( TXT_LN ));              PUT( OFILE, PRINT_NAME ( TXT ) );            ELSE        
      INT_IO.PUT ( OFILE, DATA MOD 1000 );              PUT( OFILE, ' ' );              INT_IO.PUT ( OFILE, TXT_LN, 0 
);              PUT( OFILE, "**********" );              PUT_LINE( "***** ERROR IN TABLE" );            END IF;     
     END IF;        END IF;      END;      NEW_LINE ( OFILE );    END LOOP;             GRMR.NTER_LAST := 0;    R
ULE_LIST := LIST ( D ( XD_GRAMMAR, USER_ROOT));    WHILE NOT IS_EMPTY ( RULE_LIST ) LOOP      POP ( RULE_LIST, RULE );
      GRMR.NTER_LAST := GRMR.NTER_LAST + 1;      PUT ( OFILE, 'N' );      INT_IO.PUT ( OFILE, GRMR.NTER_LAST, 4 );  
    PUT ( OFILE, ' ' );      PUT_LINE ( OFILE, PRINT_NAME ( D ( XD_NAME, RULE ) ) );    END LOOP;    PUT ( "NUMBER OF
 NONTERMINALS IS");    INT_IO.PUT ( GRMR.NTER_LAST );    NEW_LINE;    CLOSE ( OFILE );  END WRITE_TABLES;    턆EGIN
  OPEN_IDL_TREE_FILE( NOM_TEXTE & ".lar" );  USER_ROOT := D( XD_USER_ROOT, TREE_ROOT );  GR_STATE_SEQ := LIST( D( XD_
STATELIST, USER_ROOT ) );        IF DI( XD_ERR_COUNT, TREE_ROOT ) > 0 THEN    INT_IO.PUT( DI( XD_ERR_COUNT, TREE_ROOT
 ), 1 );    PUT_LINE (  " ERRORS IN EARLY PHASES." );  END IF;        FOR I IN SYLTBL'RANGE LOOP    SYLTBL( I ).STA
TE_NBR := 0;  END LOOP;        GRMR.ST_TBL_LAST := 0;  GRMR.AC_SYM_LAST := 1;  GRMR.AC_TBL_LAST := GRMR.AC_SYM'LAST
;К-- I.E., NOTHING WITH GREATER INDEX YET  GRMR.AC_SYM( 1 ) := 0;  GRMR.AC_TBL( 1 ) := 0;К-- ERROR AS FIRST ELT  
GRMR.NTER_LAST := 0;        ALT_SEM_TBL := (OTHERS=> 0);        SCAN_GRAMMAR;  WRITE_TABLES;           CLOSE_IDL_
TREE_FILE;--|-------------------------------------------------------------------------------------------------턉ND CHEC
K_GRMR;
