separate (IDL.SEM_PHASE)--|============================================================================================
=====|--|ККККК|--|ККDEF_UTILККК|--|ККККК|--|=========================================================
========================================|턯ackage body DEF_UTIL is떰  use VIS_UTIL; -- FOR DEBUG (NODE_REP)  use EXPRES
O; -- FOR GET_NAME_DEFN떰--|============================================================================================
=====떰--|ККHEADER_IS_HOMOGRAPH떰--|__________________________________________________________________________________
_______________  function HEADER_IS_HOMOGRAPH ( HEADER_1 :TREE; PARAM_S_2 :TREE; RESULT_TYPE_2 : TREE := TREE_VOID ) re
turn BOOLEAN is    KIND_1: constant NODE_NAME:= HEADER_1.TY;  begin떰    if KIND_1 not in CLASS_SUBP_ENTRY_HEADER or
 else PARAM_S_2 = TREE_VOID thenК--| IF HEADER_1 IS NON_OVERLOADABLE OR PARAM_S_2 IS VOID      return True;КККК-
-| ILS SONT HOMOGRAPHES    end if;떰    if (KIND_1 = DN_FUNCTION_SPEC) xor (RESULT_TYPE_2 /= TREE_VOID) thenК--| L'UN
 FONCTION L'AUTRE NON      return FALSE;КККК--| ILS NE SONT PAS HOMOGRAPHES    end if;떰    if KIND_1 = DN_FUNCTI
ON_SPEC thenККК--| DEUX FONCTIONS      if GET_BASE_TYPE( D( AS_NAME, HEADER_1 ) ) /= GET_BASE_TYPE( RESULT_TYPE_2 )
 thenК--| TYPES RETOURNES DIFFERENTS        return FALSE;КККК--| ILS NE SONT PAS HOMOGRAPHES      end if;    end
 if;떰    return IS_SAME_PARAMETER_PROFILE( D( AS_PARAM_S, HEADER_1 ), PARAM_S_2 );К--| COMPARER LES PROFILS DE PARAMT
RES  end HEADER_IS_HOMOGRAPH;--|######################################################################################
###########떰--|ККMAKE_DEF_FOR_ID떰--|________________________________________________________________________________
_________________  function MAKE_DEF_FOR_ID ( ID : TREE; H : H_TYPE ) return TREE is    SYMREP: constant TREE:= D( L
X_SYMREP, ID );    DEFК: TREEК:= MAKE( DN_DEF );  begin    if H.REGION_DEF /= TREE_VOID and then ID.TY in CLASS_SOU
RCE_NAME then      D( XD_REGION, ID, D( XD_SOURCE_NAME, H.REGION_DEF ) );    end if;떰    D(  XD_HEADER,      DEF,  TR
EE_TRUE    );    D(  XD_SOURCE_NAME, DEF,  ID           );    D(  XD_REGION_DEF,  DEF,  H.REGION_DEF );    DB( XD_IS_
IN_SPEC,  DEF,  H.IS_IN_SPEC );    DB( XD_IS_USED,     DEF,  FALSE        );    DI( XD_LEX_LEVEL,   DEF,  0           
 );떰    LIST (SYMREP, INSERT (LIST (SYMREP), DEF));    return DEF;  end MAKE_DEF_FOR_ID;--|#########################
########################################################################떰--|ККCHECK_UNIQUE_SOURCE_NAME_S떰--|________
_________________________________________________________________________________________  procedure CHECK_UNIQUE_SOURC
E_NAME_S ( SOURCE_NAME_S :TREE ) is    SOURCE_NAME_LIST: SEQ_TYPE:= LIST( SOURCE_NAME_S );    SOURCE_NAMEК: TREE; 
 begin    while not IS_EMPTY( SOURCE_NAME_LIST ) loop      POP( SOURCE_NAME_LIST, SOURCE_NAME );      CHECK_UNIQUE_DE
F( GET_DEF_FOR_ID( SOURCE_NAME ) );    end loop;  end CHECK_UNIQUE_SOURCE_NAME_S;--|#################################
################################################################떰--|ККCHECK_CONSTANT_ID_S떰--|_______________________
__________________________________________________________________________  procedure CHECK_CONSTANT_ID_S (SOURCE_NAME_
S :TREE; H :H_TYPE ) is    SOURCE_NAME_LIST: SEQ_TYPE:= LIST( SOURCE_NAME_S );    SOURCE_NAMEК: TREE;  begin    w
hile not IS_EMPTY( SOURCE_NAME_LIST ) loop      POP( SOURCE_NAME_LIST, SOURCE_NAME );      CHECK_CONSTANT_DEF( GET_DEF
_FOR_ID( SOURCE_NAME ), H );    end loop;  end CHECK_CONSTANT_ID_S;--|###############################################
##################################################떰--|ККGET_DEF_FOR_ID떰--|__________________________________________
_______________________________________________________  function GET_DEF_FOR_ID ( ID :TREE ) return TREE is    DEFLIS
T: SEQ_TYPE:= LIST( D( LX_SYMREP, ID ) );    DEFК: TREE;  begin    while not IS_EMPTY( DEFLIST ) loop      POP( D
EFLIST, DEF );떰      if D (XD_SOURCE_NAME, DEF) = ID then        return DEF;      end if;    end loop;떰    Put_Line
 ("!! NO DEF FOR ID - " & PRINT_NAME (D (LX_SYMREP, ID)));    raise Program_Error;  end GET_DEF_FOR_ID;      --||||||
||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||      --|  function GET_PRIOR_DE
F (DEF : TREE) return TREE is    REGION_DEF : constant TREE := D (XD_REGION_DEF, DEF);    HEADER     : constant TREE :
= D (XD_HEADER, DEF);    DEFLIST    : SEQ_TYPE      := LIST (D (LX_SYMREP, D (XD_SOURCE_NAME, DEF)));    PRIOR_DEF  : 
TREE;  begin    while not IS_EMPTY (DEFLIST) loop      POP (DEFLIST, PRIOR_DEF);      if PRIOR_DEF /= DEF and then D
 (XD_REGION_DEF, PRIOR_DEF) = REGION_DEF then        return PRIOR_DEF;      end if;    end loop;떰    return TREE_VOI
D;  end GET_PRIOR_DEF;      --||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
||||      --|  function GET_PRIOR_HOMOGRAPH_DEF (DEF : TREE) return TREE is    HEADER : TREE := D (XD_HEADER, DEF); 
 begin    if HEADER.TY = DN_FUNCTION_SPEC then      return GET_PRIOR_HOMOGRAPH_DEF (DEF, D (AS_PARAM_S, HEADER), D (AS
_NAME, HEADER));    else -- SINCE IT IS A PROCEDURE_SPEC OR AN ENTRY      return GET_PRIOR_HOMOGRAPH_DEF (DEF, D (AS_P
ARAM_S, HEADER));    end if;  end GET_PRIOR_HOMOGRAPH_DEF;떰  function GET_PRIOR_HOMOGRAPH_DEF (DEF, PARAM_S : TREE; R
ESULT_TYPE : TREE := TREE_VOID) return TREE is                -- NOTE: DOES NOT FIND DERIVED AND BUILTIN SUBPROGRAMS  
  REGION_DEF : constant TREE := D (XD_REGION_DEF, DEF);    DEFLIST    : SEQ_TYPE      := LIST (D (LX_SYMREP, D (XD_SOUR
CE_NAME, DEF)));    PRIOR_DEF  : TREE;  begin    while not IS_EMPTY (DEFLIST) loop      POP (DEFLIST, PRIOR_DEF);  
    if PRIOR_DEF /= DEF and then D (XD_SOURCE_NAME, PRIOR_DEF).TY /= DN_BLTN_OPERATOR_ID and then D (XD_SOURCE_NAME, PRI
OR_DEF).TY not in CLASS_ENUM_LITERAL and then D (XD_REGION_DEF, PRIOR_DEF) = REGION_DEF       and then HEADER_IS_HOMOGR
APH (D (XD_HEADER, PRIOR_DEF), PARAM_S, RESULT_TYPE) and then (D (XD_SOURCE_NAME, PRIOR_DEF).TY not in CLASS_SUBPROG_NAM
E or else D (SM_UNIT_DESC, D (XD_SOURCE_NAME, PRIOR_DEF)).TY /= DN_DERIVED_SUBPROG)      then        return PRIOR_DEF;
      end if;    end loop;떰    return TREE_VOID;  end GET_PRIOR_HOMOGRAPH_DEF;      --|||||||||||||||||||||||||||||
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||      --|  function GET_DEF_IN_REGION (ID : TREE; H : H
_TYPE) return TREE is    REGION_DEF : constant TREE := H.REGION_DEF;    DEFLIST    : SEQ_TYPE      := LIST (D (LX_SYMR
EP, ID));    PRIOR_DEF  : TREE;  begin    while not IS_EMPTY (DEFLIST) loop      POP (DEFLIST, PRIOR_DEF);      if 
D (XD_REGION_DEF, PRIOR_DEF) = REGION_DEF then        return PRIOR_DEF;      end if;    end loop;떰    return TREE_VO
ID;  end GET_DEF_IN_REGION;      --|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|||||||||      --|  procedure CHECK_UNIQUE_DEF (SOURCE_DEF : TREE) is    PRIOR_DEF   : constant TREE := GET_PRIOR_DEF
 (SOURCE_DEF);    SOURCE_NAME : TREE;  begin    if PRIOR_DEF /= TREE_VOID then      SOURCE_NAME := D (XD_SOURCE_NAME
, SOURCE_DEF);      ERROR (D (LX_SRCPOS, SOURCE_NAME), "DEFINITION IS NOT UNIQUE - " & PRINT_NAME (D (LX_SYMREP, SOURCE
_NAME)));      D (XD_HEADER, SOURCE_DEF, TREE_FALSE);    else      D (XD_HEADER, SOURCE_DEF, TREE_VOID);    end if;
  end CHECK_UNIQUE_DEF;      --||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
||||      --|  procedure CHECK_CONSTANT_DEF (SOURCE_DEF : TREE; H : H_TYPE) is    SOURCE_ID : constant TREE := D (XD_
SOURCE_NAME, SOURCE_DEF);    PRIOR_DEF : TREE;    PRIOR_ID  : TREE;  begin                -- IF WE ARE NOT IN PRIVAT
E PART OF A PACKAGE    if (H.IS_IN_SPEC) or (H.IS_IN_BODY) then떰                        -- CHECK FOR UNIQUENESS AND RE
TURN      CHECK_UNIQUE_DEF (SOURCE_DEF);      return;    end if;떰                -- GET PRIOR DEF, IF ANY    PRIOR_
DEF := GET_PRIOR_DEF (SOURCE_DEF);    if PRIOR_DEF = TREE_VOID then      MAKE_DEF_VISIBLE (SOURCE_DEF);      return;
    else      PRIOR_ID := D (XD_SOURCE_NAME, PRIOR_DEF);    end if;떰                -- IF PRIOR DEF IS NOT FOR A DEFE
RRED CONSTANT                -- WHICH DOES NOT YET HAVE A FULL DECLARATION    if PRIOR_ID.TY /= DN_CONSTANT_ID or else
 D (SM_INIT_EXP, PRIOR_ID) /= TREE_VOID then떰                        -- REPEAT UNIQUENESS CHECK TO PUT OUT ERROR MESSAG
E AND RETURN      CHECK_UNIQUE_DEF (SOURCE_DEF);      return;    end if;떰                -- YES, IT IS A FULL DECLAR
ATION OF A DEFERRED CONSTANT떰                -- CHECK CONFORMANCE OF DISCRIMINANT LISTS                -- AND REMOVE D
EF'S FOR DUPLICATED NAMES                -- $$$$$$ STUB -- MUST DO THIS CHECK --- $$$$$$$                --      IF KI
ND ( D ( SM_TYPE_SPEC, SOURCE_ID)) = DN_RECORD THEN                --          CONFORM_PARAMETER_LISTS                
--                  ( D ( SM_DISCRIMINANT_S, PRIOR_ID)                --                  , D ( SM_DISCRIMINANT_S, SOUR
CE_ID) );                --      ELSE                --          CONFORM_PARAMETER_LISTS                --           
       ( D ( SM_DISCRIMINANT_S, PRIOR_ID)                --                  , CONST_VOID );                --      EN
D IF;떰                -- MAKE SOURCE DEF VISIBLE AND RETURN    REMOVE_DEF_FROM_ENVIRONMENT (SOURCE_DEF);    D (SM_FIR
ST, SOURCE_ID, PRIOR_ID);    return;  end CHECK_CONSTANT_DEF;      --||||||||||||||||||||||||||||||||||||||||||||||||
||||||||||||||||||||||||||||||||||||||||||||      --|  procedure CHECK_TYPE_DEF (SOURCE_DEF : TREE; H : H_TYPE) is   
 PRIOR_DEF : constant TREE := GET_PRIOR_DEF (SOURCE_DEF);떰    SOURCE_ID : TREE;    PRIOR_ID  : TREE;떰  begin        
        -- IF THERE IS NO PRIOR DEF THEN    if PRIOR_DEF = TREE_VOID then떰                        -- MAKE SOURCE DEF V
ISIBLE AND RETURN      MAKE_DEF_VISIBLE (SOURCE_DEF);      return;    end if;떰                -- GET ID'S CORRESPOND
ING TO DEF'S    SOURCE_ID := D (XD_SOURCE_NAME, SOURCE_DEF);    PRIOR_ID  := D (XD_SOURCE_NAME, PRIOR_DEF);떰         
       -- IF VALID FULL DECLARATION FOR PRIVATE TYPE    if PRIOR_ID.TY in DN_PRIVATE_TYPE_ID .. DN_L_PRIVATE_TYPE_ID an
d then not H.IS_IN_SPEC and then not H.IS_IN_BODY then떰      declare        PRIVATE_NODE : constant TREE := D (SM_TYPE
_SPEC, PRIOR_ID);      begin                                -- IF NOT ALREADY DECLARED        if D (SM_TYPE_SPEC, PRI
VATE_NODE) = TREE_VOID then떰                                        -- MAKE THIS THE FULL TYPE DECLARATION          D 
(SM_TYPE_SPEC, PRIVATE_NODE, D (SM_TYPE_SPEC, SOURCE_ID));          D (SM_FIRST, SOURCE_ID, PRIOR_ID);떰               
                         -- CHECK CONFORMANCE OF DISCRIMINANT LISTS                                        -- AND REMOV
E DEF'S FOR DUPLICATED NAMES          if D (SM_TYPE_SPEC, SOURCE_ID).TY = DN_RECORD then            CONFORM_PARAMETER_
LISTS (D (SM_DISCRIMINANT_S, PRIOR_ID), D (SM_DISCRIMINANT_S, SOURCE_ID));          else            CONFORM_PARAMETER_
LISTS (D (SM_DISCRIMINANT_S, PRIOR_ID), TREE_VOID);          end if;떰                                        -- MAKE S
OURCE DEF VISIBLE AND RETURN          MAKE_DEF_VISIBLE (SOURCE_DEF);          return;        end if;      end;    e
nd if;떰                -- IF POSSIBLE VALID FULL DECLARATION FOR INCOMPLETE TYPE DECLARATION    if PRIOR_ID.TY = DN_TY
PE_ID and then not H.IS_IN_SPEC and then not H.IS_IN_BODY then떰      declare        INCOMPLETE_NODE : constant TREE :=
 D (SM_TYPE_SPEC, PRIOR_ID);      begin                                -- IF PRIOR ID IS INCOMPLETE AND NOT ALREADY DE
CLARED        if INCOMPLETE_NODE.TY = DN_INCOMPLETE and then D (XD_FULL_TYPE_SPEC, INCOMPLETE_NODE) = TREE_VOID then떰 
                                       -- MAKE THIS THE FULL TYPE DECLARATION          D (XD_FULL_TYPE_SPEC, INCOMPLETE
_NODE, D (SM_TYPE_SPEC, SOURCE_ID));          D (SM_FIRST, SOURCE_ID, PRIOR_ID);떰                                     
   -- REMOVE SOURCE DEF FROM ENVIRONMENT AND RETURN          REMOVE_DEF_FROM_ENVIRONMENT (SOURCE_DEF);          return
;        end if;      end;    end if;떰                -- TYPE NAME IS NOT UNIQUE                -- USE CHECK UNIQUE
 SUBPROGRAM TO GIVE ERROR MESSAGE    CHECK_UNIQUE_DEF (SOURCE_DEF);  end CHECK_TYPE_DEF;      --|||||||||||||||||||||
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||      --|  function ARE_HOMOGRAPH_HEADERS (HEAD
ER_1, HEADER_2 : TREE) return BOOLEAN is                -- DETERMINES IF TWO HEADERS ARE HOMOGRAPHS                -- 
ONLY CALLED WITH HEADER FROM XD_HEADER ATTRIBUTE OF DEF                --   (HENCE DO NOT NEED TO CHECK, E.G., DISCRETE
_RANGE IN ENTRY)떰    KIND_1 : constant NODE_NAME := HEADER_1.TY;    KIND_2 : constant NODE_NAME := HEADER_2.TY;  begi
n                -- IF EITHER HEADER IS NON_OVERLOADABLE    if KIND_1 not in CLASS_SUBP_ENTRY_HEADER or KIND_2 not in 
CLASS_SUBP_ENTRY_HEADER then떰                        -- THEY ARE HOMOGRAPHS      return True;떰                       
 -- ELSE -- SINCE BOTH ARE OVERLOADABLE    else떰                        -- SPLIT UP HEADER_2 AND CALL HEADER_IS_HOMOGR
APH      if KIND_2 = DN_FUNCTION_SPEC then        return HEADER_IS_HOMOGRAPH (HEADER_1, D (AS_PARAM_S, HEADER_2), D (A
S_NAME, HEADER_2));      else        return HEADER_IS_HOMOGRAPH (HEADER_1, D (AS_PARAM_S, HEADER_2));      end if;  
  end if;  end ARE_HOMOGRAPH_HEADERS;떰      --||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
||||||||||||||||||||      --|  function IS_SAME_PARAMETER_PROFILE (PARAM_S_1, PARAM_S_2 : TREE) return BOOLEAN is    
PARAM_LIST_1         : SEQ_TYPE := LIST (PARAM_S_1);    PARAM_LIST_2         : SEQ_TYPE := LIST (PARAM_S_2);    PARAM_
1, PARAM_2     : TREE;    ID_LIST_1, ID_LIST_2 : SEQ_TYPE := (TREE_NIL, TREE_NIL);    ID_1, ID_2           : TREE;  b
egin                -- LOOP THROUGH BOTH PARAMETER LISTS    loop떰                        -- GET NEXT ELEMENT FROM PAR
AM_LIST_1, IF ANY      if IS_EMPTY (ID_LIST_1) then        if IS_EMPTY (PARAM_LIST_1) then떰                          
              -- THERE IS NONE                                        -- COMPATIBLE IF NO NEXT ELEMENT IN PARAM_LIST_2
          return IS_EMPTY (ID_LIST_2) and then IS_EMPTY (PARAM_LIST_2);        else          POP (PARAM_LIST_1, PARAM_
1);          ID_LIST_1 := LIST (D (AS_SOURCE_NAME_S, PARAM_1));        end if;      end if;      POP (ID_LIST_1, ID_
1);떰                        -- GET NEXT ELEMENT FROM PARAM_LIST_2, IF ANY      if IS_EMPTY (ID_LIST_2) then        if
 IS_EMPTY (PARAM_LIST_2) then떰                                        -- THERE IS NONE                                
        -- NOT COMPATIBLE SINCE THERE WAS AN ELEMENT ON PARAM_LIST_1          return FALSE;        else          POP 
(PARAM_LIST_2, PARAM_2);          ID_LIST_2 := LIST (D (AS_SOURCE_NAME_S, PARAM_2));        end if;      end if;    
  POP (ID_LIST_2, ID_2);떰                        -- IF THEY ARE NOT OF THE SAME TYPE,      if GET_BASE_TYPE (D (SM_OBJ
_TYPE, ID_1)) /= GET_BASE_TYPE (D (SM_OBJ_TYPE, ID_2)) then                                -- THEN THEY ARE NOT COMPATI
BLE        return FALSE;      end if;    end loop;  end IS_SAME_PARAMETER_PROFILE;      --|||||||||||||||||||||||||
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||      --|  procedure CONFORM_PARAMETER_LISTS (PARAM
_S_1, PARAM_S_2 : TREE) is    PARAM_LIST_1         : SEQ_TYPE := LIST (PARAM_S_1);    PARAM_LIST_2         : SEQ_TYPE 
:= LIST (PARAM_S_2);    PARAM_1, PARAM_2     : TREE;    ID_LIST_1, ID_LIST_2 : SEQ_TYPE := (TREE_NIL, TREE_NIL);    I
D_1, ID_2           : TREE;떰  begin                -- IF PARAMETER LISTS ARE THE SAME    if PARAM_S_1 = PARAM_S_2 the
n떰                        -- MUST BE FROM A GENERATED LIBRARY UNIT                        -- ... SO, DO NOT CONFORM (I
.E. DO NOT REMOVE DEFS)      return;    end if;떰                -- LOOP THROUGH BOTH PARAMETER LISTS    loop떰      
                  -- CHECK THAT STRUCTURE OF LISTS IS COMPATIBLE      if (IS_EMPTY (ID_LIST_1) xor IS_EMPTY (ID_LIST_2)
) or (IS_EMPTY (PARAM_LIST_1) xor IS_EMPTY (PARAM_LIST_2)) then        exit;떰                                -- GET NE
XT ELEMENT FROM PARAM_LISTS, IF ANY                                -- RETURN IF NO MORE ELEMENTS      end if;      if
 IS_EMPTY (ID_LIST_1) then        if IS_EMPTY (PARAM_LIST_1) then          return;        else          POP (PARAM_L
IST_1, PARAM_1);          POP (PARAM_LIST_2, PARAM_2);          ID_LIST_1 := LIST (D (AS_SOURCE_NAME_S, PARAM_1));   
       ID_LIST_2 := LIST (D (AS_SOURCE_NAME_S, PARAM_2));떰          if PARAM_1.TY /= PARAM_2.TY then            exit;
          end if;떰          if not IS_COMPATIBLE_EXPRESSION (D (AS_NAME, PARAM_1), D (AS_NAME, PARAM_2)) or else not IS
_COMPATIBLE_EXPRESSION (D (AS_EXP, PARAM_1), D (AS_EXP, PARAM_2)) then            exit;          end if;        end i
f;      end if;떰      POP (ID_LIST_1, ID_1);떰      if D (LX_SYMREP, ID_1) /= D (LX_SYMREP, HEAD (ID_LIST_2)) then   
     exit;      end if;떰      POP (ID_LIST_2, ID_2);떰                        -- ID'S ARE COMPATIBLE, REPLACE DEFS   
   D (SM_FIRST, ID_2, D (SM_FIRST, ID_1));      D (XD_REGION, ID_2, D (XD_REGION, ID_1));      D (SM_INIT_EXP, ID_2, D
 (SM_INIT_EXP, ID_1));      D (SM_OBJ_TYPE, ID_2, D (SM_OBJ_TYPE, ID_1));      REMOVE_DEF_FROM_ENVIRONMENT (GET_DEF_FO
R_ID (ID_2));떰    end loop;떰                -- INCOMPATIBLE, SINCE WE EXITED FROM LOOP    ERROR (D (LX_SRCPOS, PARAM_
S_2), "PARAM LISTS NOT COMPATIBLE");떰                -- DISCARD DEFS FROM SECOND LIST ANYWAY    loop      while not I
S_EMPTY (ID_LIST_2) loop        POP (ID_LIST_2, ID_2);        REMOVE_DEF_FROM_ENVIRONMENT (GET_DEF_FOR_ID (ID_2));   
   end loop;      exit when IS_EMPTY (PARAM_LIST_2);      POP (PARAM_LIST_2, PARAM_2);      ID_LIST_2 := LIST (D (AS_
SOURCE_NAME_S, PARAM_2));    end loop;떰  end CONFORM_PARAMETER_LISTS;      --||||||||||||||||||||||||||||||||||||||||
||||||||||||||||||||||||||||||||||||||||||||||||||||      --|  function IS_COMPATIBLE_EXPRESSION (EXP_1, EXP_2 : TREE)
 return BOOLEAN is                -- ARGUMENTS ARE EXPRESSIONS OR RANGES OR VOID                -- RETURN TRUE IF COMP
ATIBLE (WITHIN PARAM OR DSCRMT LIST)  begin                -- $$$$$$$$ STUB $$$$$$$    return True;  end IS_COMPATIB
LE_EXPRESSION;      --||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||    
  --|  procedure MAKE_DEF_VISIBLE (DEF : TREE; HEADER : TREE := TREE_VOID) is  begin    D (XD_HEADER, DEF, HEADER); 
 end MAKE_DEF_VISIBLE;      --|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|||      --|  procedure MAKE_DEF_IN_ERROR (DEF : TREE) is  begin    D (XD_HEADER, DEF, TREE_FALSE);  end MAKE_DEF_I
N_ERROR;      --||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||      --|
  procedure REMOVE_DEF_FROM_ENVIRONMENT (DEF : TREE) is  begin    D (XD_HEADER, DEF, TREE_VOID);    D (XD_REGION_DEF,
 DEF, TREE_VOID);    DI (XD_LEX_LEVEL, DEF, 0);    DB (XD_IS_USED, DEF, FALSE);  end REMOVE_DEF_FROM_ENVIRONMENT;   
   --||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||      --|  function G
ET_DEF_EXP_TYPE (DEF : TREE) return TREE is    HEADER      : constant TREE := D (XD_HEADER, DEF);    SOURCE_NAME : TRE
E          := D (XD_SOURCE_NAME, DEF);  begin    if HEADER.TY = DN_FUNCTION_SPEC then      return GET_BASE_TYPE (D (A
S_NAME, HEADER));    elsif SOURCE_NAME.TY in CLASS_OBJECT_NAME then      return GET_BASE_TYPE (D (SM_OBJ_TYPE, D (XD_S
OURCE_NAME, DEF)));    elsif SOURCE_NAME.TY in CLASS_TYPE_SPEC then      if GET_BASE_TYPE (SOURCE_NAME).TY /= DN_TASK_
SPEC then        Put_Line ("!! NON TASK TYPE NAME IN CALL TO GET_DEF_EXP_TYPE");        raise Program_Error;      end
 if;      return GET_BASE_TYPE (SOURCE_NAME);    else      return TREE_VOID;    end if;  end GET_DEF_EXP_TYPE;    
  --||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||      --|  function GE
T_BASE_TYPE (TYPE_SPEC_OR_EXP_OR_ID : TREE) return TREE is    TYPE_SPEC : TREE := TYPE_SPEC_OR_EXP_OR_ID;  begin떰    
            -- GET A TYPE SPEC FOR THE EXPRESSION OR ID    case TYPE_SPEC_OR_EXP_OR_ID.TY is      when DN_VOID =>    
    null;      when DN_USED_NAME_ID =>        TYPE_SPEC := D (SM_DEFN, TYPE_SPEC);        if TYPE_SPEC /= TREE_VOID t
hen          TYPE_SPEC := D (SM_TYPE_SPEC, TYPE_SPEC);        end if;      when CLASS_OBJECT_NAME =>        TYPE_SPE
C := D (SM_OBJ_TYPE, TYPE_SPEC);      when DN_FUNCTION_ID =>                                -- (FOR SLICE WHOSE PREFIX
 IS FUNCTION WITH ALL DEFAULT ARGS)        TYPE_SPEC := GET_BASE_TYPE (D (AS_NAME, D (SM_SPEC, TYPE_SPEC)));      when
 DN_PROCEDURE_ID =>                                -- (FOR IDENTIFIER AS EXPRESSION BEFORE OVERLOAD RESOLUTION)       
 TYPE_SPEC := TREE_VOID;      when DN_GENERIC_ID =>                                -- (FOR EITHER OF THE ABOVE CASES)
        if D (XD_HEADER, GET_DEF_FOR_ID (TYPE_SPEC)).TY = DN_FUNCTION_SPEC then          TYPE_SPEC := GET_BASE_TYPE (D 
(AS_NAME, D (SM_SPEC, TYPE_SPEC)));        else          TYPE_SPEC := TREE_VOID;        end if;      when CLASS_TYPE
_NAME | CLASS_RANGE =>        TYPE_SPEC := D (SM_TYPE_SPEC, TYPE_SPEC);      when CLASS_USED_OBJECT | CLASS_EXP_EXP | 
DN_ATTRIBUTE | DN_FUNCTION_CALL | DN_INDEXED | DN_SLICE | DN_ALL =>        TYPE_SPEC := D (SM_EXP_TYPE, TYPE_SPEC);   
   when DN_SELECTED =>        TYPE_SPEC := GET_BASE_TYPE (D (AS_DESIGNATOR, TYPE_SPEC));      when CLASS_TYPE_SPEC =>
        null;      when DN_DISCRETE_SUBTYPE =>        TYPE_SPEC := GET_BASE_TYPE (D (AS_NAME, D (AS_SUBTYPE_INDICATION
, TYPE_SPEC)));      when DN_SUBTYPE_INDICATION =>        TYPE_SPEC := D (SM_TYPE_SPEC, D (AS_NAME, TYPE_SPEC));     
 when CLASS_UNSPECIFIED_TYPE =>        null;      when others =>        Put_Line ("!! BAD PARAMETER FOR GET_BASE_TYPE
");        raise Program_Error;    end case;떰                -- GET UNCONSTRAINED FOR CONSTRAINED TYPE              
  -- (IN CASE CONSTRAINED PRIVATE WITH FULL TYPE VISIBLE)    if TYPE_SPEC.TY in CLASS_CONSTRAINED then      TYPE_SPEC 
:= D (SM_BASE_TYPE, TYPE_SPEC);    end if;떰                -- GET FULL TYPE SPEC FOR PRIVATE OR INCOMPLETE    if TYPE
_SPEC.TY in CLASS_PRIVATE_SPEC then      if D (SM_TYPE_SPEC, TYPE_SPEC) /= TREE_VOID then        TYPE_SPEC := D (SM_TY
PE_SPEC, TYPE_SPEC);      end if;    elsif TYPE_SPEC.TY = DN_INCOMPLETE then      if D (XD_FULL_TYPE_SPEC, TYPE_SPEC)
 /= TREE_VOID then        TYPE_SPEC := D (XD_FULL_TYPE_SPEC, TYPE_SPEC);      end if;    end if;떰                -- 
LOOP TO GET BASE TYPE                -- $$$$ OK? NON-TASK --> PRIVATE ?    while TYPE_SPEC.TY in CLASS_NON_TASK and th
en D (SM_BASE_TYPE, TYPE_SPEC) /= TYPE_SPEC loop      TYPE_SPEC := D (SM_BASE_TYPE, TYPE_SPEC);    end loop;떰    retu
rn TYPE_SPEC;  end GET_BASE_TYPE;      --|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|||||||||||||||      --|  function GET_BASE_PACKAGE (PACKAGE_ID : TREE) return TREE is    UNIT_DESC : TREE := D (SM_U
NIT_DESC, PACKAGE_ID);    BASE_ID   : TREE;  begin    if UNIT_DESC.TY = DN_RENAMES_UNIT then      BASE_ID := GET_NAM
E_DEFN (D (AS_NAME, UNIT_DESC));      if BASE_ID /= TREE_VOID then        return GET_BASE_PACKAGE (BASE_ID);      end
 if;    end if;    return PACKAGE_ID;  end GET_BASE_PACKAGE;떰   --|-------------------------------------------------
---------------------------------------------턤nd DEF_UTIL;
