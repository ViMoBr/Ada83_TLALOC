SEPARATE( IDL )--|----------------------------------------------------------------------------------------------------
|КINIT_GRMR--|--------------------------------------------------------------------------------------------------턕ROCE
DURE INIT_GRMR ( NOM_TEXTE :STRING ) IS  USE  TERM_LIST;     GRAMMARК: TREE;  GR_RULE_SEQ: SEQ_TYPE;     MORE_PA
SSES: BOOLEAN;ККК--| INDIQUE DES CHANGEMENTS DANS LA FERMETURE TRANSITIVE  PASSК: INTEGERК:= 0;     --|-------
----------------------------------------------------------------------------------------  --|촒ROCEDURE INITIALIZE  PR
OCEDURE INITIALIZE IS    RULE_SEQК: SEQ_TYPE:= GR_RULE_SEQ;    RULEК: TREE;    RULE_INIT_LISTК: SEQ_TYPE;    RU
LEINFOК: TREE;    ALT_SEQК: SEQ_TYPE;    ALTК: TREE;    SYL_SEQК: SEQ_TYPE;    SYLК: TREE;    IS_NULLABLEК:
 BOOLEAN;ККК-- CURRENT RULE HAS NULLABLE ALT    GENS_TER_STRК: BOOLEAN;ККК-- CURRENT RULE HAS TERMINAL ALT    N
ONTER_NAMEК: TREE;ККК-- SYMBOL_REP OF NON-TERMINAL    NONTER_DEF_LISTК: SEQ_TYPE;    RULE_COUNTК: INTEGER:= 0;
    INIT_NONTER_SК: TREE;  BEGIN    WHILE NOT IS_EMPTY( RULE_SEQ ) LOOPККК--| TANT QU'IL Y A DES RGLES      POP
( RULE_SEQ, RULE );КККК--| EN EXTRAIRE UNE      RULE_COUNT := RULE_COUNT + 1;ККК--| UNE DE PLUS VUE          
     RULE_INIT_LIST := (TREE_NIL, TREE_NIL);      RULEINFO      := MAKE( DN_RULEINFO );ККК--| FABRIQUER SON INFO   
   INIT_NONTER_S := MAKE( DN_RULE_S );ККК--| FABRIQUER UNE LISTE DE RGLES      LIST( INIT_NONTER_S, INSERT ( (TREE_N
IL, TREE_NIL), RULE ) );КК--| Y METTRE LA RGLE      D  ( XD_INIT_NONTER_S, RULEINFO, INIT_NONTER_S );КК--| PORTER 
CELA DANS L'INFO      DB ( XD_IS_REACHABLE,  RULEINFO, FALSE );ККК--| METTRE REACHABLE  FAUX      DI ( XD_RULE_NBR,
      RULEINFO, RULE_COUNT );КК--| Y PORTER LE N DE RGLE      DI ( XD_TIMECHANGED,   RULEINFO, 0 );ККК--| METTRE 
 0 TIMECHANGED      DI ( XD_TIMECHECKED,   RULEINFO, 0 );ККК--| ET TIMECHECKED      D  ( XD_RULEINFO, RULE, RULEINF
O );ККК--| POINTER L'INFO DANS LA RGLE      IS_NULLABLE := FALSE;      GENS_TER_STR := FALSE;               ALT_S
EQ := LIST( RULE );ККК--| PRENDRE LA LISTE D'ALTERNATIVES      WHILE NOT IS_EMPTY( ALT_SEQ ) LOOPККК--| TANT QU'
IL Y A DES ALTERNATIVES        POP( ALT_SEQ, ALT );КККК--| EN EXTRAIRE UNE        D  ( XD_RULE, ALT, RULE );ККК
--| MENTIONNER LA RGLE QUI LA CONTIENT        DECLARE          ALT_NOT_NULLABLE: BOOLEAN:= FALSE;          ALT_NOT
_GEN_TER_STR: BOOLEAN:= FALSE;        BEGIN          SYL_SEQ := LIST( ALT );ККК--| PRENDRE LA LISTE DE SYLLABES 
DE L'ALTERNATIVE          IF NOT IS_EMPTY( SYL_SEQ ) THENККК--| S'IL Y A DES SYLLABES            SYL := HEAD( SYL_S
EQ );ККК--| PRENDRE LA TTE            IF SYL.TY = DN_TERMINAL THENККК--| SI C'EST UN TERMINAL              RULE
_INIT_LIST := UNION( RULE_INIT_LIST, SYL );КК--| L'AJOUTER  LA LISTE DES TTES TERMINALES D'ALTERNATIVES            EN
D IF;            WHILE NOT IS_EMPTY( SYL_SEQ ) LOOPККК--| TANT QU'IL Y A DES SYLLABES              POP( SYL_SEQ, SY
L );ККК--| EN EXTRAIRE UNE              IF SYL.TY = DN_TERMINAL THENККК--| SI C'EST UN TERMINAL                
ALT_NOT_NULLABLE := TRUE;ККК--| INDIQUER NON ANNULABLE              ELSEКККК--| C'EST UN NON TERMINAL         
       NONTER_NAME := D( XD_SYMREP, SYL );                NONTER_DEF_LIST := LIST( NONTER_NAME );                WHILE
 NOT IS_EMPTY( NONTER_DEF_LIST ) AND THEN HEAD( NONTER_DEF_LIST).TY /= DN_RULE LOOP                  NONTER_DEF_LIST :=
 TAIL( NONTER_DEF_LIST );                END LOOP;                IF IS_EMPTY( NONTER_DEF_LIST ) THEN                
  ERROR( D( LX_SRCPOS, SYL ), "NON-TERMINAL NOT DEFINED - " & PRINT_NAME( NONTER_NAME ) );                  D( XD_RULE,
 SYL, TREE_VOID );                  ALT_NOT_NULLABLE := TRUE;                ELSE                  D( XD_RULE, SYL, H
EAD( NONTER_DEF_LIST ) );КК-- ASSUME THE WORST ABOUT THE NON-TERMINAL FOR NOW                  ALT_NOT_NULLABLE    :=
 TRUE;                  ALT_NOT_GEN_TER_STR := TRUE;                END IF;              END IF;            END LOOP
;          END IF;          IF NOT ALT_NOT_NULLABLE THEN            IS_NULLABLE := TRUE;          END IF;          
IF NOT ALT_NOT_GEN_TER_STR THEN            GENS_TER_STR := TRUE;          END IF;        END;      END LOOP;       
       LIST( RULEINFO,RULE_INIT_LIST );      DB  ( XD_GENS_TER_STR, RULEINFO, GENS_TER_STR );      DB  ( XD_IS_NULLAB
LE, RULE, IS_NULLABLE );    END LOOP;                -- FIRST RULE IS ALWAYS REACHABLE    DB( XD_IS_REACHABLE, D( XD_
RULEINFO, HEAD( GR_RULE_SEQ ) ), TRUE );  END INITIALIZE;  --|--------------------------------------------------------
---------------------------------------  --|촒ROCEDURE TRANS_CLOSE  PROCEDURE TRANS_CLOSE IS    RULE_SEQК: SEQ_TYPE
:= GR_RULE_SEQ;    RULEК: TREE;    RULE_INIT_LISTК: SEQ_TYPE;    RULEINFOК: TREE;    ALT_SEQК: SEQ_TYPE;    AL
TК: TREE;    SYL_SEQК: SEQ_TYPE;    SYLК: TREE;    IS_NULLABLEК: BOOLEAN;ККК-- CURRENT RULE HAS NULLABLE ALT
    IS_REACHABLEК: BOOLEAN;ККК-- CURRENT RULE IS REACHABLE    GENS_TER_STRК: BOOLEAN;ККК-- CURRENT RULE HAS TE
RMINAL ALT    ALT_NOT_NULLABLE: BOOLEAN;ККК-- ALT FOUND TO BE NOT NULLABLE    ALT_NOT_GEN_TER_STR: BOOLEAN;     
           -- ALT FOUND TO BE NOT TERMINALN    NONTER_RULEК: TREE;    NONTER_INFOК: TREE;    TIMECHANGEDК: INTEGER
;    TIMECHECKEDК: INTEGER;    NONTER_CHANGEDК: INTEGER;    CHANGE_FLAGК: BOOLEAN;ККК-- RULE CHANGED IN THIS PA
SS    INIT_NONTER_SК: TREE;    INIT_NONTER_SEQК: SEQ_TYPE;        BEGIN    WHILE NOT IS_EMPTY( RULE_SEQ ) LOOP  
    RULE     := HEAD( RULE_SEQ );      RULE_SEQ := TAIL( RULE_SEQ );               RULEINFO := D( XD_RULEINFO, RULE )
;      TIMECHANGED := DI( XD_TIMECHANGED, RULEINFO );      TIMECHECKED := DI( XD_TIMECHECKED, RULEINFO );      DI( XD
_TIMECHECKED, RULEINFO, PASS );               RULE_INIT_LIST := LIST( RULEINFO );      IS_REACHABLE   := DB( XD_IS_RE
ACHABLE, RULEINFO );      IS_NULLABLE    := FALSE;ККК-- WE'LL SEE IF IT CHANGES      GENS_TER_STR   := DB( XD_GENS
_TER_STR, RULEINFO );      INIT_NONTER_S  := D( XD_INIT_NONTER_S, RULEINFO );      INIT_NONTER_SEQ:= LIST( INIT_NONTER
_S );      CHANGE_FLAG := FALSE;               ALT_SEQ := LIST( RULE );      WHILE NOT IS_EMPTY( ALT_SEQ ) LOOP    
    POP( ALT_SEQ, ALT );                    ALT_NOT_NULLABLE   := FALSE;        ALT_NOT_GEN_TER_STR:= FALSE;        
SYL_SEQ            := LIST ( ALT);        IF NOT IS_EMPTY( SYL_SEQ ) THEN          SYL := HEAD( SYL_SEQ );          I
F SYL.TY = DN_NONTERMINAL THEN            NONTER_RULE := D( XD_RULE, SYL );            IF NONTER_RULE.TY /= DN_VOID TH
EN              INIT_NONTER_SEQ := R_UNION( INIT_NONTER_SEQ, LIST( D( XD_INIT_NONTER_S, D( XD_RULEINFO, NONTER_RULE ) )
 ) );            END IF;          END IF;        END IF;        WHILE NOT IS_EMPTY( SYL_SEQ ) LOOP          POP( SY
L_SEQ, SYL );          IF SYL.TY = DN_TERMINAL THEN            IF NOT ALT_NOT_NULLABLE THEN              ALT_NOT_NULL
ABLE := TRUE;              IF TIMECHANGED >= TIMECHECKED THEN땝КК-- OTHERWISE ALREADY DONE                RULE_INIT
_LIST := UNION( RULE_INIT_LIST, SYL );              END IF;            END IF;          ELSE -- SINCE IT'S DN_NONTERM
INAL            NONTER_RULE := D( XD_RULE, SYL );            IF NONTER_RULE.TY = DN_VOID THEN              ALT_NOT_NU
LLABLE := TRUE;            ELSE              NONTER_INFO := D( XD_RULEINFO, NONTER_RULE );              NONTER_CHANGE
D := DI( XD_TIMECHANGED, NONTER_INFO );              IF TIMECHANGED >= TIMECHECKED AND THEN IS_REACHABLE AND THEN NOT D
B( XD_IS_REACHABLE, NONTER_INFO ) THEN                MORE_PASSES := TRUE;                DB( XD_IS_REACHABLE, NONTER_
INFO, TRUE);                DI( XD_TIMECHANGED, NONTER_INFO, PASS );              END IF;              IF NOT ALT_NOT
_NULLABLE THEN                IF NOT DB( XD_IS_NULLABLE, NONTER_RULE ) THEN                  ALT_NOT_NULLABLE := TRUE;
                ELSE                  IF NONTER_CHANGED > TIMECHANGED THEN                                           
                                     -- KEEP LOOKING IF NONTER BECAME NULLABLE                    TIMECHANGED := NONTER
_CHANGED;                  END IF;                END IF;                IF NONTER_CHANGED >= TIMECHECKED THEN      
            RULE_INIT_LIST := UNION ( RULE_INIT_LIST, LIST ( NONTER_INFO ) );                END IF;              END 
IF;              IF NOT ALT_NOT_GEN_TER_STR AND THEN NOT GENS_TER_STR AND THEN NOT DB ( XD_GENS_TER_STR, NONTER_INFO ) 
THEN                ALT_NOT_GEN_TER_STR := TRUE;              END IF;            END IF;          END IF;          
EXIT WHEN ALT_NOT_NULLABLE AND THEN GENS_TER_STR AND THEN TIMECHANGED < TIMECHECKED;        END LOOP;        IF NOT AL
T_NOT_NULLABLE THEN          IS_NULLABLE := TRUE;        END IF;        IF NOT ALT_NOT_GEN_TER_STR THEN          GEN
S_TER_STR := TRUE;        END IF;      END LOOP;               IF NOT SAME ( LIST ( RULEINFO ), RULE_INIT_LIST ) THE
N        LIST ( RULEINFO, RULE_INIT_LIST );        CHANGE_FLAG := TRUE;      END IF;      IF NOT SAME ( LIST ( INIT_
NONTER_S), INIT_NONTER_SEQ ) THEN        LIST ( INIT_NONTER_S, INIT_NONTER_SEQ );        CHANGE_FLAG := TRUE;      EN
D IF;      IF GENS_TER_STR AND THEN NOT DB ( XD_GENS_TER_STR, RULEINFO ) THEN        DB ( XD_GENS_TER_STR, RULEINFO, T
RUE );        CHANGE_FLAG := TRUE;      END IF;      IF IS_NULLABLE AND THEN NOT DB ( XD_IS_NULLABLE, RULE ) THEN   
     DB ( XD_IS_NULLABLE, RULE, TRUE );        CHANGE_FLAG := TRUE;      END IF;      IF CHANGE_FLAG THEN        DI 
( XD_TIMECHANGED, RULEINFO, PASS );        MORE_PASSES := TRUE;      END IF;    END LOOP;  END TRANS_CLOSE;  --|---
--------------------------------------------------------------------------------------------  --|촒ROCEDURE CHECK_GRAMM
AR  PROCEDURE CHECK_GRAMMAR IS    RULE_SEQ: SEQ_TYPE:= GR_RULE_SEQ;    RULEК: TREE;    RULEINFO: TREE;  BEGIN 
   WHILE NOT IS_EMPTY( RULE_SEQ ) LOOP      POP( RULE_SEQ, RULE );      RULEINFO := D( XD_RULEINFO, RULE );      IF N
OT DB( XD_IS_REACHABLE, RULEINFO ) THEN        ERROR( D( LX_SRCPOS,RULE ), "RULE CANNOT BE REACHED - " & PRINT_NAME( D(
 XD_NAME, RULE ) ) );      END IF;      IF NOT DB( XD_GENS_TER_STR, RULEINFO ) THEN        ERROR( D( LX_SRCPOS,RULE )
, "DOES NOT GEN TERMINAL STRING - " & PRINT_NAME( D( XD_NAME, RULE ) ) );      END IF;    END LOOP;  END CHECK_GRAMMA
R;   턆EGIN떰  PUT_LINE( "INITIALIZE.");  DECLARE    USER_ROOT: TREE;  BEGIN    OPEN_IDL_TREE_FILE( NOM_TEXTE & ".
lar" );    USER_ROOT := D( XD_USER_ROOT, TREE_ROOT );    GRAMMAR   := D( XD_GRAMMAR, USER_ROOT );  END;떰  GR_RULE_SE
Q := LIST( GRAMMAR );  INITIALIZE;떰  LOOP    PASS := PASS + 1;    PUT ( "BEGIN TRANS CLOSE PASS " );    INT_IO.PUT 
( PASS, 1 );    PUT_LINE ( "." );    MORE_PASSES := FALSE;    TRANS_CLOSE;    EXIT WHEN NOT MORE_PASSES;  END LOOP;
        PUT_LINE ( "CHECK GRAMMAR." );  CHECK_GRAMMAR;     CLOSE_IDL_TREE_FILE;--|--------------------------------
------------------------------------------------------------------턉ND INIT_GRMR;
