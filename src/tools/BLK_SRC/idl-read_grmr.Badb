WITH UNCHECKED_DEALLOCATION;턜ITH LEX, GRMR_OPS;턘EPARATE( IDL )--|----------------------------------------------------
-----------------------------------------------|КREAD_GRMR--|턕ROCEDURE READ_GRMR ( NOM_TEXTE :STRING ) IS     IFIL
E, OFILEК: FILE_TYPE;ККК--| FICHIER GRAMMAIRE ET TEXTE D'INITIALISATIONS SYMBOLES OPERATEURS     TER_COUNTК: NATU
RAL:= 0;  ALT_COUNTК: NATURAL:= 0;     SEMAN_COUNTК: INTEGER:= 0;ККК--| NOMBRE DE SYLLABES SEMANTIQUES  SEMA
N_ALT_COUNTК: INTEGER:= 0;  ККК--| NOMBRE D'ALTS AVEC SEMANTIQUE     SOURCE_LISTК: SEQ_TYPE;ККК--| LISTE DES 
SOURCELINES  SOURCEPOSК: TREE;ККК--| LA SOURCE_POSITION     ARITY_TABLEК: ARRAY( 0 .. 300 ) OF INTEGER:= (OTHE
RS => -1);     --|-----------------------------------------------------------------------------------------------  --
|  PACKAGE LALR_LEX IS  --|-------------------------------------------------------------------------------------------
----          PROCEDURE AVANCER;    FUNCTION  TOKEN촔ETURN STRING;        --|--------------------------------------
---------------------------------------------------------  END LALR_LEX;떰    --|-------------------------------------
----------------------------------------------------------  --|  PACKAGE BODY LALR_LEX IS  --|-----------------------
------------------------------------------------------------------------          SLINEК: STRING( 1 .. 256 );ККК--
| LIGNE COURANTE    LINE_COUNT: NATURAL:= 0;ККК--| NOMBRE DE LIGNES VUES    LINE_TAKEN: NATURAL:= 0;ККК--|
 N DE LA DERNIERE LIGNE PRISE DANS UN SOURCE_LINE    COLК: NATURAL:= 1;ККК--| PROCHAINE COLONNE  BALAYER    LAST
К: NATURAL:= 0;ККК--| NB DE CARACTERES DANS LA LIGNE    TS, TE: NATURAL; ККК--| BORNES DU LEXEME          
--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||    --|촒ROCEDURE AVANC
ER    PROCEDURE AVANCER IS      SOURCE_LINEК: TREE;ККК--| LE SOURCELINE COURANT    BEGIN         <<START_GET>>
               IF COL > LAST THEN        IF END_OF_FILE( IFILE ) THEN          TS := SLINE'FIRST;          TE := SL
INE'FIRST + 3;          SLINE( SLINE'FIRST..SLINE'FIRST+3 ) := "%end";        ELSE          GET_LINE( IFILE, SLINE, L
AST );          LINE_COUNT := LINE_COUNT + 1;          COL := 1;        END IF;      END IF;               WHILE C
OL <= LAST AND THEN (SLINE( COL ) = ' ' OR ELSE SLINE( COL ) = ASCII.HT) LOOP        COL := COL + 1;      END LOOP;  
             IF COL < LAST THEN        IF SLINE( COL..COL+1 ) = "--" OR SLINE( COL..COL+1 ) = "//" OR SLINE( COL..COL+
1 ) = "##" THEN          COL := LAST + 1;          GOTO START_GET;        END IF;      ELSIF COL > LAST THENКК--| 
LIGNE BLANCHE        GOTO START_GET;      END IF;                     TS := COL;      WHILE COL <= LAST LOOP      
  EXIT WHEN SLINE( COL ) = ' ' OR ELSE SLINE( COL ) = ASCII.HT;        IF COL < LAST AND THEN SLINE( COL..COL+1 ) = "--
" THEN          COL := LAST + 1;          GOTO START_GET;        END IF;        COL := COL + 1;      END LOOP;    
  TE := COL - 1;               IF LINE_COUNT /= LINE_TAKEN THEN        SOURCE_LINE := MAKE( DN_SOURCELINE );        
DI  ( XD_NUMBER, SOURCE_LINE, LINE_COUNT );        LIST( SOURCE_LINE, (TREE_NIL,TREE_NIL) );        SOURCE_LIST := APP
END( SOURCE_LIST, SOURCE_LINE );      END IF;               SOURCEPOS := MAKE_SOURCE_POSITION( SOURCE_LINE,SRCCOL_IDX
( TS ) );    END AVANCER;    --|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|||||||    --|촄UNCTION TOKEN    FUNCTION TOKEN RETURN STRING IS    BEGIN      RETURN SLINE( TS..TE );    END;    
       --|-----------------------------------------------------------------------------------------------  END LALR_LE
X;  USE LALR_LEX;            떰  --|--------------------------------------------------------------------------------
---------------  --|촒ROCEDURE LOAD_DIANA  PROCEDURE LOAD_DIANA IS    OPК: TREE;    SYMК: TREE;    NODE_POS: NAT
URAL;    DIANATBL_FILE: TEXT_IO.FILE_TYPE;    BUFFER: STRING( 1..127 );    LASTК: NATURAL RANGE 0..127;    COLК:
 NATURAL RANGE 0..127;          PROCEDURE SKIP_BLANKS IS    BEGIN      WHILE COL <= LAST AND THEN (BUFFER( COL ) = '
 ' OR BUFFER( COL ) = ASCII.HT) LOOP        COL := COL + 1;      END LOOP;    END;          PROCEDURE FIND_BLANK IS
    BEGIN      WHILE COL <= LAST AND THEN BUFFER( COL ) /= ' ' AND THEN BUFFER( COL ) /= ASCII.HT LOOP        COL := 
COL + 1;      END LOOP;    END;        BEGIN          TEXT_IO.OPEN( DIANATBL_FILE, TEXT_IO.IN_FILE, "../idl_tools/
diana.tbl" );떰TROUVER_CLASSE_ALL_SOURCE:    LOOP      GET_LINE( DIANATBL_FILE, BUFFER, LAST );      IF LAST > 0 THEN
        IF BUFFER( 1 ) = 'C' THEN          COL := 2;          SKIP_BLANKS;          EXIT WHEN BUFFER( COL..LAST ) = 
"ALL_SOURCE";        END IF;      END IF;    END LOOP TROUVER_CLASSE_ALL_SOURCE;떰TRAITER_TOUTE_CLASSE_ALL_SOURCE:  
  LOOP      GET_LINE( DIANATBL_FILE, BUFFER, LAST);      IF LAST > 0 THEN        IF BUFFER( 1 ) = 'E' THENККК--| 
FIN DE CLASSE          COL := 2;          SKIP_BLANKS;          EXIT WHEN BUFFER( COL..LAST ) = "ALL_SOURCE";КК--|
 FIN DE CLASSE SOURCE_NAME : FIN DE TRAITEMENT떰        ELSIF BUFFER( 1 ) = 'N' THENККК--| POUR UN NOEUD          C
OL := 2;          SKIP_BLANKS;          FIND_BLANK;КККК--| POUR PASSER SUR LE NUMERO DE NOEUD          SKIP_BLANK
S;                         OP := MAKE( DN_SEM_OP );ККК--| CREER UN NOEUD SEM_OP          NODE_POS := INTEGER'VALU
E( BUFFER( 2..COL-1 ) );КК--| NUMERO DE NOEUD          DI( XD_SEM_OP, OP, NODE_POS );ККК--| OP.XD_SEM_OP := POS 
         SYM := STORE_SYM( BUFFER( COL..LAST ) );КК--| NOM DU NOEUD          LIST( SYM, INSERT( LIST( SYM ), OP ) );
          ARITY_TABLE( NODE_POS ) := 0;떰        ELSIF BUFFER( 1 ) = 'A' OR ELSE BUFFER( 1 ) = 'B' OR ELSE BUFFER( 1 ) 
= 'I' THEN          COL := 2;          SKIP_BLANKS;          FIND_BLANK;          SKIP_BLANKS;                    
     IF COL + 2 <= LAST AND THEN BUFFER( COL .. COL+2 ) = "as_" THENК--| ATTRIBUT as_xxx            COL := 2;КККК
--| RECULER AU DEVANT DU NUMERO D ATTRIBUT            SKIP_BLANKS;            IF BUFFER( COL ) = '-' THENККК--| NU
MERO NEGATIF INDIQUE SEQUENCE              ARITY_TABLE( NODE_POS ) := 4;            ELSE              ARITY_TABLE( NO
DE_POS ) := ARITY_TABLE( NODE_POS ) + 1;            END IF;          END IF;        END IF;      END IF;    END LOO
P TRAITER_TOUTE_CLASSE_ALL_SOURCE;          TEXT_IO.CLOSE( DIANATBL_FILE );           EXCEPTION    WHEN END_ERROR =
>      TEXT_IO.CLOSE( DIANATBL_FILE );  END LOAD_DIANA;  --|---------------------------------------------------------
--------------------------------------  --|촒ROCEDURE LOAD_TERMINALS  PROCEDURE LOAD_TERMINALS IS    TERК: TREE;   
 SYMК: TREE;    DEFLIST: SEQ_TYPE;    USE LEX;  BEGIN    FOR T IN LEX_TYPE LOOP      TER := MAKE( DN_TERMINAL );
      SYM := STORE_SYM( LEX.LEX_IMAGE ( T ) );      DEFLIST := LIST( SYM );      WHILE NOT IS_EMPTY( DEFLIST ) AND THE
N HEAD( DEFLIST ).TY /= DN_TERMINAL LOOP        DEFLIST := TAIL( DEFLIST );      END LOOP;      IF NOT IS_EMPTY( DEFL
IST ) THEN        PUT ( "***DUPLICATE TERMINAL IMAGE - " );        PUT_LINE( LEX_IMAGE ( T ) );      END IF;      LI
ST( SYM, INSERT( LIST( SYM ), TER ) );      D( XD_SYMREP, TER, SYM );      DI( XD_TER_NBR, TER, LEX_TYPE'POS( T ) ); 
   END LOOP;  END LOAD_TERMINALS;  --|--------------------------------------------------------------------------------
--------------  --|촒ROCEDURE PROCESS_GRAMMAR  PROCEDURE PROCESS_GRAMMAR IS    USER_ROOT: TREE;    GRAMMAR: TREE;
    RULEК: TREE;    ALTERNATIVE: TREE;    SYLLABLE: TREE;    SYMBOL: TREE;    SEQК: SEQ_TYPE;    RULE_LIST: S
EQ_TYPE:= (TREE_NIL,TREE_NIL);    ALT_LIST: SEQ_TYPE;    SYL_LIST: SEQ_TYPE;    SEMAN_LIST: SEQ_TYPE;    SEM_SК
: TREE;    --|---------------------------------------------------------------------------------------------    --|촒RO
CEDURE MAKE_RULE    PROCEDURE MAKE_RULE ( TEXT :STRING ) IS      DEFLIST: SEQ_TYPE;    BEGIN               IF TEXT
 = "%%" OR TEXT = "::=" THEN RAISE PROGRAM_ERROR; END IF;떰      SYMBOL := STORE_SYM( TEXT );      PUT_LINE( "RULE = " 
& TEXT );      RULE := MAKE( DN_RULE );      D( XD_NAME, RULE, SYMBOL);      D( LX_SRCPOS, RULE, SOURCEPOS );      R
ULE_LIST := APPEND( RULE_LIST, RULE );               SEQ := LIST( SYMBOL );      DEFLIST := SEQ;      WHILE NOT IS_E
MPTY( DEFLIST )땝  AND THEN HEAD( DEFLIST).TY /= DN_RULE땝  AND THEN HEAD( DEFLIST).TY /= DN_TERMINAL      LOOP       
 DEFLIST := TAIL( DEFLIST );      END LOOP;      IF NOT IS_EMPTY( DEFLIST ) THEN        ERROR( SOURCEPOS, "DUPLICATE 
RULE - " & TEXT );      END IF;      LIST( SYMBOL, APPEND( SEQ, RULE ) );               ALT_LIST := (TREE_NIL,TREE_N
IL);    END MAKE_RULE;    --|-----------------------------------------------------------------------------------------
---    --|촒ROCEDURE MAKE_ALTERNATIVE    PROCEDURE MAKE_ALTERNATIVE IS    BEGIN      ALTERNATIVE := MAKE( DN_ALT );
      D( LX_SRCPOS, ALTERNATIVE, SOURCEPOS);      ALT_COUNT   := ALT_COUNT + 1;      DI( XD_ALT_NBR, ALTERNATIVE, ALT_
COUNT );      ALT_LIST    := APPEND( ALT_LIST, ALTERNATIVE );               SYL_LIST   := (TREE_NIL,TREE_NIL);      
SEMAN_LIST := (TREE_NIL,TREE_NIL);    END MAKE_ALTERNATIVE;    --|----------------------------------------------------
-----------------------------------------    --|촒ROCEDURE MAKE_SYLLABE    PROCEDURE MAKE_SYLLABE ( TEXT :STRING ) IS
    BEGIN               IF TEXT = "%%" OR TEXT = "::=" THEN RAISE PROGRAM_ERROR; END IF;               IF TEXT = "'|
'" THEN        SYMBOL := STORE_SYM( "|" );      ELSE        SYMBOL := STORE_SYM( TEXT );      END IF;             
  SEQ := LIST( SYMBOL );      WHILE NOT IS_EMPTY( SEQ )땝  AND THEN HEAD( SEQ ).TY /= DN_TERMINAL땝  AND THEN HEAD( SEQ
 ).TY /= DN_RULE      LOOP        SEQ := TAIL( SEQ );      END LOOP;      IF IS_EMPTY( SEQ ) OR ELSE HEAD( SEQ ).TY 
/= DN_TERMINAL THEN        SYLLABLE := MAKE( DN_NONTERMINAL);      ELSE        SYLLABLE := MAKE( DN_TERMINAL );     
   DI( XD_TER_NBR, SYLLABLE, DI( XD_TER_NBR, HEAD( SEQ ) ) );      END IF;               D( XD_SYMREP, SYLLABLE, SYMB
OL );      D( LX_SRCPOS, SYLLABLE, SOURCEPOS );               SYL_LIST := APPEND( SYL_LIST, SYLLABLE );    END MAKE_
SYLLABE;    --|---------------------------------------------------------------------------------------------    --|촒R
OCEDURE MAKE_SEMANTICS_GET_TOKEN    PROCEDURE MAKE_SEMANTICS_GET_TOKEN ( IN_TEXT :STRING ) IS      TEXTК: CONSTANT ST
RING:= IN_TEXT;КК-- COPY OF THE ARGUMENT      USE GRMR_OPS;      SEM_OPК: GRMR_OP;      SEMAN_SYMК: TREE;      
NODE_NAME_POSК: INTEGER;      DEFLISTК: SEQ_TYPE;      SEMANК: TREE;      NODE_NAME_ARITY: ARITIES;    BEGIN   
            SEM_OP := GRMR_OP_VALUE( TEXT );      AVANCER;      CASE SEM_OP IS      WHEN G_ERROR =>        ERROR ( 
SOURCEPOS, "INVALID SEMANTIC OP - " & TEXT );      WHEN N_0 .. N_L =>        SEMAN_SYM := FIND_SYM( TOKEN );        I
F SEMAN_SYM.TY = DN_VOID THEN          DEFLIST := (TREE_NIL,TREE_NIL);        ELSE          DEFLIST := LIST( SEMAN_SY
M );          WHILE NOT IS_EMPTY( DEFLIST ) AND THEN HEAD( DEFLIST ).TY /= DN_SEM_OP LOOP            DEFLIST := TAIL( 
DEFLIST );          END LOOP;        END IF;        IF IS_EMPTY( DEFLIST) THEN          ERROR( SOURCEPOS, "NODE NAME
 NOT FOUND AFTER - " & TEXT );        ELSE          NODE_NAME_POS := DI( XD_SEM_OP, HEAD( DEFLIST ) );          AVANC
ER;          SEMAN := MAKE( DN_SEM_NODE );          DI( XD_SEM_OP, SEMAN, GRMR_OP'POS( SEM_OP ) );          DI( XD_KI
ND,   SEMAN, NODE_NAME_POS );          SEMAN_LIST := APPEND( SEMAN_LIST, SEMAN );          SEMAN_COUNT := SEMAN_COUNT 
+ 1;                            NODE_NAME_ARITY := ARITIES'VAL( ARITY_TABLE( NODE_NAME_POS ) );          CASE SEM_OP 
IS          WHEN N_0 .. N_DEF =>            IF NODE_NAME_ARITY /= NULLARY THEN              ERROR( SOURCEPOS, "NODE M
UST BE NULLARY - " & TEXT & " " & PRINT_NAME( SEMAN_SYM ) );            END IF;          WHEN N_1 =>            IF NO
DE_NAME_ARITY /= UNARY THEN              ERROR( SOURCEPOS, "NODE MUST BE UNARY - " & TEXT & " " & PRINT_NAME( SEMAN_SYM
 ) );            END IF;          WHEN N_2 .. N_V2 =>            IF NODE_NAME_ARITY /= BINARY THEN              ERRO
R( SOURCEPOS, "NODE MUST BE BINARY - " & TEXT & " " & PRINT_NAME( SEMAN_SYM ) );            END IF;          WHEN N_3 
.. N_V3 =>            IF NODE_NAME_ARITY /= TERNARY THEN              ERROR( SOURCEPOS, "NODE MUST BE TERNARY - " & TE
XT & " " & PRINT_NAME( SEMAN_SYM ) );            END IF;          WHEN N_L =>            IF NODE_NAME_ARITY /= ARBITR
ARY THEN              ERROR ( SOURCEPOS, "NODE MUST BE ARBITRARY - " & TEXT & " " & PRINT_NAME( SEMAN_SYM ) );        
    END IF;          WHEN OTHERS =>            RAISE PROGRAM_ERROR;          END CASE;        END IF;      WHEN G_I
NFIX | G_UNARY =>        IF TOKEN( TOKEN'FIRST ) /= '"' THEN          ERROR( SOURCEPOS, "QUOTED STRING REQUIRED AFTER 
- " & TEXT & "( TOKEN = " & TOKEN & ")" );        ELSE          SEMAN := MAKE( DN_SEM_NODE );          DI( XD_SEM_OP,
 SEMAN, GRMR_OP'POS( SEM_OP ) );          DECLARE            SYM: TREE:= STORE_SYM( TOKEN );          BEGIN       
     D( XD_KIND, SEMAN, SYM );                                    PUT_LINE( OFILE, "STORE_SYM ( " &  TOKEN & " );" );
  SET_OUTPUT( OFILE ); PRINT_TREE( SYM ); SET_OUTPUT( STANDARD_OUTPUT );                                  END;      
    SEMAN_LIST := APPEND( SEMAN_LIST, SEMAN );          SEMAN_COUNT := SEMAN_COUNT + 1;          AVANCER;        END 
IF;      WHEN OTHERS =>        SEMAN := MAKE( DN_SEM_OP );        DI( XD_SEM_OP, SEMAN, GRMR_OP'POS( SEM_OP ) );    
    SEMAN_LIST := APPEND( SEMAN_LIST, SEMAN );        SEMAN_COUNT := SEMAN_COUNT + 1;      END CASE;    END MAKE_SEMA
NTICS_GET_TOKEN;    --|---------------------------------------------------------------------------------------------  
  --|촒ROCEDURE MAKE_TERMINAL    PROCEDURE MAKE_TERMINAL ( TEXT :STRING ) IS      SYMBOLК: TREE;      DEFLISTК: SEQ
_TYPE;    BEGIN      IF TEXT = "'|'" THEN        SYMBOL := FIND_SYM( "|");      ELSE        SYMBOL := FIND_SYM( TEX
T );      END IF;               IF SYMBOL.TY = DN_VOID THEN        DEFLIST := (TREE_NIL,TREE_NIL);      ELSE      
  DEFLIST := LIST( SYMBOL );        WHILE NOT IS_EMPTY( DEFLIST ) AND THEN HEAD( DEFLIST).TY /= DN_TERMINAL LOOP      
    DEFLIST := TAIL( DEFLIST );        END LOOP;      END IF;      IF IS_EMPTY( DEFLIST ) THEN        ERROR( SOURCEP
OS, "UNDEFINED TERMINAL - " & TEXT );      ELSE        D( LX_SRCPOS, HEAD( DEFLIST ), SOURCEPOS );      END IF;    E
ND MAKE_TERMINAL;        BEGIN          IF TOKEN /= "%terminals" THEN      ERROR( SOURCEPOS, "EXPECTING %terminals"
 );      RETURN;    END IF;    AVANCER;          MAKE_TERMINAL( "*end*" );          WHILE TOKEN /= "%start" LOOP
      MAKE_TERMINAL ( TOKEN );      AVANCER;    END LOOP;          IF TOKEN /="%start" THEN      ERROR( SOURCEPOS, 
"EXPECTING %start" );      RETURN;    END IF;    AVANCER;КККК--| SAUTER %start                -- GENERATE RULE:
                -- *SENTENCE* ::= <START_SYMBOL> *END*    MAKE_RULE( "*SENTENCE*" );    MAKE_ALTERNATIVE;    MAKE_S
YLLABE( TOKEN );    IF SYLLABLE.TY = DN_TERMINAL THEN      ERROR( SOURCEPOS, "START SYMBOL CANNOT BE TERMINAL - " & TO
KEN );    END IF;    MAKE_SYLLABE( "*end*" );    SEM_S := MAKE( DN_SEM_S );    DI  ( XD_SEM_INDEX, SEM_S, 0);    LI
ST( SEM_S, (TREE_NIL,TREE_NIL) );    LIST( ALTERNATIVE, SYL_LIST);    D   ( XD_SEMANTICS, ALTERNATIVE, SEM_S );    LI
ST( RULE, ALT_LIST );          AVANCER;КККК--| LIT LE %rules    IF TOKEN /= "%rules" THEN      ERROR( SOURCEPOS
, "EXPECTING %RULES INSTEAD OF " & TOKEN );      RETURN;    END IF;    AVANCER;КККК--| SAUTER %rules          
WHILE TOKEN /= "%end" LOOP      MAKE_RULE( TOKEN );      AVANCER;      IF TOKEN = "::=" THEN        AVANCER;      E
LSE        ERROR( SOURCEPOS, "EXPECTING ::= INSTEAD OF " & TOKEN );      END IF;               WHILE TOKEN /= "%%" L
OOP        MAKE_ALTERNATIVE;        WHILE TOKEN /= "|" AND THEN TOKEN /= "====>" AND THEN TOKEN /= "%%" LOOP         
 IF TOKEN /= "empty" THEN            MAKE_SYLLABE( TOKEN );          END IF;          AVANCER;        END LOOP;    
                   IF TOKEN = "====>" THENККК--| UNE LISTE D'OPERATIONS SEMANTIQUES          AVANCER;          WH
ILE TOKEN /= "|" AND TOKEN /= "%%" LOOPКК--| ARRET DE LA LISTE SUR NOUVELLE ALTERNATIVE OU FIN DE REGLE            M
AKE_SEMANTICS_GET_TOKEN( TOKEN );ККК--| INTEGRER L'OPERATION SEMANTIQUE          END LOOP;        END IF;         
              SEM_S := MAKE( DN_SEM_S );        DI  ( XD_SEM_INDEX, SEM_S, 0 );        LIST( SEM_S, SEMAN_LIST );   
     IF NOT IS_EMPTY( SEMAN_LIST ) THEN          SEMAN_ALT_COUNT := SEMAN_ALT_COUNT + 1;        END IF;        D   ( 
XD_SEMANTICS, ALTERNATIVE, SEM_S );        LIST( ALTERNATIVE, SYL_LIST );                       IF TOKEN = "|" THENК
ККК--| ENCORE UNE ALTERNATIVE, PASSER LE '|'          AVANCER;        END IF;      END LOOP;               LIST(
 RULE, ALT_LIST );КККК--| LISTER LA REGLE      AVANCER;КККК--| PASSER LE %%떰    END LOOP;떰    GRAMMAR := MAK
E( DN_RULE_S );    LIST( GRAMMAR, RULE_LIST );          USER_ROOT := MAKE( DN_USER_ROOT );    D( XD_SOURCENAME, USER
_ROOT, STORE_TEXT( NOM_TEXTE ) );    D( XD_GRAMMAR, USER_ROOT, GRAMMAR );          D( XD_USER_ROOT, TREE_ROOT, USER_R
OOT );  END PROCESS_GRAMMAR;      턆EGIN  OPEN  ( IFILE, IN_FILE, "../../idl/" & "diana.idl" );КК--| CONTIENT LA 
DESCRIPTION IDL DE LA GRAMMAIRE ADA83  CREATE( OFILE, OUT_FILE, NOM_TEXTE & "_INITS.txt" );  CREATE_IDL_TREE_FILE( NOM
_TEXTE & ".lar" );ККК--| FICHIER DES PAGES CONTENANT L ARBRE GRAMMAIRE ADA83  SOURCE_LIST := (TREE_NIL, TREE_NIL );
  LOAD_DIANA;  LOAD_TERMINALS;           AVANCER;  PUT_LINE( "PROCESS_GRAMMAR");  PROCESS_GRAMMAR;        LIST ( 
TREE_ROOT, SOURCE_LIST );  CLOSE( OFILE);  CLOSE( IFILE);  CLOSE_IDL_TREE_FILE;           INT_IO.PUT( SEMAN_COUNT, 
0 );  PUT( " SEM SYLS FOR " );  INT_IO.PUT( SEMAN_ALT_COUNT, 0 );  PUT_LINE( " ALTS." );--|-------------------------
------------------------------------------------------------------------턉ND READ_GRMR;
