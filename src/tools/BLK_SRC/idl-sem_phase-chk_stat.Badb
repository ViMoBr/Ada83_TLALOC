separate (IDL.SEM_PHASE)    --|----------------------------------------------------------------------------------------
------    --| CHK_STAT    --|-----------------------------------------------------------------------------------------
-----턯ackage body CHK_STAT is  use EXPRESO;  use REQ_UTIL; -- GET_BASE_STRUCT떰        -- FUNCTIONS TO CHECK FOR STAT
IC RANGES AND SUBTYPES        -- THE IMPLEMENTATION OF THESE FUNCTIONS FOLLOWS RM 4.9/11떰  function IS_STATIC_RANGE (A
 : TREE) return Boolean is  begin    return A.TY = DN_RANGE and then GET_STATIC_VALUE (D (AS_EXP1, A)) /= TREE_VOID an
d then GET_STATIC_VALUE (D (AS_EXP2, A)) /= TREE_VOID;  end IS_STATIC_RANGE;떰  function IS_STATIC_SUBTYPE (A : TREE) r
eturn Boolean is  begin    if A.TY in CLASS_PRIVATE_SPEC then      return GET_BASE_STRUCT (A).TY in CLASS_SCALAR and 
then IS_STATIC_SUBTYPE (D (SM_TYPE_SPEC, A));    elsif A.TY = DN_INCOMPLETE then      return GET_BASE_STRUCT (A).TY in
 CLASS_SCALAR and then IS_STATIC_SUBTYPE (D (XD_FULL_TYPE_SPEC, A));    end if;떰    if A.TY not in CLASS_SCALAR then 
     return False;    end if;떰    if D (SM_BASE_TYPE, A) = A then                        -- THIS IS A SCALAR BASE TYP
E; TEST FOR GENERIC FORMAL TYPE      return D (SM_RANGE, A) /= TREE_VOID;    else                        -- THIS A SU
BTYPE, NOT A BASE TYPE      return IS_STATIC_RANGE (D (SM_RANGE, A)) and then IS_STATIC_SUBTYPE (D (SM_TYPE_SPEC, D (SM
_RANGE, A)));    end if;  end IS_STATIC_SUBTYPE;떰  function IS_STATIC_DISCRETE_RANGE (A : TREE) return Boolean is  b
egin    case A.TY is      when DN_DISCRETE_SUBTYPE =>        return IS_STATIC_DISCRETE_RANGE (D (AS_SUBTYPE_INDICATIO
N, A));      when DN_SUBTYPE_INDICATION =>        if D (AS_CONSTRAINT, A) = TREE_VOID then          return IS_STATIC_
DISCRETE_RANGE (D (AS_NAME, A));        else          return IS_STATIC_DISCRETE_RANGE (D (AS_NAME, A)) and then IS_STA
TIC_RANGE (D (AS_CONSTRAINT, A));        end if;      when DN_RANGE =>        return IS_STATIC_RANGE (A);      when 
DN_USED_NAME_ID =>        return D (SM_DEFN, A) /= TREE_VOID and then IS_STATIC_DISCRETE_RANGE (D (SM_EXP_TYPE, D (SM_D
EFN, A)));      when DN_SELECTED =>        return IS_STATIC_DISCRETE_RANGE (D (AS_DESIGNATOR, A));      when others =
>        return False;    end case;  end IS_STATIC_DISCRETE_RANGE;떰  function IS_STATIC_INDEX_CONSTRAINT (ARRAY_TYPE
, INDEX_CONSTRAINT : TREE) return Boolean is    INDEX_LIST      : SEQ_TYPE := LIST (D (AS_DISCRETE_RANGE_S, INDEX_CONST
RAINT));    INDEX           : TREE;    ARRAY_TYPE_SPEC : TREE     := ARRAY_TYPE;  begin    while not IS_EMPTY (INDEX
_LIST) loop      POP (INDEX_LIST, INDEX);떰      if not IS_STATIC_DISCRETE_RANGE (INDEX) then        return False;   
   end if;    end loop;떰    if ARRAY_TYPE_SPEC.TY in CLASS_PRIVATE_SPEC then      ARRAY_TYPE_SPEC := D (SM_TYPE_SPEC,
 ARRAY_TYPE_SPEC);    elsif ARRAY_TYPE_SPEC.TY = DN_INCOMPLETE then      ARRAY_TYPE_SPEC := D (XD_FULL_TYPE_SPEC, ARRA
Y_TYPE_SPEC);    end if;떰    if ARRAY_TYPE_SPEC.TY = DN_CONSTRAINED_ARRAY then                        -- $$$$ SHOULD 
NOT HAPPEN [RM 3.6.1/3]      return False;    end if;떰    INDEX_LIST := LIST (D (SM_INDEX_S, ARRAY_TYPE_SPEC));    w
hile not IS_EMPTY (INDEX_LIST) loop      POP (INDEX_LIST, INDEX);      if not IS_STATIC_SUBTYPE (D (SM_TYPE_SPEC, INDE
X)) then        return False;      end if;    end loop;떰    return True;  end IS_STATIC_INDEX_CONSTRAINT;떰   --|--
--------------------------------------------------------------------------------------------턤nd CHK_STAT;
