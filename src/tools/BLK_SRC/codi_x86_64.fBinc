;1234567891011抖;          |;       \\ | //;     \\ u ^ u ///-------_______------\;   \
 )Y|Y|Y|Y|Y( /  |  T  h e            |;     / /o o o\ \     |  L  o n e s o m e  |;    \|H|H|H|H|H|/|  A
  d a            |;   G))  Q   Q  ((G   |  L  o v i n g      |;    / \   "   / \    |  O  l't i m e r    |
;   /_/  \VV/  \_\   |  C  o m p i l e r  |;       \vvvvv/     \-------______-------/;     \ooooooooo
/抖;-------------------------------------------------------------------------------;M A C R O S   F A S M G   P O 
U R   B A C K E N D   A D A 8 3   /   T L A L O C;-------------------------------------------------------------------
------------抖postpone; sera fait en toute toute fin car c'est le premier postpone  ASM_SIZE = $-0x400078end pos
tpone抖macro show description, value; pour debogage  repeat 1, d:value    display description,`d,13,10  end repea
tend macro抖;-------------------------------------------------------------------;S P E C I F I Q U E   P R O C 
E S S E U R   I N T E L   x 8 6   6 4;-------------------------------------------------------------------抖冬; sur p
rocesseur x86 64 les mouvements de pile se font en 64 bits (qword)冬; mais on a choisi de faire les operations arithmeti
ques en 32 bits pour rester comme sur une architecture 32 bits抖; QUANQ A LA PILE : ON A DECIDE DE LA FAIRE CROITRE VER
S LES ADRESSES HAUTES CAR LE SENS HABITUEL DESCENDANT EST INGERABLE POUR CERTAINES VARIABLES LOCALES STRUCTUREES冬; Donc
 pas possible d'utiliser les push et pop du processeur, on utilise le RBP comme pointeur de pile avec des LEA pour le me
ttre a jour en essayant de recouvrir les operations冬; d'acces memoire et de mise a jour du pointeur de pile RBP.冬; Le 
ESP reste tout en bas de pile pour gerer une micro-pile descendante des adresses de CALL/RET uniquement.冬; Attention : 
le EBP pointe sur la derniere valeur empilee comme qword冬; AUTRE PROBLEME DE PILE : Les variables dont on connat la tai
lle a la compilation s'accomodent bien a la pile usuelle, les offsets sont determine a la compilation冬; MAIS, si l'on a
 comme en Ada des variables (tableau par exemple) dont la taille n'est connue qu'a l'execution (indices eux-memes variab
les)冬; on ne peut pas mettre ces variables sur la pile normale. Mettre ces varaibles dans le tas n'est pas tres satisfa
isant car la gestion de la desallocation va poser probleme.冬; On invente donc la Co-Pile qui est une suite de blocs all
oues dynamiquement pour un niveau d'execution et qui est desallouee a la maniere de la pile usuelle.冬; De la sorte, il 
n'y a pas de melange avec les allocations de taille statique.冬; r14 est le pointeur de sommet de Co-Pile (l'analogue de
 RBP pour la pile standard, ou de RSP pour la micro-pile des retours/bricolages locaux en assembleur.抖; R15 pointeur d
e base display des frame pointers冬; R14 pointeur de haut de co-pile (lieu d'allocation)冬; R13 pointeur de debut de cha
ine de frame de co-pile (pour desallocation)抖;........................................................................
...............................................;   M A C R O S   A N C I L L A I R E S   ( P A S   U T I L I S E E S   
P A R   L E   C O D E _ G E N   T L A L O C;...........................................................................
............................................抖;........macroPUSH_RAX;........  db 0x48, 0x89, 0x45, 0x08
; mov QWORD PTR [rbp+8], rax(ecrire RAX a l'emplacement libre en haut de pile, au dessus du rbp)  db 0x48, 0x8D, 0x6D
, 0x08; lea rbp, [rbp+0x8](puis MONTER le rbp sur la valeur ecrite car pile croissante vers adresses hautes)end m
acro抖;........macroPUSH_RDX;........  db 0x48, 0x89, 0x55, 0x08; mov QWORD PTR [rbp+8], rdx(ecrire RD
X a l'emplacement libre en haut de pile, au dessus du rbp)  db 0x48, 0x8D, 0x6D, 0x08; lea rbp, [rbp+0x8](puis MO
NTER le rbp sur la valeur ecrite car pile croissante vers adresses hautes)end macro抖;.......macroPOP_RAX;..
.....  db 0x48, 0x8B, 0x45, 0x00; mov rax, QWORD PTR [rbp](lire dans RAX la valeur top sur le rbp)  db 0x48, 0x8
D, 0x6D, 0xF8; lea rbp, [rbp-0x8](puis DESCENDRE le rbp car pile croissante vers adresses hautes)end macro抖;.
......macroPOP_RBX;.......  db 0x48, 0x8B, 0x5D, 0x00; mov rbx, QWORD PTR [rbp](lire dans RBX la valeur t
op sur le rbp)  db 0x48, 0x8D, 0x6D, 0xF8; lea rbp, [rbp-0x8](puis DESCENDRE le rbp car pile croissante vers adre
sses hautes)end macro抖;.......macroPOP_RCX;.......  db 0x48, 0x8B, 0x4D, 0x00; mov rcx, QWORD PTR [rbp
](lire dans RCX la valeur top sur le rbp)  db 0x48, 0x8D, 0x6D, 0xF8; lea rbp, [rbp-0x8](puis DESCENDRE le rbp 
car pile croissante vers adresses hautes)end macro抖;.......macroPOP_RSI;.......  db 0x48, 0x8B, 0x75, 0x00
; mov rsi, QWORD PTR [rbp](lire dans RSI la valeur top sur le rbp)  db 0x48, 0x8D, 0x6D, 0xF8; lea rbp, [rbp-
0x8](puis DESCENDRE le rbp car pile croissante vers adresses hautes)end macro抖;.......macroPOP_RDI;......
.  db 0x48, 0x8B, 0x7D, 0x00; mov rdi, QWORD PTR [rbp](lire dans RDI la valeur top sur le rbp)  db 0x48, 0x8D, 0
x6D, 0xF8; lea rbp, [rbp-0x8](puis DESCENDRE le rbp car pile croissante vers adresses hautes)end macro抖;....
macroDROP;....  db 0x48, 0x8D, 0x6D, 0xF8; lea rbp, [rbp-0x8](DESCENDRE le rbp car pile croissante vers ad
resses hautes)end macro抖;...macroDUP;...  db 0x48, 0x8B, 0x45, 0x00; mov rax, QWORD PTR [rbp](amener
 le TOS dans RAX)  db 0x48, 0x89, 0x45, 0x08; mov QWORD PTR [rbp+8], rax(dupliquer)  db 0x48, 0x8D, 0x6D, 0x08
; lea rbp, [rbp+0x8](puis MONTER le rbp sur la valeur ecrite car pile croissante vers adresses hautes)end macro抖;
.......macroalign_b;.......end macro抖;.......macroalign_w;.......  desalign = $ mod 2  if desal
ign <> 0    repeat 2-desalign      db 0x90    end repeat  end ifend macro抖;.......macroalign_d;.......
  desalign = $ mod 4  if desalign <> 0    repeat 4-desalign      db 0x90    end repeat  end ifend macro抖;.....
..macroalign_q;.......  desalign = $ mod 8  if desalign <> 0    repeat 8-desalign      db 0x90    end repea
t  end ifend macro抖;last_instr_was_POP = 0; sert a faire du peep-hole sur POP - PUSH;last_instr_was_PUSH = 0
; sert a faire du peep-hole sur PUSH - POP抖;.......................macroFP_IN_RAXlvl;.....................
..  assert lvl >= 0 & lvl <= 31  if lvl = 0    db 0x49, 0x8B, 0x07; mov rax, [r15](aller chercher le frame po
inter du lvl dans le display pointe par r15)  else if lvl <= 15    db 0x49, 0x8B, 0x47, 8*lvl; mov rax, [r15 + 8*
lvl](aller chercher le frame pointer du lvl dans le display pointe par r15)  else    db 0x49, 0x8B, 0x87; mov r
ax, [r15 + 8*lvl](aller chercher le frame pointer du lvl dans le display pointe par r15)    dd 8*lvl  end ifend macr
o抖;.......................macroRAX_IN_FPlvl;.......................  assert lvl >= 0 & lvl <= 31  if lvl
 = 0    db 0x49, 0x89, 0x07; mov [r15], rax  else if lvl <= 15    db 0x49, 0x89, 0x47, 8*lvl; mov [r15 + 8
*lvl], rax(aller chercher le frame pointer du lvl dans le display pointe par r15)  else    db 0x49, 0x89, 0x87;
 mov [r15 + 8*lvl], rax(aller chercher le frame pointer du lvl dans le display pointe par r15)    dd 8*lvl  end ifen
d macro抖;.......................macroFP_IN_RBPlvl;.......................  assert lvl >= 0 & lvl <= 31  
if lvl = 0    db 0x49, 0x8B, 0x2F; mov rbp, [r15](aller chercher le frame pointer du lvl dans le display pointe 
par r15)  else if lvl <= 15    db 0x49, 0x8B, 0x6F, 8*lvl; mov rbp, [r15 + 8*lvl](aller chercher le frame pointe
r du lvl dans le display pointe par r15)  else    db 0x49, 0x8B, 0xAF; mov rbp, [r15 + 8*lvl](aller chercher le
 frame pointer du lvl dans le display pointe par r15)    dd 8*lvl  end ifend macro抖;.......................macro
BASE_IN_RAXlvl; 1 ou 2 instr;.......................  assert lvl >= -1 & lvl <= 31  if lvl = -1; oct
et range n'importe o : adresse stockage empilee    POP_RAX; 2 instr : (adress for data)  else    FP_IN_RAXlvl
; 1 instr : FP(lvl) base  end ifend macro抖;.......................................macroINDIRECT_BASE_IN_
RAXlvl, disp; 1 ou 2 instr;.......................................  assert lvl >= -1 & lvl <= 31  if lvl = -1
; top stacked adress of adress    POP_RAX; pop rax   adress of adress for data    db 0x48, 0x8B, 0x00
; mov rax, qword ptr [rax]   fetch adress of data  else; regular framed adress of byte    FP_IN_RAXlvl    F
ETCH_QWORDdisp; le FP( lvl ) + disp est dans rax  end ifend macro抖;........................macroFETCH_B
YTEdisp;........................  if disp = 0    db 0x48, 0x0F, 0xBE, 0x00; movsx rax, byte ptr [rax]  els
e if disp >= -128 & disp < 128    db 0x48, 0x0F, 0xBE, 0x40, disp; movsx rax, byte ptr [rax + ofs8]  else    db 
0x48, 0x0F, 0xBE, 0x80; movsx rax, byte ptr [rax + ofs32]    dd disp  end ifend macro抖;....................
....macroFETCH_WORDdisp;........................  if disp = 0    db 0x48, 0x0F, 0xBF, 0x00; movsx rax, 
word ptr [rax]  else if disp >= -128 & disp < 128    db 0x48, 0x0F, 0xBF, 0x40, disp; movsx rax, word ptr [rax + 
ofs8]  else    db 0x48, 0x0F, 0xBF, 0x80; movsx rax, word ptr [rax + ofs32]    dd disp  end ifend macro抖;
........................macroFETCH_DWORDdisp;........................  if disp = 0    db 0x48, 0x63, 0x00
; movsx rax, dword ptr [rax]  else if disp >= -128 & disp < 128    db 0x48, 0x63, 0x40, disp; movsx rax, dword
 ptr [rax + ofs8]  else    db 0x48, 0x63, 0x80; movsx rax, dword ptr [rax + ofs32]    dd disp  end ifend macr
o抖;........................macroFETCH_QWORDdisp;........................  if disp = 0    db 0x48, 0x8B, 0
x00; mov rax, qword ptr [rax]  else if disp >= -128 & disp < 128    db 0x48, 0x8B, 0x40, disp; mov rax, qw
ord ptr [rax + ofs8]  else    db 0x48, 0x8B, 0x80; mov rax, qword ptr [rax + ofs32]    dd disp  end ifend mac
ro抖;........................macroSTORE_BYTEdisp;........................  if disp = 0    db 0x88, 0x18
; mov byte ptr [rax], BL   (store)  else if disp >= -128 & disp < 128    db 0x88, 0x58; mov byte ptr [rax +
 ofs8], BL   store    db disp  else    db 0x88, 0x98; mov byte ptr [rax + ofs32], BL   (store)    dd disp  e
nd ifend macro抖;........................macroSTORE_WORDdisp;........................  if disp = 0    db 
0x66, 0x89, 0x18; mov word ptr [rax], BX   (store)  else if disp >= -128 & disp < 128      db 0x66, 0x89, 0x58, 
disp; mov word ptr [rax + ofs8], BX    else      db 0x66, 0x89, 0x98; mov word ptr [rax + ofs32], BX      
dd disp    end ifend macro抖;........................macroSTORE_DWORDdisp;........................  if di
sp = 0    db 0x89, 0x18; mov dword ptr [rax], EBX  else if disp >= -128 & disp < 128      db 0x89, 0x58, disp
; mov dword ptr [rax + ofs8], EBX    else      db 0x89, 0x98; mov dword ptr [rax + ofs32], EBX      dd di
sp    end ifend macro抖;........................macroSTORE_QWORDdisp;........................  if disp = 
0    db 0x48, 0x89, 0x18; mov qword ptr [rax], RBX  else if disp >= -128 & disp < 128      db 0x48, 0x89, 0x58,
 disp; mov qword ptr [rax + ofs8], RBX    else      db 0x48, 0x89, 0x98 ; mov qword ptr [rax + ofs32], RBX
      dd disp    end ifend macro抖;----------------------------------------------------------------------------------
-------------------------------------;L O A D   C O N S T A N T E S   I M M E D I A T E S;-------------------------
----------------------------------------------------------------------------------------------抖;-------------macro
LI?val; Load Integer;-------------  db 0x48, 0xC7, 0xC0; mov rax, val  dd val  PUSH_RAXend macro抖;
-------------macroLIF?val; Load Immediate Float;-------------  if val = 1.0    db 0xD9, 0xE8; f
ld1(push sur la pile de FPU  else    db 0x68; push double val32A VOIR PAS CLAIR    dd val  end ifend macr
o抖;-------------------------------------------------------------------------------------------------------------------
----;L O A D   C O N S T A N T  /  V A R I A B L E   A D R E S S E;------------------------------------------------
-----------------------------------------------------------------------抖;-------------macroLCA?ptr; Load Co
nstant Address (distinguer de LI - qui charge en 32 bits - car les adresses sont en 64 bits sur x64);------------- 
 db 0x48, 0xB8; movabs rax, ptr  dq ptr  PUSH_RAXend macro抖;------------------------macroLVa?lvl:-1, 
disp:0; Load Variable Address pour lvl et disp (empile l'adresse de la variable au deplacement disp du frame de lvl d
onne);------------------------  BASE_IN_RAXlvl  if disp = 0;    db 0x48, 0x8D, 0x00; lea rax, [rax] (nop)
  else if disp >= -128 & disp < 128    db 0x48, 0x8D, 0x40, disp; lea rax, [rax + ofs8]  else    db 0x48, 0x8D,
 0x80; lea rax, qword ptr [rax + ofs32]    dd disp  end if  PUSH_RAXend macro抖;---------------------------
----macroLIVa?lvl:-1, disp:0, ofs:0; Load Indirect Variable Address pour lvl et disp (empile l'adresse de la vari
able pointee par l adresse au deplacement disp du frame de lvl donne);-------------------------------  INDIRECT_BAS
E_IN_RAXlvl, disp  if ofs = 0;    db 0x48, 0x8D, 0x00; lea rax, [rax] (nop)  else if ofs >= -128 & ofs < 128 
   db 0x48, 0x8D, 0x40, ofs; lea rax, [rax + ofs8]  else    db 0x48, 0x8D, 0x80; lea rax, qword ptr [rax +
 ofs32]    dd ofs  end if  PUSH_RAXend macro抖;--------------------------------------------------------------------
---------------------------------------------------;L O A D   D A T A;-------------------------------------------
----------------------------------------------------------------------------抖;------------------------macroLb?l
vl:-1, disp:0; 4 ou 5 instr : Load Byte 8 bits;------------------------  BASE_IN_RAXlvl; 1 ou 2 instr  F
ETCH_BYTEdisp  PUSH_RAX; 2 instrend macro;------------------------macroLw?lvl:-1, disp:0; Load Wor
d 16 bits;------------------------  BASE_IN_RAXlvl  FETCH_WORDdisp  PUSH_RAXend macro;--------------------
----macroLd?lvl:-1, disp:0; Load doubleword 32 bits;------------------------  BASE_IN_RAXlvl  FETCH_DWORD
disp  PUSH_RAXend macro;------------------------macroLq?lvl:-1, disp:0; Load quadword 64 bits;-------
-----------------  BASE_IN_RAXlvl  FETCH_QWORDdisp  PUSH_RAXend macro;------------------------macroLa?lvl
:-1, disp:0; Load Address 64 bits;------------------------  Lq lvl, dispend macro抖;------------------------
-------macroLIb?lvl:-1, disp:0, ofs:0; Load Indirect byte (la variable en frame ou empilee est une adresse, adres
se a laquelle on va chercher l'octet avec offset);-------------------------------  INDIRECT_BASE_IN_RAXlvl, disp 
 FETCH_BYTE ofs  PUSH_RAX; empiler la donneeend macro;-------------------------------macroLIw?lvl:-1
, disp:0, ofs:0; Load Indirect word;-------------------------------  INDIRECT_BASE_IN_RAXlvl, disp  FETCH_WORD
ofs  PUSH_RAXend macro;-------------------------------macroLId?lvl:-1, disp:0, ofs:0; Load Indirect double
word;-------------------------------  INDIRECT_BASE_IN_RAXlvl, disp  FETCH_DWORDofs  PUSH_RAXend macro;--
-----------------------------macroLIq?lvl:-1, disp:0, ofs:0; Load Indirect quadword;-------------------------
------  INDIRECT_BASE_IN_RAXlvl, disp  FETCH_QWORDofs  PUSH_RAXend macro;-------------------------------macr
oLIa?lvl:-1, disp:0, ofs:0; Load Address 64 bits Indirect;-------------------------------  LIq lvl, disp, ofs
end macro抖;----------------------------------------------------------------------------------------------------------
-------------;S T O R E   D A T A;-------------------------------------------------------------------------------
----------------------------------------抖;------------------------macroSb?lvl:-1, disp:0; Store byte 8 bits
;------------------------  POP_RBX; (data)  BASE_IN_RAXlvl  STORE_BYTEdispend macro;---------------
---------macroSw?lvl:-1, disp:0; Store word 16 bits;------------------------  POP_RBX; (data)  BAS
E_IN_RAXlvl  STORE_WORDdispend macro;------------------------macroSd?lvl:-1, disp:0; Store doubleword 32
 bits;------------------------  POP_RBX; (data)  BASE_IN_RAXlvl  STORE_DWORDdispend macro;--------
----------------macroSq?lvl:-1, disp:0; Store Quadword 64 bits;------------------------  POP_RBX; (
data)  BASE_IN_RAXlvl  STORE_QWORDdispend macro;------------------------macroSa?lvl:-1, disp:0; Store A
ddress 64 bits;------------------------  Sq lvl, dispend macro抖;-------------------------------macroSIb?
lvl:-1, disp:0, ofs:0; Store Indirect byte;-------------------------------  POP_RBX; (data)  INDIRECT_BA
SE_IN_RAXlvl, disp  STORE_BYTEofsend macro;-------------------------------macroSIw?lvl:-1, disp:0, ofs:0
; Store Indirect word;-------------------------------  POP_RBX; (data)  INDIRECT_BASE_IN_RAXlvl, disp  S
TORE_WORDofsend macro;-------------------------------macroSId?lvl:-1, disp:0, ofs:0; Store Indirect double
word;-------------------------------  POP_RBX; (data)  INDIRECT_BASE_IN_RAXlvl, disp  STORE_DWORDofse
nd macro;-------------------------------macroSIq?lvl:-1, disp:0, ofs:0; Store Indirect quadword;---------
----------------------  POP_RBX; (data)  INDIRECT_BASE_IN_RAXlvl, disp  STORE_QWORDofsend macro;-----
--------------macroSIa?lvl, disp, ofs; Store Address 64 bits Indirect;-------------------  SIq lvl, disp, o
fsend macro抖;--------------------------------------------------------------------------------------------------------
---------------;O P E R A T I O N S   L O G I Q U E S;------------------------------------------------------------
-----------------------------------------------------------抖;---macroET?;---  POP_RAX  db 0x48, 0x21, 0x45
, 0x00; and qword ptr [rbp], raxend macro;---macroOU?;---  POP_RAX  db 0x48, 0x09, 0x45, 0x00
; or qword ptr [rbp], raxend macro;----macroNON?;----  db 0x48, 0xF7, 0x55, 0x00; not qword ptr [rbp
]end macro;----macroOUX?;----  POP_RAX  db 0x48, 0x31, 0x45, 0x00; xor qword ptr [rbp], raxend mac
ro;----macroSHL?; decalage gauche;----  POP_RCX; nombre de positions de decalage  db 0x48, 0x
D3, 0x65, 0x00; shl qword ptr [rbp], clend macro抖;-------------------------------------------------------------
----------------------------------------------------------;O P E R A T I O N S   A R I T H M E T I Q U E   E N T I E 
R E;-------------------------------------------------------------------------------------------------------------------
----抖;----macroDEC?; ----  db 0x48, 0xFF, 0x4D, 0x00; dec qword ptr [rbp]end macro;----macro
INC?;---  db 0x48, 0xFF, 0x45, 0x00; inc qword ptr [rbp]end macro;----macroNEG?;----  db 0x48, 
0xF7, 0x5D, 0x00; neg qword ptr [rbp]end macro;----macroABS?;----  db 0x48, 0x8B, 0x45, 0x00; 
mov rax, QWORD PTR [rbp](lire dans RAX la valeur top X sur le rbp)  db 0x48, 0xC1, 0xF8, 0x3F; sar rax, 63(R
AX = tout bit de signe = allsign)  db 0x48, 0x31, 0x45, 0x00; xor QWORD PTR [rbp], rax(X xor allsign)  db 0x48
, 0x29, 0x45, 0x00; sub QWORD PTR [rbp], rax( (X xor allsign) - allsign )end macro;----macroADD?;--
--  POP_RAX  db 0x48, 0x01, 0x45, 0x00; add qword ptr [rbp], raxend macro;----macroSUB?;----  POP_
RAX  db 0x48, 0x29, 0x45, 0x00; sub qword ptr [rbp], raxend macro;----macroMUL?;----  POP_RAX  db 
0x48, 0xF7, 0x6D, 0x00; imul qword ptr [rbp]  DROP  PUSH_RAXend macro;----macroDIV?;----  POP_RBX
  POP_RAX  db 0x48, 0x31, 0xD2; xor rdx, rdx  db 0x48, 0xF7, 0xFB; idiv rbx  PUSH_RAXend macro;----
macroREM?;----  POP_RBX  POP_RAX  db 0x48, 0x31, 0xD2; xor rdx, rdx  db 0x48, 0xF7, 0xFB; idiv rb
x  PUSH_RDXend macro;----macroSAR?; decalage arithmetique droit;----  POP_RCX; nombre de pos
itions de decalage  db 0x48, 0xD3, 0x7D, 0x00; sar qword ptr [rbp], clend macro抖;-----------------------------
------------------------------------------------------------------------------------------;C O M P A R A I S O N S
;-----------------------------------------------------------------------------------------------------------------------
抖;----macroCGT?; A > B A empile puis B (note pour avoir "A less than B" intervertir A et B);----  POP_
RBX; depiler le B dans RBX  db 0x48, 0x39, 0x5D, 0x00; cmp [rbp], rbx   (comparer avec A, calcule B-A)  
db 0x0F, 0x9F, 0x45, 0x00; setg [rbp]end macro;----macroCEQ?;----  POP_RBX  db 0x48, 0x39, 0x5D, 0x
00; cmp [rbp], rbx   (NXT > TOP ?)  db 0x0F, 0x94, 0x45, 0x00; sete [rbp]end macro抖;--------------------
---------------------------------------------------------------------------------------------------;O P E R A T I O 
N S   C O N T R O L E   D E   F L O T;---------------------------------------------------------------------------------
--------------------------------------抖;-------------macroBRA?lbl; inconditionnel;-------------  local
 disp;  if disp >= -128 & disp <= 127;    db 0xEB; jmp rel8;    db disp;  else    db 0xE9; jmp rel32
    dd disp;  end if  disp = lbl-$end macro;-------------macroBT?lbl; branch true;-------------  PO
P_RAX  db 0x08, 0xC0; or AL, AL  local disp  if disp >= -128 & disp <= 127    db 0x75; jnz rel8    db
 disp  else    db 0x0F, 0x85; jnz rel32    dd disp  end if  disp = lbl-$end macro;-------------macro
BF?lbl; branch false;-------------  POP_RAX  db 0x08, 0xC0; or AL, AL  local disp  if disp >= -128 
& disp <= 127    db 0x74; jz rel8    db disp  else    db 0x0F, 0x84; jz rel32    dd disp  end if  d
isp = lbl-$end macro;-------------------------macroCALL?prefix, subname;-------------------------  postpo
ne    if ~definite prefix#subname#_      prefix#subname#_ = prefix#subname#.elab; le nom finissant en _ determine 
l'assemblage de la routine    end if  end postpone抖  local ofs  db 0xE8; CALL empile sur la micro-pile des a
dresses de retour (qui croit vers le bas)  dd ofs  ofs = prefix#subname#_ - $end macro;--------------------macro
RTD?prm_size:0;--------------------  assert prm_size >= 0; la taille de desallocation est donnee positive
  if prm_size <> 0; s'il y a une desallocation    if prm_size < 128; de petite taille      db 0x48, 0x8D
, 0x6D, -prm_size; lea rbp, [rbp - alloc8]    else; de grande taille      db 0x48, 0x8D, 0xAD; lea 
rbp, [rbp - alloc32]      dd -prm_size    end if  end if  db 0xC3; simple return avec l'adresse sur la micro
-pile geree par rspend macro抖;---------------------------------------------------------------------------------------
--------------------------------;O P E R A T I O N S   G E S T I O N   D E   P I L E;------------------------------
-----------------------------------------------------------------------------------------抖;--------------------macr
oLINK?lvl, alloc; ALLOCATION POUR VARIABLES LOCALES APRES FRAME PTR;--------------------  FP_IN_RAXlvl
; store FP(lvl) le pointeur de pile RBP reste a pointer sur l'empile  PUSH_RAX  if lvl = 0    db 0x49, 0x89, 0x2F
; mov qword ptr [r15], rbpniveau 0, petit offset dans le display  else if lvl <= 15; 15 niveaux suivants, pe
tit offset dans le display    db 0x49, 0x89, 0x6F, 8*lvl; mov qword ptr [r15 + 8*lvl], rbp   update FP le FP point
e sur l'adresse de sauvegarde du FP anterieur  else    db 0x49, 0x89, 0x6F    dd 8*lvl; mov qword ptr [r15 + 8
*lvl], rbp   update FP le FP pointe sur l'adresse de sauvegarde du FP anterieur  end if冬; Faire l'allocation sur la 
pile de travail standard  assert alloc >= 0  if alloc <> 0    if 8*((alloc+7)/8) < 128      db 0x48, 0x8D, 0x6D, 8*(
(alloc+7)/8); lea rbp, [rbp + alloc8]    else      db 0x48, 0x8D, 0xAD; lea rbp, [rbp + alloc32]      dd 8*
((alloc+7)/8)    end if  end if冬; Gerer la co-pile au cas o on en aurait besoin抖  db 0x4D, 0x89, 0x2E; mov [
r14], r13empiler le frame pointer de co-pile sur celle-ci  db 0x4D, 0x89, 0xF5; mov r13, r14(mettre a jour le
 frame pointer de co-pile)  db 0x4D, 0x8D, 0x76, 0x08; lea r14, [r14 + 8](monter le haut de co-pile sur le premi
er lieu libre)end macro抖;-------------macroUNLINK?lvl; DISPOSE VARS LOCALES ET RESTORE FRAME PTR;-----
--------  FP_IN_RBPlvl; (throw locals)  POP_RAX  RAX_IN_FPlvl; (restore stored FP)抖; Gerer la co-pi
le pour liberer les allocations de taille dynamique eventuelles抖  db 0x4D, 0x8B, 0x6D, 0x00; mov r13, [r13]end m
acro抖;----------------------macroPROsub_name_lbl; Debut de procedure declaree;----------------------;su
b_name_lbl:  namespace sub_name_lbl; definir son espace de noms  BRA post; contournement de l'elaboration
 autour de la procedureend macro抖;----macroPRMS; En tete de la definition des parametres;----  virtua
l at 8; La pile de travail croit vers les adresses hautes, les parametres sont au dessus du FP dynamique    PRMz
one::; donc 8 octets (adresses 64 bits) au dessus du FP  end virtual抖end macro抖;------------------macro
PRMname_ofs; Definition d'un parametre;------------------  virtual PRMzone    name_ofs = $    dq ?  end vir
tual抖end macro抖;-------macroendPRMS; Fin de la definition des parametres;-------  virtual PRMzone   
 prm_siz = $-8; Calcul de la taille du parametrage  end virtual抖end macro抖;-------------macroELBlvl
; En tete de la partie elaboration de procedure;-------------elab:  virtual at 8; Commence 8 octets apres 
le FP dynamique    VARzone::  end virtual冬LINK lvl,loc_siz抖end macro抖;---------------------macroSTRname, b
ytes; Definition d'une constante chaine au format d'un tableau de caracteres (pour traitement homogene des chaines);
---------------------;Une chaine Ada est un tableau d'octets caracteres, c'est a dire un descripteur [ PTR_TO CHARS
 qword | CAR_SIZE dword | FIRST dword | LAST dword ]; et des caracteres qui pointes par PTR_TO_CHARS peuvent etre detac
hes du descripteur. Ici, cas de constante, les caracteres sont juste apres le descripteur.;  postpone    local data 
   local info    local str_byte_size    align_q; aligner le descripteur sur un quadword抖  namespace name抖  da
ta_ptr = $; adresse de la constante STRING (en fait double pointeur)    dqdata; offset 0 : adresse des c
aracteres (juste apres dans le cas present)  info_ptr = $;    dqinfo; offset 8 : adresse des infos TOT_S
IZ, COMP_SIZ, FST_1, LST_1  info = $; use info    ddstr_byte_size, 1, 1, str_byte_size; offset 16 : TOT_SI
Z=str_byte_size ; offset 20 : COMP_SIZ=1 ; offset 24 : FST=1 ; offset 28 : LST=str_byte_size    virtual at 0; de
finition des offsets sur le useinfo    SIZ = $    rd 1    COMP_SIZ = $    rd 1    FST_1 = $    rd 1    LST_1 = $
    end virtual  data = $; pour une constante les caracteres suivent (pour une chaine variable ce n'est pas le c
as, les octets sont dans la co-pile)    dbbytes    str_byte_size = $ - data; Calculer la longueur effective pou
r mettre dans LAST  end namespace抖  end postponeend macro抖;-----------------------------------------macroCST
name_cst:_nil_, sizChar:b, val&; Definition d'une constante;-----------------------------------------  postpone  
  align_#sizChar; aligner en fonction de l'unite de reservation    name_cst = $;    d#sizChar val
; reservation  end postponeend macro抖;----------------------------------------macroUSEINFOlvl, field_name, lo
ad_instruc& ; Reference __u a un __i info;----------------------------------------  virtual VARzone    align_q
; aligner en fonction de l'unite de reservation    field_name#__u = $; lieu ptr use info    rq 1; r
eservation  end virtual  load_instruc  Sa lvl, field_name#__uend macro;-------------------macroSTATOFSname,
 siz; Definition de l'offset statique (pour un record statique, dans une virtual at 0);-------------------  if 
siz > 4    align_q  else if siz > 2    align_d  else if siz > 1    align_w  end ifname = $; nom offset du
 champ  rb siz; reservationsize = $end macro抖;-----------------------------------macroVARname_disp, 
sizChar, siz:1; Definition d'un lieu de variable;-----------------------------------  virtual VARzone    if `siz
Char = 'b'  |  `sizChar = 'w'  |  `sizChar = 'd'  |  `sizChar = 'q'      align_#sizChar      name_disp = $; dis
placement des data de variable      r#sizChar siz; reservation    else      align_q; assurer l'aligneme
nt de pile dans tous les cas possibles      name_disp = $; displacement des data de variable      rb sizChar  
  end if  end virtual抖end macro抖;------macroCO_VAR; Allocation d'un bloc sur la co-pile taille en octets 
sur la pile standard, laisse l'adresse de debut de bloc sur la pile;------  POP_RAX; la taille d'allocation
 a ete empilee, la mettre dans rax  db 0x4C, 0x89, 0x75, 0x08; mov QWORD PTR [rbp+8], r14(empiler le haut de co
-pile R14 sur la pile standard)  db 0x48, 0x8D, 0x6D, 0x08; lea rbp, [rbp+0x8](puis MONTER le rbp sur la valeur
 ecrite car pile croissante vers adresses hautes)  db 0x48, 0x83, 0xC0, 0x07; add rax, 7  db 0x48, 0xC1, 0xF8, 0
x03; sar rax, 3(diviser par 8, rax est positif normalement)  db 0x4D, 0x8D, 0x34, 0xC6; lea r14, [r14 + 
8*rax](mettre le sommet de co-pile aligne sur qword)end macro抖;------macroendPRO; Fin de procedure;-
-----post:  virtual VARzone    loc_siz = $; Ce n'est que la que l'on calcule la taille des locales qui sera re
tropropagee au LINK du ELAB  end virtual  end namespaceend macro抖;------macroBLKMOV; Copie de bloc sans 
recouvrement;------  POP_RSI; adresse source  POP_RCX; nombre octets  POP_RDI; adresse de
stination  db 0xFC; cld(direction flag montant); transfer:  db 0xAC; lods al, BYTE PTR ds:[rsi]  
db 0xAA; stos BYTE PTR es:[rdi], al  db 0xE2, 0xFC; loop transfer(transfere ecx octets抖end macro抖抖;
------------------------------;SPECIFIQUE  L I N U X   X86-64;------------------------------抖;-------
------macroSYS_PUT_CHAR?; affiche un seul caractere sur stdout;-------------抖  db 0x48, 0x89, 0xEE; mov 
rsi, rbp(ADRESSE du caractere empile sur la pile)  db 0x6A, 0x01; push 1  db 0x58; pop rax(rax=1=sys_wri
te )  db 0x48, 0x89, 0xC2; mov rdx, rax(rdx=length=1)  db 0x48, 0x89, 0xC7; mov rdi, rax(rdi=stdout=1)  db 
0x0F, 0x05; syscall  DROP; caractere consommeend macro抖;------------macroSYS_PUT_STR?; affiche t
out une chaine sur stdout;------------  POP_RSI;(l'adresse du doublet @DATA | @USEINFO a ete empilee)  db
 0x48, 0x8B, 0x46, 0x08; mov rax, [rsi+8](rax contient l'adresse du USEINFO  db 0x8B, 0x50, 0x0C; mov edx, dw
ord ptr[rax+12](edx=last)  db 0xFF, 0xC2; inc edx(last+1)  db 0x2B, 0x50, 0x08; sub edx, dword ptr[rax+8]
   edx=length (=last+1 - first)  db 0x6A, 0x01; push 1  db 0x58; pop rax(rax=1=sys_write )  db 0x48, 0x
89, 0xC7; mov rdi, rax(rdi=stdout=1)  db 0x48, 0x8B, 0x36; mov rsi, [rsi](rsi est maintenant l'adresse des 
caracteres)  db 0x0F, 0x05; syscallend macro抖; - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;Pour
 le GET de caractere on veut obtenir chaque caractere tape immediatement, il faut modifier le comportement du terminal;
struc termios{;        .c_iflagrd 1; 0 input mode flags;        .c_oflagrd 1; 4 output mode flags;        .
c_cflagrd 1; 8 control mode flags;        .c_lflagrd 1; 12 local mode flags;        .c_linerb 1; line d
iscipline;        .c_ccrb 32; control characters;        .c_ispeedrd 1; input speed;        .c_ospeedrd 1
; output speed;};-------------macroSYS_GET_CHAR?; lit un seul caractere sur stdin en mode non canonique;
-------------冬; reserver le termios sur la micro-pile du rsp  db 0x48, 0x83, 0xEC, 0x40; sub rsp, 64 (espace 
large pour le termios)冬; amener le termios  db 0x6A, 0x10; push 16  db 0x58; pop rax(rax=16=sys_ioctl)
  db 0x48, 0x31, 0xFF; xor rdi, rdi(rdi=stdout=0)  db 0x48, 0xC7, 0xC6, 0x01, 0x54, 0x00, 0x00; mov rsi, 0x5401
(TCGETS)  db 0x48, 0x89, 0xE2; mov rdx, rsp(adresse du termios temporaire)  db 0x0F, 0x05; syscall(copier
 le termios)冬; modifier le termios  db 0x83, 0x64, 0x24, 0x0C, 0xF5; and dword ptr [rsp+12], 0xFFFFFFF5(ICANON b
it 1 de c_lflag mis a 0 et bit 3 ECHO a 0)冬; renvoyer le termios modifie  db 0x6A, 0x10; push 16  db 0x58
; pop rax(rax=16=sys_ioctl)  db 0x48, 0x31, 0xFF; xor rdi, rdi(rdi=stdout=0)  db 0x48, 0xC7, 0xC6, 0x02, 0x54,
 0x00, 0x00; mov rsi, 0x5402(TCSETS)  db 0x48, 0x89, 0xE2; mov rdx, rsp(adresse du termios temporaire)  db 0x0
F, 0x05; syscall(envoyer le termios modifie)冬; lire le caractere en mode non canonique  POP_RSI;(l'ad
resse destination a ete empilee sur la pile croissante)  db 0x6A, 0x00; push 0  db 0x58; pop rax(rax=0=sy
s_read)  db 0x48, 0x89, 0xC7; mov rdi, rax(rdi=stdout=0)  db 0x6A, 0x01; push 1  db 0x5A; pop rdx(r
dx=length=1 caractere)  db 0x0F, 0x05; syscall抖  db 0x83, 0x4C, 0x24, 0x0C, 0x0A; or dword ptr [rsp+12], 0xA(
ICANON bit 1 de c_lflag remis a 1 et ECHO bit 3)冬; renvoyer le termios modifie  db 0x6A, 0x10; push 16  db 0x5
8; pop rax(rax=16=sys_ioctl)  db 0x48, 0x31, 0xFF; xor rdi, rdi(rdi=stdout=0)  db 0x48, 0xC7, 0xC6, 0x02,
 0x54, 0x00, 0x00; mov rsi, 0x5402(TCSETS)  db 0x48, 0x89, 0xE2; mov rdx, rsp(adresse du termios temporaire)  
db 0x0F, 0x05; syscall(envoyer le termios modifie)冬; remettre le pointeur de micro-pile a sa place initiale  
db 0x48, 0x83, 0xC4, 0x40; add rsp, 64end macro抖;------------macroSYS_GET_STR?; lit une ligne sur stdin
;------------  POP_RSI;(l'adresse du doublet @DATA | @USEINFO a ete empilee)  db 0x48, 0x8B, 0x46, 0x08
; mov rax, [rsi+8](rax contient l'adresse du USEINFO  db 0x8B, 0x50, 0x0C; mov edx, dword ptr[rax+12](edx=last
)  db 0xFF, 0xC2; inc edx(last+1)  db 0x2B, 0x50, 0x08; sub edx, dword ptr[rax+8]   edx=length (=last+1 - 
first)  db 0x31, 0xC0; xor eax, eax(rax=0=sys_read )  db 0x31, 0xFF; xor edi, edi(rdi=stdin=0)  db 0x48
, 0x8B, 0x36; mov rsi, [rsi](rsi est maintenant l'adresse des caracteres)  db 0x0F, 0x05; syscall  POP_RSI
;(sur la pile croissante, adresse de la longueur effectivement lue qui peut etre inferieure a la longueur de str
ing)  db 0xFF, 0xC8; dec eax(diminuer la longueur rendue = retirer le caractere de fin)  db 0x89, 0x06; m
ov dword ptr[rsi], eax(reporter la longueur effectivement lue retournee par syscall dans eax)end macro抖抖;--------
--------------macroCOPY_STRING_APPEND_NUL; donne le descripteur pointe par RSI, copie la chaine sur la pile montant
e et ajoute un NUL de fin;----------------------  db 0x48, 0x8B, 0x46, 0x08; mov rax, [rsi+8](rax contient l'
adresse du USEINFO抖  db 0x8B, 0x48, 0x0C; mov ecx, dword ptr[rax+12](ecx=last)  db 0xFF, 0xC1; inc ecx(la
st+1)  db 0x2B, 0x48, 0x08; sub ecx, dword ptr[rax+8](ecx= nombre de caracteres =last+1 - first)  db 0x48, 0x8B, 
0x36; mov rsi, qword ptr[rsi](rsi= adresse des caracteres)  db 0x48, 0x8D, 0x7D, 0x08; lea rdi, [rbp+0x8](on 
va empiler la chaine sur la pile)  db 0xFC; cld(direction flag montant); transfer:  db 0xAC; lods al, 
BYTE PTR ds:[rsi]  db 0xAA; stos BYTE PTR es:[rdi], al  db 0xE2, 0xFC; loop transfer(transfere ecx octets
  db 0xC6, 0x07, 0x00; mov BYTE PTR[rdi], 0(caractere NUL de fin chaine C)  db 0x48, 0x8D, 0x7D, 0x08; lea rd
i, [rbp+0x8](remettre RDI sur le debut de chaine)end macro抖;----------------macroSYS_FILE_CREATE?; FONCTION
 creation d'un fichierrax=2 rdi=ptr_name rsi=flags(O_CREAT) rdx=mode(S_IRWXU) retour rax=ID;----------------  POP_
RSI; adresse du descripteur de chaine Ada  COPY_STRING_APPEND_NUL; faire une copie sur pile avec NUL en fin p
ointee par RDI  db 0x6A, 0x02; push 2  db 0x58; pop rax(rax=2=sys_open )  db 0xBE, 0x40, 0x00, 0x00, 0x
00; mov esi, 0x40(rsi=0x40=O_CREAT)  db 0xBA, 0x00, 0x07, 0x00, 0x00; mov edx, 0x700(rdx=0x700=S_IRWXU)  db 
0x0F, 0x05; syscall  db 0x48, 0x89, 0x45, 0x00; mov QWORD PTR [rbp], rax(ATTENTION PAS PUSH ! ID de fichier r
endu sur le lieu result de la fonction)end macro抖;--------------macroSYS_FILE_OPEN?; FONCTION ouverture d'un
 fichier;--------------  POP_RSI; adresse du descripteur de chaine Ada  COPY_STRING_APPEND_NUL; faire un
e copie sur pile avec NUL en fin pointee par RDI  db 0x6A, 0x02; push 2  db 0x58; pop rax(rax=2=sys_open
 )  db 0x6A, 0x02; push 2  db 0x5E; pop rsi(rsi=2=flags=RDWR)  db 0x48, 0x31, 0xD2; xor rdx,rdx(m
ode= 0 sans importance)  db 0x0F, 0x05; syscall  db 0x48, 0x89, 0x45, 0x00; mov QWORD PTR [rbp], rax(ATTENTI
ON PAS PUSH ! ID de fichier rendu sur le lieu result de la fonction)end macro抖;---------------macroSYS_FILE_CL
OSE?; fermeture d'un fichier;---------------  POP_RDI; ID fichier empile  db 0x6A, 0x03; push 3  db 
0x58; pop rax(rax=3=sys_close )end macro抖;----------------macroSYS_FILE_DELETE?; destruction d'un f
ichier;----------------  POP_RSI; ptr au nom (chaine nul terminated)  COPY_STRING_APPEND_NUL; faire une 
copie sur pile avec NUL en fin pointee par RDI  db 0xB8, 0x43, 0x00, 0x00, 0x00; mov eax, 67(rax=87=sys_unlink )
  db 0x0F, 0x05; syscallend macro抖;---------macroSYS_EXIT?; retour au systeme;---------  db 0x6
A, 0x3C; push x3C  (sys_exit rax=60)  db 0x58; pop rax  db 0x31, 0xFF; xor edi, edi (err_code=0)
  db 0x0F, 0x05; syscallend macro抖;---------------------------------------------;MISE EN PLACE ENTET
E ELF 64 POUR LINUX X86-64;---------------------------------------------抖ELFCLASS64= 2ELFDATA2LSB= 1EV_CURRENT
= 1ET_EXEC= 2SYSTEM_V= 0EM_X86_64= 62抖org 0x400000; adresse entree programme linux抖Elf64_Header:冬e_i
dentdb 0x7F,'ELF', ELFCLASS64, ELFDATA2LSB, EV_CURRENT, SYSTEM_V, (0x400010-$) dup 0冬e_typedw ET_EXEC冬e_machined
w EM_X86_64冬e_versiondd EV_CURRENT冬e_entrydq 0x00400078冬e_phoffdq 64冬e_shoffdq 0冬e_flagsdd 0冬e_ehsized
w 64冬e_phentsizedw 56冬e_phnumdw 1冬e_shentsizedw 0冬e_shnumdw 0冬e_shstrndxdw 0Elf64_Phdr:冬p_typedd 1;
 PT_LOAD冬p_flagsdd 7; RWX冬p_offsetdq 0x78冬p_vaddrdq 0x00400078冬p_paddrdq 0冬p_fileszdq ASM_SIZE; 
juste le necessaire code/constantes dans le fichier冬p_memszdq ASM_SIZE + 1024*1024; 1Mo au dessus du code et des c
onstantes (pour la co-pile)冬p_aligndq 4096抖;METTRE EN PLACE LA PILE CROISSANTE ET LE DISPLAY抖  db 0x48, 0x31, 0x
C0; pour point d'arret debogage  db 0x48, 0x8D, 0xA4, 0x24, 0x00, 0x00, 0xF0, 0xFF; lea rsp, [rsp - 1024*1024]
(caler rsp a 1 Mo sous le depart)  db 0x49, 0x89, 0xE7; mov r15, rsp(debut du display de 32 frame pointers)
  db 0x48, 0x8D, 0xAC, 0x24, 0x00, 0x01, 0x00, 0x00; lea rbp, [rsp + 8*32](bas de pile croissante au dessus du disp
lay)  db 0x49, 0x89, 0x2F; mov [r15], rbp(frame pointer level 0)抖;METTRE EN PLACE LA CO-PILE抖  db 0x4C, 0x
8D, 0x34, 0x25; lea r14, [0x00400078 + 8*((ASM_SIZE+7)/8)](bas de la co-pile, ou pile-tas au dessus du code et de
s constantes)  dd 0x00400078 + 8*((ASM_SIZE+7)/8)  db 0x4D, 0x89, 0x36; mov [r14], r14(empiler le premier "fr
ame" de co-pile)  db 0x4D, 0x89, 0xF5; mov r13, r14(R13 est le "frame pointer" de co-pile)  db 0x4D, 0x8D, 0x
76, 0x08; lea r14, [r14 + 8](monter le haut de co-pile sur le premier lieu libre)
