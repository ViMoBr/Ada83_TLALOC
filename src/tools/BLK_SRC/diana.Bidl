--|#################################################################################################¶--|¬SYMBOLES TERMIN
AUX¶--|#################################################################################################¶¶%terminals¶¶  
ABORT¬ABS¬ACCEPT¬ACCESS¬ALL¬AND¬ARRAY¬AT BEGIN¬BODY¬CASE¶  CONSTANT¬DECLARE¬DELAY¬DELTA¬DIGITS¬DO¬ELSE¬ELSIF¬END¶  ENTRY
¬EXCEPTION EXIT¬FOR¬FUNCTION¬GENERIC¬GOTO¬IF¬IN¬IS¶  LIMITED¬LOOP¬MOD¬NEW¬NOT¬NULL¬OF¬OR¬OTHERS¬OUT¶  PACKAGE¬PRAGMA¬PRI
VATE¬PROCEDURE¬RAISE¬RANGE¬RECORD¬REM¬RENAMES¬RETURN¶  REVERSE¬SELECT¬SEPARATE¬SUBTYPE¬TASK¬TERMINATE¬THEN¬TYPE¬USE¬WHEN
¶  WHILE¬WITH¬XOR¶¶  identifier¬numeric_literal¬string_literal¬character_literal¶¶  & ' ( ) * + , - . / : ;  < = >  '|'¬
=> .. **  := /=  >=  <= <<  >>  <>¶¶¶--|################################################################################
#################¶--|¬REGLE RACINE¶--|##################################################################################
###############¶¶%start¶¶  compilation¶¶¶--|############################################################################
#####################¶--|¬REGLES (et definitions IDL)¶--|###############################################################
##################################¶¶%rules¶¶--|-------------------------------------------------------------------------
------------------------¶--|¬Standard initial IDL items¶--|-------------------------------------------------------------
------------------------------------¶¶//  root¬=>¬xd_high_page¬: num_val,¶//¬¬xd_user_root¬: user_root,¶//¬¬xd_source_li
st¬: Seq Of sourceline,¶//¬¬xd_err_count¬: num_val,¶//¬¬spare_1 ¬: void;¶##  root¬====>¬¬¬¬--| Action sur root¶##¬call¬u
ser_root¬@ xd_user_root  root¬--| appliquer l'action user_root sur le champ xd_user_root¶¶//  txtrep¬=> ;¬¬¬¬-- represen
tation of text¶//  num_val¬=> ;¬¬¬¬-- representation of (small) integer¶¶//  BOOLEAN¬::=¬false | true;¶//  false¬=> ;¬¬¬
¬-- used for BOOLEAN¶//  true¬=> ;¶¶//  nil¬=> ;¬¬¬¬-- empty list¶//  list¬=>¬xd_head ¬: void,¬¬-- list representation¶/
/¬¬xd_tail ¬: void;¶¶//  sourceline¬=>¬xd_number¬: num_val,¶//¬¬xd_error_list¬: Seq Of error;¶¶//  error¬=>¬xd_srcpos¬: 
Source_Position,¶//¬¬xd_text ¬: txtrep;¶¶//  symbol_rep¬=>¬xd_text ¬: txtrep,¶//¬¬xd_deflist¬: Seq Of DEF_NAME;¶¶//  has
h¬=>¬xd_list ¬: Seq Of symbol_rep;¶¶//  void¬=> ;¶¶// STANDARD_IDL¬::=¶//¬root | txtrep | num_val | BOOLEAN | nil | list
 | sourceline | error | symbol_rep | hash | void;¶¶¶--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
||||||||||||||||||||||||||||||||¶-- 2.  Lexical Elements¶--|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|||||||||||||||||||||||||||||||||||||¶¶-- Syntax 2.0¶--¬Pas d'equivalent en syntaxe concrte¶¶¶¶--|----------------------
---------------------------------------------------------------------------¶-- 2.3 Identifiers, 2.4 Numeric Literals, 2.
6 String Literals¶¶-- Syntax 2.3¶--¬Ne concerne pas Diana¶¶--|..........................................................
.......................................¶//  DEF_NAME¬::=¬SOURCE_NAME | PREDEF_NAME;¶//  DEF_NAME¬=>¬lx_symrep¬: symbol_r
ep;¶--|.................................................................................................¶//  SOURCE_NAME
¬::=¬OBJECT_NAME | TYPE_NAME | UNIT_NAME | LABEL_NAME;¶//  SOURCE_NAME¬=>¬xd_region¬: SOURCE_NAME;¶¶##  SOURCE_NAME¬====
>¶##¬if_class¬OBJECT_NAME¶##¬call¬OBJECT_NAME¬SOURCE_NAME¶##¬if_class¬TYPE_NAME¶##¬call¬TYPE_NAME¬SOURCE_NAME¶##¬if_clas
s¬UNIT_NAME¶##¬call¬UNIT_NAME¬SOURCE_NAME¶##¬if_class¬LABEL_NAME¶##¬call¬LABEL_NAME¬SOURCE_NAME¶##¬if¬entry_id¶##¬call¬e
ntry_id¬SOURCE_NAME¶##¬if¬exception_id¶##¬call¬exception_id¬SOURCE_NAME¶¶--|............................................
.....................................................¶//  OBJECT_NAME¬=>¬sm_obj_type¬: TYPE_SPEC;¶¶##  OBJECT_NAME¬====>
¶##¬if¬iteration_id¶##¬call¬iteration_id¬OBJECT_NAME¶##¬if_class¬INIT_OBJECT_NAME¶##¬call¬INIT_OBJECT_NAME¬OBJECT_NAME¶#
#¬if_class¬ENUM_LITERAL¶##¬call¬ENUM_LITERAL¬OBJECT_NAME¶--|............................................................
.....................................¶//  UNIT_NAME¬=>¬sm_first¬: DEF_NAME;¶¶##  UNIT_NAME¬====>¶##¬if¬task_body_id¶##¬c
all¬task_body_id¬UNIT_NAME¶##¬if_class¬NON_TASK_NAME¶##¬call¬NON_TASK_NAME¬UNIT_NAME¶¶¶--|------------------------------
-------------------------------------------------------------------¶-- 2.8¬Pragmas¶--     These productions do not corre
spond to productions in the¶--     concrete syntax.¶¶--|----------------------------------------------------------------
---------------------------------¶-- Syntax 2.8.A¶-- pragma ::=¶--     pragma identifier [(argument_association {, argum
ent_association})];¶¶--|------------------------------------------------------------------------------------------------
-¶pragma¬::=¶¬PRAGMA  used_name_id  [(argument_association{,argument_association})]  ;¬====> $2 pragma¶¬%%¶--|..........
.......................................................................................¶used_name_id¬::=¶¬identifier¬¬¬¬
====> $0 used_name_id lx_symrep¶¬%%¶--|.................................................................................
................¶[(argument_association{,argument_association})] ::=¶¬empty¬¬¬¬====> nil $L general_assoc_s¶¬|  (  argum
ent_association{,argument_association}  )¬¬====> $L general_assoc_s¶¬%%¶--|.............................................
....................................................¶pragma_s¬::=¶¬pragma {pragma}¬¬¬¬====> insert $L pragma_s¶¬%%¶--|..
...............................................................................................¶[pragma_s]¬::=¶¬{pragma}
 ¬¬¬¬====> $L pragma_s¶¬%%¶--|..........................................................................................
.......¶¶¶//  pragma¬=>¶//¬as_used_name_id¬: used_name_id,¶//¬as_general_assoc_s¬: general_assoc_s;¬¬¬-- seq of EXP and/
or assoc¶--|.................................................................................................¶//  genera
l_assoc_s¬=>¶//¬as_list¬: Seq Of GENERAL_ASSOC;¶¶¶--|-------------------------------------------------------------------
------------------------------¶-- Syntax 2.8.B¶--  argument_association ::=¶--¬  [argument_identifier  =>] name¶--¬| [ar
gument_identifier  =>] expression¶¶--|----------------------------------------------------------------------------------
---------------¶argument_association  ::=¶¬expression¶¬|  used_name_id  =>  expression¬¬¬====> exch_1 $2 assoc¶¬%%¶--|..
...............................................................................................¶¶¶--||||||||||||||||||||
||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||¶-- 3.  Declarations and Types¶--|||||||||
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||¶-- 3.1¬Declarations¶¶-- Syntax
 3.1¶--  basic_declaration ::=¶--     object_declaration¬| number_declaration¶--     | type_declaration¬| subtype_declar
ation¶--     | subprogram_declaration¬| package_declaration¶--     | task_declaration¬| generic_declaration¶--     | exc
eption_declaration¬| generic_instantiation¶--     | renaming_declaration¬| deferred_constant_declaration¶--|------------
-------------------------------------------------------------------------------------¶¶basic_declaration¬::=¶¬  var_decl
aration¬     | number_declaration¶¬| type_declaration¬     | subtype_declaration¶¬| subprogram_declaration | package_dec
laration¶¬| task_declaration¬     | generic_declaration¶¬| exception_declaration  | generic_instantiation¶¬| renaming_de
claration   | constant_declaration¶¬%%¶--|..............................................................................
...................¶¶¶//  DECL¬¬::=¶//¬ID_S_DECL | ID_DECL;¶¶##  DECL¬====>¶##¬if_class¬ID_S_DECL¶##¬call¬ID_S_DECL¬DECL
¶##¬if_class¬ID_DECL¶##¬call¬ID_DECL¬DECL¶¶--|..........................................................................
.......................¶//  ID_DECL¬¬::=¶//¬type_decl | subtype_decl | task_decl | UNIT_DECL;¶//  ID_DECL¬¬=>¶//¬as_sour
ce_name¬: SOURCE_NAME;¶¶##  ID_DECL¬====>¶##¬if¬type_decl¶##¬call¬type_decl¬ID_DECL¶##¬if¬subtype_decl¶##¬call¬subtype_d
ecl¬ID_DECL¶##¬if¬task_decl¶##¬call¬task_decl¬ID_DECL¶##¬if_class¬UNIT_DECL¶##¬call¬UNIT_DECL¬ID_DECL¶--|...............
..................................................................................¶//  ID_S_DECL¬¬::=¶//¬EXP_DECL | exce
ption_decl | deferred_constant_decl;¶//  ID_S_DECL¬¬=>¶//¬as_source_name_s¬: source_name_s;¶¶##  ID_S_DECL¬====>¶##¬if_c
lass¬EXP_DECL¶##¬call¬EXP_DECL¬ID_S_DECL¶##¬if¬exception_decl¶##¬call¬exception_decl¬ID_S_DECL¶##¬if¬deferred_constant_d
ecl¶##¬call¬deferred_constant_decl¬ID_S_DECL¶--|........................................................................
.........................¶//  EXP_DECL¬¬::=¶//¬OBJECT_DECL | number_decl;¶//  EXP_DECL¬¬=>¶//¬as_exp¬: EXP;¶¶##  EXP_DEC
L¬====>¶##¬if_class¬OBJECT_DECL¶##¬call¬OBJECT_DECL¬EXP_DECL¶##¬if¬number_decl¶##¬call¬number_decl¬EXP_DECL¶¶¶--|-------
------------------------------------------------------------------------------------------¶-- 3.2¬Objects and Named Numb
ers¶¶-- Syntax 3.2.A¶--  object_declaration ::=¶--     identifier_list : [constant] subtype_indication [:= expression];¶
--   | identifier_list : [constant] constrained_array_definition [:= expression¶¶--** Declarations defined such that xxx
_id nodes not created until after¶--** the definition has been parsed.  Note that '$DEF' inserts the appropriate¶--** no
de at the beginning of the list which is the first son of the node at¶--** the top of the semantic stack.¶--|-----------
--------------------------------------------------------------------------------------¶¶constant_declaration ::=¶¬  iden
tifier  :  constant_definition  ;¬¬¬====> $DEF constant_id¶¬| identifier  ,  constant_declaration¬¬¬====> $DEF constant_
id¶¬%%¶--|.................................................................................................¶constant_def
inition ::=¶¬  CONSTANT  subtype_indication  :=  expression¬¬====> exch_1 $N3 constant_decl¶¬| CONSTANT constrained_arra
y_definition := expression¬¬====> exch_1 $N3 constant_decl¶¬| CONSTANT  type_mark¬¬¬====> $N2 deferred_constant_decl¶¬%%
¶--|.................................................................................................¶var_declaration¬::
=¶¬  identifier  :  var_definition  ;¬¬¬====> $DEF variable_id¶¬| identifier  ,  var_declaration¬¬¬====> $DEF variable_i
d¶¬%%¶--|.................................................................................................¶var_definitio
n¬::=¶¬  subtype_indication  [:=expression]¬¬¬====> exch_1 $N3 variable_decl¶¬| constrained_array_definition  [:=express
ion]¬¬====> exch_1 $N3 variable_decl¶¬%%¶--|............................................................................
.....................¶¶¶--|.............................................................................................
....¶//  CONSTRAINED_DEF¬¬::=¶//¬subtype_indication;¶--|................................................................
.................................¶//  OBJECT_DECL¬¬::=¶//¬constant_decl | variable_decl;¶//  OBJECT_DECL¬¬=>¶//¬as_type_
def : TYPE_DEF;¶¶##  OBJECT_DECL¬====>¶## include¬DECLARE¶## include¬  SRC_NAME_SEQ : SEQ_TYPE := LIST ( D ( AS_SOURCE_N
AME_S, OBJECT_DECL ) );¬--| AMENER LA LISTE DES NOMS DE VAR OU CONST¶## include¬  SRC_NAME     : TREE;¶## include¬  TYPE
_DEF     : TREE     := D ( AS_TYPE_DEF, OBJECT_DECL );¶## include¬  TYPE_NAME    : TREE     := D ( AS_NAME, TYPE_DEF );¬
¬--| NOM DU TYPE DANS LE CODE SOURCE¶## include¬BEGIN¶## include¬  EMITS.TYPE_SYMREP := D ( LX_SYMREP, TYPE_NAME );¬¬--|
 REPRESENTATION DU SYMBOLE DE TYPE¶¶## include¬  WHILE NOT IS_EMPTY ( SRC_NAME_SEQ ) LOOP¶## include¬    POP ( SRC_NAME_
SEQ, SRC_NAME );¶## call¬  VC_NAME¬SRC_NAME¬¬¬--| TRAITER LE NOM DE VAR CONST DECLARE¶## include¬  END LOOP;¶## include¬
END;¶¶--|.................................................................................................¶//  constant_
decl¬¬=> ;¬¬¬--| Ne fait qu'heriter¶--|.................................................................................
................¶//  variable_decl¬¬=> ;¶--|............................................................................
.....................¶//  OBJECT_NAME¬¬::=¶//¬INIT_OBJECT_NAME;¶--|.....................................................
............................................¶//  INIT_OBJECT_NAME¬::=¬¬¬--| Objet var ou cst avec initialisation¶//¬VC_N
AME;¶//  INIT_OBJECT_NAME¬=>¶//¬sm_init_exp¬: EXP;¬¬¬--| Attribut expression d'init¶--|.................................
................................................................¶//  VC_NAME¬¬::=¶//¬variable_id | constant_id;¬¬¬--| Id
entificateur variable ou constante¶//  VC_NAME¬¬=>¶//¬sm_renames_obj¬: BOOLEAN,¬¬¬--| Indique un renames (pour var)¶//¬s
m_address¬: EXP,¬¬¬--| EXP OU VIDE¶//¬cd_comp_unit¬: Integer,¶//¬cd_level¬: Integer,¶//¬cd_offset¬: Integer,¶//¬cd_compi
led¬: BOOLEAN;¶¶##  VC_NAME¬====>¶## include¬DECLARE¶## include¬  TYPE_SPEC : TREE := D ( SM_OBJ_TYPE, VC_NAME );¬¬--| L
E TYPE ATTACHE A LA DECLARATION VAR CONST¶## include¬  --|--------------------------------------------------------------
-------------¶## include¬  PROCEDURE COMPILE_VC_NAME_INTEGER ( VC_NAME :TREE ) IS¬¬--| VARIABLE DE TYPE ENTIER¶## includ
e¬  BEGIN¶## include¬    ALIGN ( INTG_AL );¬¬¬--| ALIGNER LES OFFSET POUR UN ENTIER¶## include¬    DECLARE¶## include¬  
    LVL      : LEVEL_TYPE    := EMITS.LEVEL;¬¬--| NIVEAU IMBRICATION ACTUEL¶## include¬      OFS      : OFFSET_TYPE   :=
 - EMITS.OFFSET_ACT;¬¬--| DECALAGE ACTUEL ESPACE DE STOCKAGE¶## include¬      CPU      : COMP_UNIT_NBR := EMITS.CUR_COMP
_UNIT;¬¬--| NUMERO D UNITE ACTUEL¶## include¬      INIT_EXP : TREE          := D ( SM_INIT_EXP, VC_NAME );¶## include¬  
  BEGIN¶## include¬      DI ( CD_LEVEL, VC_NAME, LVL );¬¬¬--| STOCKER LE NIVEAU¶## include¬      DI ( CD_OFFSET, VC_NAME
, OFS );¬¬¬--| LE DECALAGE¶## include¬      DI ( CD_COMP_UNIT, VC_NAME, CPU );¬¬--| L UNITE¶## include¬      DB ( CD_COM
PILED, VC_NAME, TRUE );¬¬--| INDIQUER QUE C EST COMPILE¶## include¬      INC_OFFSET ( INTG_SIZE );¬¬¬--| AUGMENTER LE DE
CALAGE¶## include¬      IF INIT_EXP /= TREE_VOID THEN¬¬¬--| SI EXPRESSION D INITIALISATION¶## call¬EXP¬INIT_EXP¬¬¬--| EV
ALUER CETTE EXPRESSION¶## include¬        GEN_STORE ( I, CPU, LVL, OFS,¬¬¬--| STOCKER SON RESULTAT COMME VALEUR INITIALE
¶## include¬                  "STO " & PRINT_NAME ( D (LX_SYMREP, VC_NAME ) ) & " VAL INIT" );¶## include¬      END IF;¶
## include¬    END;¶## include¬  END COMPILE_VC_NAME_INTEGER;¶## include¬  --|------------------------------------------
---------------------------------¶## include¬  PROCEDURE COMPILE_VC_NAME_ENUMERATION ( VC_NAME, TYPE_SPEC :TREE ) IS¶## 
include¬    NAME             : CONSTANT STRING := PRINT_NAME ( EMITS.TYPE_SYMREP );¬--| CHAINE DU NOM DE TYPE¶¶## includ
e¬    PROCEDURE COMPILE_VC_NAME_BOOL_CHAR ( VC_NAME :TREE; CT :CODE_TYPE; SIZ, ALI :NATURAL ) IS¶## include¬    BEGIN¶##
 include¬      ALIGN ( ALI );¶## include¬      DECLARE¶## include¬        LVL      : LEVEL_TYPE    := EMITS.LEVEL;¶## in
clude¬        OFS      : OFFSET_TYPE   := - EMITS.OFFSET_ACT;¶## include¬        CPU      : COMP_UNIT_NBR := EMITS.CUR_C
OMP_UNIT;¶## include¬        INIT_EXP : TREE          := D ( SM_INIT_EXP, VC_NAME );¶## include¬      BEGIN¶## include¬ 
       DI ( CD_LEVEL, VC_NAME, LVL );¬¬¬--| STOCKER LE NIVEAU¶## include¬        DI ( CD_OFFSET, VC_NAME, OFS );¬¬¬--| L
E DECALAGE¶## include¬        DI ( CD_COMP_UNIT, VC_NAME, CPU );¬¬--| L UNITE¶## include¬        DB ( CD_COMPILED, VC_NA
ME, TRUE );¬¬--| INDIQUER QUE C EST COMPILE¶## include¬        INC_OFFSET ( SIZ );¬¬¬--| AUGMENTER LE DECALAGE¶## includ
e¬        IF INIT_EXP /= TREE_VOID THEN¬¬¬--| SI EXPRESSION D INITIALISATION¶## call¬EXP¬INIT_EXP¬¬¬--| EVALUER CETTE EX
PRESSION¶## include¬        END IF;¶## include¬        GEN_STORE ( CT, CPU, LVL, OFS,¬¬¬--| STOCKER SON RESULTAT COMME V
ALEUR INITIALE¶## include¬               PRINT_NAME ( D (LX_SYMREP, VC_NAME ) ) & " := VAL INIT" );¶## include¬      END
;¶## include¬    END COMPILE_VC_NAME_BOOL_CHAR;¶¶## include¬  BEGIN¶## include¬    IF NAME = "BOOLEAN" THEN¶## include¬ 
     COMPILE_VC_NAME_BOOL_CHAR ( VC_NAME, B, BOOL_SIZE, BOOL_AL );¶## include¬    ELSIF NAME = "CHARACTER" THEN¶## inclu
de¬      COMPILE_VC_NAME_BOOL_CHAR ( VC_NAME, C, CHAR_SIZE, CHAR_AL );¶## include¬    ELSE¶## include¬      COMPILE_VC_N
AME_INTEGER ( VC_NAME );¶## include¬    END IF;¶## include¬  END COMPILE_VC_NAME_ENUMERATION;¶## include¬  --|----------
-----------------------------------------------------------------¶## include¬  PROCEDURE COMPILE_ACCESS_VAR ( VAR_ID, TY
PE_SPEC :TREE ) IS¶## include¬  BEGIN¶## include¬    ALIGN ( ADDR_AL );¶## include¬    DECLARE¶## include¬      LVL : LE
VEL_TYPE    := EMITS.LEVEL;¶## include¬      OFS : OFFSET_TYPE   := - EMITS.OFFSET_ACT;¶## include¬      CPU : COMP_UNIT
_NBR := EMITS.CUR_COMP_UNIT;¶## include¬    BEGIN¶## include¬      DI ( CD_LEVEL, VAR_ID, LVL );¶## include¬      DI ( C
D_OFFSET, VAR_ID, OFS );¶## include¬      DI ( CD_COMP_UNIT, VAR_ID, CPU );¶## include¬      DB ( CD_COMPILED, VAR_ID, T
RUE );¶## include¬      INC_OFFSET ( ADDR_SIZE );¶## include¬      DECLARE¶## include¬        INIT_EXP : TREE := D ( SM_
INIT_EXP, VAR_ID );¶## include¬      BEGIN¶## include¬        IF INIT_EXP = TREE_VOID THEN¶## include¬          EMIT ( L
DC, A, -1, "INIT NIL DE " & PRINT_NAME ( D (LX_SYMREP, VAR_ID ) ) );¶## include¬        ELSE¶## include¬          LOAD_T
YPE_SIZE ( TYPE_SPEC  );¶## include¬          EMIT ( ALO, LVL - DI ( CD_LEVEL, TYPE_SPEC ) );¶## include¬        END IF;
¶## include¬      END;¶## include¬      GEN_STORE ( A, CPU, LVL, OFS,¶## include¬               "STO " & PRINT_NAME ( D 
(LX_SYMREP, VAR_ID ) ) & " VAL INIT" );¶## include¬    END;¶## include¬  END COMPILE_ACCESS_VAR;¶## include¬  --|-------
--------------------------------------------------------------------¶## include¬  PROCEDURE COMPILE_ARRAY_VAR ( VC_NAME,
 TYPE_SPEC :TREE ) IS¶## include¬    DESCR_PTR : OFFSET_TYPE;¶## include¬  BEGIN¶## include¬    ALIGN ( ADDR_AL );¶## in
clude¬    DECLARE¶## include¬      LVL       : LEVEL_TYPE := EMITS.LEVEL;¶## include¬      VALUE_PTR : OFFSET_TYPE := - 
EMITS.OFFSET_ACT;¶## include¬      CPU       : COMP_UNIT_NBR := EMITS.CUR_COMP_UNIT;¶## include¬    BEGIN¶## include¬   
   DI ( CD_LEVEL, VC_NAME, LVL );¶## include¬      DI ( CD_OFFSET, VC_NAME, VALUE_PTR );¶## include¬      DI ( CD_COMP_U
NIT, VC_NAME, CPU );¶## include¬      DB ( CD_COMPILED, VC_NAME, TRUE );¶## include¬      INC_OFFSET ( ADDR_SIZE );¶## i
nclude¬      ALIGN ( ADDR_AL );¶## include¬      DESCR_PTR := - EMITS.OFFSET_ACT;¶## include¬      INC_OFFSET ( ADDR_SIZ
E );¶            ¶## include¬      IF DB ( CD_COMPILED, TYPE_SPEC ) THEN¶## include¬        GEN_LOAD_ADDR ( DI ( CD_COMP
_UNIT, TYPE_SPEC ) , DI ( CD_LEVEL, TYPE_SPEC ), DI ( CD_OFFSET, TYPE_SPEC ) );¶## include¬        EMIT ( DPL, A, "DUPLI
CATE " & PRINT_NAME ( D (LX_SYMREP, VC_NAME ) ) & " ARRAY DESCRIPTOR TYPE_SPEC" );¶## include¬        GEN_STORE ( A, EMI
TS.CUR_COMP_UNIT, EMITS.LEVEL, DESCR_PTR, "STO ADRESSE DESCRIPTEUR" );¶## include¬        EMIT ( IND, I, 0, "CHARGE INDE
XE TAILLE TABLEAU DE DESCRIPTEUR" );¶## include¬        EMIT ( ALO, INTEGER ( 0 ), COMMENT=> "ALLOC TABLEAU" );¶## inclu
de¬        GEN_STORE ( A, EMITS.CUR_COMP_UNIT, EMITS.LEVEL, VALUE_PTR, "STO ADRESSE TABLEAU ALLOUE" );¶## include¬      
ELSE¶## include¬        PUT_LINE ( "!!! COMPILE_ARRAY_VAR : TYPE_SPEC NON COMPILE" );¶## include¬        RAISE PROGRAM_E
RROR;¶## include¬      END IF;¶## include¬    END;¶## include¬  END COMPILE_ARRAY_VAR;¶## include¬  --|-----------------
----------------------------------------------------------¶## include¬  PROCEDURE COMPILE_RECORD_VAR ( VC_NAME, TYPE_SPE
C :TREE ) IS¶## include¬    INIT_EXP : TREE := D ( SM_INIT_EXP, VC_NAME );¶## include¬  BEGIN¶## include¬    ALIGN ( REC
ORD_AL );¶## include¬    DECLARE¶## include¬      LVL : LEVEL_TYPE    := EMITS.LEVEL;¶## include¬      OFS : OFFSET_TYPE
   := - EMITS.OFFSET_ACT;¶## include¬      CPU : COMP_UNIT_NBR := EMITS.CUR_COMP_UNIT;¶## include¬    BEGIN¶## include¬ 
     DI ( CD_LEVEL, VC_NAME, LVL );¶## include¬      DI ( CD_OFFSET, VC_NAME, OFS );¶## include¬      DI ( CD_COMP_UNIT,
 VC_NAME, CPU );¶## include¬      DB ( CD_COMPILED, VC_NAME, TRUE );¶         ¶## include¬      IF INIT_EXP.TY = DN_AGGR
EGATE THEN¶## include¬        DECLARE¶## include¬          GENERAL_ASSOC_SEQ : SEQ_TYPE := LIST ( D ( SM_NORMALIZED_COMP
_S, INIT_EXP ) );¶## include¬          COMP_EXP          : TREE;¶## include¬        BEGIN¶## include¬          WHILE NOT
 IS_EMPTY ( GENERAL_ASSOC_SEQ ) LOOP¶## include¬            POP ( GENERAL_ASSOC_SEQ, COMP_EXP );¶                    ¶##
 call¬EXP¬COMP_EXP¶-- ## include¬            GEN_STORE ( CODE_TYPE_OF ( COMP_EXP ), CPU, LVL, OFS + field_Ofs,¶-- ## inc
lude¬                        "STO " & PRINT_NAME ( D (LX_SYMREP, VC_NAME ) ) & " VAL INIT CHAMP" );¶¶## include¬        
  END LOOP;¶## include¬        END;¶## include¬      END IF;¶## include¬    END;¶## include¬  END COMPILE_RECORD_VAR;¶##
 include¬  --|---------------------------------------------------------------------------¶## include¬BEGIN¶## include¬  
CASE TYPE_SPEC.TY IS¶## include¬  WHEN DN_INTEGER =>¶## include¬    COMPILE_VC_NAME_INTEGER ( VC_NAME );¶               
¶## include¬  WHEN DN_ENUMERATION =>¶## include¬    COMPILE_VC_NAME_ENUMERATION ( VC_NAME, TYPE_SPEC );¶               ¶
## include¬  WHEN DN_ACCESS =>¶## include¬    COMPILE_ACCESS_VAR ( VC_NAME, TYPE_SPEC );¶               ¶## include¬  WH
EN DN_CONSTRAINED_ARRAY =>¶## include¬    COMPILE_ARRAY_VAR ( VC_NAME, TYPE_SPEC );¶         ¶## include¬  WHEN DN_RECOR
D =>¶## include¬    COMPILE_RECORD_VAR ( VC_NAME, TYPE_SPEC );¶               ¶## include¬  WHEN OTHERS =>¶## include¬  
  PUT_LINE ( "!!! CODE_VC_NAME, TYPE_SPEC.TY = " & NODE_NAME'IMAGE ( TYPE_SPEC.TY ) );¶## include¬    RAISE PROGRAM_ERRO
R;¶## include¬  END CASE;¶## include¬END;¶--|...........................................................................
......................¶//  variable_id¬¬=>¶//¬sm_is_shared¬: BOOLEAN;¬¬¬--| Si pragma shared applique¶¶##  variable_id¬=
===>¶##¬include¬null;¶--|...............................................................................................
..¶//  constant_id¬¬=>¶//¬sm_first¬: DEF_NAME;¶¶##  constant_id¬====>¶##¬include¬null;¶¶¶¶--|---------------------------
----------------------------------------------------------------------¶-- Syntax 3.2.B¶--  number_declaration ::=¶--    
 identifier_list : constant := universal_static_expression;¶--|---------------------------------------------------------
----------------------------------------¶¶number_declaration¬::=¶¬  identifier  :  number_definition   ;¬¬¬====> $DEF nu
mber_id¶¬| identifier  ,  number_declaration¬¬¬====> $DEF number_id¶¬%%¶--|.............................................
....................................................¶number_definition¬::=¶¬CONSTANT  :=  expression¬¬¬====> $N2 number_
decl¶¬%%¶--|.................................................................................................¶¶¶//  numb
er_decl¬¬=> ;¶##  number_decl¬====>¶##¬include¬null;¶--|................................................................
.................................¶//  INIT_OBJECT_NAME¬::=    number_id;¶--|............................................
.....................................................¶//  number_id¬¬=> ;¶¶##  number_id¬====>¶##¬include¬null;¶¶¶¶--|--
-----------------------------------------------------------------------------------------------¶-- Syntax 3.2.C¶--  iden
tifier_list ::= identifier {, identifier}¶--**  Unused syntax, since list is built by means of $DEF's¶--|---------------
----------------------------------------------------------------------------------¶¶¶//  source_name_s¬=>¬    as_list : 
Seq Of SOURCE_NAME;¶##  source_name_s¬====>¶##¬repeat_extract¬source_name_s¬source_name¶##¬call¬source_name¬source_name¶
¶¶¶--|-------------------------------------------------------------------------------------------------¶-- 3.3¬Types and
 Subtypes¶-- 3.3.1 Type Declarations¶-- Syntax 3.3.1.A¶--  type_declaration ::= full_type_declaration¶--     | incomplet
e_type_declaration | private_type_declaration¶--¶--  full_type_declaration ::=¶--     type identifier [discriminant_part
] is type_definition;¶--|-----------------------------------------------------------------------------------------------
--¶¶type_declaration¬::=¶¬full_type_declaration | incomplete_type_declaration | private_type_declaration¶¬%%¶--|........
.........................................................................................¶full_type_declaration¬::=¶¬TYP
E  identifier  [discriminant_part]__IS  type_definition  ;¬====> $V3 type_decl $DEF type_id¶¬%%¶--|.....................
............................................................................¶¶¶//  type_decl¬¬=>¶//¬as_dscrmt_decl_s¬: d
scrmt_decl_s,¶//¬as_type_def¬: TYPE_DEF;¶¶##  type_decl¬====>¶## include¬DECLARE¶## include¬  TYPE_DEF  : TREE := D ( AS
_TYPE_DEF, TYPE_DECL );¶## include¬  TYPE_ID   : TREE := D ( AS_SOURCE_NAME, TYPE_DECL );¶## include¬  TYPE_SPEC : TREE 
:= D ( SM_TYPE_SPEC, TYPE_ID );¶## include¬  ---------------------------------------------------------------------------
---¶## include¬  PROCEDURE COMPILE_ENUMERATION_DEF ( ENUMERATION_DEF :TREE ) IS¶## include¬    ENUM_LITERAL_S  : TREE   
  := D ( AS_ENUM_LITERAL_S, ENUMERATION_DEF );¶## include¬    LITERAL_SEQ     : SEQ_TYPE := LIST ( ENUM_LITERAL_S );¶## 
include¬    LITERAL         : TREE;¶## include¬  BEGIN¶## include¬    WHILE NOT IS_EMPTY ( LITERAL_SEQ ) LOOP¬¬--| TANT 
QU IL Y A DES ELEMENTS¶## include¬      POP ( LITERAL_SEQ, LITERAL );¬¬¬--| EN EXTRAIRE UN¶## include¬    END LOOP;¶## i
nclude¬    DI ( CD_LAST, ENUM_LITERAL_S, DI ( SM_REP, LITERAL ) );¬¬--| STOCKER LA VALEUR DU DERNIER¶## include¬  END;¶#
# include¬  ------------------------------------------------------------------------------¶## include¬  PROCEDURE COMPIL
E_INTEGER_DEF ( INTEGER_DEF, INTEGER_SPEC :TREE ) IS¶## include¬    LOWER      : OFFSET_TYPE;¬¬¬--| LIEU DE LA BORNE BAS
SE¶## include¬    UPPER      : OFFSET_TYPE;¬¬¬--| LIEU DE LA BORNE HAUTE¶## include¬    INT_RANGE  : TREE := D ( AS_CONS
TRAINT, INTEGER_DEF );¬¬--| ETENDUE DU TYPE ENTIER¶## include¬    EXP_BORNE  : TREE;¶## include¬  BEGIN¶## include¬    A
LIGN ( INTG_AL );¬¬¬--| ALIGNER LE SOMMET DE PILE POUR UN ENTIER¶## include¬    LOWER := - EMITS.OFFSET_ACT;¬¬¬--| LIEU 
DE LA BORNE BASSE¶## include¬    INC_OFFSET ( INTG_SIZE );¬¬¬--| ALLER AU LIEU LIBRE SUIVANT L'ENTIER¶## include¬    UPP
ER := - EMITS.OFFSET_ACT;¬¬¬--| LIEU DE LA BORNE HAUTE¶## include¬    INC_OFFSET ( INTG_SIZE );¬¬¬--| ALLER AU LIEU LIBR
E SUIVANT L'ENTIER¶      ¶## include¬    DI ( CD_OFFSET, INTEGER_SPEC, LOWER );¬¬--| LIEU DES BORNES¶## include¬    DI (
 CD_LEVEL, INTEGER_SPEC, EMITS.LEVEL );¬¬--| NIVEAU STATIQUE DE LA DEFINITION¶## include¬    DI ( CD_COMP_UNIT, INTEGER_
SPEC, CUR_COMP_UNIT );¬¬--| UNITE PARENTE¶## include¬    DB ( CD_COMPILED, INTEGER_SPEC, TRUE );¬¬--| DEFINITION TRAITEE
¶## include¬    EXP_BORNE := D ( AS_EXP1, INT_RANGE );¬¬--| EXPRESSION BORNE BASSE¶## call¬EXP¬EXP_BORNE¬¬¬--| GENERER L
E CODE DE CALCUL DE L'EXPRESSION DE BORNE BASSE¶## include¬    GEN_STORE ( I, EMITS.CUR_COMP_UNIT, EMITS.LEVEL, LOWER, "
BORNE BASSE" );¬--| STOCKER LE RSULTAT DANS LA BORNE BASSE¶## include¬    EXP_BORNE := D ( AS_EXP2, INT_RANGE );¬¬--| EX
PRESSION BORNE HAUTE¶## call¬EXP¬EXP_BORNE¬¬¬--| GENERER LE CODE DE CALCUL DE L'EXPRESSION DE BORNE HAUTE¶## include¬   
 GEN_STORE ( I, EMITS.CUR_COMP_UNIT, EMITS.LEVEL, UPPER, "BORNE HAUTE" );¬--| STOCKER LE RSULTAT DANS LA HAUTE¶## includ
e¬  END COMPILE_INTEGER_DEF;¶## include¬  ------------------------------------------------------------------------------
¶## include¬  PROCEDURE COMPILE_CONSTRAINED_ARRAY_DEF ( TYPE_DEF, TYPE_SPEC :TREE ) IS¶## include¬    DIMENSIONS_NBR    
 : NATURAL  := 0;¶## include¬    SUBTYPE_INDICATION : TREE     := D ( AS_SUBTYPE_INDICATION, TYPE_DEF );¬--| SOUS TYPE D
E L'ELEMENT¶## include¬    USED_NAME_ID       : TREE     := D ( AS_NAME, SUBTYPE_INDICATION );¶## include¬    COMP_TYPE_
ID       : TREE     := D ( SM_DEFN, USED_NAME_ID );¶## include¬    COMP_TYPE          : TREE     := D ( SM_TYPE_SPEC, CO
MP_TYPE_ID );¬--| TYPE_SPEC DU TYPE D'ELEMENT¶## include¬    INDEX_CONSTRAINT   : TREE     := D ( AS_CONSTRAINT, TYPE_DE
F );¬--| LA CONTRAINTE DE DEFINITION DU TYPE TABLEAU¶## include¬    DISCRETE_RANGE_S   : TREE     := D ( AS_DISCRETE_RAN
GE_S, INDEX_CONSTRAINT );¶## include¬    DISCRETE_RANGE_SEQ : SEQ_TYPE := LIST ( DISCRETE_RANGE_S );¬--| LA SEQUENCE DES
 INDICAGES¶         ¶## include¬    --|-------------------------------------------------------------------------¶## incl
ude¬    PROCEDURE INSTALL_ARRAY_DIMENSION ( DISCRETE_RANGE_SEQ :IN OUT SEQ_TYPE ) IS¶## include¬      IDXFAC, FIRST, LAS
T : OFFSET_TYPE;¶## include¬      DISCRETE_RANGE      : TREE;¶## include¬    BEGIN¶## include¬      DIMENSIONS_NBR := DI
MENSIONS_NBR + 1;¬¬--| UNE DIMENSION DE PLUS¶## include¬      ALIGN ( INTG_AL );¬¬¬--| ALIGNER LE LIEU POUR UN ENTIER¶##
 include¬      IDXFAC := - EMITS.OFFSET_ACT;¬¬¬--| LIEU DU FACTEUR DE L'INDICE (POUR PASSER D'UN LMENT AU SUIVANT)¶## in
clude¬      FIRST := IDXFAC - INTG_SIZE;¬¬¬--| LIEU DE L'INDICE BAS¶## include¬      LAST := FIRST - INTG_SIZE;¬¬¬--| LI
EU DE L'INDICE HAUT¶## include¬      INC_OFFSET ( 3*INTG_SIZE );¬¬¬--| MONTER LE LIEU LIBRE A 3 ENTIERS PLUS LOIN¶      
      ¶## include¬      POP ( DISCRETE_RANGE_SEQ, DISCRETE_RANGE );¬¬--| EXTRAIRE L'INDIAGE DE CETTE DIMENSION¶## includ
e¬      IF IS_EMPTY ( DISCRETE_RANGE_SEQ ) THEN¬¬--| C'ETAIT LE DERNIER INDICAGE (INDICE "RAPIDE")¶## include¬        EM
ITS.LOAD_TYPE_SIZE ( COMP_TYPE );¬¬--| EMPILER LA TAILLE DE L'ELEMENT¶## include¬        EMIT ( DPL, I, "DUPLICATE INDEX
 FACTOR" );¬¬--| GENERER UNE DUPLICATION DE CETTE TAILLE¶## include¬        GEN_STORE ( I, 0, EMITS.LEVEL, IDXFAC, "STOR
E INDEX FACTOR" );¬--| LA STOCKER COMME FACTEUR DE PASSAGE D'UN ELEMENT AU SUIVANT POUR CETTE DIMENSION¶## include¬     
 ELSE¬¬¬¬--| C'EST UN INDICAGE INTERMEDIAIRE¶## include¬        INSTALL_ARRAY_DIMENSION ( DISCRETE_RANGE_SEQ );¬¬--| TRA
ITER LA DIMENSION SUIVANTE¶## include¬        EMIT ( DPL, I, "DUPLICATE INDEX FACTOR" );¬¬--| DUPLIQUER LE FACTEUR DE PA
SSAGE¶## include¬        GEN_STORE ( I, 0, EMITS.LEVEL, IDXFAC, "STORE INDEX FACTOR" );¬--| LE STOCKER DANS LE DESCRIPTE
UR DU TABLEAU¶## include¬      END IF;¶            ¶## include¬      IF DISCRETE_RANGE.TY = DN_DISCRETE_SUBTYPE THEN¶## 
include¬        DECLARE¶## include¬          SUBTYPE_INDICATION : TREE := D ( AS_SUBTYPE_INDICATION, DISCRETE_RANGE );¶#
# include¬        BEGIN¶## include¬          DISCRETE_RANGE := D ( AS_CONSTRAINT, SUBTYPE_INDICATION );¶## include¬     
     IF DISCRETE_RANGE.TY = DN_VOID THEN¶## include¬            DECLARE¶## include¬              USED_NAME_ID : TREE := 
D ( AS_NAME, SUBTYPE_INDICATION );¶## include¬              DEF_NAME     : TREE := D ( SM_DEFN, USED_NAME_ID );¶## inclu
de¬              TYPE_SPEC    : TREE := D ( SM_TYPE_SPEC, DEF_NAME );¶## include¬            BEGIN¶## include¬          
    DISCRETE_RANGE := D ( SM_RANGE, TYPE_SPEC );¶## include¬            END;¶## include¬          END IF;¶## include¬   
     END;¶## include¬      END IF;¶         ¶## include¬      IF DISCRETE_RANGE.TY = DN_RANGE_ATTRIBUTE THEN¬¬--| CAS DU
 "SUBTYPE'RANGE"¶## include¬        DECLARE¶## include¬          TYPE_SPEC : TREE := D ( SM_TYPE_SPEC, DISCRETE_RANGE );
¬--| CHERCHER LE TYPE¶## include¬        BEGIN¶## include¬          DISCRETE_RANGE := D ( SM_RANGE, TYPE_SPEC );¬¬--| RE
MPLACER LE DISCRETE RANGE PAR LE RANGE DU TYPE¶## include¬        END;¶## include¬      END IF;¶            ¶## include¬
      IF DISCRETE_RANGE.TY = DN_RANGE THEN¶## include¬        DECLARE¶## include¬          EXP_BORNE : TREE := D ( AS_EX
P1, DISCRETE_RANGE );¶## include¬        BEGIN¶## call¬EXP¬EXP_BORNE¬¬¬--| GENERER LE CODE DE CALCUL DE L'EXPRESSION DE 
BORNE BASSE¶## include¬          GEN_STORE ( I, EMITS.CUR_COMP_UNIT, EMITS.LEVEL, FIRST, "FIRST" );¬--| LE STOCKER DANS 
LE DESCRIPTEUR¶## include¬          EXP_BORNE := D ( AS_EXP2, DISCRETE_RANGE );¶## call¬EXP¬EXP_BORNE¬¬¬--| GENERER LE C
ODE DE CALCUL DE L'EXPRESSION DE BORNE HAUTE¶## include¬          GEN_STORE ( I, EMITS.CUR_COMP_UNIT, EMITS.LEVEL, LAST,
 "LAST" );¶## include¬        END;¶¶## include¬        GEN_LOAD_ADDR ( 0, LEVEL, FIRST, "LOAD @FIRST" );¬¬--| GENERER L'
EMPILAGE DE L'ADRESSE DE LA SECTION DU DESCRIPTEUR POUR LA DIMENSION¶## include¬        EMIT ( LEN, "CALCULATE LENGTH" )
;¬¬--| PROCEDURE DE CALCUL DU LENGTH(DIM)¶## include¬        EMIT ( MUL, I, "NEXT INDEX FACTOR = LEN * PREVIOUS FACTOR" 
);¬--| LAISSER LE FACTEUR DE PASSAGE (LENGHTH*FACTEUR PRECEDENT) SUR LA PILE¶## include¬      ELSIF DISCRETE_RANGE.TY = 
DN_RANGE_ATTRIBUTE THEN¶## include¬        NULL;¶## include¬      ELSE¶## include¬        NULL;      -- DN_RANGE_ATTRIBU
TE -- DN_DISCRETE_SUBTYPE¶## include¬        PUT_LINE ( "!!! COMPILE_TYPE_ARRAY_DIMENSION : DISCRETE_RANGE.TY ILLICITE "
 & NODE_NAME'IMAGE ( DISCRETE_RANGE.TY ) );¶## include¬        RAISE PROGRAM_ERROR;¶## include¬      END IF;¶## include¬
    END INSTALL_ARRAY_DIMENSION;¶         ¶## include¬  BEGIN¶## include¬    ALIGN ( INTG_AL );¬¬¬--| ALIGNER LE LIEU LI
BRE POUR UN ENTIER¶## include¬    DI ( CD_LEVEL, TYPE_SPEC, EMITS.LEVEL );¬¬--| STOCKER LE NIVEAU STATIQUE¶## include¬  
  DI ( CD_COMP_UNIT, TYPE_SPEC, EMITS.CUR_COMP_UNIT );¬¬--| STOCKER L'UNITE COURANTE¶## include¬    DB ( CD_COMPILED, TY
PE_SPEC, TRUE );¬¬--| MARQUER COMME TRAITE¶## include¬    DECLARE¶## include¬      OFFSET : INTEGER := - EMITS.OFFSET_AC
T;¶## include¬    BEGIN¶## include¬      DI ( CD_OFFSET, TYPE_SPEC, OFFSET );¬¬--| STOCKER LE LIEU DU NOMBRE DE DIMENSIO
NS¶## include¬      INC_OFFSET ( INTG_SIZE );¬¬¬--| MONTER AU LIEU LIBRE SUIVANT L'ENTIER¶## include¬      INSTALL_ARRAY
_DIMENSION ( DISCRETE_RANGE_SEQ );¬¬--| METTRE EN PLACE LES FACTEURS D'INDEXATION ET LES LIMITES D'INDICE¶## include¬   
   GEN_STORE ( I, EMITS.CUR_COMP_UNIT, EMITS.LEVEL, OFFSET,¶## include¬             "STORE ARRAY SIZE (LAST INDEX FACTOR
)" );¬¬--| GENERER LE STOCKAGE EN PILE DU NOMBRE DE DIMENSIONS¶## include¬      DI ( CD_DIMENSIONS, TYPE_SPEC, DIMENSION
S_NBR );¬¬--| STOCKER AUSSI DANS LE TYPE_SPEC¶## include¬    END;¶## include¬  END COMPILE_CONSTRAINED_ARRAY_DEF;¶## inc
lude¬  ------------------------------------------------------------------------------¶## include¬  PROCEDURE COMPILE_ACC
ESS_DEF ( ACCESS_DEF, ACCESS_SPEC :TREE ) IS¶## include¬    POINTED_TYPE_SPEC : TREE    := D ( SM_DESIG_TYPE, ACCESS_SPE
C );¶## include¬    CONTRAINT         : BOOLEAN := (POINTED_TYPE_SPEC.TY IN CLASS_CONSTRAINED);¶## include¬  BEGIN¶## in
clude¬    DB ( CD_CONSTRAINED, ACCESS_SPEC, CONTRAINT );¶      ¶## include¬    IF CONTRAINT THEN¶## include¬      DI ( C
D_LEVEL, ACCESS_SPEC, EMITS.LEVEL );¬¬--| STOCKER LE NIVEAU STATIQUE DE LA DEFINITION¶## include¬      ALIGN ( INTG_AL )
;¬¬¬--| ALIGNER LE LIEU LIBRE POUR UN ENTIER¶## include¬      DECLARE¶## include¬        OFFSET : OFFSET_TYPE := EMITS.O
FFSET_ACT;¶## include¬      BEGIN¶## include¬        DI ( CD_OFFSET, ACCESS_SPEC, OFFSET );¬¬--| STOCKER LE LIEU¶## incl
ude¬        INC_OFFSET ( INTG_SIZE );¬¬¬--| MONTER AU LIEU SUIVANT L'ENTIER¶## include¬        EMITS.LOAD_TYPE_SIZE ( PO
INTED_TYPE_SPEC );¬¬--| GENERER LE CHARGEMENT DE LA TAILLE DU TYPE POINTE¶## include¬        GEN_STORE ( I, 0, EMITS.LEV
EL, OFFSET, "STORE POINTERD TYPE SIZE" );¬--| LA STOCKER DANS LE LIEU RESERVE¶## include¬      END;¶## include¬    END I
F;¶## include¬  END;¶## include¬  ------------------------------------------------------------------------------¶¶## inc
lude¬BEGIN¶## include¬  IF EMITS.CUR_COMP_UNIT /= 1 THEN¬¬¬--| PAS LE STANDARD¶## include¬    CASE TYPE_DEF.TY IS¶      
      ¶## include¬    WHEN DN_ENUMERATION_DEF =>¶## include¬      COMPILE_ENUMERATION_DEF ( TYPE_DEF );¶                
  ¶## include¬    WHEN DN_INTEGER_DEF =>¬¬¬--| TYPE TRUCIS RANGE 1..10*U;¶## include¬      COMPILE_INTEGER_DEF ( TYPE_DE
F, TYPE_SPEC );¶            ¶## include¬    WHEN DN_FLOAT_DEF =>¶## include¬      NULL;¶            ¶## include¬    WHEN
 DN_FIXED_DEF =>¶## include¬      NULL;¶            ¶## include¬    WHEN DN_CONSTRAINED_ARRAY_DEF =>¶## include¬      CO
MPILE_CONSTRAINED_ARRAY_DEF ( TYPE_DEF, TYPE_SPEC );¶                  ¶## include¬    WHEN DN_RECORD_DEF =>¶## include¬
      NULL;¶            ¶## include¬    WHEN DN_ACCESS_DEF =>¶## include¬      COMPILE_ACCESS_DEF ( TYPE_DEF, TYPE_SPEC 
);¶                  ¶## include¬    WHEN DN_DERIVED_DEF =>¶## include¬      NULL;¶                  ¶## include¬    WHE
N OTHERS =>¶## include¬      NULL;¬-- DN_SUBTYPE_INDICATION -- DN_L_PRIVATE_DEF -- DN_PRIVATE_DEF -- DN_UNCONSTRAINED_AR
RAY_DEF¶## include                PUT_LINE ( "!!! COMPILE_TYPE_DECL : TYPE_SPEC.TY ILLICITE " & NODE_NAME'IMAGE ( TYPE_S
PEC.TY ) );¶## include¬      RAISE PROGRAM_ERROR;¶## include¬    END CASE;¶## include¬  END IF;¶## include¬END;¶--|.....
............................................................................................¶//  TYPE_NAME¬¬::=¶//¬type_
id;¶//  TYPE_NAME¬¬=>¶//¬sm_type_spec¬: TYPE_SPEC;¶¶##  TYPE_NAME¬====>¶##¬if¬type_id¶##¬call¬type_id¬TYPE_NAME¶##¬if¬su
btype_id¶##¬call¬subtype_id¬TYPE_NAME¶##¬if¬private_type_id¶##¬call¬private_type_id¬TYPE_NAME¶##¬if¬l_private_type_id¶##
¬call¬l_private_type_id¬TYPE_NAME¶--|...................................................................................
..............¶//  type_id¬¬=>¶//¬sm_first¬: DEF_NAME;¶¶##  type_id¬====>¶##¬include¬null;¶¶¶¶--|-----------------------
--------------------------------------------------------------------------¶-- Syntax 3.3.1.B¶--  type_definition ::=¶-- 
    enumeration_type_definition  | integer_type_definition¶--   | real_type_definition¬    | array_type_definition¶--   
| record_type_definition¬    | access_type_definition¶--   | derived_type_definition¶--|--------------------------------
-----------------------------------------------------------------¶¶type_definition ::=¶¬  enumeration_type_definition¬| 
integer_type_definition¶¬| real_type_definition¬| array_type_definition¶¬| record_type_definition¬| access_type_definiti
on¶¬| derived_type_definition¶¬%%¶--|...................................................................................
..............¶¶¶//  TYPE_DEF¬¬::=¶//¬enumeration_def | CONSTRAINED_DEF | ARR_ACC_DER_DEF | record_def;¶--|.............
....................................................................................¶//  CONSTRAINED_DEF¬¬::=¶//¬integer
_def | float_def | fixed_def;¶--|.......................................................................................
..........¶//  ARR_ACC_DER_DEF¬¬::=¶//¬constrained_array_def | unconstrained_array_def | access_def | derived_def;¶//  A
RR_ACC_DER_DEF¬¬=>¶//¬as_subtype_indication¬: subtype_indication;¶--|...................................................
..............................................¶//  TYPE_SPEC¬¬::=¶//¬DERIVABLE_SPEC;¶--|................................
.................................................................¶//  DERIVABLE_SPEC¬¬::=¶//¬FULL_TYPE_SPEC | PRIVATE_SP
EC;¶//  DERIVABLE_SPEC¬¬=>¶//¬xd_source_name¬: SOURCE_NAME,¶//¬sm_derived¬: TYPE_SPEC,¶//¬sm_is_anonymous¬: BOOLEAN;¶--|
.................................................................................................¶//  FULL_TYPE_SPEC¬¬::
=¶//¬task_spec | NON_TASK;¶//  FULL_TYPE_SPEC¬¬=>¶//¬cd_comp_unit¬: Integer,¶//¬cd_level¬: Integer,¶//¬cd_compiled¬: BOO
LEAN;¶--|.................................................................................................¶//  NON_TASK¬
¬::=¶//¬SCALAR | UNCONSTRAINED | CONSTRAINED;¶//  NON_TASK¬¬=>¶//¬sm_base_type¬: TYPE_SPEC;¶--|.........................
........................................................................¶//  SCALAR¬¬::=¶//¬enumeration | Integer | REAL
;¶//  SCALAR¬¬=>¶//¬sm_range¬: RANGE,¶//¬cd_impl_size¬: Integer;¶--|....................................................
.............................................¶//  REAL¬¬::=¶//¬float | fixed;¶//  REAL¬¬=>¶//¬sm_accuracy¬: Value;¶--|..
...............................................................................................¶//  UNCONSTRAINED¬¬::=¶/
/¬UNCONSTRAINED_COMPOSITE | access;¶//  UNCONSTRAINED¬¬=>¶//¬sm_size¬: EXP;¬¬-- exp or void¶--|.........................
........................................................................¶//  UNCONSTRAINED_COMPOSITE¬::=¶//¬array | reco
rd;¶//  UNCONSTRAINED_COMPOSITE¬=>¶//¬sm_is_limited¬: BOOLEAN,¶//¬sm_is_packed¬: BOOLEAN;¶--|...........................
......................................................................¶//  CONSTRAINED¬¬::=¶//¬constrained_array | const
rained_record | constrained_access;¶//  CONSTRAINED¬¬=>¶//¬sm_depends_on_dscrmt¬: BOOLEAN,¶//¬cd_impl_size¬¬: Integer,¶/
/¬cd_alignment¬¬: Integer;¶¶¶¶--|---------------------------------------------------------------------------------------
----------¶-- 3.3.2 Subtype Declarations¶-- Syntax 3.3.2.A¶--  subtype_declaration ::= subtype identifier is subtype_ind
ication;¶--|-------------------------------------------------------------------------------------------------¶¶subtype_d
eclaration¬::=¶¬SUBTYPE  subtype_id  IS  subtype_indication  ;¬¬====> $2 subtype_decl¶¬%%¶--|...........................
......................................................................¶subtype_id¬::=¶¬identifier¬¬¬¬====> $0 subtype_id
 lx_symrep¶¬%%¶--|.................................................................................................¶¶¶//
  subtype_decl¬¬=>¶//¬as_subtype_indication¬: subtype_indication;¶¶##  subtype_decl¬====>¶##¬include¬null;¶--|..........
.......................................................................................¶//  TYPE_NAME¬¬::=¶//¬subtype_id
;¶--|.................................................................................................¶//  subtype_id¬¬=
> ;¶¶##  subtype_id¬====>¶##¬include¬null;¶¶¶¶--|-----------------------------------------------------------------------
--------------------------¶-- Syntax 3.3.2.B¶--  subtype_indication ::= type_mark [constraint]¶--¶--  type_mark ::= type
_name | subtype_name¶--|------------------------------------------------------------------------------------------------
-¶¶subtype_indication¬::=¶¬type_mark  [constraint]¬¬¬====> exch_1 $2 subtype_indication¶¬%%¶--|.........................
........................................................................¶type_mark¬::=¶¬expanded_name¶¬%%¶--|...........
......................................................................................¶expanded_name¬::=¶¬  used_id¶ ¬| 
expanded_name . used_id¬¬¬====> $2 selected¶¬%%¶--|.....................................................................
............................¶¶¶--|......................................................................................
...........¶//  CONSTRAINED_DEF¬¬=>¶//¬as_constraint¬: CONSTRAINT;¶--|..................................................
...............................................¶//  subtype_indication¬=>¶//¬as_name¬: NAME;¶¶¶--|----------------------
---------------------------------------------------------------------------¶-- Syntax 3.3.2.C¶--  constraint¬::=¶--¬  ra
nge_constraint | floating_point_constraint | fixed_point_constraint¶--¬| index_constraint | discriminant_constraint¶--|-
------------------------------------------------------------------------------------------------¶¶constraint¬::=¶¬  rang
e_constraint¬|  floating_point_constraint  |  fixed_point_constraint¶¬| index_constraint__|__discriminant_constraint¶¬%%
¶--|.................................................................................................¶¶¶//  CONSTRAINT¬¬
::=¶//¬DISCRETE_RANGE | REAL_CONSTRAINT | index_constraint | dscrmt_constraint;¶¶¶¶--|----------------------------------
---------------------------------------------------------------¶-- 3.4¬Derived Type Definitions¶-- Syntax 3.4¶--  derive
d_type_definition ::= new subtype_indication¶--|------------------------------------------------------------------------
-------------------------¶¶derived_type_definition¬::=¶¬NEW  subtype_indication¬¬¬====> $1 derived_def¶¬%%¶--|..........
.......................................................................................¶¶¶//  derived_def¬=>¬   ¬xd_deri
ved_subprog_list: Seq Of SUBPROG_NAME;¶¶¶¶--|---------------------------------------------------------------------------
----------------------¶-- 3.5¬Scalar Types¶-- Syntax 3.5¶--  range_constraint ::= range range¶--  range¬::= range_attrib
ute¶--¬| simple_expression .. simple_expression¶--|---------------------------------------------------------------------
----------------------------¶¶range_constraint¬::=¶¬RANGE range¶¬%%¶--|.................................................
................................................¶range¬::=¶¬  name¶ ¬| simple_expression .. simple_expression¬¬====> $2 
range¶¬%%¶--|.................................................................................................¶¶¶//  DIS
CRETE_RANGE¬¬::=¶//¬RANGE | discrete_subtype;¶//  RANGE¬¬::=¶//¬range | range_attribute;¶//  RANGE¬¬=>¶//¬sm_type_spec :
 TYPE_SPEC;¶//  range¬¬=>¶//¬as_exp1¬: EXP,¶//¬as_exp2¬: EXP;¶//  range_attribute¬¬=>¶//¬as_name¬: NAME,¶//¬as_used_name
_id¬: used_name_id,¶//¬as_exp¬: EXP;¬¬¬-- EXP or void¶¶¶¶--|------------------------------------------------------------
-------------------------------------¶-- 3.5.1  Enumeration Types¶-- Syntax 3.5.1.A¶--  enumeration_type_definition ::=¶
--    (enumeration_literal_specification {, enumeration_literal_specification})¶--|-------------------------------------
------------------------------------------------------------¶¶enumeration_type_definition ::=¶¬(  enumeration_literal{,e
numeration_literal}  )¬¬ ====> $L enum_literal_s $1 enumeration_def¶¬%%¶--|.............................................
....................................................¶¶¶//  enumeration_def¬¬=>¶//¬as_enum_literal_s¬: enum_literal_s;¶--
|.................................................................................................¶//  enum_literal_s¬¬=
>¶//¬as_list¬: Seq Of ENUM_LITERAL,¶//¬cd_alignment¬: Integer,¶//¬cd_impl_size¬: Integer,¶//¬cd_last¬: Integer;¶--|.....
............................................................................................¶//  enumeration¬¬=>¶//¬sm_l
iteral_s¬: enum_literal_s;¶¶¶¶--|---------------------------------------------------------------------------------------
----------¶-- Syntax 3.5.1.B¶--  enumeration_literal_specification ::= enumeration_literal¶--¶--  enumeration_literal ::
= identifier | character_literal¶--|------------------------------------------------------------------------------------
-------------¶¶enumeration_literal¬::=¶¬identifier¬¬¬¬====> $0 enumeration_id lx_symrep¶¬| character_literal ¬¬¬====> $0
 character_id lx_symrep¶¬%%¶--|.........................................................................................
........¶¶¶//  OBJECT_NAME¬¬::=¶//¬ENUM_LITERAL;¶--|....................................................................
.............................¶//  ENUM_LITERAL¬¬::=¶//¬enumeration_id | character_id;¶//  ENUM_LITERAL¬¬=>¶//¬sm_pos¬: I
nteger,¶//¬sm_rep¬: Integer;¶¶##  ENUM_LITERAL¬====>¶##¬if¬enumeration_id¶##¬call¬enumeration_id¬ENUM_LITERAL¶##¬if¬char
acter_id¶##¬call¬character_id¬ENUM_LITERAL¶--|..........................................................................
.......................¶//  enumeration_id¬=> ;¶¶##  enumeration_id¬====>¶##¬include¬null;¶--|..........................
.......................................................................¶//  character_id¬=> ;¶¶##  character_id¬====>¶##
¬include¬null;¶¶¶¶--|-------------------------------------------------------------------------------------------------¶-
- 3.5.4  Integer Types¶-- Syntax 3.5.4¶--  integer_type_definition ::= range_constraint¶--|-----------------------------
--------------------------------------------------------------------¶¶integer_type_definition¬::=¶¬range_constraint¬¬¬¬=
===> $1 integer_def¶¬%%¶--|.............................................................................................
....¶¶¶//  integer_def¬=> ;¶--|.........................................................................................
........¶//  Integer¬=>¶//¬cd_offset¬: Integer,¶//¬cd_impl_size¬: Integer;¶¶¶¶--|---------------------------------------
----------------------------------------------------------¶-- 3.5.6  Real Types¶-- Syntax 3.5.6¶--  real_type_definition
 ::=¶--     floating_point_constraint | fixed_point_constraint¶--|------------------------------------------------------
-------------------------------------------¶¶real_type_definition¬::=¶¬  floating_point_constraint¬¬¬====> $1 float_def¶
¬| fixed_point_constraint¬¬¬====> $1 fixed_def¶¬%%¶--|..................................................................
...............................¶¶¶//  REAL_CONSTRAINT ::=     float_constraint¶//¬¬¬  | fixed_constraint;¶//  REAL_CONST
RAINT¬=>¬    sm_type_spec : TYPE_SPEC;¶¶¶¶--|---------------------------------------------------------------------------
----------------------¶-- 3.5.7  Floating Point Types¶-- Syntax 3.5.7¶--  floating_point_constraint ::=¶--     floating_
accuracy_definition [range_constraint]¶--¶--  floating_accuracy_definition ::= digits static_simple_expression¶--|------
-------------------------------------------------------------------------------------------¶¶floating_point_constraint¬:
:=¶¬DIGITS  simple_expression  [range_constraint]¬¬====> $2 float_constraint¶¬%%¶--|....................................
.............................................................¶¶¶//  float_def¬¬=> ;¶--|.................................
................................................................¶//  REAL_CONSTRAINT¬¬=>¶//¬as_exp¬: EXP,¶//¬as_range¬: 
RANGE;¶--|.................................................................................................¶//  float_co
nstraint¬=> ;¶--|.................................................................................................¶//  f
loat¬¬=>¶//¬cd_impl_size¬: Integer ;¶¶¶¶--|-----------------------------------------------------------------------------
--------------------¶-- 3.5.9  Fixed Point Types¶-- Syntax 3.5.9¶--  fixed_point_constraint  ::=¶--     fixed_accuracy_d
efinition [range_constraint]¶--¶--  fixed_accuracy_definition ::= delta static_simple_expression¶--|--------------------
-----------------------------------------------------------------------------¶¶fixed_point_constraint¬::=¶¬DELTA  simple
_expression  [range_constraint]¬¬====> $2 fixed_constraint¶¬%%¶--|......................................................
...........................................¶¶¶//  fixed_def¬=> ;¶--|....................................................
.............................................¶//  fixed_constraint¬=> ;¶--|.............................................
....................................................¶//  fixed¬¬=>¶//¬cd_impl_small¬: Value,¶//¬cd_impl_size¬: Integer;¶
¶¶¶--|-------------------------------------------------------------------------------------------------¶-- 3.6¬Array Typ
es¶-- Syntax 3.6.A¶--  array_type_definition ::=¶--     unconstrained_array_definition | constrained_array_definition¶--
¶--  unconstrained_array_definition ::=¶--     array(index_subtype_definition {, index_subtype_definition}) of¶--¬¬    c
omponent_subtype_indication¶--¶--  constrained_array_definition ::=¶--     array index_constraint of component_subtype_i
ndication¶--|-------------------------------------------------------------------------------------------------¶¶array_ty
pe_definition¬::=¶¬unconstrained_array_definition | constrained_array_definition¶¬%%¶--|................................
.................................................................¶¶unconstrained_array_definition¬::=¶¬ARRAY  (index_sub
type_definition{,index_subtype_definition})  OF¶¬¬¬¬subtype_indication¬====> exch_1 $2 unconstrained_array_def¶¬%%¶--|..
...............................................................................................¶(index_subtype_definitio
n{,index_subtype_definition})¬::=¶¬(  index_subtype_definition{,index_subtype_definition}  )¬¬====> $L index_s¶¬%%¶--|..
...............................................................................................¶constrained_array_defini
tion¬::=¶¬ARRAY  index_constraint  OF  subtype_indication¬¬====> exch_1 $2 constrained_array_def¶¬%%¶--|................
.................................................................................¶¶¶//  constrained_array_def¬=>¶//¬as_c
onstraint¬: CONSTRAINT;¶--|.............................................................................................
....¶//  index_constraint¬=>¶//¬as_discrete_range_s¬: discrete_range_s;¶--|.............................................
....................................................¶//  discrete_range_s¬=>¶//¬as_list¬: Seq Of DISCRETE_RANGE;¶--|....
.............................................................................................¶//  unconstrained_array_de
f¬=>¶//¬as_index_s¬: index_s;¶--|.......................................................................................
..........¶//  scalar_s¬¬=>¶//¬as_list¬: Seq Of SCALAR;¶--|.............................................................
....................................¶//  array¬¬=>¶//¬sm_index_s¬: index_s,¶//¬sm_comp_type¬: TYPE_SPEC;¶--|............
.....................................................................................¶//  constrained_array¬=>¶//¬sm_ind
ex_subtype_s¬: scalar_s,¶//¬cd_offset¬: Integer,¶//¬cd_dimensions¬: Integer;¶¶¶¶--|-------------------------------------
------------------------------------------------------------¶-- Syntax 3.6.B¶--  index_subtype_definition ::= type_mark 
range <>¶--|-------------------------------------------------------------------------------------------------¶¶index_sub
type_definition¬::=¶¬type_mark__RANGE__<>¶¬%%¶--|.......................................................................
..........................¶¶--** name instead of type_mark to avoid LALR conflict¶¶type_mark__RANGE__<>¬::=¶¬name  RANGE
  <>¬¬¬¬====> $1 index¶¬%%¶--|..........................................................................................
.......¶¶¶//  index¬¬=>¶//¬as_name¬: NAME,¶//¬sm_type_spec¬: TYPE_SPEC;¶--|.............................................
....................................................¶//  index_s¬¬=>¶//¬as_list¬: Seq Of index;¶¶¶¶--|------------------
-------------------------------------------------------------------------------¶-- Syntax 3.6.C¶--  index_constraint ::=
 (discrete_range {, discrete_range})¶--¶--  discrete_range ::= discrete_subtype_indication | range¶--|------------------
-------------------------------------------------------------------------------¶¶index_constraint¬::=¶¬(  discrete_range
{,discrete_range}  )¬¬¬====> $L discrete_range_s $1 index_constraint¶¬%%¶--|............................................
.....................................................¶¶--** This definition of index_constraint used only in constrained
 array¶--** definitions.  In subtype indications, the wider class,¶--** index_constraint__|__discriminant_constraint is 
used¶¶discrete_range¬::=¶¬  range¶¬| name  range_constraint¬¬¬====> exch_1 $2 subtype_indication $1 discrete_subtype¶¬%%
¶--|.................................................................................................¶--** The name must
 be an expanded_name¶¶//  discrete_subtype¬=>¶//¬as_subtype_indication¬: subtype_indication;¶¶¶¶--|---------------------
----------------------------------------------------------------------------¶-- 3.7¬Record Types¶-- Syntax 3.7.A¶--  rec
ord_type_definition ::=¶--     record¶--¬    component_list¶--     end record¶--|---------------------------------------
----------------------------------------------------------¶¶record_type_definition ::=¶     RECORD  component_list  END 
 RECORD¬====> $1 record_def¶¬%%¶--|.....................................................................................
............¶¶¶--|.................................................................................................¶//  
record_def¬¬=>¶//¬as_comp_list¬: comp_list;¶--|.........................................................................
........................¶//  record¬¬=>¶//¬sm_discriminant_s¬: dscrmt_decl_s,¶//¬sm_comp_list¬: comp_list,¶//¬sm_represe
ntation¬: REP;¬¬¬-- REP or void¶//¬cd_impl_size¬¬: Integer,¶//¬cd_alignment¬¬: Integer;¶--|.............................
....................................................................¶//  constrained_record¬=>¶//¬sm_normalized_dscrmt_s
¬: exp_s;¶¶¶¶--|-------------------------------------------------------------------------------------------------¶-- Syn
tax 3.7.B¶--  component_list ::=¶--¬ component_declaration {component_declaration}¶--     | {component_declaration} vari
ant_part¶--     | null;¶--¶--  component_declaration ::=¶--     identifier_list : component_subtype_definition [:= expre
ssion];¶--¶--  component_subtype_definition ::= subtype_indication¶--|--------------------------------------------------
-----------------------------------------------¶¶component_list¬::=¶¬  component_decl_s¬¬¬¬====> void nil $L pragma_s $3
 comp_list¶¬| component_decl_s¬variant_part  {pragma}¬¬====> $L pragma_s $3 comp_list¶¬| empty_component_decl_s  variant
_part  {pragma}¬¬====> $L pragma_s $3 comp_list¶¬| {pragma} null_comp {pragma}¬¬¬====> insert cat $L decl_s void nil $L 
pragma_s $3 comp_list¶¬%%¶--|...........................................................................................
......¶component_decl_s¬::=¶¬{pragma} component_declaration {pragma}{component_declaration{pragma}}¬====> insert cat $L 
decl_s¶¬%%¶--|.................................................................................................¶empty_co
mponent_decl_s¬::=¬¬¬====> nil $L decl_s¶¬%%¶--|........................................................................
.........................¶component_declaration¬::=¶¬  identifier  :  component_definition ;¬¬¬====> $DEF component_id¶¬
| identifier  ,  component_declaration¬¬¬====> $DEF component_id¶¬%%¶--|................................................
.................................................¶component_definition¬::=¶¬subtype_indication  [:=expression]¬¬¬====> e
xch_1 $N3 variable_decl¶¬%%¶--|.........................................................................................
........¶null_comp¬::=¶¬NULL ;¬¬¬¬====> $0 null_comp_decl¶¬%%¶--|.......................................................
..........................................¶¶¶//  DECL¬¬::=¶//¬null_comp_decl;¶--|.......................................
..........................................................¶//  null_comp_decl¬¬=> ;¶//¬¬    -- (missing from Intermetric
s definition)¶--|.................................................................................................¶//  I
NIT_OBJECT_NAME¬::=¶//¬COMP_NAME;¶--|...................................................................................
..............¶//  COMP_NAME¬::=¶//¬component_id | discriminant_id;¶//  COMP_NAME¬=>¶//¬sm_comp_rep¬: COMP_REP_ELEM;¶¶##
  COMP_NAME¬====>¶##¬if¬component_id¶##¬call¬component_id¬COMP_NAME¶##¬if¬discriminant_id¶##¬call¬discriminant_id¬COMP_N
AME¶--|.................................................................................................¶//  component_i
d¬¬=> ;¶¶##  component_id¬====>¶##¬include¬null;¶¶¶¶--|-----------------------------------------------------------------
--------------------------------¶-- 3.7.1  Discriminants¶-- Syntax 3.7.1¶--  discriminant_part ::=¶--     (discriminant_
specification {; discriminant_specification})¶--¶--  discriminant_specification ::=¶--     identifier_list : type_mark [
:= expression]¶--|-------------------------------------------------------------------------------------------------¶¶dis
criminant_part¬::=¶¬(  discriminant_specification{;discriminant_specification}  )¬====> $L dscrmt_decl_s¶¬%%¶--|........
.........................................................................................¶[discriminant_part] ::=¶¬  emp
ty¬¬¬¬====> nil $L dscrmt_decl_s¶¬| discriminant_part¶¬%%¶--|...........................................................
......................................¶discriminant_specification¬::=¶¬  identifier  :  discriminant_definition¬¬====> $
DEF discriminant_id¶¬| identifier  ,  discriminant_specification¬¬====> $DEF discriminant_id¶¬%%¶--|....................
.............................................................................¶discriminant_definition¬::=¶¬type_mark [:=
expression]¬¬¬====> $N3 dscrmt_decl¶¬%%¶--|.............................................................................
....................¶¶¶//  ITEM¬¬::=¶//¬DSCRMT_PARAM_DECL;¶--|..........................................................
.......................................¶//  DSCRMT_PARAM_DECL¬::=¶//¬dscrmt_decl;¶//  DSCRMT_PARAM_DECL¬=>¶//¬as_source_
name_s¬: source_name_s,¶//¬as_name¬: NAME,¶//¬as_exp¬: EXP;¶--|.........................................................
........................................¶//  dscrmt_decl_s¬¬=>¶//¬as_list¬: Seq Of dscrmt_decl;¶//  dscrmt_decl¬¬=> ;¶--
|.................................................................................................¶//  discriminant_id¬¬
=>¶//¬sm_first¬: DEF_NAME;¶¶##  discriminant_id¬====>¶##¬include¬null;¶¶¶¶--|-------------------------------------------
------------------------------------------------------¶-- 3.7.2  Discriminant Constraints¶-- Syntax 3.7.2¶--  discrimina
nt_constraint ::=¶--     (discriminant_association {, discriminant_association})¶--  discriminant_association ::=¶--    
 [discriminant_simple_name {|discriminant_simple_name}¬=>] expression¶--¶--|--------------------------------------------
-----------------------------------------------------¶¶index_constraint__|__discriminant_constraint¬::=¶¬  (  discrimina
nt_association{,discriminant_association}  )¬¬====> $L general_assoc_s¶¬| (  discriminant_association{,discriminant_asso
ciation}  others_association  )¬====> append $L general_assoc_s¶¬| (  others_association  )¬¬¬====> list $L general_asso
c_s¶¬%%¶--|.................................................................................................¶discriminan
t_association¬::=¶¬  expression¶¬| simple_expression .. simple_expression¬¬====> $2 range¶¬| name range_constraint¬¬¬===
=> exch_1 $2 subtype_indication¶¬| discriminant_choice_s  =>  expression¬¬¬====> exch_1 $2 named¶¬%%¶--** discriminant a
ssociation includes discrete_range (for index constraint)¶--|...........................................................
......................................¶discriminant_choice_s¬::=¶¬discriminant_choice{|discriminant_choice}¬¬====> $L ch
oice_s¶¬%%¶--|.................................................................................................¶¶discrim
inant_choice¬::=¶¬used_name_id¬¬¬¬====> $1 choice_exp¶¬%%¶--|...........................................................
......................................¶¶¶//  dscrmt_constraint¬=>¶//¬as_general_assoc_s¬: general_assoc_s;¶¶¶¶--|-------
------------------------------------------------------------------------------------------¶-- 3.7.3  Variant Parts¶-- Sy
ntax 3.7.3.A¶--  variant_part ::=¶--     case discriminant_simple_name is¶--¬   variant¶--¬  {variant}¶--     end case;¶
--¶--  variant  ::=¶--     when choice {| choice}¬=>¶--¬   component_list¶--|-------------------------------------------
------------------------------------------------------¶¶variant_pragma¬::=¶¬pragma¬¬¬¬====> $1 variant_pragma¶¬%%¶--|...
..............................................................................................¶variant_part¬::=¶¬CASE  u
sed_id  IS  variant_s  END  CASE  ;¬¬====> $2 variant_part¶¬%%¶--|......................................................
...........................................¶variant_s¬::=¶¬ {variant_pragma}  {variant}  variant¬¬¬====> append cat $L v
ariant_s¶¬| {variant_pragma}  {variant}  others_variant¬¬====> append cat $L variant_s¶¬%%¶--|..........................
.......................................................................¶--** pragma's between variants picked up in comp
onent lists¶¶variant¬::=¶¬WHEN  choice_s  =>  component_list¬¬¬====> $2 variant¶¬%%¶--|.................................
................................................................¶¶choice_s¬::=¶¬choice{|choice}¬¬¬¬====> $L choice_s¶¬%%
¶--|.................................................................................................¶¶¶//  VARIANT_PART
¬¬::=¶//¬variant_part;¶--|..............................................................................................
...¶//  variant_part¬¬=>¶//¬as_name¬: NAME,¶//¬as_variant_s¬: variant_s;¶--|............................................
.....................................................¶//  variant_s¬¬=>¶//¬as_list¬: Seq Of VARIANT_ELEM;¶--|...........
......................................................................................¶//  VARIANT_ELEM¬::=¶//¬variant |
 variant_pragma;¶--|.................................................................................................¶//
  variant¬¬=>¶//¬as_choice_s¬: choice_s,¶//¬as_comp_list¬: comp_list;¶--|...............................................
..................................................¶//  choice_s¬¬=>¶//¬as_list¬: Seq Of CHOICE,¶//¬cd_label¬: Integer;¶¶
##  choice_s¬====>¶##¬repeat_extract¬choice_s¬choice¶##¬call¬CHOICE¬choice¶##¬include¬IF NOT CHOICE_OTHERS_FLAG THEN¶##¬
include¬   EMIT ( JMPT, LABEL_TYPE ( DI ( CD_LABEL, CHOICE_S ) ), COMMENT=> "TRAITE EXCEPTION" );¶##¬include¬END IF;¶¶--
|.................................................................................................¶//  comp_list¬¬=>¶//¬
as_decl_s¬: decl_s,¶//¬as_variant_part¬: VARIANT_PART,¶//¬as_pragma_s¬: pragma_s;¶--|...................................
..............................................................¶//  variant_pragma¬=>¬    as_pragma : pragma;¶¶¶¶--|-----
--------------------------------------------------------------------------------------------¶-- Syntax 3.7.3.B¶--  choic
e ::= simple_expression¶--     | discrete_range | others | component_simple_name¶--¶--|---------------------------------
----------------------------------------------------------------¶¶choice¬::=¶¬  simple_expression¬¬¬¬====> $1 choice_exp
¶¬| simple_expression  ..  simple_expression¬¬====> $2 range $1 choice_range¶¬| name  range_constraint¬¬¬====> exch_1 $2
 subtype_indication $1 discrete_subtype $1 choice_range¶¬%%¶--** The name must be an expanded_name¶--|..................
...............................................................................¶¶others_variant¬::=¶¬WHEN  others_s  => 
 component_list¬¬¬====> $2 variant¶¬%%¶--|..............................................................................
...................¶others_s¬::=¶¬OTHERS¬¬¬¬====> $0 choice_others list $L choice_s¶¬%%¶--|.............................
....................................................................¶¶¶//  CHOICE¬¬::=¶//¬choice_exp | choice_range | ch
oice_others;¶¶##  CHOICE¬====>¶##¬if¬choice_exp¶##¬call¬choice_exp¬CHOICE¶##¬if¬choice_range¶##¬call¬choice_range¬CHOICE
¶##¬if¬choice_others¶##¬call¬choice_others¬CHOICE¶--|...................................................................
..............................¶//  choice_exp¬¬=>¶//¬as_exp¬: EXP;¶--¬lx_srcpos¬:Source_Position¶¶##  choice_exp¬====>¶#
#¬call¬EXP¬@ as_EXP¬choice_exp¶--|......................................................................................
...........¶//  choice_range¬¬=>¶//¬as_discrete_range¬: DISCRETE_RANGE;¶--¬lx_srcpos¬:Source_Position¶¶##  choice_range¬
====>¶##¬include¬null;¶--|..............................................................................................
...¶//  choice_others¬¬=> ;¶--¬lx_srcpos¬:Source_Position¶¶##  choice_others¬====>¶##¬include¬choice_Others_Flag := true
;¶¶¶¶--|-------------------------------------------------------------------------------------------------¶-- 3.8¬Access 
Types¶-- Syntax 3.8¶--  access_type_definition ::= access subtype_indication¶--¶--|-------------------------------------
------------------------------------------------------------¶¶access_type_definition¬::=¶¬ACCESS  subtype_indication¬¬¬=
===> $1 access_def¶¬%%¶--|..............................................................................................
...¶¶¶//  access_def¬=> ;¶--|...........................................................................................
......¶//  access¬¬=>¶//¬sm_storage_size¬: EXP,¬¬¬-- EXP or void¶//¬sm_is_controlled¬: BOOLEAN,¶//¬sm_desig_type¬: TYPE_
SPEC,¶//¬sm_master¬: ALL_DECL,¶//¬cd_offset¬: Integer,¶//¬cd_constrained¬: BOOLEAN;¶--|.................................
................................................................¶//  constrained_access¬=>¶//¬sm_desig_type¬: TYPE_SPEC;
¶¶¶¶--|-------------------------------------------------------------------------------------------------¶-- 3.8.1 Incomp
lete Type Declarations¶-- Syntax 3.8.1¶--  incomplete_type_declaration ::= type identifier [discriminant_part];¶--¶--|--
-----------------------------------------------------------------------------------------------¶¶incomplete_type_declara
tion¬::=¶¬TYPE  identifier  [discriminant_part]  ;¬¬====> void $V3 type_decl $DEF type_id¶¬%%¶--|.......................
..........................................................................¶¶--|.........................................
........................................................¶//  TYPE_SPEC ::=¬    incomplete;¶--|..........................
.......................................................................¶//  incomplete¬¬=>¶//¬sm_discriminant_s¬: dscrmt
_decl_s,¶//¬xd_source_name¬: SOURCE_NAME,¶//¬xd_full_type_spec¬: TYPE_SPEC;¶--|.........................................
........................................................¶¶¶¶--|---------------------------------------------------------
----------------------------------------¶-- 3.9¬Declarative Parts¶-- Syntax 3.9.A¶--  declarative_part ::=¶--     {basic
_declarative_item} {later_declarative_item}¶--¶--  basic_declarative_item ::= basic_declaration¶--     | representation_
clause | use_clause¶--¶¶--** Following Fisher & Charles, a body is the only later_declarative_item¶--** which is not als
o a basic declarative item; it is used as the boundary.¶--|-------------------------------------------------------------
------------------------------------¶¶declarative_part¬::=¶¬  {pragma}  {basic_declarative_item{pragma}}¬¬====> cat $L i
tem_s¶¬| {pragma}  {basic_declarative_item{pragma}}¶¬¬body  {pragma}  {later_declarative_item{pragma}}¬====> cat insert 
cat cat $L item_s¶¬%%¶--|...............................................................................................
..¶basic_declarative_item¬::=¶¬basic_declaration | representation_clause | use_clause¶¬%%¶--|...........................
......................................................................¶¶¶//  DECL¬¬::=¶//¬REP | USE_PRAGMA;¶--|.........
........................................................................................¶//  USE_PRAGMA¬::=¶//¬use | pra
gma;¶¶¶¶--|-------------------------------------------------------------------------------------------------¶-- Syntax 3
.9.B¶--  later_declarative_item ::= body¶--     | subprogram_declaration | package_declaration¶--     | task_declaration
¬| generic_declaration¶--     | use_clause¬¬| generic_instantiation¶--¶--  body  ::=  proper_body | body_stub¶--¶--  pro
per_body ::= subprogram_body | package_body | task_body¶--|-------------------------------------------------------------
------------------------------------¶¶later_declarative_item ::= body¶     | subprogram_declaration | package_declaratio
n¶     | task_declaration       | generic_declaration¶     | use_clause¬ | generic_instantiation¶¬%%¶--|................
.................................................................................¶¶body ::= proper_body | body_stub¶¬%%¶
--|.................................................................................................¶¶proper_body ::= su
bprogram_body | package_body | task_body¶¬%%¶--|........................................................................
.........................¶¶¶//  ITEM¬¬::=¶//¬DECL | SUBUNIT_BODY;¶¶##  ITEM¬====>¬¬¬¬--| Action sur ITEM¶##¬if_class¬DEC
L¬¬¬--| Si dans classe DECL¶##¬call¬DECL¬ITEM¬¬--| Appliquer l'action DECL au paramtre ITEM¶##¬if_class¬SUBUNIT_BODY¬¬¬-
-| Si dans classe SUBUNIT_BODY¶##¬call¬SUBUNIT_BODY¬ITEM¬¬--| Appliquer l'action subunit_body au paramtre ITEM¶--|......
...........................................................................................¶//  item_s¬¬=>¶//¬as_list¬: 
Seq Of ITEM;¶¶##  item_s¬====>¶##¬repeat_extract¬item_s¬item¶##¬call¬ITEM¬item¶--|......................................
...........................................................¶//  UNIT_DECL¬¬::=¬    generic_decl | NON_GENERIC_DECL;¶//  
UNIT_DECL¬¬=>¶//¬as_header¬: HEADER;¶¶## UNIT_DECL¬====>¬¬¬¬--| Action sur DECL¶##¬if¬generic_decl¬¬¬--| Si generic_decl
¶##¬call¬generic_decl¬UNIT_DECL¬¬--| Appliquer l'action generic_decl au paramtre DECL¶##¬if_class¬NON_GENERIC_DECL¬¬¬--|
 Si dans classe NON_GENERIC_DECL¶##¬call¬NON_GENERIC_DECL¬UNIT_DECL¬¬--| Appliquer l'action NON_GENERIC_DECL au paramtre
 DECL¶--|.................................................................................................¶//  NON_GENER
IC_DECL¬::=¶//¬subprog_entry_decl | package_decl;¶//  NON_GENERIC_DECL¬=>¶//¬as_unit_kind¬: UNIT_KIND;¶¶##  NON_GENERIC_
DECL¬====>¬¬¬--| Action sur NON_GENERIC_DECL¶##¬if¬subprog_entry_decl¬¬¬--| Si subprog_entry_decl¶##¬call¬subprog_entry_
decl¬NON_GENERIC_DECL¬¬--| Appliquer l'action subprog_entry_decl sur le paramtre NON_GENERIC_DECL¶##¬if¬package_decl¬¬¬-
-| Si package_decl¶##¬call¬package_decl¬NON_GENERIC_DECL¬¬--| Appliquer l'action package_decl sur le paramtre NON_GENERI
C_DECL¶¶¶¶--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||¶-- 4.  Na
mes and Expressions¶--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
¶-- 4.1¬Names¶¶-- Syntax 4.1.A¶--  name ::= simple_name¶--     | character_literal    | operator_symbol¶--     | indexed
_component    | slice¶--     | selected_component   | attribute¶--¶--  simple_name ::= identifier¶--|-------------------
------------------------------------------------------------------------------¶¶name¬::=¶¬  selected_component¬|  attrib
ute¶¬| used_id¬| used_char¬| used_string¶¬| indexed_component__|__slice¶¬%%¶--|.........................................
........................................................¶used_id¬::=¶¬identifier¬¬¬¬====> $0 used_object_id lx_symrep¶¬%
%¶--|.................................................................................................¶used_char¬::=¶¬ch
aracter_literal¬¬¬¬====> $0 used_char lx_symrep¶¬%%¶--|.................................................................
................................¶used_string¬::=¶¬string_literal¬¬¬¬====> $0 string_literal lx_symrep¶¬%%¶--|...........
......................................................................................¶¶¶//  NAME¬¬::=¶//¬DESIGNATOR | N
AME_EXP;¶¶##  NAME¬====>¶##¬if_class¬DESIGNATOR¶##¬call¬DESIGNATOR¬NAME¶##¬if_class¬NAME_EXP¶##¬call¬NAME_EXP¬NAME¶--|..
...............................................................................................¶//  NAME_EXP¬¬::=¶//¬NAM
E_VAL | indexed | slice | all;¶//  NAME_EXP¬¬=>¶//¬as_name¬: NAME,¶//¬sm_exp_type¬: TYPE_SPEC;¶¶##  NAME_EXP¬====>¶##¬if
¬indexed¶##¬call¬indexed¬NAME_EXP¶##¬if¬slice¶##¬call¬slice¬NAME_EXP¶##¬if¬all¶##¬call¬all¬NAME_EXP¶--|.................
................................................................................¶//  NAME_VAL¬¬::=¶//¬attribute | select
ed;¶//  NAME_VAL¬¬=>¶//¬sm_value¬: Value;¶--|...........................................................................
......................¶//  DESIGNATOR¬¬::=¶//¬USED_OBJECT | USED_NAME;¶//  DESIGNATOR¬¬=>¶//¬sm_defn¬: DEF_NAME,¶//¬lx_s
ymrep¬: symbol_rep;¶¶##  DESIGNATOR¬====>¶##¬if_class¬USED_OBJECT¶##¬call¬USED_OBJECT¬DESIGNATOR¶##¬if_class¬USED_NAME¶#
#¬call¬USED_NAME¬DESIGNATOR¶--|.........................................................................................
........¶//  USED_NAME¬¬::=¶//¬used_op | used_name_id;¶##  USED_NAME¬====>¶##¬if¬used_op¶##¬call¬used_op¬USED_NAME¶##¬if
¬used_name_id¶##¬call¬used_name_id¬USED_NAME¶--|........................................................................
.........................¶//  used_op¬¬=> ;¶¶##  used_op¬====>¶##¬include¬null;¶--|.....................................
............................................................¶//  used_name_id¬¬=> ;¶¶##  used_name_id¬====>¶##  include¬
DECLARE¶##  include¬  DEFN   : TREE := D ( SM_DEFN, USED_NAME_ID );¬¬--| RAMENER LA DEFINITION ASSOCIEE AU NOM UTILISE¶#
#  include¬  SYMREP : TREE := D ( LX_SYMREP, USED_NAME_ID );¬¬--| RAMENER AUSSI SA REPRESENTATION¶##  include¬BEGIN¶¶## 
 include¬  IF DEFN.TY = DN_EXCEPTION_ID THEN¬¬¬--| ON A NOMME UNE EXCEPTION¶##  include¬    DECLARE¶##  include¬      LA
BEL : TREE := D ( CD_LABEL, DEFN );¬¬--| RAMENER LE CHAMP CD_LABEL DE L EXCEPTION¶##  include¬      LBL : LABEL_TYPE;¶##
  include¬    BEGIN¶##  include¬      IF LABEL.TY /= DN_NUM_VAL THEN¬¬¬--| AUCUN RAISE N A ETE VU PUR CETTE EXCEPTION RI
EN DANS LE CHAMP CD_LABEL¶##  include¬        LBL := NEXT_LABEL;¬¬¬--| DONC ALLOUER UNE ETIQUETTE¶##  include¬        DI
 ( CD_LABEL, DEFN, INTEGER ( LBL ) );¬¬--| METTRE CE NUMERO D ETIQUETTE DANS LE CD_LABEL POUR REPERER L EXCEPTION¶##  in
clude¬        EMIT ( EXL, LBL, S=> PRINT_NAME ( SYMREP ),¬¬--| DECLARER CETTE ASSOCIATION¶##  include¬¬COMMENT=> "NUM D 
EXCEPTION EXTERNE ATTRIBUE SUR USED_NAME_ID" );¶##  include¬      END IF;¶##  include¬      EMIT ( DPL, I, COMMENT=> "CO
DE D EXCEPTION EMPILE" );¬¬--| EMPILAGE DUPLICATA DU CODE ENTIER D EXCEPTION¶##  include¬      EMIT ( LDC, I, DI ( CD_LA
BEL, DEFN ), COMMENT=> "EXCEPTION " & PRINT_NAME ( SYMREP ));¶##  include¬      EMIT ( EQ, I );¬¬¬--| ¶##  include¬    E
ND;¶¶##  include¬  ELSIF DEFN.TY = DN_PACKAGE_ID THEN¶##  include¬    IF NOT DB ( CD_COMPILED, DEFN ) THEN¬¬--| REFERENC
E A UN PACKAGE NON COMPILE (SPEC)¶##  include¬      DECLARE¶##  include¬        PACKAGE_SPEC : TREE := D ( SM_SPEC, DEFN
 );¬¬--| UN HEADER (PACKAGE SPEC)¶##  include¬      BEGIN¶##  include¬        EMIT ( RFP, EMITS.CUR_COMP_UNIT, s=> PRINT
_NAME ( SYMREP ) );¬--| EMETTRE UNE REFERENCE A PACKAGE¶##  include¬        EMITS.GENERATE_CODE := FALSE;¬¬¬--| PAS DE C
ODE GENERE (SEULEMENT FAIRE LES OPERATIONS ETIQUETAGE PLACEMENT ETC. )¶##  include¬        DB ( CD_COMPILED, DEFN, TRUE 
);¬¬¬--| INDIQUER DES A PRESENT QUE L ON A COMPILE CE PACKAGE WITHE POUR NE FAIRE CELA QU UNE SEULE FOIS¶¶##  call¬decl_
s¬@ as_DECL_S1 package_Spec¬¬--| TRAITER LES DECLARATIONS DE CE PACKAGE¶¶##  include¬      END;¶##  include¬    END IF;¶
##  include¬    EMITS.CUR_COMP_UNIT := CUR_COMP_UNIT + 1;¬¬--| NUMERO D UNITE SUIVANT¶¶##  include¬  ELSIF DEFN.TY = DN_
PROCEDURE_ID THEN¬¬¬--| REFERENCE A UNE PROCEDURE DE LIBRAIRIE¶##  include¬    IF NOT DB ( CD_COMPILED, DEFN ) THEN¬¬--|
 SI PAS COMPILEE¶##  include¬      DECLARE¶##  include¬        PROC_LBL : LABEL_TYPE := NEXT_LABEL;¬¬--| ALLOCATION ETIQ
UETTE D ENTREE DE LA PROCEDURE REFERENCEE¶##  include¬      BEGIN¶##  include¬        EMITS.GENERATE_CODE := TRUE;¬¬¬--|
 IL FAUT GENERER LA REFERENCE¶##  include¬        EMIT ( RFP, INTEGER( 0 ), s=> PRINT_NAME ( SYMREP ) );¬--| REFERENCE A
 PROCEDURE DE LIBRAIRIE¶##  include¬        DI ( CD_LABEL, DEFN, INTEGER ( PROC_LBL ) );¬¬--| STOCKER L ETIQUETTE¶##  in
clude¬        DI ( CD_LEVEL, DEFN, 1 );¬¬¬--| STOCKER LE NIVEAU DE LA PROCEDURE REFERENCEE (1)¶##  include¬        DI ( 
CD_PARAM_SIZE, DEFN, 0 );¬¬¬--| INITIALISER LA TAILLE DU PARAMETRAGE A ZERO )¶##  include¬        DB ( CD_COMPILED, DEFN
, TRUE );¬¬¬--| INDIQUER QUE L'ON A DEJA TRAITE¶##  include¬        EMIT ( RFL, PROC_LBL );¬¬¬--| EMETTRE L ETIQUETTE¶##
  include¬      END;¶##  include¬    END IF;¶¶##  include¬  END IF;¶##  include¬END;¶--|................................
.................................................................¶//  USED_OBJECT¬¬::=¶//¬used_char | used_object_id;¶//
  USED_OBJECT¬¬=>¶//¬sm_exp_type¬: TYPE_SPEC,¶//¬sm_value¬: Value;¶¶##  USED_OBJECT¬====>¶##¬if¬used_char¶##¬call¬used_c
har¬USED_OBJECT¶##¬if¬used_object_id¶##¬call¬used_object_id¬USED_OBJECT¶--|.............................................
....................................................¶//  used_char¬=> ;¶¶##  used_char¬====>¶##¬include¬null;¶--|.......
..........................................................................................¶//  used_object_id¬=> ;¶¶##  
used_object_id¬====>¶##  include¬    NULL;¶¶¶¶--|-----------------------------------------------------------------------
--------------------------¶-- Syntax 4.1.B¶--  prefix ::= name | function_call¶--|--------------------------------------
-----------------------------------------------------------¶¶prefix¬::=¶¬name¶¬%%¶--|...................................
..............................................................¶--** name includes function_call¶¶//  NAME_VAL¬¬::=¶//¬fu
nction_call;¶¶¶¶--|-------------------------------------------------------------------------------------------------¶-- 
4.1.1  Indexed Components¶-- Syntax 4.1.1¶--  indexed_component ::= prefix(expression {, expression})¶--¶--|------------
-------------------------------------------------------------------------------------¶¶indexed_component__|__slice¬::=¶¬
apply¶¬%%¶--|.................................................................................................¶¶¶//  exp
_s¬¬=>¶//¬as_list¬: Seq Of EXP;¶--|.....................................................................................
............¶//  indexed¬¬=>¶//¬as_exp_s¬: exp_s;¶¶##  INDEXED¬====>¶##  include¬DECLARE¶##  include¬  PROCEDURE INDEX (
 EXP_SEQ :SEQ_TYPE ) IS¶##  include¬    EXP_S : SEQ_TYPE := EXP_SEQ;¶##  include¬    EXP   : TREE;¶##  include¬  BEGIN¶#
#  include¬    POP ( EXP_S, EXP );¶##  call¬    EXP¬EXP¶##  include¬    IF IS_EMPTY ( EXP_S ) THEN¬¬¬--| DERNIER INDICE¶
##  include¬      EMIT ( AR2, "ADRESSE POUR LE DERNIER INDICE (RAPIDE)" );¶##  include¬    ELSE¬¬¬¬--| INDICES INTERMEDI
AIRES¶##  include¬      EMIT ( AR1, "ADRESSE POUR INDICE INTERMEDIAIRE" );¶##  include¬      EMIT ( DEC, A, 3*INTG_SIZE,
 "PTR DESCRIPTEUR AU TRIPLET INDICE SUIVANT" );¶##  include¬      INDEX ( EXP_S );¶##  include¬      EMIT ( ADD, I, "AJO
UTER LE DECALAGE A L ADRESSE DES INDICES PRECEDENTS" );¶##  include¬    END IF;¶##  include¬  END INDEX;¶      ¶##  incl
ude¬BEGIN¶##  include¬  CODE_OBJECT ( D ( AS_NAME, INDEXED ) );¬¬¬--| EMPILER L ADRESSE D OBJET¶##  include¬  EMIT ( DPL
, A, "DUP ADRESS OBJET" );¬¬¬¬--| DUPLIQUER CETTE ADRESSE¶##  include¬  EMIT ( IND, A, 0, "CHARGE INDEXE D ADRESSE TABLE
AU" );¬¬¬--| CHARGEMENT DE L ADRESSE DE TABLEAU¶##  include¬  EMIT ( SWP, A, "ADRESSE OBJET AU TOP" );¶##  include¬  EMI
T ( IND, A, -addr_Size, "CHARGE INDEXE ADRESSE DU DESCRIPTEUR TABLEAU" );¶##  include¬  EMIT ( DEC, A, INTG_SIZE, "ADRES
SE DESCRIPTEUR - TAILLE ENTIER" );¶##  include¬  DECLARE¶##  include¬    EXP_SEQ : SEQ_TYPE := LIST ( D ( AS_EXP_S, INDE
XED ) );¶##  include¬  BEGIN¶##  include¬    IF NOT IS_EMPTY ( EXP_SEQ ) THEN¶##  include¬     INDEX ( EXP_SEQ );¶##  in
clude¬    END IF;¶##  include¬  END;¶##  include¬  EMIT ( IXA, INTEGER ( 1 ) );¶##  include¬END;¶¶¶¶--|-----------------
--------------------------------------------------------------------------------¶-- 4.1.2  Slices¶-- Syntax 4.1.2¶--  sl
ice ::= prefix(discrete_range)¶¶--** slice is parsed as an indexed_component__|__slice¶--|------------------------------
-------------------------------------------------------------------¶¶//  slice¬¬=>¶//¬as_discrete_range¬: DISCRETE_RANGE
;¶¶##  slice¬====>¶##¬include¬null;¶¶¶--|-------------------------------------------------------------------------------
------------------¶-- 4.1.3  Selected Components¶-- Syntax 4.1.3¶--  selected_component ::=  prefix.selector¶--¶--  sele
ctor ::= simple_name¶--     | character_literal | operator_symbol | all¶--|---------------------------------------------
----------------------------------------------------¶¶selected_component¬::=¶¬  prefix  .  selector¬¬¬====> $2 selected¶
¬| prefix  .  ALL¬¬¬¬====> $1 all¶¬%%¶--|...............................................................................
..................¶selector¬::=¶¬used_id | used_char | operator_symbol¶¬%%¶--|..........................................
.......................................................¶¶¶//  selected¬¬=>¶//¬as_designator¬: DESIGNATOR;¶--|...........
......................................................................................¶//  all¬¬=> ;¶¶##  all¬====>¶##¬i
nclude¬null;¶¶¶¶--|-------------------------------------------------------------------------------------------------¶-- 
4.1.4  Attributes¶-- Syntax 4.1.4¶--  attribute ::= prefix'attribute_designator¶--¶--  attribute_designator ::= simple_n
ame [(universal_static_expression)]¶--|---------------------------------------------------------------------------------
----------------¶¶attribute¬::=¶¬prefix  '  used_id¬¬¬¬====> void $3 attribute¶¬%%¶--|..................................
...............................................................¶¶--** attribute_call parsed as function call¶¶//  attrib
ute¬¬=>¶//¬as_used_name_id¬: used_name_id,¶//¬as_exp¬: EXP;¶¶¶¶--|------------------------------------------------------
-------------------------------------------¶-- 4.2¬Literals¶-- Refer to 4.4.C for numeric_literal, string_literal,¶-- an
d null_access.¶-- Refer to 4.1 for character_literal¶¶¶--|--------------------------------------------------------------
-----------------------------------¶-- 4.3¬Aggregates¶-- Syntax 4.3.A¶--  aggregate ::=¶--     (component_association {,
 component_association})¶¶--** Syntax added to not parse ( expression ) as aggregate¶--|--------------------------------
-----------------------------------------------------------------¶¶aggregate¬::=¶¬  ( named_association )¬¬¬====> list $
L general_assoc_s $1 aggregate¶¬| ( others_association )¬¬¬====> list $L general_assoc_s $1 aggregate¶¬| ( component_ass
ociation,{component_association,} component_association )¬====> append $L general_assoc_s $1 aggregate¶¬| ( component_as
sociation,{component_association,} others_association )¬====> append $L general_assoc_s $1 aggregate¶¬%%¶--|............
.....................................................................................¶¶¶//  aggregate¬¬=>¶//¬as_general_
assoc_s¬¬: general_assoc_s,¶//¬sm_normalized_comp_s¬: general_assoc_s;¶¶##  aggregate¬====>¶##¬include¬null;¶¶¶¶--|-----
--------------------------------------------------------------------------------------------¶-- Syntax 4.3.B¶--  compone
nt_association ::=¶--     [choice {| choice}¬=> ] expression¶--|--------------------------------------------------------
-----------------------------------------¶¶component_association¬::=¶¬expression | named_association¶¬%%¶--|............
.....................................................................................¶¶named_association¬::=¶¬choice_s  
=>  expression¬¬¬====> exch_1 $2 named¶¬%%¶--|..........................................................................
.......................¶others_association¬::=¶¬others_s  =>  expression¬¬¬====> exch_1 $2 named¶¬%%¶--|................
.................................................................................¶¶¶//  GENERAL_ASSOC¬¬::=¶//¬NAMED_ASSO
C | EXP;¶--|.................................................................................................¶//  NAMED_
ASSOC¬¬::=¶//¬named;¶//  NAMED_ASSOC¬¬=>¶//¬as_exp¬: EXP;¶--|...........................................................
......................................¶//  named¬¬=>¶//¬as_choice_s¬: choice_s;¶¶¶¶--|----------------------------------
---------------------------------------------------------------¶-- 4.4¬Expressions¶-- Syntax 4.4.A¶--  expression ::=¶--
¬ relation {and relation}  | relation {and then relation}¶--     | relation {or relation}   | relation {or else relation
}¶--     | relation {xor relation}¶--|----------------------------------------------------------------------------------
---------------¶¶expression¬::=¶¬relation | relation_and | relation_and_then | relation_or¶¬| relation_or_else | relatio
n_xor¶¬%%¶--|.................................................................................................¶relation_
and_then¬::=¶¬  relation  and_then  relation¬¬¬====> $3 short_circuit¶¬| relation_and_then  and_then  relation¬¬¬====> $
3 short_circuit¶¬%%¶--|.................................................................................................
¶and_then¬::=¶¬AND  THEN¬¬¬¬====> $0 and_then¶¬%%¶--|...................................................................
..............................¶relation_or_else¬::=¶¬  relation  or_else   relation¬¬¬====> $3 short_circuit¶¬| relation
_or_else   or_else   relation¬¬¬====> $3 short_circuit¶¬%%¶--|..........................................................
.......................................¶or_else¬::=¶¬OR  ELSE¬¬¬¬====> $0 or_else¶¬%%¶--|...............................
..................................................................¶relation_and¬::=¶¬  relation  AND  relation¬¬¬====> i
nfix "AND"¶¬| relation_and  AND  relation¬¬¬====> infix "AND"¶¬%%¶--|...................................................
..............................................¶relation_or¬::=¶¬  relation  OR  relation¬¬¬====> infix "OR"¶¬| relation_
or   OR  relation¬¬¬====> infix "OR"¶¬%%¶--|............................................................................
.....................¶relation_xor¬::=¶¬  relation  XOR  relation¬¬¬====> infix "XOR"¶¬| relation_xor  XOR  relation¬¬¬=
===> infix "XOR"¶¬%%¶--|................................................................................................
.¶¶¶//  EXP_VAL¬¬::=¶//¬short_circuit;¶--|..............................................................................
...................¶//  short_circuit¬¬=>¶//¬as_exp1¬: EXP,¶//¬as_short_circuit_op¬: SHORT_CIRCUIT_OP,¶//¬as_exp2¬: EXP;
¶¶##  short_circuit¬====>¶##¬include¬null;¶--|..........................................................................
.......................¶//  SHORT_CIRCUIT_OP¬::=¶//¬and_then | or_else;¶--|.............................................
....................................................¶//  and_then¬=> ;¶--|..............................................
...................................................¶//  or_else¬=> ;¶¶¶¶--|---------------------------------------------
----------------------------------------------------¶-- Syntax 4.4.B¶--  relation ::=¶--¬ simple_expression [relational_
operator simple_expression]¶--     | simple_expression [not] in range¶--     | simple_expression [not] in type_mark¶--|-
------------------------------------------------------------------------------------------------¶¶relation¬::=¶¬simple_e
xpression¶¬| simple_expression =  simple_expression¬¬====> infix "="¶¬| simple_expression /= simple_expression¬¬====> in
fix "/="¶¬| simple_expression <  simple_expression¬¬====> infix "<"¶¬| simple_expression <= simple_expression¬¬====> inf
ix "<="¶¬| simple_expression >  simple_expression¬¬====> infix ">"¶¬| simple_expression >= simple_expression¬¬====> infi
x ">="¶¬| simple_expression  membership_op¬range¬¬====> $3 range_membership¶¬%%¶--|.....................................
............................................................¶--** range includes type_mark and range_attribute¶¶membersh
ip_op¬::=¶¬  IN¬¬¬¬====> $0 in_op¶¬| NOT IN¬¬¬¬====> $0 not_in¶¬%%¶--|..................................................
...............................................¶¶//  EXP_VAL_EXP¬¬::=¶//¬MEMBERSHIP;¶--|................................
.................................................................¶//  MEMBERSHIP¬¬::=¶//¬range_membership | type_members
hip;¶//  MEMBERSHIP¬¬=>¶//¬as_membership_op¬: MEMBERSHIP_OP;¶¶##  MEMBERSHIP¬====>¶##¬if¬range_membership¶##¬call¬range_
membership¬MEMBERSHIP¶##¬if¬type_membership¶##¬call¬type_membership¬MEMBERSHIP¶--|......................................
...........................................................¶//  range_membership¬=>¶//¬as_range¬: RANGE;¶¶##  range_memb
ership¬====>¶##¬include¬null;¶¶//  type_membership¬¬=>¶//¬as_name¬: NAME;¶¶##  type_membership¬====>¶##¬include¬null;¶--
|.................................................................................................¶//  MEMBERSHIP_OP¬¬::
=¶//¬in_op | not_in;¶--|................................................................................................
.¶//  in_op¬=> ;¶--|.................................................................................................¶//
  not_in¬=> ;¶¶¶¶--|-------------------------------------------------------------------------------------------------¶--
 Syntax 4.4.C¶--  simple_expression ::=¶--     [unary_operator] term {binary_adding_operator term}¶--¶--  term ::= facto
r {multiplying_operator factor}¶--¶--  factor ::= primary [** primary] | abs primary | not primary¶--|------------------
-------------------------------------------------------------------------------¶¶simple_expression¬¬::=¶¬[unary_operator
]term¶     |  simple_expression  +  term              ====> infix "+"¶     |  simple_expression  -  term              ==
==> infix "-"¶     |  simple_expression  &  term              ====> infix "&"¶¬%%¶--|...................................
..............................................................¶term¬¬::=¶¬factor¶¬| term / factor¬¬====> infix "/"¶¬| te
rm * factor¬¬====> infix "*"¶¬| term MOD factor¬¬====> infix "MOD"¶¬| term REM factor¬¬====> infix "REM"¶¬%%¶--|........
.........................................................................................¶factor¬¬::=¶¬primary¶¬| primar
y  **  primary¬====> infix "**"¶¬| ABS primary¬¬====> unary "ABS"¶¬| NOT primary¬¬====> unary "NOT"¶¬%%¶--|.............
....................................................................................¶[unary_operator]term¬::=¶¬term¶¬|  
+  term¬¬====> unary "+"¶¬|  -  term¬¬====> unary "-"¶¬%%¶--|...........................................................
......................................¶¶¶¶--|---------------------------------------------------------------------------
----------------------¶-- Syntax 4.4.D¶--  primary ::=¶--¬ numeric_literal | null | aggregate | string_literal | name | 
allocator¶--     | function_call | type_conversion | qualified_expression | (expression)¶--|----------------------------
---------------------------------------------------------------------¶¶primary¬::=¶¬  numeric_literal¬¬¬¬====> $0 numeri
c_literal lx_numrep¶¬| NULL¬¬¬¬====> $0 null_access¶¬| aggregate  |  name  |  allocator¶¬| qualified_expression¶¬| (  ex
pression  )¬¬¬¬====> $1 parenthesized¶¬%%¶--|...........................................................................
......................¶--** string_literal, function_call and type_conversion are included in name¶¶¶//  EXP¬¬::=¶//¬NAM
E | EXP_EXP;¶¶##  EXP¬====>¶##¬if_class¬NAME¶##¬call¬NAME¬EXP¶##¬if_class¬EXP_EXP¶##¬call¬EXP_EXP¬EXP¶--|...............
..................................................................................¶//  EXP_EXP¬¬::=¶//¬EXP_VAL | AGG_EXP
 | qualified_allocator | subtype_allocator;¶//  EXP_EXP¬¬=>¶//¬sm_exp_type¬: TYPE_SPEC;¶¶##  EXP_EXP¬====>¶##¬if_class¬E
XP_VAL¶##¬call¬EXP_VAL¬EXP_EXP¶##¬if_class¬AGG_EXP¶##¬call¬AGG_EXP¬EXP_EXP¶##¬if¬qualified_allocator¶##¬call¬qualified_a
llocator¬EXP_EXP¶##¬if¬subtype_allocator¶##¬call¬subtype_allocator¬EXP_EXP¶--|..........................................
.......................................................¶//  EXP_VAL¬¬::=¶//¬numeric_literal | null_access | EXP_VAL_EXP;
¶//  EXP_VAL¬¬=>¶//¬sm_value¬: Value;¶¶##  EXP_VAL¬====>¶##¬if_class¬EXP_VAL_EXP¶##¬call¬EXP_VAL_EXP¬EXP_VAL¶##¬if¬numer
ic_literal¶##¬call¬numeric_literal¬EXP_VAL¶##¬if¬null_access¶##¬call¬null_access¬EXP_VAL¶##¬if¬short_circuit¶##¬call¬sho
rt_circuit¬EXP_VAL¶--|.................................................................................................¶
//  EXP_VAL_EXP¬¬::=¶//¬QUAL_CONV | parenthesized;¶//  EXP_VAL_EXP¬¬=>¶//¬as_exp¬: EXP;¶¶##  EXP_VAL_EXP¬====>¶##¬if_cla
ss¬QUAL_CONV¶##¬call¬QUAL_CONV¬EXP_VAL_EXP¶##¬if_class¬MEMBERSHIP¶##¬call¬MEMBERSHIP¬EXP_VAL_EXP¶##¬if¬parenthesized¶##¬
call¬parenthesized¬EXP_VAL_EXP¶--|......................................................................................
...........¶//  AGG_EXP¬¬::=¶//¬aggregate | string_literal;¶//  AGG_EXP¬¬=>¶//¬sm_discrete_range¬: DISCRETE_RANGE;¶¶##  
AGG_EXP¬====>¶##¬if¬aggregate¶##¬call¬aggregate¬AGG_EXP¶##¬if¬string_literal¶##¬call¬string_literal¬AGG_EXP¶--|.........
........................................................................................¶//  parenthesized¬¬=> ;¶¶##  pa
renthesized¬====>¶##¬include¬null;¶--|..................................................................................
...............¶//  numeric_literal¬¬=>¶//¬lx_numrep¬: Number_Rep;¶¶##  numeric_literal¬====>¶##¬include¬null;¶--|......
...........................................................................................¶//  string_literal¬¬=>¶//¬lx
_symrep¬: symbol_rep;¶¶##  string_literal¬====>¶##¬include¬null;¶--|....................................................
.............................................¶//  null_access¬¬=> ;¶¶##  null_access¬====>¶##¬include¬null;¶¶¶¶--|------
-------------------------------------------------------------------------------------------¶-- 4.5¬Operators and Express
ion Evaluation¶-- Syntax 4.5¶--  logical_operator ::= and | or | xor¶--¶--  relational_operator ::=  = | /= | < | <= | >
 | >=¶--¶--  adding_operator ::= + | - | &¶--¶--  unary_operator ::= + | -¶--¶--  multiplying_operator ::= * | / | mod |
 rem¶--¶--  highest_precedence_operator ::= ** | abs | not¶--|----------------------------------------------------------
---------------------------------------¶¶¶--|---------------------------------------------------------------------------
----------------------¶-- 4.6¬Type Conversions¶-- Syntax 4.6¶--  type_conversion ::= type_mark(expression)¶--|----------
---------------------------------------------------------------------------------------¶¶--** parsed as name¶//  QUAL_CO
NV¬¬::=¶//¬conversion | qualified;¶//  QUAL_CONV¬¬=>¶//¬as_name¬: NAME;¶¶##  QUAL_CONV¬====>¶##¬if¬conversion¶##¬call¬co
nversion¬QUAL_CONV¶##¬if¬qualified¶##¬call¬qualified¬QUAL_CONV¶--|......................................................
...........................................¶//  conversion¬=> ;¶¶##  conversion¬====>¶##¬include¬null;¶¶¶¶--|-----------
--------------------------------------------------------------------------------------¶-- 4.7¬Qualified Expressions¶-- S
yntax 4.7¶--  qualified_expression ::=¶--     type_mark'(expression) | type_mark'aggregate¶--|--------------------------
-----------------------------------------------------------------------¶¶qualified_expression¬::=¶¬  prefix  '  (  expre
ssion  )¬¬¬====> exch_1 $2 qualified¶¬| prefix  '  aggregate¬¬¬====> exch_1 $2 qualified¶¬%%¶--|........................
.........................................................................¶¶--** The 'prefix' must be a 'type_mark'¶¶//  
qualified¬=> ;¶¶##  qualified¬====>¶##¬include¬null;¶¶¶¶--|-------------------------------------------------------------
------------------------------------¶-- 4.8¬Allocators¶-- Syntax 4.8¶--  allocator ::=¶--     new subtype_indication | n
ew qualified_expression¶--|---------------------------------------------------------------------------------------------
----¶¶allocator¬::=¶¬  NEW  allocator_subtype_indication¬¬¬====> $1 subtype_allocator¶¬| NEW  allocator_qualified_expres
sion¬¬¬====> $1 qualified_allocator¶¬%%¶--|.............................................................................
....................¶¶--** The only allowed forms of constraint in the subtype indication of¶--** an allocator are index
 and discriminant constraints [RM 4.8/4]¶¶allocator_subtype_indication ::=¶¬  type_mark¶¬| type_mark  index_constraint__
|__discriminant_constraint¬¬====> exch_1 $2 subtype_indication¶¬%%¶--|..................................................
...............................................¶--** Elsewhere, a qualified_expression begins with prefix to avoid¶--** 
LALR conflict.  Here, type mark can (must) be used.¶¶allocator_qualified_expression¬::=¶¬  type_mark  ' ( expression )¬¬
¬====> exch_1 $2 qualified¶¬| type_mark  ' aggregate¬¬¬====> exch_1 $2 qualified¶¬%%¶--|................................
.................................................................¶¶¶//  qualified_allocator¬=>¶//¬as_qualified¬: qualifi
ed;¶¶##  qualified_allocator¬====>¶##¬include¬null;¶¶--|................................................................
.................................¶//  subtype_allocator¬=>¶//¬as_subtype_indication¬: subtype_indication,¶//¬sm_desig_ty
pe¬¬: TYPE_SPEC;¶¶##  subtype_allocator¬====>¶##¬include¬null;¶¶¶¶--||||||||||||||||||||||||||||||||||||||||||||||||||||
||||||||||||||||||||||||||||||||||||||||||||||¶-- 5.  Statements¶--|||||||||||||||||||||||||||||||||||||||||||||||||||||
|||||||||||||||||||||||||||||||||||||||||||||¶-- 5.1¬Simple and Compound Statements - Sequences of Statements¶-- Syntax 
5.1.A¶--  sequence_of_statements ::= statement {statement}¶--|----------------------------------------------------------
---------------------------------------¶¶sequence_of_statements¬::=¶      {stm_pragma} stm_s_tail¬¬¬====> cat $L stm_s¶¬
%%¶--|.................................................................................................¶stm_s_tail¬¬::=¶
¬statement  {stm_pragma}¬¬====> insert¶¬| stm_s_tail  statement  {stm_pragma}¬¬====> insert cat¶¬%%¶--|.................
................................................................................¶stm_pragma¬::=¶¬pragma¬¬¬====> $1 stm_p
ragma¶¬%%¶--|.................................................................................................¶¶¶//  STM
_ELEM¬::=¶//¬STM | stm_pragma;¶//  stm_s¬¬=>¶//¬as_list¬: Seq Of STM_ELEM;¶¶##  stm_s¬====>¶##¬repeat_extract¬stm_s¬stm_
elem¶##¬call¬STM_ELEM¬stm_elem¶¶##  STM_ELEM¬====>¶##¬if_class¬STM¶##¬call¬STM¬STM_ELEM¶##¬if¬stm_pragma¶##¬call¬stm_pra
gma¬STM_ELEM¶¶//  stm_pragma¬¬=>¶//¬as_pragma¬: pragma;¶¶##  stm_pragma¬====>¶##¬include¬null;¶¶¶¶--|-------------------
------------------------------------------------------------------------------¶-- Syntax 5.1.B¶--  statement ::=¶--     
{label} simple_statement | {label} compound_statement¶--|---------------------------------------------------------------
----------------------------------¶¶statement¬¬::=¶¬simple_statement¶¬| compound_statement¶¬| label_s  [pragma_s]  simpl
e_statement¬¬====> $3 labeled¶¬| label_s  [pragma_s]  compound_statement¬====> $3 labeled¶¬%%¶--|.......................
..........................................................................¶¶¶//  STM¬¬::=¶//¬labeled;¶¶##  STM¬====>¶##¬
if¬labeled¶##¬call¬labeled¬STM¶##¬if¬null_stm¶##¬call¬null_stm¬STM¶##¬if¬accept¶##¬call¬accept¬STM¶##¬if¬terminate¶##¬ca
ll¬terminate¬STM¶##¬if¬abort¶##¬call¬abort¬STM¶##¬if_class¬CLAUSES_STM¶##¬call¬CLAUSES_STM¬STM¶##¬if_class¬BLOCK_LOOP¶##
¬call¬BLOCK_LOOP¬STM¶##¬if_class¬ENTRY_STM¶##¬call¬ENTRY_STM¬STM¶##¬if_class¬STM_WITH_NAME¶##¬call¬STM_WITH_NAME¬STM¶##¬
if_class¬STM_WITH_EXP¶##¬call¬STM_WITH_EXP¬STM¶--|......................................................................
...........................¶//  labeled¬¬=>¶//¬as_source_name_s¬: source_name_s,¶//¬as_pragma_s¬: pragma_s,¶//¬as_stm¬: 
STM;¶¶##  labeled¬====>¶##¬include¬null;¶¶¶¶--|-------------------------------------------------------------------------
------------------------¶-- Syntax 5.1.C¶--  simple_statement ::= null_statement¶--     | assignment_statement | procedu
re_call_statement¶--     | exit_statement       | return_statement¶--     | goto_statement       | entry_call_statement¶
--     | delay_statement      | abort_statement¶--     | raise_statement      | code_statement¶--|----------------------
---------------------------------------------------------------------------¶¶simple_statement¬¬::=¶¬  null_statement¶¬| 
assignment_statement¬ |  goto_statement¶¬| exit_statement¬¬ |  return_statement¶¬| delay_statement¬¬ |  abort_statement¶
¬| raise_statement¬¬ |  code_statement¶¬| procedure_call_statement__|__entry_call_statement¶¬%%¶--|.....................
............................................................................¶¶procedure_call_statement__|__entry_call_st
atement¬::=¶¬procedure_call_statement¶¬%%¶--|...........................................................................
......................¶--** Semantics required to determine that call is to an entry¶¶¶//  STM¬¬::=¶//¬null_stm | abort 
| STM_WITH_EXP | STM_WITH_NAME;¶--|.....................................................................................
............¶//  STM_WITH_EXP¬¬::=¶//¬return | delay | STM_WITH_EXP_NAME;¶//  STM_WITH_EXP¬¬=>¶//¬as_exp¬: EXP;¶¶##  STM
_WITH_EXP¬====>¶##¬if¬return¶##¬call¬return¬STM_WITH_EXP¶##¬if¬delay¶##¬call¬delay¬STM_WITH_EXP¶##¬if¬case¶##¬call¬case¬
STM_WITH_EXP¶##¬if_class¬STM_WITH_EXP_NAME¶##¬call¬STM_WITH_EXP_NAME¬STM_WITH_EXP¶--|...................................
..............................................................¶//  STM_WITH_EXP_NAME¬::=¶//¬assign | exit | code;¶//  ST
M_WITH_EXP_NAME¬=>¶//¬as_name¬: NAME;¶¶##  STM_WITH_EXP_NAME¬====>¶##¬if¬code¶##¬call¬code¬STM_WITH_EXP_NAME¶##¬if¬assig
n¶##¬call¬assign¬STM_WITH_EXP_NAME¶##¬if¬exit¶##¬call¬exit¬STM_WITH_EXP_NAME¶--|........................................
.........................................................¶//  STM_WITH_NAME¬¬::=¶//¬goto | raise;¶--|...................
..............................................................................¶//  STM_WITH_NAME¬¬::=¶//¬CALL_STM;¶//  S
TM_WITH_NAME¬¬=>¶//¬as_name¬: NAME;¶¶##  STM_WITH_NAME¬====>¶##¬if¬goto¶##¬call¬goto¬STM_WITH_NAME¶##¬if¬raise¶##¬call¬r
aise¬STM_WITH_NAME¶##¬if_class¬CALL_STM¶##¬call¬CALL_STM¬STM_WITH_NAME¶--|..............................................
...................................................¶//  CALL_STM¬¬::=¶//¬entry_call | procedure_call;¶¶##  CALL_STM¬====
>¶##¬if¬procedure_call¶##¬call¬procedure_call¬CALL_STM¶##¬if¬entry_call¶##¬call¬entry_call¬CALL_STM¶--|.................
................................................................................¶¶¶¶--|---------------------------------
----------------------------------------------------------------¶-- Syntax 5.1.D¶--  compound_statement ::=¶--¬ if_state
ment¬ | case_statement¶--     | loop_statement       | block_statement¶--     | accept_statement     | select_statement¶
--|-------------------------------------------------------------------------------------------------¶¶compound_statement
¬::=¶¬  if_statement¬| case_statement¶¬| loop_statement¬| block_statement¶¬| accept_statement¬| select_statement¶¬%%¶--|
.................................................................................................¶¶//  STM¬¬::=¶//¬accep
t | BLOCK_LOOP | ENTRY_STM | CLAUSES_STM;¶--|...........................................................................
......................¶//  STM_WITH_EXP¬¬::=¶//¬case;¶--|...............................................................
..................................¶//  CLAUSES_STM¬¬::=¶//¬if | selective_wait;¶//  CLAUSES_STM¬¬=>¶//¬as_test_clause_el
em_s¬: test_clause_elem_s,¶//¬as_stm_s¬¬: stm_s;¶¶##  CLAUSES_STM¬====>¶##¬if¬if¶##¬call¬if¬CLAUSES_STM¶##¬if¬selective_
wait¶##¬call¬selective_wait¬CLAUSES_STM¶¶¶¶--|--------------------------------------------------------------------------
-----------------------¶-- Syntax 5.1.E¶--  label ::= <<label_simple_name>>¶--|-----------------------------------------
--------------------------------------------------------¶¶label_id¬¬::=¶¬identifier ¬¬¬¬====> $0 label_id lx_symrep¶¬%%¶
--|.................................................................................................¶label¬¬::=¶¬<<  lab
el_id  >>¶¬%%¶--|.................................................................................................¶label
_s¬¬::=¶¬label{label}¬¬¬¬====> $L source_name_s¶¬%%¶--|.................................................................
................................¶¶¶//  LABEL_NAME¬¬::=¶//¬label_id;¶//  LABEL_NAME¬¬=>¶//¬sm_stm¬: STM;¶¶##  LABEL_NAME¬
====>¶##¬if¬label_id¶##¬call¬label_id¬LABEL_NAME¶##¬if¬block_loop_id¶##¬call¬block_loop_id¬LABEL_NAME¶--|...............
..................................................................................¶//  label_id¬¬=>¶//¬cd_label¬: Intege
r;¶¶##  label_id¬====>¶##¬include¬null;¶¶¶¶--|--------------------------------------------------------------------------
-----------------------¶-- Syntax 5.1.F¶--  null_statement ::= null ;¶--|-----------------------------------------------
--------------------------------------------------¶¶null_statement¬¬::=¶¬NULL ;¬¬¬¬====> $0 null_stm¶¬%%¶--|............
.....................................................................................¶¶¶//  null_stm¬¬=> ;¶¶##  null_stm
¬====>¶##¬include¬null;¶¶¶¶--|------------------------------------------------------------------------------------------
-------¶-- 5.2¬Assignment Statement¶-- Syntax 5.2¶--  assignment_statement ::=¶--     variable_name := expression;¶--|--
-----------------------------------------------------------------------------------------------¶¶assignment_statement ::
=¶¬name  :=   expression  ;¬¬¬====> exch_1 $2 assign¶¬%%¶--|............................................................
.....................................¶##  OBJECT¬====>¬¬¬¬--| N EST PAS UN ELEMENT SYNTAXIQUE SE RATTACHE A USED_OBJECT_
ID CONTEXTUALISE¶##  include¬  CASE OBJECT.TY IS¶##  include¬   WHEN DN_VARIABLE_ID =>¬¬¬--| De classe OBJECT_NAME ; INI
T_OBJECT_NAME ; VC_NAME¶##  include¬      GEN_LOAD_ADDR ( DI (CD_COMP_UNIT, OBJECT ), DI ( CD_LEVEL, OBJECT ), DI ( CD_O
FFSET, OBJECT ),¶##  include¬                  "EMPILE ADRESSE DE VARIABLE" );¶         ¶##  include¬   WHEN DN_IN_ID =>
¬¬¬¬--| De classe OBJECT_NAME ; INIT_OBJECT_NAME ; PARAM_NAME¶##  include¬     EMIT ( LDA, LEVEL - DI ( CD_LEVEL, OBJECT
 ), DI ( CD_OFFSET, OBJECT ),¶##  include¬                  "EMPILE ADRESSE DE PARAM IN" );¶         ¶##  include¬   WHE
N DN_IN_OUT_ID | DN_OUT_ID =>¬¬¬--| De classe OBJECT_NAME ; INIT_OBJECT_NAME ; PARAM_NAME ; PARAM_IO_O¶##  include¬     
EMIT ( LDA, LEVEL - DI ( CD_LEVEL, OBJECT ), DI ( CD_VAL_OFFSET, OBJECT ),¶##  include¬                  "EMPILE ADRESSE
 PARAM IN_OUT/OUT" );¶         ¶##  include¬   WHEN DN_INDEXED =>¬¬¬--| De classe EXP ; NAME ; NAME_EXP¶##  include¬    
 CODE_INDEXED ( OBJECT );¶         ¶##  include¬   WHEN DN_USED_OBJECT_ID =>¬¬¬--| De classe EXP ; NAME ; DESIGNATOR ; U
SED_OBJECT¶##  include¬     CODE_OBJECT ( D ( SM_DEFN, OBJECT ) );¬¬--| CHARGER L ADRESSE CONTENUE DANS LA DEFINITION¶  
       ¶##  include¬   WHEN OTHERS =>¶##  include¬     PUT_LINE ( "!!! LOAD_OBJECT_ADDRESS : OBJECT.TY ILLICITE " & NODE
_NAME'IMAGE ( OBJECT.TY ) );¶##  include¬     RAISE PROGRAM_ERROR;¶##  include¬  END CASE;¶--|..........................
.......................................................................¶##  ADRESSE¬====>¬¬¬¬--| N EST PAS UN ELEMENT SY
NTAXIQUE SE RATTACHE AUX ACCESS¶##  include¬CASE ADRESSE.TY is¶##  include¬WHEN DN_VARIABLE_ID =>¬¬¬--| UNE VARIABLE ACC
ESS DE CLASSE OBJECT_NAME ; INIT_OBJECT_NAME ; VC_NAME¶##  include¬  GEN_LOAD ( A, DI (CD_COMP_UNIT, ADRESSE ), DI ( CD_
LEVEL, ADRESSE ), DI ( CD_OFFSET, ADRESSE ) );¶         ¶##  include¬WHEN DN_IN_ID =>¬¬¬¬--| UN PARAMETRE ACCESS IN DE C
LASSE OBJECT_NAME ; INIT_OBJECT_NAME ; PARAM_NAME¶##  include¬  GEN_LOAD ( A, 0,  DI ( CD_LEVEL, ADRESSE ), DI ( CD_OFFS
ET, ADRESSE ) );¶         ¶##  include¬WHEN DN_IN_OUT_ID | DN_OUT_ID =>¬¬¬--| UNPARAMETRE DE CLASSE OBJECT_NAME ; INIT_O
BJECT_NAME ; PARAM_NAME ; PARAM_IO_O¶##  include¬  GEN_LOAD ( A, 0, DI ( CD_LEVEL, ADRESSE ), DI ( CD_VAL_OFFSET, ADRESS
E ) );¶         ¶##  include¬WHEN DN_INDEXED =>¬¬¬¬--| De classe EXP ; NAME ; NAME_EXP¶##  include¬  CODE_INDEXED ( ADRE
SSE );¶         ¶##  include¬WHEN DN_USED_OBJECT_ID =>¬¬¬--| De classe EXP ; NAME ; DESIGNATOR ; USED_OBJECT¶##  include
¬  CODE_ADRESSE ( D ( SM_DEFN, ADRESSE ) );¶##  include¬WHEN OTHERS =>¶##  include¬PUT_LINE ( "!!! CODE_ADRESSE : OBJECT
.TY ILLICITE " & NODE_NAME'IMAGE ( ADRESSE.TY ) );¶##  include¬  RAISE PROGRAM_ERROR;¶##  include¬END CASE;¶¶--|........
.........................................................................................¶//  assign¬¬=> ;¶¶##  assign¬=
===>¶##  include¬DECLARE¶##  include¬  NAME : TREE := D ( AS_NAME, ASSIGN );¬¬¬--| RAMENER LE NOM AFFECTE¶¶##  include¬ 
 PROCEDURE STORE_VAL ( TYPE_SPEC :TREE ) IS¶##  include¬  BEGIN¶##  include¬    CASE TYPE_SPEC.TY IS¶##  include¬    WHE
N DN_ACCESS =>¬¬¬--| STOCKAGE D UNE VALEUR POINTEUR¶##  include¬      EMIT ( STO, A );¬¬¬--| STOCKER L ADRESSE A L ADRES
SE DONNEE¶                  ¶##  include¬    WHEN DN_ENUMERATION =>¬¬¬--| STOCKAGE D UNE VALEUR ENUMEREE¶##  include¬   
   DECLARE¶##  include¬        TYPE_SOURCE_NAME : TREE            := D ( XD_SOURCE_NAME, TYPE_SPEC );¶##  include¬      
  TYPE_SYMREP      : TREE            := D ( LX_SYMREP, TYPE_SOURCE_NAME );¶##  include¬        NAME             : CONSTA
NT STRING := PRINT_NAME ( TYPE_SYMREP );¶##  include¬      BEGIN¶##  include¬        IF NAME = "BOOLEAN" THEN EMIT ( STO
, B );¬¬--| STOCKER LE BOOLEAN A L ADRESSE DONNEE¶##  include¬        ELSIF NAME = "CHARACTER" THEN EMIT ( STO, C );¬¬--
| STOCKER LE CARACTERE¶##  include¬        ELSE EMIT ( STO, I );¬¬¬--| STOCKER L ENTIER¶##  include¬        END IF;¶##  
include¬      END;¶                  ¶##  include¬    WHEN DN_INTEGER =>¬¬¬--| STOCKAGE D UNE VALEUR ENTIERE¶##  include
¬      EMIT ( STO, I );¶               ¶##  include¬    WHEN DN_UNIVERSAL_INTEGER =>¶##  include¬      DECLARE¶##  inclu
de¬        COMP_UNIT : COMP_UNIT_NBR := DI ( CD_COMP_UNIT, TYPE_SPEC );¶##  include¬        LVL       : LEVEL_TYPE    :=
 DI ( CD_LEVEL, TYPE_SPEC );¶##  include¬        OFS       : INTEGER       := DI ( CD_OFFSET, TYPE_SPEC );¶##  include¬ 
     BEGIN¶##  include¬        GEN_LOAD_ADDR ( COMP_UNIT, LVL, OFS );¶##  include¬        EMIT ( CVB );¶##  include¬    
    EMIT ( STO, I );¶##  include¬      END;¶               ¶##  include¬    WHEN OTHERS =>¶##  include¬      PUT_LINE ( 
"!!! STORE_VAL TYPE_SPEC.TY ILLICITE " & NODE_NAME'IMAGE ( TYPE_SPEC.TY ) );¶##  include¬      RAISE PROGRAM_ERROR;¶##  
include¬    END CASE;¶##  include¬  END STORE_VAL;¶¶##  include¬BEGIN¶##  include¬  --|---------------------------------
------------------------------------------¶##  include¬  IF NAME.TY = DN_ALL THEN¬¬¬--| C EST UNE INDIRECTION QQC.ALL¶##
  include¬    CODE_ADRESSE ( D ( AS_NAME, NAME ) );¬¬--| ADRESSE DE QQC¶##  call¬EXP¬@ AS_EXP¬ASSIGN¬¬--| TRAITER L EXPR
ESSION A AFFECTER¶##  include¬    STORE_VAL ( D ( SM_EXP_TYPE, NAME ) );¬¬--| STOCKER LA VALEUR D EXPRESSION¶¶##  includ
e¬  --|---------------------------------------------------------------------------¶##  include¬  ELSIF NAME.TY = DN_INDE
XED THEN¬¬¬--| DESTINATION CASE DE TABLEAU¶##  include¬    CODE_INDEXED ( NAME );¬¬¬--| ELABORER L ADRESSE DESTINATION P
AR CALCUL D INDEX¶##  call¬EXP¬@ AS_EXP¬ASSIGN¬¬--| TRAITER L EXPRESSION A AFFECTER¶##  include¬    STORE_VAL ( D ( SM_E
XP_TYPE, NAME ) );¬¬--| STOCKER LA VALEUR D EXPRESSION¶¶##  include¬  --|-----------------------------------------------
----------------------------¶##  include¬  ELSIF NAME.TY = DN_USED_OBJECT_ID THEN¬¬--| DESTINATION IDENTIFICATEUR D OBJE
T DEST :=¶##  include¬    DECLARE¶##  include¬      NAMEXP    : TREE := D ( SM_EXP_TYPE, NAME );¬¬--| GENRE D OBJET DEST
INATION¶##  include¬      DEFN      : TREE := D ( SM_DEFN, NAME );¬¬--| DEFINITION DE L OBJET A AFFECTER¶##  include¬   
   COMP_UNIT : COMP_UNIT_NBR;¬¬¬--| NUMERO D UNITE POUR LE STOCKAGE¶##  include¬      LVL       : LEVEL_TYPE;¬¬¬--| NIVE
AU DE STOCKAGE¶##  include¬      OFS       : OFFSET_TYPE;¬¬¬--| DECALAGE DE STOCKAGE¶##  include¬    BEGIN¶##  include¬ 
     --|-----------------------------------------------------------------------¶##  include¬      IF NAMEXP.TY = DN_ACCE
SS THEN¬¬¬--| L OBJET DESTINATION EST UN ACCES¶##  call¬EXP¬@ AS_EXP¬ASSIGN¬¬--| TRAITER L EXPRESSION A AFFECTER¶##  inc
lude¬        EMITS.GET_CLO ( DEFN, COMP_UNIT, LVL, OFS );¬¬--| LIEU DE LA DEFINITION DESTINATION¶##  include¬        EMI
TS.GEN_STORE ( A, COMP_UNIT, LVL, OFS );¬¬--| STOCKAGE DANS LA DESTINATION¶##  include¬      --|------------------------
-----------------------------------------------¶##  include¬      ELSIF NAMEXP.TY = DN_ARRAY THEN¬¬¬--| L OBJET DESTINAT
ION EST UN TABLEAU¶##  include¬        CODE_OBJECT ( DEFN );¬¬¬--| ADRESSE DESTINATION¶##  include¬        DECLARE¶##  i
nclude¬          EXP : TREE := D ( AS_EXP, ASSIGN );¬¬--| EXPRESSION A DROITE DE L AFFECTATION¶##  include¬        BEGIN
¶##  include¬          IF EXP.TY = DN_USED_OBJECT_ID THEN¬¬--| IDENTIFICATEUR D OBJET DU GENRE := SRC¶##  include¬      
      CODE_OBJECT ( D ( SM_DEFN, EXP ) );¬¬--| CHARGER L ADRESSE CONTENUE DANS LA DEFINITION¶##  include¬            COD
E_OBJECT( EXP );¬¬¬--| ADRESSE SOURCE¶##  include¬            EMIT ( LDC, I, NUMBER_OF_DIMENSIONS ( NAMEXP ), COMMENT=>"
NB DIM" );¶##  include¬            EMIT ( CYA );¬¬¬--| PROCEDURE STANDARD COPY ARRAY¶##  include¬          ELSE¶##  call
¬EXP¬@ AS_EXP¬ASSIGN¬¬--| TRAITER L EXPRESSION A AFFECTER¶##  include¬            EMIT ( LDC, I, NUMBER_OF_DIMENSIONS ( 
NAMEXP ), COMMENT=>"NB DIM" );¶##  include¬            EMIT ( PUA );¬¬¬--| PROCEDURE STANDARD PUSH ARRAY¶##  include¬   
       END IF;¶##  include¬        END;¶##  include¬      --|-----------------------------------------------------------
------------¶##  include¬      ELSIF NAMEXP.TY = DN_ENUMERATION THEN¬¬--| L OBJET DESTINATION A UN TYPE ENUMERE¶##  call
¬EXP¬@ AS_EXP¬ASSIGN¬¬--| TRAITER L EXPRESSION A AFFECTER¶##  include¬        EMITS.GET_CLO ( DEFN, COMP_UNIT, LVL, OFS 
);¬¬--| LIEU DE LA DEFINITION DESTINATION¶##  include¬        DECLARE¶##  include¬          CT : CODE_TYPE := CODE_TYPE_
OF ( NAMEXP );¬¬--| CODE BOOL OU CHAR OU INT¶##  include¬        BEGIN¶##  include¬          GEN_STORE ( CT, COMP_UNIT, 
LVL, OFS );¬¬--| EMETTRE STORE EN FONCTION DU CODE TYPE¶##  include¬        END;¶##  include¬      --|------------------
-----------------------------------------------------¶##  include¬      ELSIF NAMEXP.TY = DN_INTEGER THEN¬¬¬--| L OBJET 
DESTINATION A UN TYPE ENTIER¶##  call¬EXP¬@ AS_EXP¬ASSIGN¬¬--| TRAITER L EXPRESSION A AFFECTER¶##  include¬        IF NA
MEXP.TY /= DN_UNIVERSAL_INTEGER THEN¬¬--| UN ENTIER NON STANDARD¶##  include¬          EMITS.GET_CLO ( NAMEXP, COMP_UNIT
, LVL, OFS );¬¬--| LIEU DE LA SOURCE¶##  include¬          GEN_LOAD_ADDR ( COMP_UNIT, LVL, OFS );¬¬--| ADRESSE DE LA SOU
RCE¶##  include¬          EMIT ( CVB );¬¬¬--| EMPILEMENT DU CONVERTI¶##  include¬        END IF;¶##  include¬        EMI
TS.GET_CLO ( DEFN, COMP_UNIT, LVL, OFS );¬¬--| LIEU DE LA DEFINITION DESTINATION¶##  include¬        EMITS.GEN_STORE ( I
, COMP_UNIT, LVL, OFS );¬¬--| STOCKAGE DU CONVERTI DANS LA DESTINATION¶¶##  include¬      END IF;¶##  include¬    END;¶#
#  include¬  END IF;¶##  include¬END;¶¶¶¶--|----------------------------------------------------------------------------
---------------------¶-- 5.3¬If Statements¶-- Syntax 5.3.A¶--  if_statement ::=¶--¬if condition then¶--¬    sequence_of_
statements¶--     {elsif condition then¶--¬    sequence_of_statements}¶--     [else¶--¬    sequence_of_statements]¶--¬en
d if;¶--|-------------------------------------------------------------------------------------------------¶¶if_statement
¬::=¶¬  if_clause_s  END IF ;¬¬¬¬====> nil $L stm_s $2 if¶¬| if_clause_s  else_clause  END IF  ; ¬¬¬====> $2 if¶¬%%¶--|.
................................................................................................¶if_clause¬::=¶¬IF  cond
ition  THEN  sequence_of_statements¬¬====> $2 cond_clause¶¬%%¶--|.......................................................
..........................................¶elsif_clause¬::=¶¬ELSIF  condition  THEN  sequence_of_statements¬¬====> $2 co
nd_clause¶¬%%¶--|.................................................................................................¶if_cl
ause_s¬::=¶¬if_clause{elsif_clause} ¬¬¬====> $L test_clause_elem_s¶¬%%¶--|..............................................
...................................................¶else_clause¬::=¶¬ELSE  sequence_of_statements¶¬%%¶--|...............
..................................................................................¶condition¬::=¶¬expression¶¬%%¶--|....
.............................................................................................¶¶¶//  if¬¬=> ;¶--¬as_test_
clause_elem_s¬:test_clause_elem_s¶--¬as_stm_s¬:stm_s¶--¬lx_srcpos¬:Source_Position¶¶##  if¬====>¶##  include¬DECLARE¶## 
 include¬  OLD_AFTER_IF_LBL : LABEL_TYPE := EMITS.AFTER_IF_LBL;¬¬--| GARER EN CAS D IMBRICATION DE IF¶##  include¬BEGIN¶
##  include¬  EMITS.AFTER_IF_LBL := NEXT_LABEL;¬¬¬--| ALLOUER UNE ETIQUETTE POST FIN DU IF¶##  call¬test_clause_elem_s¬@
 as_test_clause_elem_s¬if¬--| TRAITER LA SEQUENCE DES IF ELSIF ELSE¶##  include¬  WRITE_LABEL ( EMITS.AFTER_IF_LBL, COMM
ENT=> "ETIQUETTE END IF" );¬--| ECRIRE L ETIQUETTE POST FIN DU IF¶##  include¬  EMITS.AFTER_IF_LBL := OLD_AFTER_IF_LBL;¬
¬--| RESTAURER L EVENTUELLE ETIQUETTE D UN IF ENGLOBANT¶##  include¬END;¶--|............................................
.....................................................¶//  TEST_CLAUSE¬¬::=¶//¬cond_clause;¶//  TEST_CLAUSE¬¬=>¶//¬as_exp
¬: EXP,¶//¬as_stm_s¬: stm_s;¶¶##  TEST_CLAUSE¬====>¶##¬if¬cond_clause¶##¬call¬cond_clause¬TEST_CLAUSE¶##¬if¬select_alter
native¶##¬call¬select_alternative¬TEST_CLAUSE¶¶--|......................................................................
...........................¶//  cond_clause¬¬=> ;¶--¬as_exp¬:EXP¶--¬as_stm_s¬:stm_s¶--¬lx_srcpos¬:Source_Position¶¶##  c
ond_clause¬====>¶--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%¶##
  include¬DECLARE¶##  include¬  EXP : TREE := D ( AS_EXP, COND_CLAUSE );¶##  include¬  NEXT_CLAUSE_LBL : LABEL_TYPE;¶## 
 include¬BEGIN¶##  call¬exp¬exp¬¬¬--| EXPRESSION CONDITION¶##  include¬  NEXT_CLAUSE_LBL := NEXT_LABEL;¬¬¬--| ALLOUER UN
E ETIQUETTE POUR LA CONDITION SUIVANTE¶##  include¬  EMIT ( JMPF, NEXT_CLAUSE_LBL, COMMENT=> "NON CONDITION SAUT CLAUSE 
SUIVANTE" );¶##  call¬stm_s¬@ as_STM_S¬cond_clause¬¬--| INSTRUCTIONS DE L ALTERNATIVE¶##  include¬  EMIT ( JMP, EMITS.AF
TER_IF_LBL, COMMENT=> "SAUT END IF" );¬--| SAUT POST IF¶##  include¬  WRITE_LABEL ( NEXT_CLAUSE_LBL, COMMENT=> "LBL COND
ITION SUIVANTE" );¶##  include¬END;¶¶¶¶--|------------------------------------------------------------------------------
-------------------¶-- Syntax 5.3.B¶--  condition ::= expression¶--|----------------------------------------------------
---------------------------------------------¶-- 5.4¬Case Statements¶-- Syntax 5.4¶--  case_statement ::=¶--     case ex
pression is¶--¬case_statement_alternative¶--¬    {case_statement_alternative}¶--     end case;¶--¶--  case_statement_alt
ernative ::=¶--     when choice {| choice }¬=>¶--¬    sequence_of_statements}¶--|---------------------------------------
----------------------------------------------------------¶¶case_statement¬::=¶¬CASE  expression  IS  alternative_s  END
  CASE  ;¬¬====> $2 case¶¬%%¶--|........................................................................................
.........¶alternative_pragma¬::=¶¬pragma¬¬¬¬====> $1 alternative_pragma¶¬%%¶--|.........................................
........................................................¶alternative_s¬::=¶¬  {alternative_pragma} {case_sta_alt} case_s
ta_alt¬¬====> append cat $L alternative_s¶¬| {alternative_pragma} {case_sta_alt} case_sta_others¬¬====> append cat $L al
ternative_s¶¬%%¶--|.................................................................................................¶cas
e_sta_alt¬::=¶¬WHEN  choice_s  =>  sequence_of_statements¬¬====>  $2 alternative¶¬%%¶--|................................
.................................................................¶case_sta_others¬::=¶¬WHEN  others_s  =>  sequence_of_s
tatements¬¬====>  $2 alternative¶¬%%¶--|................................................................................
.................¶¶¶//  ALTERNATIVE_ELEM¬::=¶//¬alternative | alternative_pragma;¶¶##  ALTERNATIVE_ELEM¬====>¶##¬if¬alte
rnative¶##¬call¬alternative¬ALTERNATIVE_ELEM¶##¬if¬alternative_pragma¶##¬call¬alternative_pragma¬ALTERNATIVE_ELEM¶--|...
..............................................................................................¶//  case¬¬=>¶//¬as_altern
ative_s¬: alternative_s;¶¶##  case¬====>¶##¬include¬null;¶--|...........................................................
......................................¶//  alternative_s¬¬=>¶//¬as_list¬: Seq Of ALTERNATIVE_ELEM;¶¶##  alternative_s¬==
==>¶##¬repeat_extract¬alternative_s¬alternative_elem¶##¬call¬ALTERNATIVE_ELEM¬alternative_elem¶--|......................
...........................................................................¶//  alternative¬¬=>¶//¬as_choice_s¬: choice_
s,¶//¬as_stm_s¬: stm_s;¶¶##  alternative¬====>¬¬¬¬--| UNE ALTERNATIVE DE CASE¶##  include¬DECLARE¶##  include¬  SKIP_LBL
          : LABEL_TYPE := NEXT_LABEL;¬¬--| ALLOUER UNE ETIQUETTE POUR LE SAUT POST ALTERNATIVE¶##  include¬  HANDLER_BEG
IN_LBL : LABEL_TYPE := NEXT_LABEL;¬¬--| ALLOUER UNE ETIQUETTE POUR LE DEBUT DES INSTRUCTIONS DE L ALTERNATIVE¶##  includ
e¬  CHOICE_S          : TREE       := D ( AS_CHOICE_S, ALTERNATIVE );¬--| LISTE DES ELEMENTS CONDITIONANTS¶##  include¬B
EGIN¶##  include¬  DI ( CD_LABEL, CHOICE_S, INTEGER ( HANDLER_BEGIN_LBL ) );¬¬--| STOCKER L ETIQUETTE DE DEBUT DES INSTR
UCTIONS¶##  call¬choice_s¬choice_s¬¬¬--| TRAITER LES ELEMENTS DE CONDITION¶##  include¬  IF NOT CHOICE_OTHERS_FLAG THEN¬
¬¬--| SI PAS ALTERNATIVE WHEN OTHERS¶##  include¬    EMIT ( JMP, SKIP_LBL, COMMENT=> "SKIP ALTERNATIVE SUIVANTE"  );¬--|
 SAUTER A L ALTERNATIVE SUIVANTE¶##  include¬    WRITE_LABEL ( HANDLER_BEGIN_LBL, COMMENT=> "LABEL DEBUT INSTRUCTIONS" )
;¶##  include¬  END IF;¶##  call¬stm_s¬@ as_STM_S¬alternative¬¬--| TRAITER LES INSTRUCTIONS DE L ALTERNATIVE¶-- ##  incl
ude¬  PERFORM_RETURN ( ENCLOSING_BODY );¬¬¬??¶##  include¬  IF NOT CHOICE_OTHERS_FLAG THEN¬¬¬--| SI PAS ALTERNATIVE WHEN
 OTHERS¶##  include¬    WRITE_LABEL ( SKIP_LBL, COMMENT=> "ALTERNATIVE SUIVANTE" );¬--| METTRE L ETIQUETTE D'ALTERNATIVE
 SUIVANTE¶##  include¬  END IF;¶##  include¬END;¶¶--|...................................................................
..............................¶//  alternative_pragma¬=>¶//¬as_pragma¬: pragma;¶¶##  alternative_pragma¬====>¶##¬include
¬null;¶¶¶¶--|-------------------------------------------------------------------------------------------------¶-- 5.5¬Lo
op Statements¶-- Syntax 5.5.A¶--  loop_statement ::=¶--     [loop_simple_name:]¶--¬    [iteration_scheme] loop¶--¬¬ sequ
ence_of_statements¶--¬    end loop [loop_simple_name];¶--|--------------------------------------------------------------
-----------------------------------¶¶loop_statement¬::=¶¬  loop  ;¬¬¬¬====> void exch_2 exch_1 $V3 loop $DEF block_loop_
id¶¬| identifier  :  loop  identifier  ;¬¬¬====> check_name $V3 loop $DEF block_loop_id¶¬%%¶--|.........................
........................................................................¶loop¬::=¶¬[iteration_scheme]  LOOP  sequence_of
_statements  END  LOOP¶¬%%¶--|..........................................................................................
.......¶¶¶//  BLOCK_LOOP¬¬::=¶//¬loop;¶//  BLOCK_LOOP¬¬=>¶//¬as_source_name¬: SOURCE_NAME;¶¶##  BLOCK_LOOP¬====>¶##¬if¬l
oop¶##¬call¬loop¬BLOCK_LOOP¶##¬if¬block¶##¬call¬block¬BLOCK_LOOP¶--|....................................................
.............................................¶//  LABEL_NAME¬¬::=¶//¬block_loop_id;¶--|.................................
................................................................¶//  block_loop_id¬¬=> ;¶¶##  block_loop_id¬====>¶##¬inc
lude¬null;¶--|.................................................................................................¶¶##  ITE
RATION¬====>¶##¬if_class¬FOR_REV¶##¬call¬FOR_REV¬ITERATION¶##¬if¬while¶##¬call¬while¬ITERATION¶--|......................
...........................................................................¶//  loop¬¬=>¶//¬as_iteration¬: ITERATION,¶//
¬as_stm_s¬: stm_s¶//¬cd_level¬: Integer¶//¬cd_after_loop¬: Integer;¶¶##  loop¬====>¬¬¬¬--| BOUCLE SIMPLE¶##  include¬DEC
LARE¶##  include¬  OLD_LOOP_STM_S          : TREE := EMITS.LOOP_STM_S;¬¬--| GARER LA SEQUENCE EN CAS D IMBRICATION¶##  i
nclude¬  OLD_BEFORE_LOOP_LBL : LABEL_TYPE := EMITS.BEFORE_LOOP_LBL;¬--| GARER CES ETIQUETTES EN CAS D IMBRICATION DE BOU
CLES¶##  include¬  OLD_AFTER_LOOP_LBL  : LABEL_TYPE := EMITS.AFTER_LOOP_LBL;¶##  include¬BEGIN¶##  include¬  LOOP_STM_S 
:= D ( as_STM_S, ADA_LOOP );¬¬--| RAMENER LA SEQUENCE D'INSTRUCTIONS INTERNE A LA BOUCLE¶##  include¬  EMITS.BEFORE_LOOP
_LBL := NEXT_LABEL;¬¬¬--| ALLOUER UNE ETIQUETTE DE DEBUT DE BOUCLE¶##  include¬  EMITS.AFTER_LOOP_LBL := NEXT_LABEL;¬¬¬-
-| ALLOUER UNE ETIQUETTE POST FIN DE BOUCLE¶##  include¬  DI ( CD_AFTER_LOOP, ADA_LOOP, INTEGER( after_Loop_Lbl) );¬¬--|
 PLACER L ETIQUETTE POST BOUCLE DANS LE STM LOOP (ADA_LOOP)¶##  include¬  DI ( CD_LEVEL, ADA_LOOP, EMITS.LEVEL );¬¬--| P
LACER LE NIVEAU ACTUEL EGALEMENT¶¶##  include¬  DECLARE¶##  include¬    ITERATION : TREE := D ( AS_ITERATION, ADA_LOOP )
;¬¬--| RAMENER LE SCHEMA ITERATIF EVENTUEL¶##  include¬  BEGIN¶##  include¬    IF ITERATION = TREE_VOID then¬¬¬--| S IL 
N Y EN A PAS (LOOP instructions END LOOP)¶##  include¬      WRITE_LABEL ( BEFORE_LOOP_LBL );¬¬¬--| ECRIRE L ETIQUETTE DE
 DEBUT DE BOUCLE¶##  call¬stm_s¬LOOP_STM_S¬¬¬--| COMPILER LES INSTRUCTIONS DE LA BOUCLE¶##  include¬      EMIT ( JMP, BE
FORE_LOOP_LBL );¬¬¬--| ECRIRE LE SAUT DE RETOUR DE BAS DE BOUCLE¶##  include¬    ELSE¬¬¬¬--| S IL Y A UN SCHEMA ITERATIF
¶##  call¬ITERATION¬@ as_iteration¬ada_loop¶##  include¬    END IF;¶##  include¬  END;¶##  include¬  WRITE_LABEL ( after
_Loop_Lbl );¬¬¬--| ECRIRE L ETIQUETTE POST BOUCLE¶##  include¬  EMITS.BEFORE_LOOP_LBL := OLD_BEFORE_LOOP_LBL;¬¬--| RESTA
URER LES ETIQUETTES D UNE EVENTUELLE BOUCLE EXTERNE¶##  include¬  EMITS.AFTER_LOOP_LBL := OLD_AFTER_LOOP_LBL;¶##  includ
e¬  EMITS.LOOP_STM_S := OLD_LOOP_STM_S;¶##  include¬END;¶¶¶--|----------------------------------------------------------
---------------------------------------¶-- Syntax 5.5.B¶--  iteration_scheme ::=  while condition¶--     | for loop_para
meter_specification¶--¶--  loop_parameter_specification ::=¶--     identifier in [reverse] discrete_range¶--|-----------
--------------------------------------------------------------------------------------¶¶iteration_scheme¬::=¶¬  WHILE  c
ondition¬¬¬¬====> $1 while¶¬| FOR  iteration_id  IN  discrete_range¬¬¬====> $2 for¶¬| FOR  iteration_id  IN  REVERSE  di
screte_range¬¬====> $2 reverse¶¬%%¶--|..................................................................................
...............¶iteration_id¬::=¶¬identifier¬¬¬¬====> $0 iteration_id lx_symrep¶¬%%¶--|.................................
................................................................¶¶¶//  ITERATION¬¬::=¶//¬FOR_REV;¶--|...................
..............................................................................¶//  FOR_REV¬¬::=¶//¬for | reverse;¶//  FO
R_REV¬¬=>¶//¬as_source_name¬: SOURCE_NAME,¶//¬as_discrete_range¬: DISCRETE_RANGE;¶¶##  FOR_REV¬====>¬¬¬¬--| BOUCLE FOR O
U REVERSE (LES SAUVEGARDES D ETIQUETTES SONT DEJA FAITES PAR LOOP QUI APPELLE)¶##  include¬DECLARE¶##  include¬  OLD_LOO
P_OP_INC_DEC   : OP_CODE      := EMITS.LOOP_OP_INC_DEC;¬--| GARER CELA EN CAS D IMBRICATION DE BOUCLES FOR REV¶##  inclu
de¬  OLD_LOOP_OP_GT_LT     : OP_CODE      := EMITS.LOOP_OP_GT_LT;¶##  include¬  COUNTER, TEMP         : INTEGER;¶##  inc
lude¬  OLD_OFFSET_ACT        : OFFSET_TYPE  := EMITS.OFFSET_ACT;¶##  include¬  ITERATION_ID          : TREE         := D
 ( AS_SOURCE_NAME, FOR_REV );¶##  include¬  aCT                   : CODE_TYPE    := EMITS.CODE_TYPE_OF ( D ( SM_OBJ_TYPE
, ITERATION_ID ) );¶##  include¬  PROCEDURE LOAD_DSCRT_RANGE ( DSCRT_RANGE : TREE ) IS¶##  include¬  BEGIN¶##  include¬ 
   NULL;¶##  include¬  END;¶##  include¬BEGIN¶##  include¬  EMITS.BEFORE_LOOP_LBL := NEXT_LABEL;¬¬¬--| ALLOUER UNE ETIQU
ETTE DE DEBUT DE BOUCLE¶##  include¬  EMITS.AFTER_LOOP_LBL := NEXT_LABEL;¬¬¬--| ALLOUER UNE ETIQUETTE POST FIN DE BOUCLE
¶##  if¬for¶##  call¬for¬FOR_REV¬¬¬--| POSITIONNE LES OPERATIONS LOOP_OP INC LE¶##  if¬reverse¶##  call¬reverse¬FOR_REV¬
¬¬--| POSITIONNE LES OPERATIONS LOOP_OP DEC GE¶##  end_if¶##  include¬  CASE aCT IS¬¬¬¬--| SUIVANT LE TYPE DE LA VARIABL
E D ITERATION¶##  include¬  WHEN B =>¬¬¬¬--| BOOLEEN (? POUR UNE BOUCLE ?)¶##  include¬    ALIGN ( Bool_Al );¶##  includ
e¬    COUNTER := -EMITS.OFFSET_ACT;¶##  include¬    INC_OFFSET ( Bool_Size);¶##  include¬    ALIGN ( Bool_Al);¶##  inclu
de¬    TEMP := -EMITS.OFFSET_ACT;¶##  include¬    INC_OFFSET ( Bool_Size );¶##  include¬  WHEN C =>¬¬¬¬--| CARACTERE¶## 
 include¬    ALIGN ( Char_Al );¶##  include¬    COUNTER := -EMITS.OFFSET_ACT;¶##  include¬    INC_OFFSET ( Char_Size );¶
##  include¬    ALIGN ( Char_Al);¶##  include¬    TEMP := -EMITS.OFFSET_ACT;¶##  include¬    INC_OFFSET ( Char_Size );¶#
#  include¬  WHEN I =>¬¬¬¬--| ENTIER¶##  include¬    ALIGN ( INTG_Al );¬¬¬--| ALIGNER POUR L ENTIER VARIABLE COMPTEUR¶##
  include¬    COUNTER := -EMITS.OFFSET_ACT;¬¬¬--| OFFSET DU COMPTEUR DE BOUCLE¶##  include¬    INC_OFFSET ( INTG_SIZE );
¬¬¬--| RESERVER UNE PLACE D ENTIER COMPTEUR¶##  include¬    ALIGN ( INTG_Al );¬¬¬--| ALIGNER POUR L ENTIER BORNE DE COMP
TAGE¶##  include¬    TEMP := -EMITS.OFFSET_ACT;¬¬¬--| OFFSET DE LA BORNE DE COMPTAGE¶##  include¬    INC_OFFSET ( INTG_S
IZE );¬¬¬--| RESERVER UNE PLACE D ENTIER BORNE¶##  include¬  WHEN A =>¶##  include¬    PUT_LINE ( "!!! compile_stm_loop_
reverse aCT illicite " & Code_Type'IMAGE ( aCT ) );¶##  include¬    RAISE PROGRAM_ERROR;¶##  include¬  END CASE;¶¶##  in
clude¬  DI ( CD_LEVEL, ITERATION_ID, EMITS.LEVEL );¬¬--| RANGER LE NIVEAU STATIQUE DU COMPTEUR¶##  include¬  DI ( CD_OFF
SET, ITERATION_ID, COUNTER );¬¬--| RANGER L OFFSET DE COMPTEUR¶##  include¬  LOAD_DSCRT_RANGE ( D ( as_DISCRETE_RANGE, F
OR_REV ) );¶¶##  include¬  EMIT ( STR, aCT, 0, TEMP );¶##  include¬  WRITE_LABEL ( EMITS.BEFORE_LOOP_LBL );¬¬--| ETIQUET
TE DE DEBUT DE BOUCLE¶##  include¬  EMIT ( STR, aCT, 0, COUNTER );¬¬¬--| STOCKER LE COMPTEUR (IL EST MODIFIE EN FIN DE B
OUCLE)¶##  include¬  EMIT ( LOD, aCT, 0, COUNTER );¬¬¬--| RECHARGER LE COMPTEUR¶##  include¬  EMIT ( LOD, aCT, 0, TEMP )
;¬¬¬--| CHARGER LA BORNE¶##  include¬  EMIT ( EMITS.LOOP_OP_GT_LT, aCT );¬¬¬--| FAIRE LA COMPARAISON SUIVANT LE CAS FOR 
OU REVERSE¶##  include¬  EMIT ( JMPT, EMITS.AFTER_LOOP_LBL );¬¬¬--| LE COMPTEUR DEPASSE LA BORNE SORTIE DE BOUCLE¶##  ca
ll¬stm_s¬LOOP_STM_S¬¬¬--| TRAITER LES INSTRUCTIONS DE BOUCLE¶##  include¬  EMIT ( LOD, aCT, 0, COUNTER );¬¬¬--| CHARGER 
LE COMPTEUR¶##  include¬  EMIT ( EMITS.LOOP_OP_INC_DEC, aCT, 1 );¬¬--| L INCREMENTER OU DECREMENTER SUIVANT LE TYPE DE B
OUCLE¶##  include¬  EMIT ( JMP, EMITS.BEFORE_LOOP_LBL );¬¬¬--| FOND DE BOUCLE SAUT AU DEBUT¶##  include¬  WRITE_LABEL ( 
EMITS.AFTER_LOOP_LBL );¬¬¬--| ETIQUETTE POST BOUCLE¶¶##  include¬  EMITS.OFFSET_ACT := OLD_OFFSET_ACT;¶##  include¬  EMI
TS.LOOP_OP_INC_DEC := OLD_LOOP_OP_INC_DEC;¬¬--| RESTAURER CES OPERATIONS D UNE EVENTUELLE BOUCLE EXTERNE FOR REV¶##  inc
lude¬  EMITS.LOOP_OP_GT_LT := OLD_LOOP_OP_GT_LT;¶##  include¬END;¶¶--|..................................................
...............................................¶//  for¬¬=> ;¶¶##  for¬====>¶##  include¬LOOP_OP_INC_DEC := INC;¬¬¬--| U
NE BOUCLE FOR NORMALE INCREMENTE SON COMPTEUR¶##  include¬LOOP_OP_GT_LT := GT;¬¬¬--| ON L ARRETE QUAND LE COMPTEUR DEPAS
SE LA BORNE¶¶--|.................................................................................................¶//  re
verse¬¬=> ;¶¶##  reverse¬====>¶##  include¬LOOP_OP_INC_DEC := DEC;¬¬¬--| UNE BOUCLE FOR REVERSE DECREMENTE SON COMPTEUR¶
##  include¬LOOP_OP_GT_LT := LT;¬¬¬--| ON L ARRETE QUAND LE COMPTEUR PASSE SOUS LA BORNE¶--|............................
.....................................................................¶//  OBJECT_NAME¬¬::=¶//¬iteration_id;¶--|.........
........................................................................................¶//  iteration_id¬¬=>¶//¬cd_leve
l¬: Integer,¶//¬cd_offset¬: Integer;¶¶##  iteration_id¬====>¶##¬include¬null;¶--|.......................................
..........................................................¶//  ITERATION¬¬::=¶//¬while;¶--|.............................
....................................................................¶//  while¬¬=>¶//¬as_exp¬: EXP;¶¶##  while¬====>¬¬¬¬
--| BOUCLE WHILE (LES SAUVEGARDES D ETIQUETTES SONT DEJA FAITE PAR LOOP QUI APPELLE WHILE)¶##  include¬BEFORE_LOOP_LBL :
= NEXT_LABEL;¬¬¬--| ALLOUER UNE ETIQUETTE DE DEBUT DE BOUCLE¶##  include¬AFTER_LOOP_LBL := NEXT_LABEL;¬¬¬--| ALLOUER UNE
 ETIQUETTE POST FIN DE BOUCLE¶##  include¬WRITE_LABEL ( BEFORE_LOOP_LBL );¬¬¬--| ECRIRE L ETIQUETTE ENTREE DE BOUCLE¶## 
 call¬EXP¬@ as_EXP¬ADA_WHILE¬¬--| TRAITER L EXPRESSION CONDITION¶##  include¬EMIT ( JMPF, AFTER_LOOP_LBL );¬¬¬--| SAUT P
OST BOUCLE SI CONDITION FAUSSE¶##  call¬stm_s¬LOOP_STM_S¬¬¬--| TRAITER LES INSTRUCTIONS DE LA BOUCLE¶##  include¬EMIT ( 
JMP, BEFORE_LOOP_LBL );¬¬¬--| FOND DE BOUCLE SAUT AU DEBUT DE BOUCLE¶¶¶--|----------------------------------------------
---------------------------------------------------¶-- 5.6¬Block Statements¶-- Syntax 5.6¶--  block_statement ::=¶--    
 [block_simple_name:]¶--¬    [declare¶--¬¬ declarative_part]¶--¬    begin¶--¬¬ sequence_of_statements¶--¬    [exception¶
--¬¬  exception_handler¶--¬¬ {exception_handler}]¶--¬    end [block_simple_name];¶--|-----------------------------------
--------------------------------------------------------------¶¶block_statement¬::=¶¬  block ;¬¬¬¬====> void exch_1 $V2 
block $DEF block_loop_id¶¬| identifier  :  block  identifier  ;¬¬¬====> check_name $V2 block $DEF block_loop_id¶¬%%¶--|.
................................................................................................¶block¬::=¶¬[DECLARE__de
clarative_part]  BEGIN  sequence_of_statements¶¬[EXCEPTION__exception_handler{exception_handler}]  END¬¬====> $3 block_b
ody¶¬%%¶--|.................................................................................................¶[DECLARE__d
eclarative_part]¬::=¶¬  empty¬¬¬¬====> nil $L item_s¶¬| DECLARE  declarative_part¶¬%%¶--|...............................
..................................................................¶[EXCEPTION__exception_handler{exception_handler}]  ::
=¶¬  empty¬¬¬¬====> nil $L alternative_s¶¬| EXCEPTION  alternative_s¶¬%%¶--|............................................
.....................................................¶¶¶//  BLOCK_LOOP¬¬::=¶//¬block;¶--|...............................
..................................................................¶//  block¬¬=>¶//¬as_block_body¬: block_body;¶--¬as_so
urce_name¬:SOURCE_NAME¶--¬lx_srcpos¬:Source_Position¶¶##  block¬====>¶##  include¬DECLARE¶##  include¬  AFTER_BLOCK_LBL 
: LABEL_TYPE := NEXT_LABEL;¶##  include¬  PROC_LBL        : LABEL_TYPE := NEXT_LABEL;¶##  include¬BEGIN¶##  include¬  EM
IT ( MST, INTEGER ( 0 ), INTEGER( 0 ), COMMENT=> "POUR BLOC" );¶##  include¬  EMIT ( CALL, EMITS.RELATIVE_RESULT_OFFSET,
 PROC_LBL,¬¬--| UN BLOC EST TRAITE COMME UNE PROCEDURE SANS PARAMETRE DONC APPELE¶##  include¬         COMMENT=> "APPEL 
DE BLOC" );¶##  include¬  EMIT ( JMP, AFTER_BLOCK_LBL, COMMENT=> "SAUT POST BLOC" );¬--| AU RETOUR DU BLOC SAUTER POST B
LOC¶##  include¬  WRITE_LABEL ( PROC_LBL);¬¬¬--| ETIQUETTE DEBUT DE BLOC¶##  include¬  DECLARE¶##  include¬    OLD_OFFSE
T_ACT : OFFSET_TYPE := EMITS.OFFSET_ACT;¬¬--| GARER LES OFFSETS ANTERIEURS¶##  include¬    OLD_OFFSET_MAX : OFFSET_TYPE 
:= EMITS.OFFSET_MAX;¶##  include¬  BEGIN¶##  include¬    EMITS.OFFSET_ACT := FIRST_LOCAL_VAR_OFFSET;¬¬--| METTRE LES OFF
SETS SUR LA PREMIERE VARIABLE LOCALE¶##  include¬    EMITS.OFFSET_MAX := FIRST_LOCAL_VAR_OFFSET;¶##  include¬    INC_LEV
EL;¬¬¬¬--| UN NIVEAU PLUS PROFOND¶##  call¬block_body¬@ as_block_body¬block¬¬--| TRAITER LE CORPS DU BLOC¶##  include¬  
  DEC_LEVEL;¶##  include¬    EMITS.OFFSET_ACT := OLD_OFFSET_ACT;¬¬¬--| RESTAURER LES OFFSETS D AVANT LE BLOC¶##  include
¬    EMITS.OFFSET_MAX := OLD_OFFSET_MAX;¶##  include¬  END;¶##  include¬  WRITE_LABEL ( AFTER_BLOCK_LBL );¶##  include¬E
ND;¶--|.................................................................................................¶//  block_body¬
¬=>¶//¬as_item_s¬: item_s,¶//¬as_stm_s¬: stm_s,¶//¬as_alternative_s¬: alternative_s,¶//¬cd_level¬: Integer,¶//¬cd_return
_label¬: Integer,¶//¬cd_result_offset¬: Integer;¶¶##  block_body¬====>¶¶##  include¬DECLARE¬¬¬¬--| TRAITEMENT DU CORPS D
E SOUS PROGRAMME¶##  include¬  SAVE_ENCLOSING_BODY : TREE := ENCLOSING_BODY;¶##  include¬  OLD_TOP_ACT         : OFFSET_
TYPE := EMITS.TOP_ACT;¶##  include¬  OLD_TOP_MAX         : OFFSET_TYPE := EMITS.TOP_MAX;¶##  include¬BEGIN¶##  include¬ 
 ENCLOSING_BODY := BLOCK_BODY;¬¬¬--| LE BLOC EN TRAITEMENT DEVIENT L'ENGLOBANT ACTUEL¶##  include¬  EMITS.TOP_ACT := 0;¬
¬¬--| RAZ DES TOPS PUISQUE ON A UN NOUVEAU CONTEXTE¶##  include¬  EMITS.TOP_MAX := 0;¶##  include¬  DI ( CD_LEVEL, BLOCK
_BODY, INTEGER ( EMITS.LEVEL ) );¬¬--| PLACER LE NIVEAU COURANT DANS LE CHAMP LEVEL DU BLOC¶##  include¬  DI ( CD_RETURN
_LABEL, BLOCK_BODY, INTEGER ( NEXT_LABEL ) );¬--| ALLOUER UNE ETIQUETTE ET LA PLACER DANS LE CHAMP POUR RETOUR¶##  inclu
de¬  DECLARE¶##  include¬    ENT_1_LBL : LABEL_TYPE := NEXT_LABEL;¶##  include¬    ENT_2_LBL : LABEL_TYPE := NEXT_LABEL;
¶##  include¬  BEGIN¶##  include¬    EMIT ( ENT, INTEGER ( 1 ), ENT_1_Lbl );¬¬--| EMETTRE LE MARQUEUR D ENTREE DE BLOC A
VEC ETIQUETTE POUR OFFSET_MAX¶##  include¬    EMIT ( ENT, INTEGER ( 2 ), ENT_2_Lbl );¬¬--| SECOND MARQUEUR POUR TOP + OF
FSET MAXIS¶¶##  include¬    IF FUNCTION_RESULT /= TREE_VOID THEN¬¬--| S IL Y A UN RESULTAT DE FONCTION¶##  include¬     
 IF FUNCTION_RESULT.TY = DN_ARRAY THEN¬¬--| SI C EST UN TABLEAU INITIALISER LE DESCRIPTEUR RESULTAT¶##  include¬        
GEN_LOAD_ADDR ( DI ( CD_COMP_UNIT, FUNCTION_RESULT ),¶##  include¬                        DI ( CD_LEVEL, FUNCTION_RESULT
 ),¶##  include¬                        DI ( CD_OFFSET, FUNCTION_RESULT )¶##  include¬            );¶##  include¬       
 EMIT ( DPL, A );¬¬¬--| DUPLIQUER L ADRESSE OBTENUE¶##  include¬        EMIT ( STR, A, 0, FUN_RESULT_OFFSET - EMITS.ADDR
_SIZE );¬--| LA STOCKER¶##  include¬        EMIT ( IND, I, 0 );¶##  include¬        EMIT ( ALO, INTEGER ( -1 ) );¶##  in
clude¬        EMIT ( STR, A, 0, FUN_RESULT_OFFSET );¬¬--| STOCKER L ADRESSE DE L ALLOCATION¶##  include¬      END IF;¶##
  include¬    END IF;¶##  call¬item_s¬@ as_ITEM_S¬block_body¬¬--| TRAITER LES DECLARATIONS¶##  include¬    DECLARE¶##  i
nclude¬      EXC_LBL : LABEL_TYPE := NEXT_LABEL;¬¬--| ALLOUER UNE ETIQUETTE POUR LE DEBUT DES HANDLERS EXCEPTION¶##  inc
lude¬    BEGIN¶##  include¬      EMIT ( EXH, EXC_LBL, COMMENT=> "EXCEPTION HANDLERS" );¬--| DECLARER UNE ETIQUETTE POUR 
LES HANDLERS EXCEPTION (PEUT Y AVOIR DES RAISE DANS LES INSTRUCTIONS SUIVANTES)¶##  call¬stm_s¬@ as_STM_S¬block_body¬¬--
| TRAITER LES INSTRUCTIONS¶##  include¬      WRITE_LABEL ( LABEL_TYPE ( DI ( CD_RETURN_LABEL, BLOCK_BODY ) ) );¬--| ETIQ
UETTE DU RETOUR¶-- CG_Param.COPY_OUT_PARAMS ( params );¬¬¬¬--| COPIER LES PARAMETRES DE SORTIE¶##  include¬      EMIT ( 
RET, PARAM_SIZE );¬¬¬--| EMETTRE L INSTRUCTION RETURN¶##  include¬      WRITE_LABEL ( EXC_LBL );¬¬¬--| PLACER L ETIQUETT
E DES HANDLERS¶##  include¬    END;¶##  include¬    IF NOT IS_EMPTY ( LIST ( D ( AS_ALTERNATIVE_S, BLOCK_BODY ) ) ) THEN
¬--| S IL Y A UNE LISTE DE HANDLERS¶##  call¬alternative_s¬@ as_ALTERNATIVE_S¬block_body¬¬--| TRAITER LES HANDLERS¶##  i
nclude¬    ELSE¬¬¬¬--| SINON¶##  include¬      EMIT ( EEX );¬¬¬¬--| SIMPLEMENT EMETTRE UN MARQUEUR DE FIN DES HANDLERS E
XCEPTION¶##  include¬    END IF;¶##  include¬    GEN_LBL_ASSIGNMENT ( ENT_1_LBL, EMITS.OFFSET_MAX );¬¬--| DONNER LES VAL
EURS AUX ETIQUETTES DES ENTER BLOCKS¶##  include¬    GEN_LBL_ASSIGNMENT ( ENT_2_LBL, EMITS.OFFSET_MAX + EMITS.TOP_MAX );
¶##  include¬  END;¶##  include¬  EMITS.TOP_MAX := OLD_TOP_MAX;¬¬¬--| RESTAURER LES OFFSETS ANTERIEURS¶##  include¬  EMI
TS.TOP_ACT := OLD_TOP_ACT;¶##  include¬  ENCLOSING_BODY := SAVE_ENCLOSING_BODY;¬¬--| ET L ENGLOBANT PRECEDENT¶##  includ
e¬END;¶¶¶¶--|-------------------------------------------------------------------------------------------------¶-- 5.7¬Ex
it Statements¶-- Syntax 5.7¶--  exit_statement ::=¶--     exit [loop_name] [when condition] ;¶--|-----------------------
--------------------------------------------------------------------------¶¶exit_statement¬::= ¶¬EXIT  [expanded_name]  
[WHEN__condition]  ;¬¬====> exch_1 $2 exit¶¬%%¶--|......................................................................
...........................¶[WHEN__condition]¬::=¶¬empty¬¬¬¬====> void¶¬| WHEN  expression¶¬%%¶--|......................
...........................................................................¶¶--|........................................
.........................................................¶//  exit¬¬=>¶//¬sm_stm¬: STM;¶--¬as_exp¬:EXP¶--¬as_name¬:NAME¶
--¬lx_srcpos¬:Source_Position¶¶##  exit¬====>¶¶##  include¬DECLARE¶##  include¬  LVB_LBL          : LABEL_TYPE;¶##  incl
ude¬  EXP              : TREE := D ( AS_EXP, ada_exit );¬¬--| AMENER L EXPRESSION EVENTUELLE DE CONDITION DE SORTIE¶##  
include¬  LOOP_STM         : TREE := D ( SM_STM, ada_exit );¬¬--| AMENER L INSTRUCTION BOUCLE DONT ON SORT¶##  include¬ 
 LOOP_LEVEL       : LEVEL_TYPE := DI ( CD_LEVEL, LOOP_STM );¬--| LIRE SON NIVEAU STATIQUE¶##  include¬  AFTER_LOOP_LABEL
 : LABEL_TYPE := LABEL_TYPE( DI( CD_AFTER_LOOP, LOOP_STM ) );¬--| REPRENDRE LE NUMERO D ETIQUETTE DE FIN DE BOUCLE¶##  i
nclude¬BEGIN¶##  include¬  IF EXP = TREE_VOID THEN¬¬¬--| PAS D EXPRESSION DONC EXIT SANS CONDITION (SANS WHEN)¶##  inclu
de¬    IF LOOP_LEVEL /= EMITS.LEVEL THEN¬¬¬--| LE NIVEAU DE LA BOUCLE DIFFERE DU NIVEAU COURANT DE L EXIT (PLUS PROFOND)
¶##  include¬         LVB_LBL := NEXT_LABEL;¬¬¬--| ALLOUER UNE ETIQUETTE¶##  include¬         EMIT ( LVB, LVB_LBL, COMME
NT=> "NOMBRE DE NIVEAUX REMONTES" );¬--| EMETTRE UN LEAVE BLOCK AVEC CETTE ETIQUETTE¶##  include¬         GEN_LBL_ASSIGN
MENT ( LVB_LBL, EMITS.LEVEL - LOOP_LEVEL );¬--| QUI A VALEUR LE NOMBRE DE NIVEAUX REMONTES¶##  include¬    END IF;¶##  i
nclude¬    EMIT ( JMP, AFTER_LOOP_LABEL, COMMENT=> "SORTIE DE BOUCLE" );¬--| EMETTRE LE SAUT EN FIN DE BOUCLE¶¶##  inclu
de¬  ELSE¬¬¬¬--| EXIT AVEC CONDITION (AVEC WHEN)¶##  call¬exp¬exp¬¬¬--| TRAITER L EXPRESSION¶##  include¬    IF LOOP_LEV
EL /= EMITS.LEVEL THEN¬¬¬--| LE NIVEAU DE LA BOUCLE DIFFERE DU NIVEAU COURANT DE L EXIT (PLUS PROFOND)¶##  include¬     
 DECLARE¶##  include¬        SKIP_LBL : LABEL_TYPE := NEXT_LABEL;¬¬--| ALLOUER UNE ETIQUETTE DE SAUT POUR POURSUITE SI C
ONDITION FAUSSE¶##  include¬      BEGIN¶##  include¬        EMIT ( JMPF, SKIP_LBL, COMMENT=> "PAS D EXIT SI CONDITION FA
USSE" );¬--| EMETTRE LE SAUT A CETTE ETIQUETTE¶##  include¬        LVB_LBL := NEXT_LABEL;¬¬¬--| ALLOUER UNE ETIQUETTE¶##
  include¬        EMIT ( LVB, LVB_lbl, COMMENT=> "NOMBRE DE NIVEAUX REMONTES" );¬--| EMETTRE UN LEAVE BLOCK AVEC CETTE E
TIQUETTE¶##  include¬        GEN_LBL_ASSIGNMENT ( LVB_LBL, EMITS.LEVEL - LOOP_LEVEL );¬--| QUI A VALEUR LE NOMBRE DE NIV
EAUX REMONTES¶##  include¬        EMIT ( JMP, AFTER_LOOP_LABEL, COMMENT=> "SORTIE DE BOUCLE" );¬--| EMETTRE LE SAUT EN F
IN DE BOUCLE¶##  include¬        WRITE_LABEL ( SKIP_LBL, COMMENT=> "LABEL NO EXIT" );¬--| ECRIRE L ETIQUETTE DE CONTOURN
EMENT¶##  include¬      END;¶##  include¬    ELSE¬¬¬¬--| LE NIVEAU DE L EXIT EST CELUI DE LA BOUCLE¶##  include¬      EM
IT ( JMPT, AFTER_LOOP_LABEL );¬¬¬--| EMETTRE UN SIMPLE SAUT POST FIN DE BOUCLE¶##  include¬    END IF;¶##  include¬  END
 IF;¶##  include¬END;¶¶¶¶--|--------------------------------------------------------------------------------------------
-----¶-- 5.8¬Return Statements¶-- Syntax 5.8¶--  return_statement ::= return [expression] ;¶--|-------------------------
------------------------------------------------------------------------¶¶return_statement¬::=¶¬RETURN  [expression]  ;¬
¬¬====> $1 return¶¬%%¶--|...............................................................................................
..¶¶¶//  return¬¬=> ;¶¶##  return¬====>¶##  include¬DECLARE¶##  include¬  EXP : TREE := D ( AS_EXP, ADA_RETURN );¬¬--| R
AMENER L EXPRESSION RETOURNEE¶##  include¬BEGIN¶##  include¬  IF EXP /= TREE_VOID THEN¬¬¬--| IL Y A UNE EXPRESSION¶##  i
nclude¬STORE_FUNCTION_RESULT:¶##  include¬    DECLARE¶##  include¬      ENCLOSING_LEVEL : INTEGER := DI ( CD_LEVEL, EMIT
S.ENCLOSING_BODY );¬--| NIVEAU STATIQUE DE L ENGLOBANT¶##  include¬      RESULT_OFFSET : INTEGER := DI ( CD_RESULT_OFFSE
T, EMITS.ENCLOSING_BODY );¬--| DECALAGE DU RESULTAT¶##  include¬      EXPR_TYPE     : TREE := D ( SM_EXP_TYPE, EXP );¬¬-
-| TYPE DE L EXPRESSION¶##  include¬    BEGIN¶##  include¬      IF EXPR_TYPE.TY = DN_ARRAY THEN¬¬¬--| RETOUR D'UN TABLEA
U¶##  include¬        EMIT ( LDA, EMITS.LEVEL - ENCLOSING_LEVEL, RESULT_OFFSET );¶##  call¬EXP¬exp¬¬¬--| TRAITER L EXPRE
SSION¶##  include¬        EMIT ( LDC, I, EMITS.NUMBER_OF_DIMENSIONS ( EXP ) );¬--| EMPILER LE NOMBRE DE DIMENSIONS¶##  i
nclude¬        EMIT ( PUA );¬¬¬--| APPELER "PUT ARRAY"¶                     ¶##  include¬       ELSIF EXPR_TYPE.TY = DN_
ENUM_LITERAL_S THEN¬¬--| ENUMERE¶##  call¬EXP¬exp¬¬¬--| TRAITER L EXPRESSION¶##  include¬         EMIT ( STR, EMITS.CODE
_TYPE_OF ( EXP ), EMITS.LEVEL - ENCLOSING_LEVEL, RESULT_OFFSET );¶                     ¶##  include¬       ELSIF EXPR_TY
PE.TY = DN_INTEGER THEN¶##  call¬EXP¬exp¶##  include¬         EMIT ( STR, I, EMITS.LEVEL - ENCLOSING_LEVEL, RESULT_OFFSE
T );¶##  include¬       END IF;¶##  include¬     END STORE_FUNCTION_RESULT;¶##  include¬   END IF;¶##  include¬   EMITS.
PERFORM_RETURN ( EMITS.ENCLOSING_BODY );¬¬--| EFFECTUER LE RETOUR PROPREMENT DIT¶##  include¬end;¶¶¶¶--|----------------
---------------------------------------------------------------------------------¶-- 5.9¬Goto Statements¶-- Syntax 5.9¶-
-  goto_statement ::= goto label_name;¶--|------------------------------------------------------------------------------
-------------------¶¶goto_statement¬::=¶¬GOTO  expanded_name  ;¬¬¬====> $1 goto¶¬%%¶--|.................................
................................................................¶¶¶//  goto¬¬=> ;¶¶##  goto¬====>¶##¬include¬null;¶¶¶¶--
||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||¶-- 6.  Subprograms¶--
||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||¶-- 6.1¬Subprogram Dec
larations¶-- Syntax 6.1.A¶--  subprogram_declaration ::= subprogram_specification;¶--|----------------------------------
---------------------------------------------------------------¶¶subprogram_declaration¬::=¶¬subprogram_specification  ;
¬¬¬====> void $3 subprog_entry_decl¶¬%%¶--|.............................................................................
....................¶proc_id¬::=¶¬identifier¬¬¬¬====> $0 procedure_id lx_symrep¶¬%%¶--|.................................
................................................................¶function_id¬::=¶¬identifier¬¬¬¬====> $0 function_id lx_
symrep¶¬%%¶--|.................................................................................................¶def_op¬:
:=¶¬string_literal¬¬¬¬====> $0 operator_id lx_symrep¶¬%%¶--|............................................................
.....................................¶¶¶//  subprog_entry_decl¬=>;¶--¬as_source_name¬:SOURCE_NAME¶--¬as_header¬:HEADER¶-
-¬as_unit_kind¬:UNIT_KIND¶--¬lx_srcpos¬:Source_Position¶¶##  subprog_entry_decl¬====>¬¬¬--| DECLARATION DE SOUS PROGRAMM
E¶##  include¬DECLARE¶##  include¬  OLD_OFFSET_ACT : OFFSET_TYPE := EMITS.OFFSET_ACT;¬¬--| GARER LES OFFSETS DU NIVEAU S
UPERIEUR¶##  include¬  OLD_OFFSET_MAX : OFFSET_TYPE := EMITS.OFFSET_MAX;¶##  include¬  SOURCE_NAME    : TREE        := D
 ( AS_SOURCE_NAME, SUBPROG_ENTRY_DECL );¬--| RAMENER LE NOEUD NOM DU SOUS PROGRAMME¶##  include¬  HEADER         : TREE 
       := D ( AS_HEADER, SUBPROG_ENTRY_DECL );¬--| RAMENER L ENTETE DE PARAMETRAGE¶##  include¬BEGIN¶##  include¬  EMITS
.OFFSET_ACT := EMITS.FIRST_PARAM_OFFSET;¬¬--| OFFSET DU PREMIER PARAMETRE COMME OFFSET DE PILE ACTUEL¶##  include¬  EMIT
S.OFFSET_MAX := EMITS.OFFSET_ACT;¬¬¬--| OFFSET MAX MIS A L OFFSET ACTUEL¶##  include¬  INC_LEVEL;¬¬¬¬--| NIVEAU STATIQUE
 SUIVANT¶¶##  include¬  IF SOURCE_NAME.TY IN CLASS_SUBPROG_NAME THEN¶##  include¬    DECLARE¶##  include¬      LBL : LAB
EL_TYPE := NEXT_LABEL;¬¬¬--| ALLOUER UNE ETIQUETTE POUR LE SOUS PROGRAMME¶##  include¬    BEGIN¶##  include¬      DI ( C
D_LABEL, SOURCE_NAME, INTEGER ( LBL ) );¬¬--| INTEGRER CETTE ETIQUETTE AU NOM DU SOUS PROGRAMME¶##  include¬      DI ( C
D_LEVEL, SOURCE_NAME, EMITS.LEVEL );¬¬--| MENTIONNER AUSSI LE NIVEAU STATIQUE¶##  include¬      DB ( CD_COMPILED, SOURCE
_NAME, TRUE );¬¬--| INDIQUER QUE L ON VA AVOIR COMPILE CETTE DECLARATION¶##  include¬      IF NOT EMITS.GENERATE_CODE TH
EN¬¬¬--| SI PAS DE GENERATION DE CODE¶##  include¬        EMITS.GENERATE_CODE := TRUE;¬¬¬--| LA METTRE QUAND MEME¶##  in
clude¬        EMIT ( RFL, LBL );¬¬¬--| POUR EMETTRE CETTE REFERENCE D ETIQUETTE¶##  include¬        EMITS.GENERATE_CODE 
:= FALSE;¬¬¬--| ET REMETTRE COMME AVANT¶##  include¬      END IF;¶¶##  call¬HEADER¬@ as_header¬subprog_entry_decl¬¬--| T
RAITER L ENTETE DE PARAMETRAGE¶¶##  include¬      DI ( CD_PARAM_SIZE, SOURCE_NAME, OFFSET_ACT - FIRST_PARAM_OFFSET );¬--
| APRES TRAITEMENT DE L ENTETE ON A LA TAILLE DU PARAMETRAGE QUE L ON STOCKE¶##  include¬    END;¶¶##  include¬    IF SO
URCE_NAME.TY = DN_FUNCTION_ID OR SOURCE_NAME.TY = DN_OPERATOR_ID THEN¬--| SI L ON A UNE FONCTION OU UN OPERATEUR (QUI ON
T UN RESULTAT)¶##  include¬      DECLARE¶##  include¬        USED_OBJECT_ID   : TREE := D ( AS_NAME, HEADER );¬¬--| RAME
NER LE CHAMP AS_NAME DE L ENTETE DE PARAMETRAGE¶##  include¬        RESULT_TYPE_SPEC : TREE := D ( SM_EXP_TYPE, USED_OBJ
ECT_ID );¬--| RAMENER SON TYPE¶##  include¬      BEGIN¶##  include¬        DI ( CD_RESULT_SIZE, SOURCE_NAME, EMITS.TYPE_
SIZE( RESULT_TYPE_SPEC ));¬--| STOCKER LA TAILLE DU TYPE RESULTAT¶##  include¬      END;¶##  include¬    END IF;¶##  inc
lude¬  END IF;¶¶##  include¬  DEC_LEVEL;¬¬¬¬--| REVENIR AU NIVEAU STATIQUE PRECEDENT¶##  include¬  EMITS.OFFSET_MAX := O
LD_OFFSET_MAX;¬¬¬--| REGENERER LES OFFSETS DU NIVEAU PRECEDENT¶##  include¬  EMITS.OFFSET_ACT := OLD_OFFSET_ACT;¶##  inc
lude¬END;¶--|.................................................................................................¶//  UNIT_
NAME¬¬::=¶//¬NON_TASK_NAME;¶--|.........................................................................................
........¶//  NON_TASK_NAME¬¬::=¶//¬SUBPROG_PACK_NAME;¶//  NON_TASK_NAME¬¬=>¶//¬sm_spec¬: HEADER,¶//¬xd_stub¬: stub,¶//¬x
d_body¬: SUBUNIT_BODY;¶¶##  NON_TASK_NAME¬====>¶##¬if¬generic_id¶##¬call¬generic_id¬NON_TASK_NAME¶##¬if_class¬SUBPROG_PA
CK_NAME¶##¬call¬SUBPROG_PACK_NAME¬NON_TASK_NAME¶--|.....................................................................
............................¶//  SUBPROG_PACK_NAME¬::=¶//¬SUBPROG_NAME;¶//  SUBPROG_PACK_NAME¬=>¶//¬sm_unit_desc¬: UNIT_
DESC,¶//¬sm_address¬: EXP,¶//¬cd_compiled¬: BOOLEAN;¶¶##  SUBPROG_PACK_NAME¬====>¶##¬if¬package_id¶##¬call¬package_id¬SU
BPROG_PACK_NAME¶##¬if_class¬SUBPROG_NAME¶##¬call¬SUBPROG_NAME¬SUBPROG_PACK_NAME¶--|.....................................
............................................................¶//  SUBPROG_NAME¬¬::=¶//¬procedure_id | function_id | opera
tor_id;¶//  SUBPROG_NAME¬¬=>¶//¬sm_is_inline¬: BOOLEAN,¶//¬sm_interface¬: PREDEF_NAME,¶//¬cd_level¬: Integer,¶//¬cd_labe
l¬: Integer,¶//¬cd_param_size¬: Integer;¶¶##  SUBPROG_NAME¬====>¶##¬if¬procedure_id¶##¬call¬procedure_id¬SUBPROG_NAME¶##
¬if¬function_id¶##¬call¬function_id¬SUBPROG_NAME¶##¬if¬operator_id¶##¬call¬operator_id¬SUBPROG_NAME¶--|.................
................................................................................¶//  UNIT_DESC¬¬::=¶//¬UNIT_KIND | BODY 
| implicit_not_eq | derived_subprog;¶--|................................................................................
.................¶//  derived_subprog¬¬=>¶//¬sm_derivable¬: SOURCE_NAME;¶--|............................................
.....................................................¶//  implicit_not_eq¬¬=>¶//¬sm_equal¬: SOURCE_NAME;¶--|............
.....................................................................................¶//  procedure_id¬¬=> ;¶¶##  proced
ure_id¬====>¶##¬include¬null;¶--|.......................................................................................
..........¶//  function_id¬¬=>¶//¬cd_result_size¬: Integer;¶¶##  function_id¬====>¶##¬include¬null;¶--|.................
................................................................................¶//  operator_id¬¬=>¶//¬xd_not_equal¬: o
perator_id;¬¬¬-- "/=" corresponding to "="¶¶##  operator_id¬====>¶##¬include¬null;¶--|..................................
...............................................................¶¶¶¶¶--|-------------------------------------------------
------------------------------------------------¶-- Syntax 6.1.B¶--  subprogram_specification ::=¶--¬ procedure identifi
er [formal_part]¶--     | function designator [formal_part] return type_mark¶--¶--  designator ::= identifier | operator
_symbol¶--¶--  operator_symbol ::= string_literal¶--|-------------------------------------------------------------------
------------------------------¶¶subprogram_specification¬::=¶¬  PROCEDURE  proc_id  procedure_header¶¬| PROCEDURE  proc_
id  nil_procedure_header¶¬| FUNCTION  function_id  function_header¶¬| FUNCTION  def_op  function_header¶¬%%¶--|.........
........................................................................................¶procedure_header¬::=¶¬param_s¬¬
¬¬====> $1 procedure_spec¶¬%%¶--|.......................................................................................
..........¶nil_procedure_header¬::=¶¬nil_param_s¬¬¬¬====> $1 procedure_spec¶¬%%¶--|.....................................
............................................................¶[param_s]¬::=¶¬  nil_param_s¶¬| param_s¶¬%%¶--|............
.....................................................................................¶--** nil_param_s is used for gener
ic instantiation¶nil_param_s¬::=¶¬empty¬¬¬¬====> nil $L param_s¶¬%%¶--|.................................................
................................................¶param_s¬::=¶¬(  parameter_specification{;parameter_specification}  )¬¬=
===> $L param_s¶¬%%¶--|.................................................................................................
¶function_header¬::=¶¬[param_s]  RETURN  type_mark¬¬¬====> $2 function_spec¶¬%%¶--|.....................................
............................................................¶operator_symbol¬::=¶¬used_string¶¬%%¶--|...................
..............................................................................¶¶¶//  HEADER¬¬::=¶//¬SUBP_ENTRY_HEADER;¶¶
##  HEADER¬====>¶##¬if_class¬SUBP_ENTRY_HEADER¶##¬call¬param_s¬@ as_param_s¬HEADER¶##¬call¬SUBP_ENTRY_HEADER¬HEADER¶##¬i
f¬package_spec¶##¬call¬package_spec¬HEADER¶--|..........................................................................
.......................¶//  SUBP_ENTRY_HEADER¬::=¶//¬procedure_spec | function_spec;¶//  SUBP_ENTRY_HEADER¬=>¶//¬as_para
m_s¬: param_s;¶¶##  SUBP_ENTRY_HEADER¬====>¶##¬if¬procedure_spec¶##¬call¬procedure_spec¬SUBP_ENTRY_HEADER¶##¬if¬function
_spec¶##¬call¬function_spec¬SUBP_ENTRY_HEADER¶--|.......................................................................
..........................¶//  procedure_spec¬¬=> ;¶--¬as_param_s¬:param_s¶--¬lx_srcpos¬:Source_Position¶¶##  procedure_
spec¬====>¶##  include¬EMITS.PARAM_SIZE := (EMITS.OFFSET_ACT - EMITS.FIRST_PARAM_OFFSET + EMITS.RELATIVE_RESULT_OFFSET);
¶¶--|.................................................................................................¶//  function_spec
¬¬=>¶//¬as_name¬: NAME;¶--¬as_param_s¬:param_s¶--¬lx_srcpos¬:Source_Position¶¶##  function_spec¬====>¶##  include¬INC_OF
FSET ( EMITS.RELATIVE_RESULT_OFFSET );¶##  include¬EMITS.PARAM_SIZE := ( EMITS.OFFSET_ACT - EMITS.FIRST_PARAM_OFFSET );¶
-- ##  include¬EMITS.RESULT_SIZE := EMITS.TYPE_SIZE ( RESULT_TYPE_SPEC );¬¬--| A VOIR¶##  include¬DI ( CD_RESULT_SIZE, D
 ( AS_NAME, FUNCTION_SPEC ), EMITS.RESULT_SIZE );¶##  include¬INC_OFFSET ( EMITS.RESULT_SIZE );¶##  include¬ALIGN ( STAC
K_AL );¶##  include¬DI ( CD_RESULT_OFFSET, FUNCTION_SPEC, EMITS.OFFSET_ACT );¶##  include¬EMITS.FUN_RESULT_OFFSET := EMI
TS.OFFSET_ACT;¶¶¶¶--|-------------------------------------------------------------------------------------------------¶-
- Syntax 6.1.C¶--  formal_part ::=¶--     (parameter_specification {; parameter_specification})¶--¶--  parameter_specifi
cation ::=¶--     identifier_list : mode type_mark [:= expression]¶--¶--  mode  ::= [in] | in out | out¶--|-------------
------------------------------------------------------------------------------------¶parameter_specification¬::=¶¬  in_s
pecification¶¬| in_out_specification¶¬| out_specification¶¬%%¶--|.......................................................
..........................................¶in_specification¬::=¶¬  identifier  :  in_definition¬¬¬====> $DEF in_id lx_de
fault¶¬| identifier  :  IN  in_definition¬¬¬====> $DEF in_id not_lx_default¶¬| identifier  ,  in_specification¬¬¬====> $
DEF in_id¶¬%%¶--|.................................................................................................¶in_de
finition¬::=¶¬subtype_indication  [:=expression]¬¬¬====> $N3 in¶¬%%¶--|.................................................
................................................¶in_out_specification¬::=¶¬  identifier  :  IN OUT  in_out_definition¬¬=
===> $DEF in_out_id¶¬| identifier  ,  in_out_specification¬¬¬====> $DEF in_out_id¶¬%%¶--|...............................
..................................................................¶in_out_definition¬¬::=¶¬subtype_indication¬¬¬¬====> v
oid $N3 in_out¶¬%%¶--|.................................................................................................¶
out_specification¬::=¶¬  identifier  :  OUT  out_definition¬¬¬====> $DEF out_id¶¬| identifier  ,  out_specification¬¬¬==
==> $DEF out_id¶¬%%¶--|.................................................................................................
¶out_definition¬::=¶¬subtype_indication¬¬¬¬====> void $N3 out¶¬%%¶--|...................................................
..............................................¶¶¶//  param_s¬¬=>¶//¬as_list¬: Seq Of PARAM;¶¶##  param_s¬====>¶##¬repeat
_extract¬param_s¬param¶##¬call¬param¬param¶--|..........................................................................
.......................¶//  DSCRMT_PARAM_DECL¬::=¶//¬PARAM;¶--|.........................................................
........................................¶//  PARAM¬¬::=¶//¬in | out | in_out;¶¶##  PARAM¬====>¶##¬if¬in¶##¬call¬in¬PARAM
¶##¬if¬out¶##¬call¬out¬PARAM¶##¬if¬in_out¶##¬call¬in_out¬PARAM¶¶--|.....................................................
............................................¶//  in¬¬=>¶//¬lx_default¬: BOOLEAN;¶--¬as_source_name_s¬:source_name_s¶--¬a
s_name¬:NAME¶--¬as_exp¬:EXP¶--¬lx_srcpos¬:Source_Position¶¶##  in¬====>¶##¬include¬null;¶--|............................
.....................................................................¶//  in_out¬¬=> ;¶¶##  in_out¬====>¶##¬include¬null
;¶¶//  out¬¬=> ;¶¶##  out¬====>¶##¬include¬null;¶--|....................................................................
.............................¶//  INIT_OBJECT_NAME¬::=¶//¬PARAM_NAME;¶¶##  INIT_OBJECT_NAME¬====>¶##¬if¬number_id¶##¬cal
l¬number_id¬INIT_OBJECT_NAME¶##¬if_class¬VC_NAME¶##¬call¬VC_NAME¬INIT_OBJECT_NAME¶##¬if_class¬COMP_NAME¶##¬call¬COMP_NAM
E¬INIT_OBJECT_NAME¶##¬if_class¬PARAM_NAME¶##¬call¬PARAM_NAME¬INIT_OBJECT_NAME¶--|.......................................
..........................................................¶//  PARAM_NAME¬¬::=¶//¬in_id | PARAM_IO_O;¶//  PARAM_NAME¬¬=>
¶//¬sm_first¬: DEF_NAME,¶//¬cd_level¬: Integer;¶¶##  PARAM_NAME¬====>¶##¬if¬in_id¶##¬call¬in_id¬PARAM_NAME¶##¬if_class¬P
ARAM_IO_O¶##¬call¬PARAM_IO_O¬PARAM_NAME¶--|.............................................................................
....................¶//  PARAM_IO_O¬¬::=¶//¬in_out_id | out_id;¶//  PARAM_IO_O¬¬=>¶//¬cd_addr_offset¬: Integer,¶//¬cd_va
l_offset¬: Integer;¶¶##  PARAM_IO_O¬====>¶##¬if¬in_out_id¶##¬call¬in_out_id¬PARAM_IO_O¶##¬if¬out_id¶##¬call¬out_id¬PARAM
_IO_O¶--|.................................................................................................¶//  in_id¬=>¶
//¬cd_offset¬: Integer;¶¶##  in_id¬====>¶##¬include¬null;¶--|...........................................................
......................................¶//  in_out_id¬=> ;¶¶##  in_out_id¬====>¶##¬include¬null;¶--|.....................
............................................................................¶//  out_id¬=> ;¶¶##  out_id¬====>¶##¬includ
e¬null;¶¶¶¶--|-------------------------------------------------------------------------------------------------¶-- 6.3¬S
ubprogram Bodies¶-- Syntax 6.3¶--  subprogram_body ::=¶--¬subprogram_specification is¶--¬    [declarative_part]¶--¬begin
¶--¬    sequence_of_statements¶--     [exception¶--¬exception_handler¶--¬    {exception_handler}]¶--¬end [designator];¶-
-|-------------------------------------------------------------------------------------------------¶¶subprogram_body¬::=
¶¬  PROCEDURE  proc_id  procedure_header  subprogram_block¬¬====> exch_1 $3 subprogram_body¶¬| PROCEDURE  proc_id  nil_p
rocedure_header  subprogram_block¬====> exch_1 $3 subprogram_body¶¬| FUNCTION  function_id  function_header  subprogram_
block¬¬====> exch_1 $3 subprogram_body¶¬| FUNCTION  def_op  function_header  subprogram_block¬¬====> exch_1 $3 subprogra
m_body¶¬%%¶--|.................................................................................................¶subprogr
am_block¬::=¶¬IS  declarative_part  BEGIN  sequence_of_statements¶¬[EXCEPTION__exception_handler{exception_handler}]¶¬EN
D__[designator]  ;¬¬¬====> $3 block_body¶¬%%¶--|........................................................................
.........................¶END__[designator]¬::=¶¬END¶¬| END  identifier¬¬¬¬====> check_subp_name¶¬| END  string_literal¬
¬¬====> check_subp_name¶¬%%¶--|.........................................................................................
........¶¶¶//  BODY¬¬::=¶//¬block_body | stub;¶##  BODY¬====>¶##¬if¬block_body¶##¬call¬block_body¬BODY¶--|..............
...................................................................................¶//  subprogram_body¬¬=>¶//¬as_header
¬: HEADER;¶--¬as_source_name¬:SOURCE_NAME¶--¬as_body¬:BODY¶--¬lx_srcpos¬:Source_Position¶¶##  subprogram_body¬====>¶¶## 
 include¬DECLARE¶##  include¬   OLD_OFFSET_ACT : OFFSET_TYPE := EMITS.OFFSET_ACT;¬¬--| GARER LES DECALAGES DE L ENGLOBAN
T¶##  include¬   OLD_OFFSET_MAX : OFFSET_TYPE := EMITS.OFFSET_MAX;¶##  include¬   SOURCE_NAME    : TREE := D ( AS_SOURCE
_NAME, SUBPROGRAM_BODY );¬--| RAMENER LE NOM DE SOUS PROGRAMME¶##  include¬   START_LABEL    : LABEL_TYPE := NEXT_LABEL;
¬¬--| ALLOUER UNE ETIQUETTE DE POINT D ENTREE¶##  include¬BEGIN¶##  include¬  IF EMITS.ENCLOSING_BODY = TREE_VOID THEN¬¬
--| Au niveau externe (pas d'imbrication)¶##  include¬    EMIT ( PRO, S=> PRINT_NAME ( D ( LX_SYMREP, SOURCE_NAME ) ) );
¬--| Indiquer la mention "PRO"¶##  include¬  END IF;¶##  include¬  EMITS.OFFSET_ACT := EMITS.FIRST_PARAM_OFFSET;¬¬--| LI
EU DU PREMIER PARAMETRE COMME DECALAGE ACTUEL¶##  include¬  EMITS.OFFSET_MAX := EMITS.OFFSET_ACT;¬¬¬--| ET DECALAGE MAXI
MAL ACTUEL¶##  include¬  INC_LEVEL;¬¬¬¬--| NIVEAU STATIQUE SUIVANT¶##  include¬  DI ( CD_LABEL, SOURCE_NAME, INTEGER ( S
TART_LABEL ) );¬¬--| STOCKER LE NUMERO D ETIQUETTE ENTREE¶##  include¬  DI ( CD_LEVEL, SOURCE_NAME, EMITS.LEVEL );¬¬--| 
STOCKER LE NIVEAU STATIQUE¶##  include¬  WRITE_LABEL ( START_LABEL );¬¬¬--| EMETTRE L ETIQUETTE ENTREE¶##  call¬HEADER¬@
 as_header¬subprogram_body¬¬--| TRAITER LES PARAMETRES D APPEL¶##  include¬  DI ( CD_PARAM_SIZE, SOURCE_NAME, PARAM_SIZE
 );¬¬--| STOCKER LA TAILLE DU PARAMETRAGE MAINTENANT CONNUE¶##  include¬  EMITS.OFFSET_ACT := EMITS.FIRST_LOCAL_VAR_OFFS
ET;¬¬--| REPLACER LES OFFSETS SUR LA PREMIERE VARIABLE LOCALE¶##  include¬  EMITS.OFFSET_MAX := EMITS.OFFSET_ACT;¶##  ca
ll¬BODY¬@ as_BODY¬subprogram_body¬¬--| TRAITER LE CORPS DE SOUS PROGRAMME¶##  include¬  DEC_LEVEL;¬¬¬¬--| REVENIR AU NIV
EAU PRECEDENT¶##  include¬  EMITS.OFFSET_MAX := OLD_OFFSET_MAX;¬¬¬--| RESTAURER LES OFFSETS ANTERIEURS¶##  include¬  EMI
TS.OFFSET_ACT := OLD_OFFSET_ACT;¶##  include¬END;¶¶¶--|-----------------------------------------------------------------
--------------------------------¶-- 6.4¬Subprogram Calls¶-- Syntax 6.4¶--  procedure_call_statement ::=¶--     procedure
_name [actual_parameter_part];¶--¶--  function_call ::=¶--     function_name [actual_parameter_part]¶--¶--  actual_param
eter_part ::=¶--     (parameter_association {, parameter_association})¶--¶--  parameter_association ::=¶--     [formal_p
arameter¬=>] actual_parameter¶--¶--  formal_parameter ::= parameter_simple_name¶--¶--  actual_parameter ::=¶--     expre
ssion | variable_name | type_mark(variable_name)¶--|--------------------------------------------------------------------
-----------------------------¶¶procedure_call_statement¬::=¶¬used_id  ;¬¬¬¬====> nil $L general_assoc_s $2 procedure_cal
l¶¬| selected_component  ;¬¬¬====> nil $L general_assoc_s $2 procedure_call¶¬| name  general_assoc_s  ;¬¬¬====> $2 proce
dure_call¶¬%%¶--|.................................................................................................¶funct
ion_call¬::=¶¬name¶¬%%¶--|..............................................................................................
...¶apply¬::=¶¬name  general_assoc_s¬¬¬====> $2 function_call¶¬%%¶--|...................................................
..............................................¶general_assoc_s¬::=¶¬(  general_assoc{,general_assoc}  )¬¬¬====> $L gener
al_assoc_s¶¬%%¶--|.................................................................................................¶gene
ral_assoc¬::=¶¬argument_association¶¬| simple_expression  ..  simple_expression¬¬====> $2 range¶¬| name range_constraint
¬¬¬====> exch_1 $2 subtype_indication¶¬%%¶--|...........................................................................
......................¶¶¶//  CALL_STM¬¬=> ¶//¬as_general_assoc_s¬¬: general_assoc_s,¶//¬sm_normalized_param_s¬: exp_s;¶-
-|.................................................................................................¶//  procedure_call¬¬
=> ;¶¶##  procedure_call¬====>¶##¬include¬null;¶--|.....................................................................
............................¶//  function_call¬¬=>¶//¬as_general_assoc_s¬¬: general_assoc_s,¶//¬sm_normalized_param_s¬: 
exp_s,¶//¬lx_prefix¬¬: BOOLEAN;¶¶##  function_call¬====>¶##¬include¬null;¶--|...........................................
......................................................¶//  NAMED_ASSOC¬¬::=¶//¬assoc;¶--|...............................
..................................................................¶//  assoc¬¬=>¶//¬as_used_name¬: USED_NAME;¶¶¶¶--|||||
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||¶-- 7.  Packages¶--||||||||
||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||¶-- 7.1¬Package Structure¶-- S
yntax 7.1.A¶--  package_declaration ::= package_specification;¶--|------------------------------------------------------
-------------------------------------------¶¶//  package_decl¬¬=> ;¶--¬as_source_name¬:SOURCE_NAME¶--¬as_header¬:HEADER¶
--¬as_unit_kind¬:UNIT_KIND¶--¬lx_srcpos¬:Source_Position¶¶##  package_decl¬====>¶##  include¬EMIT ( PKG, S=> PRINT_NAME 
( D ( LX_SYMREP, D ( AS_SOURCE_NAME, PACKAGE_DECL ) ) ) );¶##  include¬WRITE_LABEL ( 1 );¶##  include¬DECLARE¶##  includ
e¬  L1 : LABEL_TYPE := NEXT_LABEL;¶##  include¬  L2 : LABEL_TYPE := NEXT_LABEL;¶##  include¬BEGIN¶##  include¬  EMIT ( E
NT, Integer( 1 ), L1 );¬¬¬--| DEUX ENTER LABELS POUR LES VALEURS DE PILE MAX AFFECTEES EN FIN¶##  include¬  EMIT ( ENT, 
Integer( 2 ), L2 );¶##  include¬  EMITS.OFFSET_ACT := 0;¬¬¬--| RAZ DES OFFSETS¶##  include¬  EMITS.OFFSET_MAX := 0;¶##  
call¬HEADER¬@ as_header¬package_decl¬¬--| ACTION HEADER SUR CHAMP AS_HEADER¶##  include¬  DECLARE¶##  include¬    EXC_LB
L : LABEL_TYPE := NEXT_LABEL;¬¬¬--| ETIQUETTE DE DEBUT DU HANDLER EXCEPTIONS¶##  include¬  BEGIN¶##  include¬    EMIT ( 
EXH, EXC_LBL, COMMENT=> "ETIQUETTE EXCEPTION HANDLE DU PACKAGE" );¶##  include¬    EMIT ( RET, RELATIVE_RESULT_OFFSET );
¶##  include¬    WRITE_LABEL ( EXC_LBL );¶##  include¬  END;¶##  include¬  EMIT ( EEX );¬¬¬¬--| FIN DE HANDLER EXCEPTION
S¶##  include¬  GEN_LBL_ASSIGNMENT ( L1, OFFSET_MAX );¬¬--| OFFSET MAX ASSIGNE AU LABEL L1¶##  include¬  GEN_LBL_ASSIGNM
ENT ( L2, TOP_MAX + OFFSET_MAX );¬¬--| PILE MAX ASSIGNE AU LABEL L2¶##  include¬END;¶--|................................
.................................................................¶//  SUBPROG_PACK_NAME¬::=¶//¬package_id;¶--|..........
.......................................................................................¶//  package_id¬¬=> ;¶¶##  packag
e_id¬====>¶##¬include¬null;¶¶¶¶--|--------------------------------------------------------------------------------------
-----------¶-- Syntax 7.1.B¶--  package_specification ::=¶--     package identifier is¶--¬    {basic_declarative_item}¶-
-     [private¶--¬    {basic_declarative_item}]¶--     end [package_simple_name]¶--|------------------------------------
-------------------------------------------------------------¶¶package_declaration¬::=¶¬PACKAGE  package_id  package_def
inition  END__[simple_name]  ;¬====> void $3 package_decl¶¬%%¶--|.......................................................
..........................................¶package_id¬::=¶¬identifier¬¬¬¬====> $0 package_id lx_symrep¶¬%%¶--|..........
.......................................................................................¶package_definition¬::=¶¬IS  decl
_s  [PRIVATE__decl_s]¬¬¬====> $2 package_spec¶¬%%¶--|...................................................................
..............................¶[PRIVATE__decl_s]¬::=¶¬  empty¬¬¬¬====> nil $L decl_s¶¬| PRIVATE  decl_s¶¬%%¶--|.........
........................................................................................¶decl_s¬::=¶¬{pragma}  {basic_de
clarative_item{pragma}}¬¬====> cat $L decl_s¶¬%%¶--|....................................................................
.............................¶END__[simple_name]¬::=¶¬  END¶¬| END  identifier¬¬¬¬====> check_name¶¬%%¶--|..............
...................................................................................¶¶¶//  package_spec¬¬=>¶//¬as_decl_s1
¬: decl_s,¶//¬as_decl_s2¬: decl_s,¶//   ¬xd_body_is_required¬: BOOLEAN;¶¶##  package_spec¬====>¶##¬call¬decl_s¬@ as_decl
_s1¬package_spec¶--|.................................................................................................¶//
  decl_s¬¬=>¶//¬as_list¬: Seq Of DECL;¶¶##  decl_s¬====>¶##¬repeat_extract¬decl_s¬decl¶##¬call¬DECL¬decl¶¶¶¶--|---------
----------------------------------------------------------------------------------------¶-- Syntax 7.1.C¶--  package_bod
y ::=¶--¬package body package_simple_name is¶--¬    [declarative_part]¶--     [begin¶--¬ sequence_of_statements¶--     [
exception¶--¬exception_handler¶--¬    {exception_handler}]]¶--¬end [package_simple_name];¶--|---------------------------
----------------------------------------------------------------------¶¶package_body¬::=¶¬PACKAGE  BODY  package_id  pac
kage_block¬¬====> $2 package_body¶¬%%¶--|...............................................................................
..................¶package_block¬::=¶¬  IS  declarative_part  BEGIN  sequence_of_statements¶¬  [EXCEPTION__exception_han
dler{exception_handler}]¶¬  END__[designator]  ;¬¬¬====> $3 block_body¶¬| IS  declarative_part  END__[designator]  ;¬¬==
==> nil $L stm_s nil $L alternative_s $3 block_body¶¬%%¶--|.............................................................
....................................¶¶¶//  package_body¬¬=> ;¶¶##  package_body¬====>¶##  include¬EMIT ( PKB, S=> PRINT_
NAME ( D ( LX_SYMREP, D ( AS_SOURCE_NAME, PACKAGE_BODY ) ) ) );¶##  include¬EMITS.GENERATE_CODE := FALSE;¶##  call¬packa
ge_spec¬@ sm_spec @ as_source_name package_body¶##  include¬EMITS.GENERATE_CODE := TRUE;¶##  include¬WRITE_LABEL ( 1 );¶
##  call¬BODY¬@ as_body  package_body¶¶¶¶--|----------------------------------------------------------------------------
---------------------¶-- 7.4¬Private Type and Deferred Constant Declarations¶-- Syntax 7.4.A¶--  private_type_declaratio
n ::=¶--     type identifier [discriminant_part] is [limited] private;¶--|----------------------------------------------
---------------------------------------------------¶¶private_type_declaration¬::=¶¬  TYPE  identifier¬[discriminant_part
]__IS  LIMITED  PRIVATE  ;¬====> $0 l_private_def $V3 type_decl $DEF l_private_type_id¶¬| TYPE  identifier¬[discriminant
_part]__IS  PRIVATE  ;¬¬====> $0 private_def $V3 type_decl $DEF private_type_id¶¬%%¶--|.................................
................................................................¶[discriminant_part]__IS¬::=¶¬  IS¬¬¬¬====> nil $L dscrm
t_decl_s¶¬| discriminant_part  IS¶¬%%¶--|...............................................................................
..................¶¶¶//  TYPE_DEF¬¬::=¶//¬private_def | l_private_def;¶--|..............................................
...................................................¶//  private_def¬¬=> ;¶--|...........................................
......................................................¶//  l_private_def¬¬=> ;¶--|......................................
...........................................................¶//  TYPE_NAME¬¬::=¶//¬private_type_id | l_private_type_id;¶-
-|.................................................................................................¶//  private_type_id¬
¬=> ;¶¶##  private_type_id¬====>¶##¬include¬null;¶--|...................................................................
..............................¶//  l_private_type_id¬=> ;¶¶##  l_private_type_id¬====>¶##¬include¬null;¶--|.............
....................................................................................¶//  PRIVATE_SPEC¬¬::=¶//¬private | 
l_private;¶//  PRIVATE_SPEC¬¬=>¶//¬sm_discriminant_s¬: dscrmt_decl_s,¶//¬sm_type_spec¬: TYPE_SPEC;¶--|..................
...............................................................................¶//  private¬¬=> ;¶--|...................
..............................................................................¶//  l_private¬¬=> ;¶¶¶¶--|---------------
----------------------------------------------------------------------------------¶-- Syntax 7.4.B¶--  deferred_constant
_declaration ::=¶--     identifier_list : constant type_mark;¶--|-------------------------------------------------------
------------------------------------------¶--** See 3.2.A¶¶//  deferred_constant_decl¬=>¶//¬as_name¬: NAME;¶¶##  deferre
d_constant_decl¬====>¶##¬include¬null;¶¶¶¶--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
||||||||||||||||||||||¶-- 8.  Visibility Rules¶--|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|||||||||||||||||||||||||||¶-- 8.4¬Use Clauses¶-- Syntax 8.4¶--  use_clause ::= use package_name {, package_name};¶--|--
-----------------------------------------------------------------------------------------------¶¶use_clause¬::=¶¬USE  ex
panded_name{,expanded_name}  ;¬¬¬====> $L name_s $1 use¶¬%%¶--|.........................................................
........................................¶¶¶//  use¬¬=>¶//¬as_name_s¬: name_s;¶¶¶¶--|------------------------------------
-------------------------------------------------------------¶-- 8.5¬Renaming Declarations¶-- Syntax 8.5¶--  renaming_de
claration ::=¶--¬ identifier : type_mark    renames object_name;¶--     | identifier : exception    renames exception_na
me;¶--     | package identifier¬   renames package_name;¶--     | subprogram_specification  renames subprogram_or_entry_
name;¶--|-------------------------------------------------------------------------------------------------¶¶renaming_dec
laration ::=¶¬  identifier  :  renamed_var_definition  ;¬¬====> $DEF variable_id¶¬| identifier  :  renamed_exception_def
inition  ;¬¬====> $DEF exception_id¶¬| PACKAGE  package_id  renames_unit  ;¬¬¬====> void exch_1 $3 package_decl¶¬| subpr
ogram_specification  renames_unit  ;¬¬====> $3 subprog_entry_decl¶¬%%¶--|...............................................
..................................................¶--** var_id will be replaced by const_id if necessary¶¶renamed_var_de
finition¬::=¶¬type_mark  RENAMES  name¬¬¬====> exch_1 $V3 renames_obj_decl¶¬%%¶--|......................................
...........................................................¶renamed_exception_definition¬::=¶¬EXCEPTION  RENAMES  name¬¬
¬====> $V2 renames_exc_decl¶¬%%¶--|.....................................................................................
............¶renames_unit¬::=¶¬RENAMES  name¬¬¬¬====> $1 renames_unit¶¬%%¶--|...........................................
......................................................¶¶¶//  ID_DECL¬¬::=¶//¬SIMPLE_RENAME_DECL;¶--|....................
.............................................................................¶//  SIMPLE_RENAME_DECL¬::=¶//¬renames_obj_
decl | renames_exc_decl;¶//  SIMPLE_RENAME_DECL¬=>¶//¬as_name¬: NAME;¶--|...............................................
..................................................¶//  renames_obj_decl¬=>¶//¬as_type_mark_name¬: NAME;¶--|.............
....................................................................................¶//  renames_exc_decl¬=> ;¶--|......
...........................................................................................¶//  UNIT_KIND¬¬::=¶//¬RENAME
_INSTANT;¶--|.................................................................................................¶//  RENAM
E_INSTANT¬¬::=¶//¬renames_unit;¶//  RENAME_INSTANT¬¬=>¶//¬as_name¬: NAME;¶--|...........................................
......................................................¶//  renames_unit¬¬=> ;¶¶¶¶--|||||||||||||||||||||||||||||||||||||
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||¶-- 9.  Tasks¶--|||||||||||||||||||||||||||||||||||||||||||
|||||||||||||||||||||||||||||||||||||||||||||||||||||||¶-- 9.1¬Task Specifications and Task Bodies¶-- Syntax 9.1.A¶--  t
ask_declaration ::= task_specification;¶--¶--  task_specification ::=¶--     task [type] identifier [is¶--¬    {entry_de
claration}¶--¬    {representation_clause}¶--     end [task_simple_name]]¶--|--------------------------------------------
-----------------------------------------------------¶¶task_declaration¬::=¶¬  TASK  TYPE  type_id  task_spec  ;¬¬¬====>
 $2 task_decl¶¬| TASK  variable_id  task_spec  ;¬¬¬====> $2 task_decl¶¬%%¶--|...........................................
......................................................¶task_spec¬::=¶¬  empty¬¬¬¬====> nil $L decl_s¶¬| IS  entry_list  
END__[simple_name]¶--** ??? Need to check all the END__[...]'s¶¬%%¶--|..................................................
...............................................¶type_id¬::=¶¬identifier¬¬¬¬====> $0 type_id lx_symrep¶¬%%¶--|...........
......................................................................................¶variable_id¬::=¶¬identifier¬¬¬¬==
==> $0 variable_id lx_symrep¶¬%%¶--|....................................................................................
.............¶entry_list¬::=¶¬{pragma}  {entry_declaration{pragma}}  {representation_clause{pragma}}¬====> cat cat $L de
cl_s¶¬%%¶--|.................................................................................................¶¶¶//  task
_decl¬¬=>¶//¬as_decl_s¬: decl_s;¶¶##  task_decl¬====>¶##¬include¬null;¶--|..............................................
...................................................¶//  task_spec¬¬=>¶//¬sm_decl_s¬: decl_s,¶//¬sm_body¬: BODY,¶//¬sm_ad
dress¬: EXP,¶//¬sm_size¬: EXP,¶//¬sm_storage_size¬: EXP,¶//¬xd_stub¬: stub,¶//¬xd_body¬: SUBUNIT_BODY;¶¶¶¶--|-----------
--------------------------------------------------------------------------------------¶-- Syntax 9.1.B¶--  task_body ::=
¶--¬task body task_simple_name is¶--¬    [declarative_part]¶--¬begin¶--¬    sequence_of_statements¶--     [exception¶--¬
exception_handler¶--¬    {exception_handler}]¶--¬end [task_simple_name];¶--|--------------------------------------------
-----------------------------------------------------¶¶task_body¬::=¶¬TASK  BODY  task_body_id  subprogram_block¬¬====> 
$2 task_body¶¬%%¶--|.................................................................................................¶ta
sk_body_id¬::=¶¬identifier¬¬¬¬====> $0 task_body_id lx_symrep¶¬%%¶--|...................................................
..............................................¶¶¶//  task_body¬¬=> ;¶¶##  task_body¬====>¶##¬include¬null;¶--|..........
.......................................................................................¶//  UNIT_NAME¬¬::=¶//¬task_body_
id;¶--|.................................................................................................¶//  task_body_i
d¬¬=>¶//¬sm_type_spec¬: TYPE_SPEC,¶//¬sm_body¬: BODY;¶¶##  task_body_id¬====>¶##¬include¬null;¶¶¶¶--|-------------------
------------------------------------------------------------------------------¶-- 9.4 Task Dependence - Termination of T
asks¶--|-------------------------------------------------------------------------------------------------¶¶//  ALL_DECL¬
¬::=¶//¬block_master;¶--|...............................................................................................
..¶//  block_master¬¬=>¶//¬sm_stm¬: STM;¶¶¶¶--|-------------------------------------------------------------------------
------------------------¶-- 9.5¬Entries, Entry Calls and Accept Statements¶-- Syntax 9.5.A¶--  entry_declaration ::=¶-- 
    entry identifier [(discrete_range)] [formal_part];¶--|--------------------------------------------------------------
-----------------------------------¶¶entry_declaration¬::=¶¬ENTRY  entry_id  entry_header  ;¬¬¬====> void $3 subprog_ent
ry_decl¶¬%%¶--|.................................................................................................¶entry_i
d¬::=¶¬identifier¬¬¬¬====> $0 entry_id lx_symrep¶¬%%¶--|................................................................
.................................¶entry_header¬::=¶¬  [param_s]¬¬¬¬====> void $2 entry¶¬| (  discrete_range  )  [param_s
]¬¬¬====> exch_1 $2 entry¶¶¬%%¶--|......................................................................................
...........¶¶¶//  SUBP_ENTRY_HEADER¬::=¶//¬entry;¶--|...................................................................
..............................¶//  entry¬¬=>¶//¬as_discrete_range¬: DISCRETE_RANGE;¶--|.................................
................................................................¶//  SOURCE_NAME¬::=¶//¬entry_id;¶--|...................
..............................................................................¶//  entry_id¬¬=>¶//¬sm_spec¬: HEADER,¶//¬
sm_address¬: EXP;¶¶##  entry_id¬====>¶##¬include¬null;¶¶¶¶--|-----------------------------------------------------------
--------------------------------------¶-- Syntax 9.5.B¶--  entry_call_statement ::= entry_name [actual_parameter_part];¶
--|-------------------------------------------------------------------------------------------------¶¶entry_call_stateme
nt¬::=¶¬  used_id  ;¬¬¬¬====> nil $L general_assoc_s $2 entry_call¶¬| selected_component  ;¬¬¬====> nil $L general_assoc
_s $2 entry_call¶¬| name  general_assoc_s  ;¬¬¬====> $2 entry_call¶¬%%¶--|..............................................
...................................................¶¶¶//  entry_call¬¬=> ;¶¶##  entry_call¬====>¶##¬include¬null;¶¶¶¶--|
-------------------------------------------------------------------------------------------------¶-- Syntax 9.5.C¶--  ac
cept_statement ::=¶--     accept entry_simple_name [(entry_index)] [formal_part] [do¶--¬    sequence_of_statements¶--   
  end [entry_simple_name]];¶--¶--  entry_index ::= expression¶--|-------------------------------------------------------
------------------------------------------¶¶accept_statement¬::=¶¬ACCEPT  accept_name__[param_s]¶¬[DO__sequence_of_state
ments__END[entry_simple_name]]  ;¬¬====> $3 accept¶¬%%¶--|..............................................................
...................................¶accept_name__[param_s]¬::=¶¬  used_name_id¬¬¬¬====> void¶¬| used_name_id param_s¶¬| 
used_name_id__(entry_index)  [param_s]¶¬%%¶--|..........................................................................
.......................¶used_name_id__(entry_index)¬::=¶¬used_name_id  (  expression  )¬¬¬====> list $L exp_s $2 indexed
¶¬%%¶--|.................................................................................................¶[DO__sequence_
of_statements__END[entry_simple_name]]¬::=¶¬  empty¬¬¬¬====> nil $L stm_s¶¬| DO  sequence_of_statements  END__[entry_sim
ple_name]¶¬%%¶--|.................................................................................................¶END__
[entry_simple_name]¬::=¶¬  END¶¬| END  identifier ¬¬¬¬====> check_accept_name¶¬%%¶--|...................................
..............................................................¶¶¶//  accept¬¬=>¶//¬as_name¬: NAME,¶//¬as_param_s¬: param
_s,¶//¬as_stm_s¬: stm_s;¶¶##  accept¬====>¶##¬include¬null;¶¶¶¶--|------------------------------------------------------
-------------------------------------------¶-- 9.6¬Delay Statements, Duration and Time¶-- Syntax 9.6¶--  delay_statement
 ::= delay simple_expression;¶--|---------------------------------------------------------------------------------------
----------¶¶delay_statement¬::=¶¬DELAY  simple_expression  ;¬¬¬====> $1 delay¶¬%%¶--|...................................
..............................................................¶¶//  delay¬¬=> ;¶¶##  delay¬====>¶##¬include¬null;¶¶¶¶--|
-------------------------------------------------------------------------------------------------¶-- 9.7¬Select Statemen
ts¶-- Syntax 9.7¶--  select_statement ::= selective_wait¶--     | conditional_entry_call | timed_entry_call¶--|---------
----------------------------------------------------------------------------------------¶¶select_statement¬::=¶¬selectiv
e_wait | conditional_entry_call | timed_entry_call¶¬%%¶¶¶¶--|-----------------------------------------------------------
--------------------------------------¶-- 9.7.1  Selective Waits¶-- Syntax 9.7.1.A¶--  selective_wait ::=¶--¬select¶--¬ 
   select_alternative¶--     {or¶--¬    select_alternative}¶--     [else¶--¬    sequence_of_statements]¶--¬end select;¶-
- select_alt_pragma ::= pragma ¬¬====> $1 select_alt_pragma¶--** -- parsed as stm_pragma; must be changed in test_clause
_elem_s¶--|-------------------------------------------------------------------------------------------------¶¶selective_
wait¬::=¶¬SELECT  select_clause_s¶¬[ELSE__sequence_of_statements]¶¬END  SELECT  ;¬¬¬¬====> $2 selective_wait¶¬%%¶--|....
.............................................................................................¶select_clause_s¬::=¶¬selec
t_alternative_list¬¬¬====> $L test_clause_elem_s¶¬%%¶--|................................................................
.................................¶select_alternative_list¬::=¶¬select_alternative¬¬¬¬====> list¶¬| {stm_pragma}  when_se
lect_alternative¬¬¬====> append¶¬| select_alternative_list  OR  select_alternative¬¬====> append¶¬| select_alternative_l
ist  OR  {stm_pragma}  when_select_alternative¬====> append cat¶¬%%¶--|.................................................
................................................¶[ELSE__sequence_of_statements]¬::=¶¬  empty¬¬¬¬====> nil $L stm_s¶¬| EL
SE  sequence_of_statements¶¬%%¶--|......................................................................................
...........¶¶¶//  selective_wait¬¬=> ;¶¶##  selective_wait¬====>¶##¬include¬null;¶¶¶¶--|--------------------------------
-----------------------------------------------------------------¶-- Syntax 9.7.1.B¶--  selective_alternative ::=¶--    
 [when condition¬=>]¶--¬    selective_wait_alternative¶--¶--  selective_wait_alternative ::= accept_alternative¶--     |
 delay_alternative | terminate_alternative¶--¶--  accept_alternative ::= accept_statement [sequence_of_statements]¶--¶--
  delay_alternative ::= delay_statement  [sequence_of_statements]¶--¶--  terminate_alternative ::= terminate;¶--|-------
------------------------------------------------------------------------------------------¶¶when_select_alternative¬::=¶
¬WHEN  expression  =>  selective_wait_alternative¬¬====> $2 select_alternative¶¬%%¶--|..................................
...............................................................¶select_alternative¬::=¶¬| selective_wait_alternative ¬¬¬
====> $V2 select_alternative¶¬%%¶--|....................................................................................
.............¶selective_wait_alternative¬::=¶¬accept_alternative | delay_alternative | terminate_alternative¶¬%%¶--|....
.............................................................................................¶accept_alternative¬::=¶¬ac
cept_statement[sequence_of_statements]¶¬%%¶--|..........................................................................
.......................¶delay_alternative ::= delay_statement[sequence_of_statements]¶¶¬%%¶--|..........................
.......................................................................¶terminate_alternative¬::=¶¬{stm_pragma}  termina
te  {stm_pragma}¬¬¬====> insert cat $L stm_s¶¬%%¶--|....................................................................
.............................¶terminate¬::=¶¬TERMINATE  ;¬¬¬¬====> $0 terminate¶¬%%¶--|.................................
................................................................¶accept_statement[sequence_of_statements]¬::=¶¬  {stm_pr
agma}  accept_statement  {stm_pragma}  stm_s_tail¬¬====> cat insert cat $L stm_s¶¬| {stm_pragma}  accept_statement¬¬¬===
=> append $L stm_s¶¬%%¶--|..............................................................................................
...¶delay_statement[sequence_of_statements]¬::=¶¬  {stm_pragma}  delay_statement  {stm_pragma}  stm_s_tail¬¬====> cat in
sert cat $L stm_s¶¬| {stm_pragma}  delay_statement¬¬¬====> append $L stm_s¶¬%%¶--|......................................
...........................................................¶¶¶//  TEST_CLAUSE_ELEM¬::=¶//¬TEST_CLAUSE | select_alt_pragm
a;¶¶##  TEST_CLAUSE_ELEM¬====>¶##¬if_class¬TEST_CLAUSE¶##¬call¬TEST_CLAUSE¬TEST_CLAUSE_ELEM¶##¬if¬select_alt_pragma¶##¬c
all¬select_alt_pragma¬TEST_CLAUSE_ELEM¶--|..............................................................................
...................¶//  TEST_CLAUSE¬¬::=¶//¬select_alternative;¶¶--|....................................................
.............................................¶//  test_clause_elem_s¬=>¶//¬as_list¬: Seq Of TEST_CLAUSE_ELEM;¶¶##  test_
clause_elem_s¬====>¶##¬repeat_extract¬test_clause_elem_s¬test_clause_elem¶##¬call¬TEST_CLAUSE_ELEM¬test_clause_elem¶--|.
................................................................................................¶//  select_alternative¬
=> ;¶¶##  select_alternative¬====>¶##¬include¬null;¶--|.................................................................
................................¶//  select_alt_pragma¬=>¶//¬as_pragma¬: pragma;¶¶##  select_alt_pragma¬====>¶##¬include
¬null;¶--|.................................................................................................¶//  STM¬¬::=
¶//¬terminate;¶--|.................................................................................................¶//  
terminate¬¬=> ;¶¶##  terminate¬====>¶##¬include¬null;¶¶¶¶--|------------------------------------------------------------
-------------------------------------¶-- 9.7.2  Conditional Entry Calls¶-- Syntax 9.7.2¶--  conditional_entry_call ::=¶-
-     select¶--¬entry_call_statement¶--¬    [sequence_of_statements]¶--     else¶--¬    sequence_of_statements¶--     en
d select;¶--|-------------------------------------------------------------------------------------------------¶¶conditio
nal_entry_call¬::=¶¬SELECT  entry_call_statement[sequence_of_statements]¶¬ELSE  sequence_of_statements  END  SELECT  ;¬¬
====> $2 cond_entry¶¬%%¶--|.............................................................................................
....¶entry_call_statement[sequence_of_statements]¬::=¶¬  {stm_pragma}  entry_call_statement  {stm_pragma}  stm_s_tail¬==
==> cat insert cat $L stm_s¶¬| {stm_pragma}  entry_call_statement¬¬¬====> append $L stm_s¶¬%%¶--|.......................
..........................................................................¶¶¶//  ENTRY_STM¬¬::=¶//¬cond_entry | timed_en
try;¶//  ENTRY_STM¬¬=>¶//¬as_stm_s1¬: stm_s,¶//¬as_stm_s2¬: stm_s;¶¶##  ENTRY_STM¬====>¶##¬if¬cond_entry¶##¬call¬cond_en
try¬ENTRY_STM¶##¬if¬timed_entry¶##¬call¬timed_entry¬ENTRY_STM¶--|.......................................................
..........................................¶//  cond_entry¬¬=> ;¶¶##  cond_entry¬====>¶##¬include¬null;¶¶¶¶--|-----------
--------------------------------------------------------------------------------------¶-- 9.7.3  Timed Entry Calls¶¶-- S
yntax 9.7.3¶--  timed_entry_call ::=¶--     select¶--¬entry_call_statement¶--¬    [sequence_of_statements]¶--     or¶--¬
delay_alternative¶--     end select;¶--|--------------------------------------------------------------------------------
-----------------¶¶timed_entry_call¬::=¶¬SELECT  entry_call_statement[sequence_of_statements]¶¬OR  delay_alternative  EN
D  SELECT  ;¬¬¬====> $2 timed_entry¶¬%%¶--|.............................................................................
....................¶¶¶//  timed_entry¬¬=> ;¶¶##  timed_entry¬====>¶##¬include¬null;¶¶¶¶--|-----------------------------
--------------------------------------------------------------------¶-- 9.10  Abort Statements¶-- Syntax 9.10¶--  abort_
statement ::= abort task_name {, task_name};¶--|------------------------------------------------------------------------
-------------------------¶¶abort_statement¬::=¶¬ABORT  name_s  ;¬¬¬¬====> $1 abort¶¬%%¶--|..............................
...................................................................¶name_s¬::=¶¬name{,name}¬¬¬¬====> $L name_s¶¬%%¶--|..
...............................................................................................¶¶¶//  name_s¬¬=>¶//¬as_l
ist¬: Seq Of NAME;¶¶##  name_s¬====>¶##¬repeat_extract¬name_s¬name¶##¬call¬NAME¬name¶--|................................
.................................................................¶//  abort¬¬=>¶//¬as_name_s¬: name_s;¶¶##  abort¬====>¶
##¬include¬null;¶¶¶--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||¶
-- 10.¬Program Structure and Compilation Issues¶--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
||||||||||||||||||||||||||||¶-- 10.1  Compilation Units - Library Units¶-- Syntax 10.1.A¶--  compilation ::= {compilatio
n_unit}¶--|-------------------------------------------------------------------------------------------------¶¶compilatio
n¬::=¶¬  pragma_only_unit  {compilation_unit}¬¬¬====> insert $L compltn_unit_s $1 compilation¶¬| {compilation_unit}¬¬¬==
==> $L compltn_unit_s $1 compilation¶¬%%¶--|............................................................................
.....................¶pragma_only_unit¬::=¶¬null_context  pragma_s¬¬¬====> $3 compilation_unit¶¬%%¶--|..................
...............................................................................¶null_context¬::=¶¬empty¬¬¬¬====> nil $L 
context_elem_s void¶¬%%¶--|.............................................................................................
....¶--** pragma_only_unit records pragmas at beginning of compilation¶--** pragmas at end of compilation_unit are parse
d as part of unit¶¶¶//  compilation¬¬=>¶//¬as_compltn_unit_s¬: compltn_unit_s;¶¶##  compilation¬====>¬¬¬¬--| Action sur 
compilation¶##¬call¬compltn_unit_s¬@ as_compltn_unit_s compilation¬--| Appliquer l'action compltn_unit_s sur le champ as
_compltn_unit_s¶--|.................................................................................................¶// 
 compltn_unit_s¬¬=>¶//¬as_list¬: Seq Of compilation_unit;¶¶##  compltn_unit_s¬====>¬¬¬¬--| ACTION SUR LA LISTE DES UNITE
S DE COMPILATION¶##  repeat_extract¬compltn_unit_s¬compltn_unit¬¬¬--| EXTRACTION D UN ELEMENT¶##  include¬EMITS.OPEN_OUT
PUT_FILE ( GET_LIB_PREFIX & PRINT_NAME ( D ( XD_LIB_NAME, COMPLTN_UNIT ) ) );¶##  call¬compilation_unit¬compltn_unit¬¬¬-
-| ACTION COMPILATION_UNIT SUR L UNITE EXTRAITE¶##  include¬EMITS.CLOSE_OUTPUT_FILE;¬¬¬--| FERMER LE FICHIER¶¶¶¶--|-----
--------------------------------------------------------------------------------------------¶-- Syntax 10.1.B¶--  compil
ation_unit ::=¶--     context_clause library_unit | context_clause secondary_unit¶--¶--  library_unit ::=¶--¬ subprogram
_declaration| package_declaration¶--     | generic_declaration   | generic_instantiation¶--     | subprogram_body¶--¶-- 
 secondary_unit ::= library_unit_body | subunit¶--¶--  library_unit_body ::= subprogram_body | package_body¶--|---------
----------------------------------------------------------------------------------------¶¶compilation_unit¬::=¶¬  contex
t_clause  library_unit  [pragma_s]¬¬====> $3 compilation_unit¶¬| context_clause  secondary_unit  [pragma_s]¬¬====> $3 co
mpilation_unit¶¬%%¶--|.................................................................................................¶
library_unit¬::=¶¬  subprogram_declaration¬| package_declaration¶¬| generic_declaration¬| generic_instantiation¶¬| subpr
ogram_body¶¬%%¶--|.................................................................................................¶seco
ndary_unit¬::=¶¬library_unit_body | subunit¶¬%%¶--|.....................................................................
............................¶library_unit_body¬::=¶¬subprogram_body__|__package_body¶¬%%¶--|............................
.....................................................................¶subprogram_body__|__package_body¬::=¶¬package_body
¶¬%%¶--|.................................................................................................¶¶--|..........
.......................................................................................¶//  pragma_s¬¬=>¶//¬as_list¬: Se
q Of pragma;¶--|.................................................................................................¶//  co
mpilation_unit¬=>¶//¬as_context_elem_s¬: context_elem_s,¶//¬as_all_decl¬: ALL_DECL,¶//¬as_pragma_s¬: pragma_s,¶//¬xd_tim
estamp¬: Integer,¶//¬xd_with_list¬: Seq Of trans_with,¶//¬xd_nbr_pages¬: Integer,¶//¬xd_parent¬: compilation_unit,¶//¬xd
_lib_name¬: symbol_rep;¶¶##  compilation_unit¬====>¬¬¬--| ACTION SUR compilation_unit¶##  include¬EMITS.TOP_ACT := 0;¬¬¬
¬--| HAUT DE PILE A ZERO¶##  include¬EMITS.TOP_MAX := 0;¬¬¬¬--| HAUT MAXIMAL DE PILE AUSSI¶##  include¬EMITS.OFFSET_ACT 
:= 0;¬¬¬--| DECALAGE SUR PILE A ZERO¶##  include¬EMITS.OFFSET_MAX := 0;¬¬¬--| DECALAGE MAX AUSSI¶##  include¬EMITS.LEVEL
 := 0;¬¬¬¬--| NIVEAU D IMBRICATION ZERO¶##  include¬EMITS.GENERATE_CODE := FALSE;¬¬¬--| NE PAS GENERER ENCORE LE CODE¶##
  include¬EMITS.CUR_COMP_UNIT := 2;¬¬¬--| UNITE DE COMPILATION NUMERO 2 (STANDARD ET SYSTEM AVANT)¶##  include¬EMITS.ENC
LOSING_BODY := Tree_VOID;¬¬¬--| PAS D ENGLOBANT¶##  call¬context_elem_s¬@ as_context_elem_s¬compilation_unit¬¬--| TRAITE
R LA LISTE DE CONTEXTE (PRAGMA ET WITH)¶##  include¬EMITS.CUR_COMP_UNIT := 0;¬¬¬--| SE REPLACER SUR L UNITE 0 (STANDARD)
¶##  include¬EMITS.GENERATE_CODE := TRUE;¬¬¬--| GENERER LE CODE¶##  call¬ALL_DECL¬@ as_all_decl¬compilation_unit¬¬--| AP
PLIQUER L ACTION ALL_DECL SUR LE CHAMP as_all_decl¶##  include¬EMIT ( QUIT );¶--|.......................................
..........................................................¶//  CONTEXT_ELEM¬¬::=¶//¬context_pragma;¶¶##  CONTEXT_ELEM¬==
==>¶##¬if¬context_pragma¶##¬call¬context_pragma¬CONTEXT_ELEM¶##¬if¬with¶##¬call¬with¬CONTEXT_ELEM¶--|...................
..............................................................................¶//  context_pragma¬¬=>¶//¬as_pragma¬: pra
gma;¶¶##  context_pragma¬====>¶##¬include¬null;¶¶¶¶--|------------------------------------------------------------------
-------------------------------¶-- Syntax 10.1.1.A¶--  context_clause ::= {with_clause {use_clause}}¶--|----------------
---------------------------------------------------------------------------------¶¶context_clause¬::=¶¬{with_clause}¬¬¬¬
====> $L context_elem_s¶¬%%¶--|.........................................................................................
........¶¶¶//  context_elem_s¬¬=>¶//¬as_list¬: Seq Of CONTEXT_ELEM;¶¶##  context_elem_s¬====>¶##¬repeat_extract¬context_
elem_s¬context_elem¶##¬call¬CONTEXT_ELEM¬context_elem¶¶¶¶--|------------------------------------------------------------
-------------------------------------¶-- Syntax 10.1.1.B¶--  with_clause ::= with unit_simple_name {, unit_simple_name};
¶--|-------------------------------------------------------------------------------------------------¶¶with_clause¬::=¶¬
WITH  name_s  ;  use_pragma_s¬¬¬====> $2 with¶¬%%¶--|...................................................................
..............................¶use_pragma_s¬::=¶¬{pragma}  {use_clause{pragma}}¬¬¬====> cat $L use_pragma_s¶¬%%¶--|.....
............................................................................................¶¶¶//  CONTEXT_ELEM¬¬::=¶//¬
with;¶--|.................................................................................................¶//  with¬¬=>¶
//¬as_name_s¬: name_s,¶//¬as_use_pragma_s¬: use_pragma_s;¶--¬lx_srcpos¬:Source_Position¶¶##  with¬====>¶##¬call¬name_s¬@
 as_NAME_S¬with¶--|.................................................................................................¶// 
 use_pragma_s¬¬=>¶//¬as_list¬: Seq Of USE_PRAGMA;¶¶¶¶--|----------------------------------------------------------------
---------------------------------¶-- 10.2  Subunits of Compilation Units¶-- Syntax 10.2.A¶--  subunit ::=¶--     separat
e (parent_unit_name) proper_body¶--|------------------------------------------------------------------------------------
-------------¶¶subunit¬::=¶¬SEPARATE  (  expanded_name  )  proper_body¬¬====> $2 subunit¶¬%%¶--|........................
.........................................................................¶¶¶//  subunit¬¬=>¶//¬as_name¬: NAME,¶//¬as_sub
unit_body¬: SUBUNIT_BODY;¶¶##  subunit¬====>¶##¬include¬null;¶--|.......................................................
..........................................¶//  SUBUNIT_BODY¬¬::=¶//¬subprogram_body | package_body | task_body;¶//  SUBU
NIT_BODY¬¬=>¶//¬as_source_name¬: SOURCE_NAME,¶//¬as_body¬: BODY;¶--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%¶##  SUBUNIT_BODY¬====>¶¶##  include¬DECLARE¶##  include¬   POST_LBL : LABE
L_TYPE;¬¬¬--| ETIQUETTE EVENTUELLE POUR L APRES CORPS¶##  include¬BEGIN¶##  include¬  IF ENCLOSING_BODY /= TREE_VOID THE
N¬¬¬--| S IL Y A UN CORPS ENGLOBANT¶##  include¬    POST_LBL := NEXT_LABEL;¬¬¬--| ALLOUER L ETIQUETTE DE FIN DE CORPS SO
US UNITE¶##  include¬    EMIT ( JMP, POST_LBL, COMMENT=> "CONTOURNEMENT" );¬¬--| Y SAUTER¶##  include¬  END IF;¶¶##  if¬
subprogram_body¶##  call¬subprogram_body¬SUBUNIT_BODY¶¶##  if¬package_body¶##  call¬package_body¬SUBUNIT_BODY¶¶##  if¬ta
sk_body¶##  call¬task_body¬SUBUNIT_BODY¶¶##  end_if¶¶##  include¬  IF ENCLOSING_BODY /= TREE_VOID THEN¶##  include¬    W
RITE_LABEL ( POST_LBL, COMMENT=> "FIN DE CONTOURNEMENT" );¶##  include¬  END IF;¶##  include¬END;¶--%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%¶¶¶--|------------------------------------
-------------------------------------------------------------¶-- Syntax 10.2.B¶--  body_stub ::=¶--¬ subprogram_specific
ation is separate;¶--     | package body package_simple_name is separate;¶--     | task body task_simple_name is separat
e;¶--|-------------------------------------------------------------------------------------------------¶¶body_stub¬::=¶¬
  PROCEDURE  proc_id  procedure_header  IS__SEPARATE  ;¬¬====> exch_1 $3 subprogram_body¶¬| PROCEDURE  proc_id  nil_proc
edure_header IS__SEPARATE  ;¬¬====> exch_1 $3 subprogram_body¶¬| FUNCTION  function_id  function_header  IS__SEPARATE  ;
¬¬====> exch_1 $3 subprogram_body¶¬| PACKAGE  BODY  package_id  IS__SEPARATE  ;¬¬====> $2 package_body¶¬| TASK  BODY  ta
sk_body_id  IS__SEPARATE  ;¬¬====> $2 task_body¶¬%%¶--|.................................................................
................................¶IS__SEPARATE¬::=¶¬IS  SEPARATE¬¬¬¬====> $0 stub¶¬%%¶--|................................
.................................................................¶//  stub¬¬=> ;¶¶¶¶--||||||||||||||||||||||||||||||||||
||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||¶-- 11.¬Exceptions¶--|||||||||||||||||||||||||||||||||||
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||¶-- 11.1¬Exception Declarations¶-- Syntax 11.1¶--  except
ion_declaration ::= identifier_list : exception;¶--|--------------------------------------------------------------------
-----------------------------¶¶exception_declaration¬::=¶¬  identifier  :  exception_definition  ;¬¬====> $DEF exception
_id¶¬| identifier  ,  exception_declaration¬¬¬====> $DEF exception_id¶¬%%¶--|...........................................
......................................................¶exception_definition¬::=¶¬EXCEPTION¬¬¬¬====> nil $L source_name_s
 $1 exception_decl¶¬%%¶--|..............................................................................................
...¶¶¶//  exception_decl¬¬=> ;¶--¬as_source_name_s¬:source_name_s¶--¬lx_srcpos¬:Source_Position¶¶##  exception_decl¬====
>¶##¬call¬source_name_s¬@ as_source_name_s¬exception_decl¶--|...........................................................
......................................¶//  SOURCE_NAME¬¬::=¶//¬exception_id;¶--|........................................
.........................................................¶//  exception_id¬¬=>¶//¬sm_renames_exc¬: NAME,¶//¬cd_label¬: I
nteger;¶¶##  exception_id¬====>¬¬¬¬--| DECLARATION D IDENTIFICATEUR D EXCEPTION¶##  include¬DECLARE¶##  include¬  LBL : 
LABEL_TYPE := NEXT_LABEL;¬¬¬--| ALLOUER UNE ETIQUETTE¶##  include¬BEGIN¶##  include¬  DI ( CD_LABEL, EXCEPTION_ID, INTEG
ER ( LBL ) );¬¬--| LA STOCKER¶##  include¬  EMIT ( EXL, LBL, S=> PRINT_NAME ( D ( LX_SYMREP, EXCEPTION_ID ) ),¶##  inclu
de¬         COMMENT=> "NUMERO D EXCEPTION SUR DECLARATION" );¬¬--| CAS NORMAL PUISQUE LA DECLARATION DOIT PRECEDER L USA
GE¶##  include¬END;¶¶¶¶¶--|---------------------------------------------------------------------------------------------
----¶-- 11.2  Exception Handlers¶-- Syntax 11.2¶--  exception_handler ::=¶--     when exception_choice {| exception_choi
ce}¬=>¶--¬    sequence_of_statements¶--¶--  exception_choice ::= exception_name | others¶--|----------------------------
---------------------------------------------------------------------¶--** Parsed as case statement alternative¶¶¶¶--|--
-----------------------------------------------------------------------------------------------¶-- 11.3  Raise Statement
s¶-- Syntax 11.3¶--  raise_statement ::= raise [exception_name];¶--|----------------------------------------------------
---------------------------------------------¶¶raise_statement¬::=¶¬RAISE  [expanded_name]  ;¬¬¬====> $1 raise¶¬%%¶--|..
...............................................................................................¶¶//  raise¬¬=> ;¶¶##  ra
ise¬====>¶##  include¬DECLARE¶##  include¬  NAME : TREE := D ( AS_NAME, ADA_RAISE );¬¬--| AMENER LE NOM DE L EXCEPTION L
EVEE¶##  include¬BEGIN¶##  include¬  IF NAME = TREE_VOID THEN¬¬¬--| PAS DE NOM (UN SIMPLE "RAISE")¶##  include¬    EMIT 
( RAI );¬¬¬¬--| EMETTRE LE RAISE¶##  include¬  ELSE¬¬¬¬--| IL Y A UN NOM D EXCEPTION¶##  include¬    DECLARE¶##  include
¬      EXCEPTION_ID : TREE := D ( SM_DEFN, NAME );¬¬--| RAMENER LA DEFINITION DE L EXCEPTION¶##  include¬      LBL : LAB
EL_TYPE;¬¬¬--| ETIQUETTE EVENTUELLE¶##  include¬    BEGIN¶##  include¬      IF D ( CD_LABEL, EXCEPTION_ID ).TY /= DN_NUM
_VAL THEN¬¬--| PAS DEJA DE VALEUR D ETIQUETTES (PAS DE RAISE ANTERIEUR)¶##  include¬        LBL := NEXT_LABEL;¬¬¬--| ALL
OUER UNE ETIQUETTE¶##  include¬        DI ( CD_LABEL, EXCEPTION_ID, INTEGER ( LBL ) );¬¬--| PORTER SON NUMERO DANS L IDE
NTIFICATEUR¶##  include¬        EMIT ( EXL, LBL, S=> PRINT_NAME ( D ( LX_SYMREP, NAME ) ),¬--| EMETTRE UNE ETIQUETTE EXC
EPTION¶##  include¬¬COMMENT=> "NUMERO D EXCEPTION EXTERNE SUR RAISE" );¬--| ME PARAIT UN CAS IMPOSSIBLE LA DECLARATION D
EVANT PRECEDER¶##  include¬      END IF;¶##  include¬      EMIT ( RAI, DI ( CD_LABEL, EXCEPTION_ID ) );¬¬--| EMETTRE LE 
RAISE¶##  include¬    END;¶##  include¬  END IF;¶##  include¬END;¶¶¶--||||||||||||||||||||||||||||||||||||||||||||||||||
||||||||||||||||||||||||||||||||||||||||||||||||¶-- 12.¬Generic Program Units¶--||||||||||||||||||||||||||||||||||||||||
||||||||||||||||||||||||||||||||||||||||||||||||||||||||||¶-- 12.1  Generic Declarations¶-- Syntax 12.1.A¶--  generic_de
claration ::= generic_specification;¶--¶--  generic_specification ::=¶--¬ generic_formal_part subprogram_specification¶-
-     | generic_formal_part package_specification¶--|-------------------------------------------------------------------
------------------------------¶¶generic_declaration¬::=¶¬generic_specification  ;¶¬%%¶--|...............................
..................................................................¶generic_specification¬::=¶¬  generic_formal_part  FUN
CTION  generic_id  function_header¬====> exch_1 exch_2 $3 generic_decl¶¬| generic_formal_part  PROCEDURE  generic_id  pr
ocedure_header¬====> exch_1 exch_2 $3 generic_decl¶¬| generic_formal_part  PROCEDURE  generic_id  nil_procedure_header¬=
===> exch_1 exch_2 $3 generic_decl¶¬| generic_formal_part  PACKAGE  generic_id¶¬¬package_definition  END__[simple_name]¬
¬====> exch_1 exch_2 $3 generic_decl¶¬%%¶--|............................................................................
.....................¶generic_id¬::=¶¬identifier¬¬¬¬====> $0 generic_id lx_symrep¶¬%%¶--|...............................
..................................................................¶¶¶//  HEADER¬¬::=¶//¬package_spec;¶¶--|..............
...................................................................................¶//  generic_decl¬¬=>¶//¬as_item_s¬: 
item_s;¶¶##  generic_decl¬====>¶##¬include¬null;¶--|....................................................................
.............................¶//  NON_TASK_NAME¬¬::=¶//¬generic_id;¶--|.................................................
................................................¶//  generic_id¬¬=>¶//¬sm_generic_param_s¬: item_s,¶//¬sm_body¬: BODY,¶/
/¬sm_is_inline¬: BOOLEAN;¶¶##  generic_id¬====>¶##¬include¬null;¶¶¶¶--|-------------------------------------------------
------------------------------------------------¶-- Syntax 12.1.B¶--  generic_formal_part ::= generic {generic_parameter
_declaration}¶--|-------------------------------------------------------------------------------------------------¶¶gene
ric_formal_part¬::=¶¬GENERIC  {pragma}  {generic_parameter_declaration{pragma}}¬¬====> cat $L item_s¶¬%%¶--|............
.....................................................................................¶¶¶¶--|----------------------------
---------------------------------------------------------------------¶-- Syntax 12.1.C¶--  generic_parameter_declaration
 ::=¶--¬ identifier_list : [in [out]] type_mark [:= expression];¶--     | type identifier is generic_type_definition;¶--
     | private_type_declaration¶--     | with subprogram_specification [is name];¶--     | with subprogram_specification
 [is <>];¶--|-------------------------------------------------------------------------------------------------¶¶generic_
parameter_declaration¬::=¶¬  in_specification  ;¶¬| in_out_specification  ;¶¬| TYPE  identifier  empty_discriminant_part
__IS  generic_type_definition  ;¬====> $V3 type_decl $DEF type_id¶¬| private_type_declaration¶¬| WITH  subprogram_specif
ication  formal_subprogram_def  ;¬¬====> $3 subprog_entry_decl¶¬%%¶--|..................................................
...............................................¶empty_discriminant_part__IS¬::=¶¬IS¬¬¬¬====> nil $L dscrmt_decl_s¶¬%%¶--
|.................................................................................................¶formal_subprogram_def
¬::=¶¬empty¬¬¬¬====> $0 no_default¶¬| IS  <>¬¬¬¬====> $0 box_default¶¬| IS  name ¬¬¬¬====> $1 name_default¶¬%%¶--|......
...........................................................................................¶¶¶//  UNIT_KIND¬¬::=¶//¬GENE
RIC_PARAM;¶--|.................................................................................................¶//  GENE
RIC_PARAM¬¬::=¶//¬name_default | box_default | no_default;¶--|..........................................................
.......................................¶//  name_default¬¬=>¶//¬as_name¬: NAME;¶--|.....................................
............................................................¶//  box_default¬¬=> ;¶--|..................................
...............................................................¶//  no_default¬¬=> ;¶¶¶¶--|-----------------------------
--------------------------------------------------------------------¶-- Syntax 12.1.D¶--  generic_type_definition ::=¶--
¬ (<>) | range <> | digits <> | delta <>¶--     | array_type_definition | access_type_definition¶--|--------------------
-----------------------------------------------------------------------------¶¶generic_type_definition¬::=¶¬  (  <>  )¬¬
¬¬====> $0 formal_dscrt_def¶¬| RANGE  <>¬¬¬¬====> $0 formal_integer_def¶¬| DIGITS  <>¬¬¬¬====> $0 formal_float_def¶¬| DE
LTA  <>¬¬¬¬====> $0 formal_fixed_def¶¬| array_type_definition¶¬| access_type_definition¶¬%%¶--|.........................
........................................................................¶¶¶//  TYPE_DEF¬¬::=¶//¬formal_dscrt_def | forma
l_integer_def | formal_fixed_def | formal_float_def;¶--|................................................................
.................................¶//  formal_dscrt_def¬=> ;¶--|.........................................................
........................................¶//  formal_fixed_def¬=> ;¶--|..................................................
...............................................¶//  formal_float_def¬=> ;¶--|...........................................
......................................................¶//  formal_integer_def¬=> ;¶¶¶¶--|-------------------------------
------------------------------------------------------------------¶-- 12.3  Generic Instantiation¶-- Syntax 12.3.A¶--  g
eneric_instantiation ::=¶--¬ package identifier is¶--¬ new generic_package_name [generic_actual_part];¶--     | procedur
e identifier is¶--¬ new generic_procedure_name [generic_actual_part];¶--     | function identifier is¶--¬ new generic_fu
nction_name [generic_actual_part];¶--¶--  generic_actual_part ::=¶--     (generic_association {, generic_association})¶-
-|-------------------------------------------------------------------------------------------------¶¶generic_instantiati
on¬::=¶¬  PACKAGE  package_id  instantiation¬¬¬====> void exch_1 $3 package_decl¶¬| PROCEDURE  proc_id  nil_procedure_he
ader  instantiation¬¬====> $3 subprog_entry_decl¶¬| FUNCTION  function_id  generic_function_header  instantiation¬====> 
$3 subprog_entry_decl¶¬| FUNCTION  def_op  generic_function_header  instantiation¬¬====> $3 subprog_entry_decl¶¬%%¶--|..
...............................................................................................¶generic_function_header¬
::=¶¬nil_param_s¬¬¬¬====> void $2 function_spec¶¬%%¶--|.................................................................
................................¶instantiation¬::=¶¬IS  NEW  expanded_name  generic_assoc_s  ;¬¬====> $2 instantiation¶¬
%%¶--|.................................................................................................¶generic_assoc_s¬
::=¶¬  empty¬¬¬¬====> nil $L general_assoc_s¶¬| (  generic_association{,generic_association}  )¬¬====> $L general_assoc_
s¶¬%%¶--|.................................................................................................¶¶¶//  RENAME_
INSTANT¬¬::=¶//¬instantiation;¶--|......................................................................................
...........¶//  instantiation¬¬=>¶//¬as_general_assoc_s¬: general_assoc_s,¶//¬sm_decl_s¬: decl_s;¶¶¶¶--|----------------
---------------------------------------------------------------------------------¶-- Syntax 12.3.B¶--  generic_associati
on ::=¶--     [generic_formal_parameter¬=>] generic_actual_parameter¶--¶--  generic_formal_parameter ::= parameter_simpl
e_name | operator_symbol¶--|--------------------------------------------------------------------------------------------
-----¶¶generic_association¬::=¶¬  generic_actual_parameter¶¬| used_id  =>  generic_actual_parameter¬¬¬====> exch_1 $2 as
soc¶¬| used_string  =>  generic_actual_parameter¬¬====> exch_1 $2 assoc¶¬%%¶--|.........................................
........................................................¶¶¶¶--|---------------------------------------------------------
----------------------------------------¶-- Syntax 12.3.C¶--  generic_actual_parameter ::= expression | variable_name¶--
     | subprogram_name | entry_name | type_mark¶--|---------------------------------------------------------------------
----------------------------¶¶generic_actual_parameter¬::=¶¬expression¶¬%%¶--|..........................................
.......................................................¶¶¶--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
||||||||||||||||||||||||||||||||||||||¶-- 13. Representation Clauses and¶-- Implementation Dependent Features¶--||||||||
||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||¶-- 13.1  Representation Claus
es¶¶-- Syntax 13.1¶--  representation_clause ::=¶--¬ type_representation_clause | address_clause¶--¶--  type_representat
ion_clause ::= length_clause¶--     | enumeration_representation_clause | record_representation_clause¶--|--------------
-----------------------------------------------------------------------------------¶¶representation_clause¬::=¶¬type_rep
resentation_clause | address_clause¶¬%%¶--|.............................................................................
....................¶type_representation_clause¬::=¶¬length_clause | enumeration_representation_clause | record_represen
tation_clause¶¬%%¶--|.................................................................................................¶¶
¶//  REP¬¬::=¶//¬NAMED_REP | record_rep;¶//  REP¬¬=>¶//¬as_name¬: NAME;¶--|.............................................
....................................................¶//  NAMED_REP¬¬=>¶//¬as_exp¬: EXP;¶¶¶¶--|--------------------------
-----------------------------------------------------------------------¶-- 13.2 Length Clause¶-- Syntax 13.2¶--  length_
clause ::= for attribute use simple_expression;¶--|---------------------------------------------------------------------
----------------------------¶¶length_clause¬::=¶¬FOR  attribute  USE  simple_expression  ;¬¬====> $2 length_enum_rep¶¬%%
¶--|.................................................................................................¶¶¶¶--|------------
-------------------------------------------------------------------------------------¶-- 13.3 Enumeration Representation
 Clauses¶-- Syntax 13.3¶--  enumeration_representation_clause ::=¶--¬ for type_simple_name use aggregate;¶--|-----------
--------------------------------------------------------------------------------------¶¶enumeration_representation_claus
e¬::=¶¬FOR  used_id  USE  aggregate  ;¬¬¬====> $2 length_enum_rep¶¬%%¶--|...............................................
..................................................¶¶¶//  NAMED_REP¬¬::=¶//¬length_enum_rep;¶--|.........................
........................................................................¶//  length_enum_rep¬¬=> ;¶¶¶¶--|---------------
----------------------------------------------------------------------------------¶-- 13.4  Record Representation Clause
s¶-- Syntax 13.4.A¶--  record_representation_clause ::=¶--     for type_simple_name use¶--¬    record [alignment_clause]
¶--¬¬ {component_clause}¶--¬    end record;¶--¶--  alignment_clause ::= at mod static_simple_expression;¶--|------------
-------------------------------------------------------------------------------------¶¶record_representation_clause¬::=¶
¬  FOR  used_id  USE  RECORD  null_alignment  comp_rep_s  END  RECORD  ;¬====> $3 record_rep¶¬| FOR  used_id  USE  RECOR
D  alignment {comp_rep_pragma}comp_rep_s¶¬¬¬¬END  RECORD  ;¬====> $3 record_rep¶¬%%¶--|.................................
................................................................¶--** Note two definitions to deal with extra {pragma}¶-
-** Leading {pragma} always included in alignment clause even if null¶¶null_alignment¬¬::=¶¬[pragma_s]¬¬¬¬====> void $2 
alignment¶¬%%¶--|.................................................................................................¶align
ment¬::=¶¬[pragma_s]  AT  MOD  simple_expression  ;¬¬====> $2 alignment¶¬%%¶--|.........................................
........................................................¶¬¶¶//  ALIGNMENT_CLAUSE¬::=¶//¬alignment;¶--|..................
...............................................................................¶//  alignment¬¬=>¶//¬as_pragma_s¬: pragm
a_s,¶//¬as_exp¬: EXP;¶--|...............................................................................................
..¶//  record_rep¬¬=>¶//¬as_alignment_clause¬: ALIGNMENT_CLAUSE,¶//¬as_comp_rep_s¬: comp_rep_s;¶--|.....................
............................................................................¶¶¶¶--|-------------------------------------
------------------------------------------------------------¶-- Syntax 13.4.B¶--  component_clause¬::=¶--     component_
simple_name at static_simple_expression range static_range;¶--|---------------------------------------------------------
----------------------------------------¶¶comp_rep_pragma¬::=¶¬pragma¬¬¬¬====> $1 comp_rep_pragma¶¬%%¶--|...............
..................................................................................¶{comp_rep_pragma}comp_rep_s¬::=¶¬{com
p_rep_pragma}  {component_clause{comp_rep_pragma}}¬¬====> cat $L comp_rep_s¶¬%%¶--|.....................................
............................................................¶comp_rep_s¬¬::=¶¬{component_clause{comp_rep_pragma}}¬¬¬====
> $L comp_rep_s¶¬%%¶--|.................................................................................................
¶component_clause¬¬::=¶¬used_id  AT  simple_expression  RANGE  range  ;¬¬====> $3 comp_rep¶¬%%¶--|......................
...........................................................................¶¶¶//  COMP_REP_ELEM¬¬::=¶//¬comp_rep | comp_
rep_pragma;¶--|.................................................................................................¶//  com
p_rep_s¬¬=>¶//¬as_list¬: Seq Of COMP_REP_ELEM;¶--|......................................................................
...........................¶//  comp_rep¬¬=>¶//¬as_name¬: NAME,¶//¬as_exp¬: EXP,¶//¬as_range¬: RANGE;¶--|...............
..................................................................................¶//  comp_rep_pragma¬¬=>¶//¬as_pragma¬
: pragma;¶¶¶¶--|-------------------------------------------------------------------------------------------------¶-- 13.
5  Address Clauses¶-- Syntax 13.5¶--  address_clause ::= for simple_name use at simple_expression;¶--|------------------
-------------------------------------------------------------------------------¶¶address_clause¬::=¶¬FOR  used_id  USE  
AT  simple_expression  ;¬¬====> $2 address¶¬%%¶--|......................................................................
...........................¶¶¶//  NAMED_REP¬¬::=¶//¬address;¶--|........................................................
.........................................¶//  address¬¬=> ;¶¶¶¶--|------------------------------------------------------
-------------------------------------------¶-- 13.8  Machine Code Insertions¶-- Syntax 13.8¶--  code_statement ::= type_
mark'record_aggregate;¶--|----------------------------------------------------------------------------------------------
---¶¶code_statement¬¬::=¶¬prefix  '  aggregate  ;¬¬¬====> exch_1 $2 code¶¬%%¶--|........................................
.........................................................¶¶¶//  code¬¬=> ;¶¶##  code¬====>¶##¬include¬null;¶¶¶¶--|||||||
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||¶-- 14.0 Input-Output¶--|||||
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||¶-- I/O procedure calls are
 not specially handled. They are¶-- represented by procedure or function calls (see 6.4).¶--|---------------------------
----------------------------------------------------------------------¶¶¶¶-- Predefined Diana Environment¶-- ===========
=================¶--¶-- see Appendix   of this manual¶--¶¶//  PREDEF_NAME¬¬::=¶//¬  attribute_id | pragma_id | argument_
id | bltn_operator_id;¶--|..............................................................................................
...¶//  attribute_id¬¬=>¶//¬xd_pos¬: Integer;¬¬¬-- Predefined_Attributes'POS¶--|........................................
.........................................................¶//  TYPE_SPEC¬¬::=¶//¬universal_integer | universal_fixed | un
iversal_real;¶--|.................................................................................................¶//  u
niversal_integer¬=> ;¶--|...............................................................................................
..¶//  universal_fixed¬¬=> ;¶--|........................................................................................
.........¶//  universal_real¬¬=> ;¶--|..................................................................................
...............¶//  argument_id¬¬=>¶//¬xd_pos¬: Integer;¬¬¬-- 'POS in appropriate enum type¶--|.........................
........................................................................¶//  bltn_operator_id¬=>¶//¬sm_operator¬: Intege
r;¬¬¬-- (bltn_operators'POS)¶--|........................................................................................
.........¶//  pragma_id¬¬=>¶//¬sm_argument_id_s¬: argument_id,¶//¬xd_pos¬: Integer;¬¬¬-- Defined_Pragmas'POS¶--|........
.........................................................................................¶//  argument_id_s¬=>¶//¬as_lis
t¬: Seq Of argument_id;¶--|.............................................................................................
....¶//  ALL_SOURCE¬¬::=¶//¬  DEF_NAME¬| ALL_DECL¬| TYPE_DEF¬| SEQUENCES¶//¬| STM_ELEM¬| GENERAL_ASSOC¬| CONSTRAINT¬| CH
OICE¶//¬| HEADER¬| UNIT_DESC¬| TEST_CLAUSE_ELEM¶//¬| MEMBERSHIP_OP¬| SHORT_CIRCUIT_OP¬| ITERATION¶//¬| ALTERNATIVE_ELEM¬
| COMP_REP_ELEM¬| CONTEXT_ELEM¶//¬| VARIANT_ELEM¬| ALIGNMENT_CLAUSE¬| VARIANT_PART¶//¬| comp_list¬| compilation¬| compil
ation_unit¬| index;¶--|.................................................................................................
¶//  SEQUENCES¬¬::=¶//¬  alternative_s¬| argument_id_s¬| choice_s¶//¬| comp_rep_s¬| compltn_unit_s¬| context_elem_s¶//¬|
 decl_s¬| dscrmt_decl_s¬| general_assoc_s¶//¬| discrete_range_s¬| enum_literal_s¬| exp_s¬| item_s¶//¬| index_s | name_s¬
| param_s¬| pragma_s¬| scalar_s¶//¬| source_name_s¬| stm_s¬| test_clause_elem_s¶//¬| use_pragma_s¬| variant_s;¶--|......
...........................................................................................¶//  ALL_SOURCE¬¬=>¶//¬lx_src
pos¬: Source_Position,¶//¬lx_comments¬: comments;¶--|...................................................................
..............................¶//  ALL_DECL¬¬::=¶//¬ITEM | subunit;¶¶## ALL_DECL¬====>¬¬¬¬--| Action sur ALL_DECL¶##¬if_
class¬ITEM¬¬¬--| Si dans classe ITEM¶##¬call¬ITEM¬ALL_DECL¬¬--| Appliquer l'action sur ITEM au paramtre ALL_DECL¶##¬if¬s
ubunit¬¬¬--| Si subunit¶##¬call¬subunit¬ALL_DECL¬¬--| Appliquer l'action subunit au paramtre ALL_DECL¶--|...............
..................................................................................¶//  user_root¬¬=>¶//  ¬xd_sourcename¬
: txtrep,¶//¬xd_grammar¬: void,¶//¬xd_statelist¬: void,¶//¬xd_structure¬: compilation,¶//¬xd_timestamp¬: Integer,¶//¬spa
re_3¬: void;¶##  user_root¬====>¬¬¬¬--| Action sur user_root¶##¬call¬compilation¬@ xd_structure¬user_root¬--| Appliquer 
l'action compilation sur le champ xd_structure¶--|......................................................................
...........................¶//  NON_DIANA¬¬::=¶//¬user_root;¶--|........................................................
.........................................¶//  NON_DIANA¬¬::=¶//¬real_val | trans_with | lib_info;¶--|...................
..............................................................................¶//  real_val¬¬=>¬¬¬-- universal real valu
es¶//¬xd_numer¬: num_val,¶//¬xd_denom¬: num_val;¶--|....................................................................
.............................¶//  trans_with¬¬=>¶//¬tw_filename¬: txtrep,¶//¬tw_comp_unit¬: compilation_unit;¶--|.......
..........................................................................................¶//  lib_info¬¬=>¶//¬xd_short¬
: txtrep,¶//¬xd_primary¬: txtrep,¶//¬xd_secondary¬: txtrep;¶--|.........................................................
........................................¶//  any_integer     ¬=> ;¶--|..................................................
...............................................¶//  any_real¬¬=> ;¶--|..................................................
...............................................¶//  any_access¬¬=> ;¶--|................................................
.................................................¶//  any_composite   ¬=> ;¶--|.........................................
........................................................¶//  any_string¬¬=> ;¶--|.......................................
..........................................................¶//  any_access_of   ¬=>¶//¬xd_item ¬: ITEM;¶--|..............
...................................................................................¶//  UNSPECIFIED_TYPE¬::=¶//¬any_acce
ss | any_composite | any_string | any_access_of | any_integer | any_real;¶--|...........................................
......................................................¶//  NON_DIANA¬¬::=¶//¬def | UNSPECIFIED_TYPE;¶--|................
.................................................................................¶//  def ¬¬=>¶//¬xd_header¬: HEADER,¶//
¬xd_source_name¬: SOURCE_NAME,¶//¬xd_region_def¬: def,¶//¬xd_is_in_spec¬: BOOLEAN,¶//¬xd_lex_level¬: Integer,¬¬¬-- 0 pou
r la base¶//¬xd_is_used¬: BOOLEAN;¶--|..................................................................................
...............¶// implicit_conv    ¬=>¶//¬xd_item ¬: ITEM,¬¬¬-- (or type spec)¶//¬xd_list ¬: Seq Of EXP;¶--|...........
......................................................................................¶// nullary_call     ¬=>¶//¬xd_ite
m ¬: ITEM;¶--|.................................................................................................¶// NON_D
IANA¬¬::=¶//¬implicit_conv | nullary_call;¶--|..........................................................................
.......................¶// end¬--| Fin de specification IDL¶¶¶¶--** Definitions of rules for meta-brackets¶--** Only rul
es with "standard" definitions are given here:¶--**   [xxx]  is void or has semantics of xxx¶--**   {xxx}  is a sequence
 of 0 or more xxx's¶--**   other rules combined with {xxx} extend the sequence¶¶{pragma}¬::=¶¬  empty¬¬¬¬====> nil¶¬| pr
agma  {pragma} ¬¬¬¬====> insert¶¬%%¶--|.................................................................................
................¶{variant_pragma}¬::=¶¬  empty¬¬¬¬====> nil¶¬| variant_pragma {variant_pragma}¬¬¬====> insert¶¬%%¶--|...
..............................................................................................¶{stm_pragma}¬::=¶¬  empty
¬¬¬¬====> nil¶¬| stm_pragma  {stm_pragma} ¬¬¬====> insert¶¬%%¶--|.......................................................
..........................................¶{alternative_pragma}¬::=¶¬  empty¬¬¬¬====> nil¶¬| alternative_pragma {alterna
tive_pragma}¬¬====> insert¶¬%%¶--|......................................................................................
...........¶{comp_rep_pragma}¬::=¶¬empty¬¬¬¬====> nil¶¬| comp_rep_pragma {comp_rep_pragma}¬¬¬====> insert¶¬%%¶--|.......
..........................................................................................¶argument_association{,argumen
t_association}¬::=¶¬  argument_association¬¬¬====> list¶¬| argument_association{,argument_association}  ,  argument_asso
ciation¬====> append¶¬%%¶--|............................................................................................
.....¶[:=expression]¬::=¶¬  empty¬¬¬¬====> void¶¬| :=  expression¶¬%%¶--|...............................................
..................................................¶[expression]¬::=¶¬  empty¬¬¬¬====> void¶¬| expression¶¬%%¶--|........
.........................................................................................¶enumeration_literal{,enumerati
on_literal}¬::=¶¬enumeration_literal ¬¬¬====> list¶¬| enumeration_literal{,enumeration_literal} , enumeration_literal¬==
==> append¶¬%%¶--|.................................................................................................¶[con
straint]¬::=¶¬  empty¬¬¬¬====> void¶¬| constraint¶¬%%¶--|...............................................................
..................................¶[range_constraint]¬::=¶¬  empty¬¬¬¬====> void¶¬| range_constraint¶¬%%¶--|............
.....................................................................................¶index_subtype_definition{,index_su
btype_definition}¬::=¶¬  index_subtype_definition¬¬¬====> list¶¬| index_subtype_definition{,index_subtype_definition}¶¬¬
¬,  index_subtype_definition¬====> append¶¬%%¶--|.......................................................................
..........................¶{pragma}{component_declaration{pragma}}¬::=¶¬  {pragma}¶¬| {pragma}{component_declaration{pra
gma}}  component_declaration  {pragma}¬====> insert cat¶¬%%¶--|.........................................................
........................................¶discriminant_specification{;discriminant_specification}¬::=¶¬  discriminant_spe
cification¬¬¬====> list¶¬| discriminant_specification{;discriminant_specification}¶¬¬¬;  discriminant_specification¬====
> append¶¬%%¶--|.................................................................................................¶{varia
nt}¬::=¶¬  empty¬¬¬¬====> nil¶¬| {variant}  variant¬¬¬====> append¶¬%%¶--|..............................................
...................................................¶choice{|choice}¬::=¶¬  choice¬¬¬¬====> list¶¬| choice{|choice}  '|' 
 choice¬¬¬====> append¶¬%%¶--|..........................................................................................
.......¶{basic_declarative_item{pragma}}¬::=¶¬  empty¬¬¬¬====> nil¶¬| {basic_declarative_item{pragma}} basic_declarative
_item  {pragma}¬====> insert cat¶¬%%¶--|................................................................................
.................¶{later_declarative_item{pragma}}¬::=¶¬  empty¬¬¬¬====> nil¶¬| {later_declarative_item{pragma}} later_d
eclarative_item  {pragma}¬====> insert cat¶¬%%¶--|......................................................................
...........................¶component_association,{component_association,}¬::=¶¬  component_association  ,¬¬¬====> list¶
¬| component_association,{component_association,}  component_association  ,¬====> append¶¬%%¶--|........................
.........................................................................¶label{label}¬::=¶¬  label¬¬¬¬====> list¶¬| lab
el{label}  label ¬¬¬====> append¶¬%%¶--|................................................................................
.................¶if_clause{elsif_clause}¬::=¶¬  if_clause¬¬¬¬====> list¶¬| if_clause{elsif_clause}  elsif_clause¬¬¬====
> append¶¬%%¶--|.................................................................................................¶{case_
sta_alt}¬::=¶¬  empty¬¬¬¬====> nil¶¬| {case_sta_alt}  case_sta_alt ¬¬¬====> append¶¬%%¶--|..............................
...................................................................¶[iteration_scheme]¬::=¶¬  empty¬¬¬¬====> void¶¬| ite
ration_scheme¶¬%%¶--|.................................................................................................¶p
arameter_specification{;parameter_specification}¬::=¶¬  parameter_specification¬¬¬====> list¶¬| parameter_specification{
;parameter_specification}  ;  parameter_specification¬====> append¶¬%%¶--|..............................................
...................................................¶general_assoc{,general_assoc}¬::=¶¬  general_assoc¬¬¬¬====> list¶¬| 
general_assoc{,general_assoc}  ,  general_assoc¬¬====> append¶¬%%¶--|...................................................
..............................................¶expanded_name{,expanded_name}¬::=¶¬  expanded_name¬¬¬¬====> list¶¬| expan
ded_name{,expanded_name}  ,  expanded_name¬¬====> append¶¬%%¶--|........................................................
.........................................¶{representation_clause{pragma}}¬::=¶¬  empty¬¬¬¬====> nil¶¬| representation_cl
ause  {pragma}  {representation_clause{pragma}}¬====> cat insert¶¬%%¶--|................................................
.................................................¶{compilation_unit}¬::=¶¬  empty¬¬¬¬====> nil¶¬| {compilation_unit} com
pilation_unit¬¬¬====> append¶¬%%¶--|....................................................................................
.............¶name{,name}¬::=¶¬  name¬¬¬¬====> list¶¬| name{,name} , name¬¬¬====> append¶¬%%¶--|........................
.........................................................................¶{with_clause}¬::=¶¬empty¬¬¬¬====> nil¶¬| {with
_clause}  with_clause¬¬¬====> append¶¬%%¶--|............................................................................
.....................¶{use_clause{pragma}}¬::=¶¬  empty¬¬¬¬====> nil¶¬| {use_clause{pragma}}  use_clause  {pragma}¬¬====
> insert cat¶¬%%¶--|.................................................................................................¶[e
xpanded_name]¬::=¶¬  empty¬¬¬¬====> void¶¬| expanded_name¶¬%%¶--|.......................................................
..........................................¶{entry_declaration{pragma}}¬::=¶¬  empty¬¬¬¬====> nil¶¬| {entry_declaration{p
ragma}}  entry_declaration  {pragma}¬¬====> insert cat¶¬%%¶--|..........................................................
.......................................¶{generic_parameter_declaration{pragma}}¬::=¶¬  empty¬¬¬¬====> nil¶¬| {generic_pa
rameter_declaration{pragma}} generic_parameter_declaration {pragma} ====> insert cat¶¬%%¶--|............................
.....................................................................¶generic_association{,generic_association}¬::=¶¬  g
eneric_association ¬¬¬====> list¶¬| generic_association{,generic_association}  ,  generic_association¬====> append¶¬%%¶-
-|.................................................................................................¶{component_clause{co
mp_rep_pragma}}¬::=¶¬  empty¬¬¬¬====> nil¶¬| {component_clause{comp_rep_pragma}}  component_clause  {comp_rep_pragma}¬==
==> insert cat¶¬%%¶--|.................................................................................................¶
discrete_range{,discrete_range}¬::=¶¬  discrete_range¬¬¬¬====> list¶¬| discrete_range{,discrete_range}  ,  discrete_rang
e¬¬====> append¶¬%%¶--|.................................................................................................
¶discriminant_association{,discriminant_association}¬::=¶¬  discriminant_association¬¬¬====> list¶¬| discriminant_associ
ation{,discriminant_association}¶¬¬¬,  discriminant_association¬====> append¶¬%%¶--|....................................
.............................................................¶discriminant_choice{|discriminant_choice}¬::=¶¬  discrimin
ant_choice ¬¬¬====> list¶¬| discriminant_choice{|discriminant_choice}  '|'  discriminant_choice¬====> append¶¬%%¶--|....
.............................................................................................¶¶--#######################
###########################################################################¶--¬FIN !! Eh ben dis donc !!¶--#############
#####################################################################################¶%end¶##  STOP¬¬¬¬¬--| ARRET POUR L
E GEN_CODEGEN¶
