SEPARATE (IDL)--|---------------------------------------------------------------------------------------------------|
촒ROCEDURE IDL_READ--|-------------------------------------------------------------------------------------------------
턕ROCEDURE IDL_READ ( NOM_TEXTE :STRING ) ISККК--| LIT UNE DESCRIPTION IDL EN MEMOIRE VIRTUELLE     IFILE К: FILE
_TYPE;ККК--| FICHIER IDL  SLINEК: STRING ( 1..256 );КК--| LIGNE TEXTE COURANTE  COLК: NATURALК:= 1;КК--|
 PROCHAINE COLONNE  LIRE  F_COLК: NATURAL;ККК--| PREMIERE COLONNE DU LEXEME  TOKEN_LENGTHК: NATURAL;ККК--| LO
NGUEUR DU LEXEME  LASTК: NATURALК:= 0;КК--| NOMBRE DE CARACTERE DE LA LIGNE  TOKEN_IS_NAMEК: BOOLEAN;  LINE_CO
UNTК: NATURALК:= 0;     ATTR_COUNTК: INTEGERК:= -1;  SOURCE_LISTК: SEQ_TYPE;ККК--| LISTE  DES LIGNES SOURCES
  SOURCEPOSК: TREE;ККК--| LA POSITION SOURCE DU LEXEME COURANT  SOURCELINEК: TREE;ККК--| LE NOEUD LIGNE SOURC
E     USER_ROOTК: TREE;ККК--| RACINE DE L'ARBRE     TYPE CONTEXT_TYPEКIS (NIL, IN_NODE, IN_CLASS);  CONTEXTК
: CONTEXT_TYPE:= NIL;     PROCEDURE PROCESS_IDL;  PROCEDURE CHECK_IDL;  PROCEDURE PRINT_IDL;     --|------------
-----------------------------------------------------------------------------------  --|КPROCEDURE GET_TOKEN  PROCEDU
RE GET_TOKEN IS  BEGIN    WHILE COL <= LAST AND THEN ( SLINE( COL ) = ' ' OR ELSE SLINE( COL ) = ASCII.HT ) LOOP--| P
ASSER LES ESPACES      COL := COL + 1;    END LOOP;             IF COL < LAST AND THEN SLINE( COL ) = '-' AND THEN S
LINE( COL+1 ) = '-' THENК--| SAUTER EN FIN DE LIGNE SUR COMMENTAIRE      COL := LAST + 1;    END IF;             IF
 COL > LAST THENКККК--| SI ON EST POST FIN DE LIGNE      LOOP        IF END_OF_FILE ( IFILE ) THEN RETURN; END IF;
                    IF END_OF_LINE ( IFILE ) THEN          SKIP_LINE ( IFILE );          LINE_COUNT := LINE_COUNT + 
1;          LAST := 0;        ELSE          SLINE( 1..2 ) := "??";ККК--| FORCER  AUTRE CHOSE QUE // EN CAS DE LIG
NE VIDE          GET_LINE( IFILE, SLINE, LAST );ККК--| LIRE UNE LIGNE          IF SLINE( 1..2 ) = "//" THENККК-
-| NE S'OCCUPER QUE DES LIGNES COMMENANT PAR //            COL := 3;КККК--| SE METTRE EN COL 3 POST "//"          
ELSE            COL := LAST + 1;КККК--| POST FIN DE LIGNE POUR NEGLIGER LA LIGNE          END IF;        END IF;
                    WHILE COL <= LAST AND THEN ( SLINE(COL) = ' ' OR ELSE SLINE(COL) = ASCII.HT ) LOOP--| PASSER LES B
LANCS          COL := COL + 1;        END LOOP;                    IF COL <= LAST THEN          IF SLINE( COL ) = '
-' AND THEN COL < LAST AND THEN SLINE( COL+1 ) = '-' THEN            COL := LAST + 1;          ELSEКККК--| LIGNE 
NON VIDE            SOURCELINE := MAKE ( DN_SOURCELINE );ККК--| CREER UN NOEUD LIGNE SOURCE            DI  ( XD_NUM
BER, SOURCELINE, LINE_COUNT );КК--| Y METTRE LE NUMERO DE LIGNE            LIST( SOURCELINE, (TREE_NIL,TREE_NIL) );
КК--| INITIALISER LA XD_ERROR_LIST            SOURCE_LIST := APPEND ( SOURCE_LIST, SOURCELINE );КК--| METTRE LA LIG
NE EN FILE            EXIT;          END IF;        END IF;      END LOOP;    END IF;             F_COL := COL; 
   TOKEN_LENGTH := 1;    TOKEN_IS_NAME := FALSE;             CASE SLINE(COL) IS    WHEN 'A'..'Z' | 'a'..'z' =>     
 TOKEN_IS_NAME := TRUE;      COL := COL +1;      WHILE COL <= LAST            AND THEN ( SLINE( COL ) IN 'A'..'Z'   
                    OR ELSE SLINE( COL ) IN 'a'..'z'                       OR ELSE SLINE( COL ) = '_'                 
      OR ELSE SLINE( COL ) IN '0'..'9'               К)      LOOP        TOKEN_LENGTH := TOKEN_LENGTH + 1;        C
OL := COL + 1;      END LOOP;                   WHEN ':' =>КККК--| PEUT ETRE ::=      IF COL + 2 <= LAST      
            AND THEN SLINE (COL + 1) = ':' AND THEN SLINE( COL + 2 ) = '=' THENК--| OUI UN ::=        TOKEN_LENGTH := 
3;КККК--| LONGUEUR 3        COL := COL + 3;      ELSE        COL := COL + 1;      END IF;                   WH
EN '=' =>КККК--| PEUT ETRE =>      IF COL + 1 <= LAST AND THEN SLINE( COL + 1 ) = '>' THENКК--| OUI "=>"       
 TOKEN_LENGTH := 2;        COL := COL + 2;      ELSE        COL := COL + 1;      END IF;                   WHEN '|
' | ';' | ',' =>      COL := COL + 1;                   WHEN OTHERS =>      COL := COL + 1;                   END 
CASE;             SOURCEPOS := MAKE_SOURCE_POSITION( SOURCELINE, SRCCOL_IDX( F_COL ) );떰  END GET_TOKEN;  --|-------
----------------------------------------------------------------------------------------  --|КPROCEDURE PROCESS_IDL  
PROCEDURE PROCESS_IDL IS          RULE_NODEК: TREE;    NODE_LISTК: SEQ_TYPE:= (TREE_NIL,TREE_NIL);    PRIOR_F_COL
К: POSITIVE:= 1;    PRIOR_TOKEN_LENGTH: NATURALК:= 0;    TYPE ATTR_TYPEКIS (NORMAL, SEQ);             --|------
---------------------------------------------------------------------------------------    --|КPROCEDURE MAKE_RULE_OR_
CLASS_NODE    PROCEDURE MAKE_RULE_OR_CLASS_NODE ( NODE_NAME :STRING ) IS      SYMBOLК: TREEК:= STORE_SYM ( NODE_NAME
 );К--| STOCKER/RETIRER LE NOM DE NOEUD REGLE (NOM EN PARTIE GAUCHE AVANT LE => )      R_LISTК: SEQ_TYPE:= LIST ( S
YMBOL );КК--| LISTE CONTENANT LE NOEUD REGLE ASSOCIEES AU SYMBOLE (REFERENCE COMME GAUCHE DE REGLE OU TYPAGE)    BEGI
N      IF IS_EMPTY ( R_LIST ) THENККК--| LA LISTE EST VIDE, C'EST LA PREMIERE DEFINITION DE REGLE/CLASSE        RU
LE_NODE := MAKE ( DN_CLASS_NODE );ККК--| FABRIQUER UN NOEUD POUR LA REGLE/CLASSE        D ( XD_SYMREP, RULE_NODE, SY
MBOL );ККК--| METTRE LE SYMBOLE DU NOM DE REGLE (NOM GAUCHE) DANS LE XD_NAME DU NOEUD REGLE        LIST ( RULE_NODE,
 (TREE_NIL,TREE_NIL) );ККК--| INITIALISER  VIDE LA LISTE DES ELEMENTS DU CTE DROIT        IF CONTEXT = IN_NODE THEN
ККК--| DANS UN NOEUD REGLE SIMPLE          DB ( XD_IS_CLASS, RULE_NODE, FALSE );ККК--| MARQUER UNE REGLE DE STRUC
TURE D'ATTRIBUTS        ELSEКККК--| DANS UNE CLASSE          DB ( XD_IS_CLASS, RULE_NODE, TRUE );ККК--| MARQUE
R UNE REGLE DE DEFINITION DE CLASSE        END IF;        D ( LX_SRCPOS, RULE_NODE, SOURCEPOS );ККК--| METTRE LA PO
SITION SOURCE DONNEE PAR GET_TOKEN        D ( XD_PARENT, RULE_NODE, TREE_VOID );        LIST ( SYMBOL, APPEND ( (TREE_
NIL,TREE_NIL), RULE_NODE ) );КК--| METTRE LE NOEUD REGLE COMME ELEMENT UNIQUE DE LISTE DU SYMBOLE DE NOM GAUCHE (XD_DE
FLIST)        NODE_LIST := APPEND ( NODE_LIST, RULE_NODE );КК--| METTRE EN LISTE LA REGLE                  ELSEК
ККК--| UNE REGLE AVEC MEME PARTIE GAUCHE A DEJ ETE VUE        DECLARE          DEFК: TREEК:= HEAD ( R_LIST );КК
--| PRENDRE LE NOEUD DE TETE, LE NOEUD REGLE        BEGIN          IF DEF.TY = DN_CLASS_NODE THENККК--| VERIFIER QU
E C'EST UNE REGLE            RULE_NODE := DEF;КККК--| PRENDRE CE NOEUD COMME COURANT            IF CONTEXT = IN_CL
ASS THENККК--| ON A UN NOM CITE EN CLASSE (PEUT AVOIR ETE TROUVE AUPARAVANT CITE COMME TYPAGE EN DROITE DE REGLE D'A
TTRIBUTION )              DB ( XD_IS_CLASS, RULE_NODE, TRUE );КК--| MARQUER COMME CLASSE            END IF;       
                        ELSEКККК--| ANOMALIE LE NOEUD N'EST PAS UNE REGLE            ERROR ( SOURCEPOS, "HOLA ! "
 & NODE_NAME & " N EST PAS UN NOM EN PARTIE GAUCHE (REGLE) !" );          END IF;        END;      END IF;          
      END MAKE_RULE_OR_CLASS_NODE;    --|-----------------------------------------------------------------------------
----------------    --|КPROCEDURE MAKE_ATTR    PROCEDURE MAKE_ATTR ( ATTR_NAME :STRING; ATYPE :ATTR_TYPE; NOM_TYPE :S
TRING ) IS      SYMBOLК: TREEК:= STORE_SYM ( ATTR_NAME );К--| STOCKER/RETIRER LE SYMBOLE (SYMREP) DE L'ATTRIBUT   
   A_LISTК: SEQ_TYPE:= LIST ( SYMBOL );КК--| LISTE CONTENANT LA DEFINITION DE L'ATTRIBUT      TYPAGEК: TREEК:= ST
ORE_SYM ( NOM_TYPE );К--| STOCKER/REPRENDRE LE SYMBOLE DU TYPE DE L'ATTRIBUT (UN NOM DE REGLE OU DE CLASSE)      ATTR
К: TREE;    BEGIN               IF IS_EMPTY ( A_LIST ) THENККК--| AUCUNE APPARITION DE CET ATTRIBUT        ATTR
_COUNT := ATTR_COUNT + 1;ККК--| UN ATTRIBUT DE PLUS        ATTR := MAKE ( DN_ATTR );ККК--| CREER UN NOEUD DE TY
PE ATTRIBUT/TERMINAL        D ( XD_SYMREP, ATTR, SYMBOL );ККК--| POINTER LE SYMBOLE DANS LE CHAMP XD_SYMREP DU TERM
INAL                       CASE ATYPE ISКККК--| SUIVANT QUE L'ON A UN ATTRIBUT SIMPLE OU UNE SEQUENCE        WHEN
 NORMAL =>КККК--| UN ATTRIBUT SIMPLE          DI ( XD_ATTR_ID, ATTR, ATTR_COUNT );ККК--| PORTER LE N D'ATTRIBUT 
EN POSITIF        WHEN OTHERS =>КККК--| UN ATTRIBUT SEQUENCE, PORTER LE N D'ATTRIBUT EN NEGATIF          DI (XD_AT
TR_ID, ATTR, - ATTR_COUNT );        END CASE;        D ( XD_ATTR_TYPE, ATTR, TYPAGE );ККК--| METTRE LE TYPAGE     
   LIST ( SYMBOL, APPEND ( (TREE_NIL,TREE_NIL), ATTR ) );КК--| PORTER L'ATTRIBUT CRE EN LISTE DANS LE XD_DEFLIST DU SY
MREP                     ELSEКККК--| IL Y A DEJ EU UNE APPARITION        ATTR := HEAD ( A_LIST );ККК--| PREN
DRE LA DEFINITION EXISTANTE      END IF;                  IF ATTR.TY = DN_ATTR THENККК--| CE DOIT ETRE UN ATTRIBU
T/TERMINAL        CASE ATYPE IS        WHEN NORMAL =>КККК--| ATTRIBUT SIMPLE (NON SEQUENCE)          IF DI ( XD_A
TTR_ID, ATTR ) < 0  THENККК--| IL Y A UNE ANOMALIE (LE N D'ATTRIBUT DOIT ETRE POSITIF DANS CE CAS)            ERROR 
( SOURCEPOS, "ATTR IS SEQ" & ATTR_NAME);                                 ELSIF TYPAGE /= D ( XD_ATTR_TYPE, ATTR ) THEN
КК--| ANOMALIE SI LE TYPAGE NE CORRESPOND PAS  CE QUI EST DANS L'ATTRIBUT (VOIR LA LIGNE (**) UN PEU PLUS HAUT)     
       DECLARE              OLD_TYPAGE: TREEК:= D ( XD_ATTR_TYPE, ATTR );            BEGIN              ERROR ( SOU
RCEPOS, "VALUE OF " & ATTR_NAME                              & " IS "   & PRINT_NAME ( TYPAGE )                       
       & " [" & PAGE_IDX'IMAGE ( TYPAGE.PG )                              & "." & LINE_IDX'IMAGE ( TYPAGE.LN )        
                      & "." & NODE_NAME'IMAGE ( TYPAGE.TY ) & "] CALLED " & PRINT_NAME ( TYPAGE )                      
                                      & ", NOT " & PRINT_NAME ( OLD_TYPAGE )                              & " [" & PAG
E_IDX'IMAGE ( OLD_TYPAGE.PG )                              & "." & LINE_IDX'IMAGE ( OLD_TYPAGE.LN )                   
           & "." & NODE_NAME'IMAGE ( OLD_TYPAGE.TY ) & "] CALLED " & PRINT_NAME ( OLD_TYPAGE )                         
     );            END;          END IF;        WHEN OTHERS =>КККК--| ATTRIBUT SEQUENCE          IF DI ( XD_ATTR
_ID, ATTR) >= 0 THENККК--| ANOMALIE SI LE N D'ATTRIBUT EST POSITIF (IL DOIT ETRE NEGATIF POUR UNE SEQUENCE)         
   ERROR ( SOURCEPOS, "ATTR IS NOT SEQ" & ATTR_NAME );                                  ELSIF TYPAGE /= D ( XD_ATTR_TY
PE, ATTR) THENКК--| SI LE TYPAGE DE SEQUENCE DIFFERE DE L'ANTERIEUR            DECLARE              TEMPК: TREEК:
= ATTR;КК--| GARER L'ATTRIBUT ANCIENNEMENT TYPE            BEGIN              ATTR := MAKE ( DN_ATTR );ККК--| R
EFAIRE UN TERMINAL QUI EST PRIS COMME ATTRIBUT              D  ( XD_SYMREP, ATTR, D ( XD_SYMREP, TEMP ) );КК--| DANS 
LE SYMREP DU NOUVEAU, RECOPIER LE SYMREP DE L'ANCIEN              DI ( XD_ATTR_ID, ATTR, DI ( XD_ATTR_ID, TEMP ) );КК
--| REPORTER AUSSI LE N D'ATTRIBUT              D  ( XD_ATTR_TYPE, ATTR, TYPAGE );ККК--| METTRE LE TYPAGE DANS CE NO
UVEAU NOEUD ATTRIBUT QUI DIFERE PAR LE TYPAGE            END;          END IF;        END CASE;        DECLARE     
     ASEQК: SEQ_TYPE := LIST ( RULE_NODE );К--| REPRENDRE LA XD_LIST DU NOEUD REGLE EN COURS        BEGIN         
 LIST ( RULE_NODE, APPEND ( ASEQ, ATTR ) );КК--| AJOUTER AU NOEUD REGLE EN COURS LA LISTE DES ATTRIBUTS AUGMENTEE   
     END;      ELSEКККК--| LA DEFINITION (TROUVEE) N'EST PAS UN TERMINAL !        ERROR ( SOURCEPOS, "NOT DEFINED
 AS AN ATTRIBUTE -" & ATTR_NAME );                     END IF;                END MAKE_ATTR;    --|----------------
-----------------------------------------------------------------------------    --|КPROCEDURE MAKE_MEMBER    PROCEDU
RE MAKE_MEMBER ( MEMBER_NAME :STRING ) IS               SYMBOLК: TREEК:= STORE_SYM ( MEMBER_NAME );К--| STOCKER/RE
PRENDRE LE SYMREP CORRESPONDANT AU NOM D'ELEMENT DE CLASSE      MEMBERК: TREEК:= MAKE ( DN_MEMBER );К--| FABRIQUER 
UN NON TERMINAL POUR UN ELEMENT APPARTENANT  UNE CLASSE      M_LISTК: SEQ_TYPE:= LIST ( SYMBOL );КК--| LA LISTE CON
TENANT LA REGLE DEFINISSANT LE SYMBOLE    BEGIN      D ( XD_SYMREP, MEMBER, SYMBOL );ККК--| METTRE LE SYMREP DANS 
LE CHAMP XD_SYMREP DU MEMBRE DE CLASSE      D ( LX_SRCPOS, MEMBER, SOURCEPOS );ККК--| METTRE LA POSITION SOURCE DU M
EMBRE CRE PAR GET_TOKEN      LIST ( RULE_NODE, APPEND ( LIST ( RULE_NODE ), MEMBER ) );КК--| AJOUTER LE MEMBRE  LA LI
STE DES MEMBRES DU NOEUD    END ;    --|------------------------------------------------------------------------------
---------------        BEGIN    LAST := 0;    COL := 1;    GET_TOKEN;    LOOP               EXIT WHEN END_OF_FIL
E (IFILE) OR ELSE SLINE( F_COL..F_COL + TOKEN_LENGTH - 1) = "end";--| FINIR AVEC LE FICHIER OU LE LEXEME %%% QUI INDIQU
E LA FIN               IF TOKEN_IS_NAME THENКККК--| LEXEME IDENTIFICATEUR        PRIOR_F_COL := F_COL;КККК--|
 GARDER SA POSITION        PRIOR_TOKEN_LENGTH := TOKEN_LENGTH;ККК--| ET SA LONGUEUR        GET_TOKEN;КККК--| E
T PASSER AU SUIVANT (QUI VA PERMETTRE DE SAVOIR CE QUE L'ON VA FAIRE)                        ELSIF SLINE( F_COL..F_COL
 + TOKEN_LENGTH - 1) = "=>" THENКК--| INDIQUE UNE REGLE DEFINISSANT DES ATTRIBUTS        CONTEXT := IN_NODE;КККК-
-| GARDER UNE TRACE DE CE FAIT : DEFINITION D'UNE ASSOCIATION D'ATTRIBUTS        MAKE_RULE_OR_CLASS_NODE ( SLINE( PRIOR
_F_COL..PRIOR_F_COL +PRIOR_TOKEN_LENGTH -1 ) );--| TENTER LA CREATION D'UN NOEUD REGLE (OU LE RAMENER S'IL EXISTE DEJ)
        GET_TOKEN;КККК--| ALLER CHERCHER LE PREMIER NOM D'ATTRIBUT OU LE ;                        ELSIF SLINE( F_
COL..F_COL + TOKEN_LENGTH - 1) = "::=" THENКК--| LEXEME MARQUANT UNE DEFINITION DE CLASSE        CONTEXT := IN_CLASS;
КККК--| GARDER UNE TRACE DE CE FAIT : DEFINITION D'UNE CLASSE        MAKE_RULE_OR_CLASS_NODE ( SLINE( PRIOR_F_COL..
PRIOR_F_COL +PRIOR_TOKEN_LENGTH -1 ) );--| TENTER LA CREATION D'UN NOEUD REGLE (OU LE RAMENER S'IL EXISTE DEJ)        
GET_TOKEN;КККК--| ALLER CHERCHER UN COMPOSANT DE CLASSE        WHILE SLINE( F_COL..F_COL + TOKEN_LENGTH - 1) /= ";
" LOOPКК--| JUSQU' LA FIN DE LA DEFINITION DE CLASSE          IF TOKEN_IS_NAME THENККК--| SI L'ON A UN NOM (PAS U
NE ',' SEPARATRICE)            MAKE_MEMBER ( SLINE( F_COL..F_COL + TOKEN_LENGTH - 1) );КК--| CREER UN MEMBRE DE CLASS
E          END IF;          GET_TOKEN;КККК--| AVANCER AU LEXEME SUIVANT        END LOOP;                       
 ELSIF SLINE( F_COL..F_COL + TOKEN_LENGTH - 1) = ":" THENКК--| SEPARATEUR DU TYPAGE        GET_TOKEN;КККК--| AME
NER UN SEQ OU LE NOM DU TYPE        IF SLINE( F_COL..F_COL + TOKEN_LENGTH - 1) = "Seq" THENКК--| C'EST UN SEQ       
   GET_TOKEN;КККК--| PRENDRE LE OF OU LE NOM DE TYPE          IF SLINE( F_COL..F_COL + TOKEN_LENGTH - 1) = "Of" THE
NКК--| ON A LE OF            GET_TOKEN;КККК--| PRENDRE LE NOM DE TYPE          END IF;          MAKE_ATTR ( SLI
NE( PRIOR_F_COL..PRIOR_F_COL +PRIOR_TOKEN_LENGTH -1 ), SEQ,К--| AJOUTER UN ATTRIBUT SEQUENCE                      SLIN
E( F_COL..F_COL + TOKEN_LENGTH - 1 )КК--| AVEC SON TYPAGE                     );                       ELSIF SLINE(
 PRIOR_F_COL..PRIOR_F_COL +PRIOR_TOKEN_LENGTH -1 ) /= "lx_comments" THEN--| SI CE N'EST PAS UN ATTRIBUT LX_COMMENTS   
       MAKE_ATTR ( SLINE( PRIOR_F_COL..PRIOR_F_COL + PRIOR_TOKEN_LENGTH - 1), NORMAL,К--| AJOUTER UN ATTRIBUT SIMPLE (N
ON SEQUENCE)                      SLINE( F_COL..F_COL + TOKEN_LENGTH - 1 )КК--| AVEC SON TYPAGE                     
);        END IF;                     ELSE        GET_TOKEN;КККК--| LEXEME NON RECONNU, PASSER AU SUIVANT     
 END IF;    END LOOP;          USER_ROOT := MAKE ( DN_USER_ROOT );ККК--| FABRIQUER LE NOEUD RACINE ARBRE    D ( 
XD_SOURCENAME, USER_ROOT, STORE_TEXT ( NOM_TEXTE ) );КК--| Y METTRE LE NOM DE FICHIER ANS XD_SOURCENAME    LIST ( USE
R_ROOT, NODE_LIST );ККК--| PORTER DANS LE NOEUD SEQUENCE LA LISTE DES NOEUDS    D ( XD_USER_ROOT, TREE_ROOT, USER_R
OOT );ККК--| METTRE LE NOEUD RACINE ARBRE DANS LA RACINE SYSTEME  END PROCESS_IDL;  --|----------------------------
-------------------------------------------------------------------  --|КPROCEDURE CHECK_IDL  PROCEDURE CHECK_IDL IS
    NODE_LISTК: SEQ_TYPEК:= LIST ( USER_ROOT );К--| REPRENDRE LA LISTE DES REGLES DU CHAMP XD_LIST    RULE_NODEК: T
REE;    ITEM_LISTК: SEQ_TYPE;    ITEMК: TREE;  BEGIN    PUT_LINE ( "**** VERIFICATION ...");    WHILE NOT IS_EMP
TY ( NODE_LIST ) LOOP      POP ( NODE_LIST, RULE_NODE );ККК--| RETIRER UN NOEUD REGLE      ITEM_LIST := LIST ( RUL
E_NODE );ККК--| LISTE DES ATTRIBUTS OU DES MEMBRES      WHILE NOT IS_EMPTY ( ITEM_LIST ) LOOPККК--| TANT QUE LIS
TE NON VIDE        POP ( ITEM_LIST, ITEM );ККК--| RETIRER UN ELEMENT DE LA XD_LIST (ATTRIBUT OU MEMBRE DE CLASSE) 
                   IF ITEM.TY = DN_ATTR THENККК--| TERMINAL (OU ATTRIBUT)          DECLARE            TYPAGEК: T
REEК:= D ( XD_ATTR_TYPE, ITEM );К--| LE TYPE DE L'ATTRIBUT          BEGIN            IF TYPAGE.TY /= DN_SYMBOL_REP 
THEN              ERROR ( D ( LX_SRCPOS, RULE_NODE ), "TYPAGE INEXISTANT: " );            END IF;          END;     
                    ELSEКККК--| NON TERMINAL (OU MEMBRE DE CLASSE)          DECLARE            DEFINING_RULE_LIS
T: SEQ_TYPE:= LIST ( D ( XD_SYMREP, ITEM ) );          BEGIN                              IF IS_EMPTY ( DEFINING_RU
LE_LIST ) THEN              ERROR ( D ( LX_SRCPOS, RULE_NODE ), "!! CLASSE VIDE : " & PRINT_NAME ( D ( XD_SYMREP, ITEM 
) ) );            ELSIF HEAD ( DEFINING_RULE_LIST ).TY /= DN_CLASS_NODE THEN               ERROR ( D ( LX_SRCPOS, RULE
_NODE ), "!! PAS UN NOEUD CLASSE : " & PRINT_NAME ( D ( XD_SYMREP, ITEM ) ) );            ELSE              DECLARE  
              DEFINING_RULEК: CONSTANT TREE:= HEAD ( DEFINING_RULE_LIST );                OWNERК: CONSTANT TREE:= R
ULE_NODE;                PARENTК: TREEК:= D ( XD_PARENT, DEFINING_RULE );              BEGIN                D ( XD_
CLASS_NODE, ITEM, DEFINING_RULE );                IF PARENT = TREE_VOID THEN                  D ( XD_PARENT, DEFINING_
RULE, OWNER );                                             ELSIF DEFINING_RULE = TREE_VOID THEN                  NULL
;                ELSIF PARENT /= OWNER THEN                  ERROR ( D ( LX_SRCPOS, OWNER ), "NOEUD/CLASSE "         
                        & PRINT_NAME ( D ( XD_SYMREP, DEFINING_RULE ) )                                 & " A LA FOIS D
ANS " & PRINT_NAME ( D ( XD_SYMREP, OWNER ) )                                 & " ET " & PRINT_NAME ( D ( XD_SYMREP, PA
RENT ) )                                 );                END IF;              END;            END IF;          EN
D;        END IF;      END LOOP;    END LOOP;  END CHECK_IDL;  --|-------------------------------------------------
----------------------------------------------  --|КPROCEDURE PRINT_IDL  PROCEDURE PRINT_IDL IS    NODE_LISTК: SEQ_
TYPEК:= LIST ( USER_ROOT );    RULE_NODEК: TREE;    ITEM_LISTК: SEQ_TYPE;    ITEMК: TREE;    DEFLISTК: SEQ_TYP
E;    NFILE, CFILEК: TEXT_IO.FILE_TYPE;КК--| FICHIERS NOEUDS ET HIERARCHIE    --|---------------------------------
------------------------------------------------------------    --|КPROCEDURE CLASS_PATH    PROCEDURE CLASS_PATH ( NO
DE :TREE; IS_CLASS :BOOLEAN ) IS      PARENTК: CONSTANT TREEК:= D( XD_PARENT, NODE );    BEGIN      IF PARENT = NOD
E THEN        ERROR( D( LX_SRCPOS, NODE ), "AUTO PARENT ! " & PRINT_NAME( D( XD_SYMREP, NODE ) ) );        PUT_LINE ( 
"ERREUR PARTITION" );      END IF;               IF PARENT = TREE_VOID THENККК--| CLASSE DE BASE        IF DB( X
D_IS_CLASS, NODE ) THENККК--| UN NOEUD CLASSE          DECLARE            THE_NAME: CONSTANT STRINGК:= PRINT_NAM
E( D ( XD_SYMREP, NODE ) );          BEGIN            IF THE_NAME /= "NON_DIANA"              AND THEN THE_NAME /= "A
LL_SOURCE"              AND THEN THE_NAME /= "TYPE_SPEC"              AND THEN THE_NAME /= "STANDARD_IDL"            
THEN              PUT_LINE ( "**** PARTITION INATTENDUE = " & THE_NAME );            END IF;            PUT( THE_NAME
 );            IF NOT IS_CLASS THEN              PUT( CFILE, THE_NAME );            END IF;          END;          
             ELSEКККК--| UN NOEUD DE REGLE D'ATTRIBUTION          PUT( "..." );        END IF;                
  ELSEКККК--| PAS CLASSE DE BASE        CLASS_PATH( PARENT, IS_CLASS );ККК--| REMONTER VERS LA CLASSE DE BASE
        PUT( " > " & PRINT_NAME( D( XD_SYMREP, NODE ) ) );        IF NOT IS_CLASS THEN          PUT ( CFILE, " > " & P
RINT_NAME ( D ( XD_SYMREP, NODE ) ) );К--| REPETER        END IF;      END IF;    END CLASS_PATH;                
    BEGIN    CREATE ( NFILE, OUT_FILE, NOM_TEXTE & "_NODES_.txt" );КК--| FICHIER INFORMATION TEXTE DES NOEUDS    C
REATE ( CFILE, OUT_FILE, NOM_TEXTE & "_CLASS_.txt" );КК--| FICHIER INFORMATION TEXTE HIERARCHIE DES CLASSES    SET_O
UTPUT ( NFILE );    PUT_LINE ( "----- ARBORESCENCE IDL -----");    WHILE NOT IS_EMPTY ( NODE_LIST ) LOOP      POP ( N
ODE_LIST, RULE_NODE );                  DECLARE        IS_A_CLASSК: CONSTANT BOOLEANК:= DB ( XD_IS_CLASS, RULE_NODE
 );      BEGIN        DECLARE          RULE_CLASS_NAME: CONSTANT STRINGК:= PRINT_NAME ( D ( XD_SYMREP, RULE_NODE ) 
);        BEGIN                         IF IS_A_CLASS THENКККК--| DEFINIT UNE CLASSE            PUT ( "{" & RULE
_CLASS_NAME & "}" );          ELSE            PUT ( RULE_CLASS_NAME );          END IF;        END;               
     PUT ( ASCII.HT & "PATH " );        CLASS_PATH ( RULE_NODE, IS_CLASS=> DB ( XD_IS_CLASS, RULE_NODE ) );        IF 
NOT IS_A_CLASS THENККК--| PAS UNE CLASSE          NEW_LINE ( CFILE );        END IF;                    ITEM_LIS
T := LIST ( RULE_NODE );ККК--| LISTE DES ATTRIBUTS OU DES MEMBRES        IF NOT IS_EMPTY ( ITEM_LIST ) THEN        
  IF IS_A_CLASS THENКККК--| DEFINIT UNE CLASSE            PUT ( " ::= " );          END IF;        END IF;      
  NEW_LINE;      END;               WHILE NOT IS_EMPTY ( ITEM_LIST ) LOOP        POP ( ITEM_LIST, ITEM );          
             IF ITEM.TY = DN_ATTR THENККК--| ATTRIBUT          PUT ( ASCII.HT & "=> " & PRINT_NAME ( D ( XD_SYMREP
, ITEM ) ) & ASCII.HT & ": ");          IF DI ( XD_ATTR_ID, ITEM ) < 0 THENККК--| ATTRIBUT SEQUENCE            PUT 
( "SEQ OF ");          END IF;          PUT_LINE ( PRINT_NAME ( D ( XD_ATTR_TYPE, ITEM ) ) );КК--| TYPAGE          
                ELSEКККК--| MEMBRE DE CLASSE          PUT ( ASCII.HT & PRINT_NAME ( D ( XD_SYMREP, ITEM ) ) );К
--| NOM DU MEMBRE          DEFLIST := LIST ( D ( XD_SYMREP, ITEM ) );          IF IS_EMPTY ( DEFLIST ) OR ELSE HEAD (
 DEFLIST ).TY /= DN_CLASS_NODE THEN            PUT ( " ?????" );          END IF;          NEW_LINE;        END IF;
      END LOOP;      NEW_LINE;                END LOOP;    SET_OUTPUT ( STANDARD_OUTPUT );    CLOSE ( NFILE );    
CLOSE ( CFILE );           EXCEPTION    WHEN OTHERS =>      CLOSE ( NFILE );      CLOSE ( CFILE );      PUT_LINE (
 "ERREUR A L IMPRESSION" );  END PRINT_IDL;   턆EGIN     OPEN ( IFILE, IN_FILE, "../../idl/" & NOM_TEXTE & ".idl" );
ККК--| FICHIER SOURCE IDL  PUT_LINE ( "LE FICHIER : " & NOM_TEXTE & ".IDL EST OUVERT " );  CREATE_IDL_TREE_FILE ( N
OM_TEXTE & ".lar");КККК--| FICHIER D'ARBRE IDL  PUT_LINE ( "LE FICHIER : " & NOM_TEXTE & ".lar  EST CREE" );  SOUR
CE_LIST := (TREE_NIL,TREE_NIL);        PUT_LINE ( "PROCESS IDL ..." ); PROCESS_IDL; PUT_LINE ( " OK" );  LIST ( TREE_
ROOT, SOURCE_LIST );  CLOSE ( IFILE );        CHECK_IDL;  PRINT_IDL;           CLOSE_IDL_TREE_FILE;       턉XCEPT
ION  WHEN NAME_ERROR =>    PUT_LINE ( "LE FICHIER DESCRIPTION : " & "../../idl/" & NOM_TEXTE & ".idl  EST INTROUVABLE"
 );   --|-------------------------------------------------------------------------------------------------턉ND IDL_REA
D;
