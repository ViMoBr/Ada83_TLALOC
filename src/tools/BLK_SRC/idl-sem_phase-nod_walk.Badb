separate (IDL.SEM_PHASE)    --|----------------------------------------------------------------------------------------
------    --| NOD_WALK    --|-----------------------------------------------------------------------------------------
-----턯ackage body NOD_WALK is떰  use DEF_UTIL;  use VIS_UTIL;  use MAKE_NOD;  use EXP_TYPE, EXPRESO;  use REQ_UTIL;
  use RED_SUBP;  use DEF_WALK;  use SET_UTIL;  use STM_WALK;  use PRA_WALK;  use ATT_WALK;  use HOM_UNIT;  use D
ERIVED; -- REMEMBER_DERIVED_DECL떰  EQUAL_SYM     : TREE := TREE_VOID; -- STORESYM("=");  NOT_EQUAL_SYM : TREE := TREE_
VOID; -- STORESYM("/=");떰      --|-------------------------------------------------------------------------------------
------      --|       PROCEDURE FORCE_UPPER_CASE  procedure FORCE_UPPER_CASE (OPERATOR_ID : TREE) is    function MAKE
_UPPER_CASE (A_IN : String) return String is      MAGIC : constant            := Character'POS ('A') - Character'POS ('
A');      A     : String (A_IN'RANGE) := A_IN;    begin      for II in A'RANGE loop        if A (II) in 'A' .. 'Z' t
hen          A (II) := Character'VAL (Character'POS (A (II)) - MAGIC);        end if;      end loop;      return A;
    end MAKE_UPPER_CASE;떰  begin    D (LX_SYMREP, OPERATOR_ID, STORE_SYM (MAKE_UPPER_CASE (PRINT_NAME (D (LX_SYMREP, O
PERATOR_ID)))));  end FORCE_UPPER_CASE;      --|----------------------------------------------------------------------
---------------------      --|       PROCEDURE INSERT_OBJ_TYPE_AND_INIT_EXP_IN_S  procedure INSERT_OBJ_TYPE_AND_INIT_E
XP_IN_S (SOURCE_NAME_S : TREE; OBJ_TYPE : TREE; INIT_EXP : TREE := TREE_VOID) is    SOURCE_NAME_LIST : SEQ_TYPE := LIST
 (SOURCE_NAME_S);    SOURCE_NAME      : TREE;    SOURCE_DEF       : TREE;    PRIOR_NAME       : TREE;    PRIOR_DEF  
      : TREE;떰    TEMP_OBJ_TYPE : TREE := OBJ_TYPE;    TEMP_INIT_EXP : TREE := INIT_EXP;  begin    while not IS_EMPT
Y (SOURCE_NAME_LIST) loop떰      POP (SOURCE_NAME_LIST, SOURCE_NAME);      SOURCE_DEF := GET_DEF_FOR_ID (SOURCE_NAME);
      MAKE_DEF_VISIBLE (SOURCE_DEF);      PRIOR_DEF := GET_PRIOR_DEF (SOURCE_DEF);      D (SM_OBJ_TYPE, SOURCE_NAME, T
EMP_OBJ_TYPE);      if TEMP_INIT_EXP /= TREE_VOID then        D (SM_INIT_EXP, SOURCE_NAME, TEMP_INIT_EXP);      end i
f;떰      if OBJ_TYPE = TREE_VOID then        MAKE_DEF_IN_ERROR (SOURCE_DEF);      elsif PRIOR_DEF /= TREE_VOID then 
       if SOURCE_NAME.TY = DN_CONSTANT_ID then          PRIOR_NAME := D (XD_SOURCE_NAME, PRIOR_DEF);          if PRIOR
_NAME.TY = DN_CONSTANT_ID and then D (SM_INIT_EXP, PRIOR_NAME) = TREE_VOID and then GET_BASE_TYPE (D (SM_OBJ_TYPE, PRIOR
_NAME)) = GET_BASE_TYPE (TEMP_OBJ_TYPE) then            REMOVE_DEF_FROM_ENVIRONMENT (SOURCE_DEF);            D (SM_FIR
ST, SOURCE_NAME, PRIOR_NAME);            D (SM_INIT_EXP, PRIOR_NAME, TEMP_INIT_EXP);          else            ERROR (
D (LX_SRCPOS, SOURCE_NAME), "DUPLICATE DECLARATION OF CONSTANT - " & PRINT_NAME (D (LX_SYMREP, SOURCE_NAME)));         
   MAKE_DEF_IN_ERROR (SOURCE_DEF);          end if;        else          ERROR (D (LX_SRCPOS, SOURCE_NAME), "DUPLICAT
E DECLARATION - " & PRINT_NAME (D (LX_SYMREP, SOURCE_NAME)));          MAKE_DEF_IN_ERROR (SOURCE_DEF);        end if;
      else        MAKE_DEF_VISIBLE (SOURCE_DEF);      end if;떰    end loop;  end INSERT_OBJ_TYPE_AND_INIT_EXP_IN_S;
      --|-------------------------------------------------------------------------------------------      --|       PRO
CEDURE FIXUP_CONSTRAINED_ARRAY_OBJECTS  procedure FIXUP_CONSTRAINED_ARRAY_OBJECTS (SOURCE_NAME_S : TREE; H : H_TYPE) is
    SOURCE_NAME_LIST   : SEQ_TYPE := LIST (SOURCE_NAME_S);    SOURCE_NAME        : TREE;    OBJ_TYPE           : TREE
;    EXP                : TREE;    CONSTRAINED_SPEC   : TREE;    UNCONSTRAINED_SPEC : TREE;  begin    POP (SOURCE_N
AME_LIST, SOURCE_NAME);    OBJ_TYPE := D (SM_OBJ_TYPE, SOURCE_NAME);    EXP      := D (SM_INIT_EXP, SOURCE_NAME);    
            -- MAKE PREDEFINED OPERATORS FOR FIRST OBJECT TYPE    PRE_FCNS.GEN_PREDEFINED_OPERATORS (GET_BASE_TYPE (OBJ
_TYPE), H);                -- FOR EACH SOURCE NAME EXCEPT THE FIRST    while not IS_EMPTY (SOURCE_NAME_LIST) loop    
  POP (SOURCE_NAME_LIST, SOURCE_NAME);                        -- MAKE COPIES OF TYPE AND SUBTYPE SPEC      CONSTRAINED
_SPEC   := COPY_NODE (OBJ_TYPE);      UNCONSTRAINED_SPEC := COPY_NODE (D (SM_BASE_TYPE, CONSTRAINED_SPEC));      D (XD
_SOURCE_NAME, CONSTRAINED_SPEC, SOURCE_NAME);      D (XD_SOURCE_NAME, UNCONSTRAINED_SPEC, SOURCE_NAME);      D (SM_BAS
E_TYPE, UNCONSTRAINED_SPEC, UNCONSTRAINED_SPEC);      D (SM_BASE_TYPE, CONSTRAINED_SPEC, UNCONSTRAINED_SPEC);         
               -- GENERATE PREDEFINED OPERATORS FOR CREATED TYPE      PRE_FCNS.GEN_PREDEFINED_OPERATORS (GET_BASE_TYPE 
(UNCONSTRAINED_SPEC), H);                        -- IF AN INITIALIZATION EXPRESSION WAS GIVEN      if EXP /= TREE_VOID
 then                                -- MAKE A COPY OF IT WITH THE NEW TYPE        EXP := COPY_NODE (EXP);        D (
SM_EXP_TYPE, EXP, CONSTRAINED_SPEC);        D (SM_INIT_EXP, SOURCE_NAME, EXP);      end if;    end loop;  end FIXUP_
CONSTRAINED_ARRAY_OBJECTS;      --|------------------------------------------------------------------------------------
-------      --|       PROCEDURE FINISH_PARAM_DECL  procedure FINISH_PARAM_DECL (NODE : TREE; H : H_TYPE) is    SOURC
E_NAME_S : TREE := D (AS_SOURCE_NAME_S, NODE);    EXP           : TREE := D (AS_EXP, NODE);    NAME          : TREE :=
 D (AS_NAME, NODE);떰    TYPE_SPEC : TREE;    TYPESET   : TYPESET_TYPE;  begin    TYPE_SPEC := EVAL_TYPE_MARK (NAME);
    NAME      := RESOLVE_TYPE_MARK (NAME);    D (AS_NAME, NODE, NAME);떰    if EXP /= TREE_VOID then      EVAL_EXP_TY
PES (EXP, TYPESET);      REQUIRE_TYPE (GET_BASE_TYPE (TYPE_SPEC), EXP, TYPESET);      EXP := RESOLVE_EXP (EXP, TYPESET
);    end if;                -- GET SUBTYPE FOR OBJECT    if TYPE_SPEC /= TREE_VOID then      TYPE_SPEC := D (SM_TYP
E_SPEC, GET_NAME_DEFN (NAME));    end if;떰    INSERT_OBJ_TYPE_AND_INIT_EXP_IN_S (SOURCE_NAME_S, OBJ_TYPE => TYPE_SPEC,
 INIT_EXP => EXP);  end FINISH_PARAM_DECL;      --|-------------------------------------------------------------------
------------------------      --|       PROCEDURE FINISH_PARAM_S  procedure FINISH_PARAM_S (DECL_S : TREE; H : H_TYPE)
 is    DECL_LIST : SEQ_TYPE := LIST (DECL_S);    DECL      : TREE;  begin    while not IS_EMPTY (DECL_LIST) loop   
   POP (DECL_LIST, DECL);      WALK (DECL, H);      FINISH_PARAM_DECL (DECL, H);    end loop;  end FINISH_PARAM_S; 
     --|-------------------------------------------------------------------------------------------      --|       PROC
EDURE WALK_HEADER  procedure WALK_HEADER (NODE : TREE; H : H_TYPE) is  begin떰    case CLASS_HEADER'(NODE.TY) is떰    
  when DN_PROCEDURE_SPEC =>        declare          PARAM_S : TREE := D (AS_PARAM_S, NODE);        begin          FI
NISH_PARAM_S (PARAM_S, H);        end;떰      when DN_FUNCTION_SPEC =>        declare          PARAM_S : TREE := D (A
S_PARAM_S, NODE);          NAME    : TREE := D (AS_NAME, NODE);          DUMMY   : TREE;        begin          if NA
ME /= TREE_VOID then            DUMMY := EVAL_TYPE_MARK (NAME);            NAME  := RESOLVE_TYPE_MARK (NAME);        
    D (AS_NAME, NODE, NAME);          end if;          FINISH_PARAM_S (PARAM_S, H);        end;떰      when DN_ENTRY 
=>        declare          PARAM_S        : TREE := D (AS_PARAM_S, NODE);          DISCRETE_RANGE : TREE := D (AS_DIS
CRETE_RANGE, NODE);          TYPESET        : TYPESET_TYPE;          TYPE_SPEC      : TREE;        begin          if
 DISCRETE_RANGE /= TREE_VOID then            EVAL_NON_UNIVERSAL_DISCRETE_RANGE (DISCRETE_RANGE, TYPESET);            R
EQUIRE_UNIQUE_TYPE (DISCRETE_RANGE, TYPESET);            TYPE_SPEC := GET_THE_TYPE (TYPESET);            if TYPE_SPEC.
TY = DN_UNIVERSAL_INTEGER then                                                        --$$$$ CHECK FOR VALID BOUND EXPR
ESSIONS                                                        --$$$$ ARE WE CHECKING THAT IT IS DISCRETE ?           
   TYPE_SPEC := PREDEFINED_INTEGER;            end if;            DISCRETE_RANGE := RESOLVE_DISCRETE_RANGE (DISCRETE_R
ANGE, TYPE_SPEC);            D (AS_DISCRETE_RANGE, NODE, DISCRETE_RANGE);          else            TYPE_SPEC := TREE_
VOID;          end if;          FINISH_PARAM_S (PARAM_S, H);        end;떰      when DN_PACKAGE_SPEC =>        decla
re          DECL_S1 : constant TREE := D (AS_DECL_S1, NODE);          DECL_S2 : constant TREE := D (AS_DECL_S2, NODE);
          H       : H_TYPE        := WALK_HEADER.H;        begin          DB (XD_BODY_IS_REQUIRED, NODE, False);    
      WALK_ITEM_S (DECL_S1, H);          H.IS_IN_SPEC := False;          WALK_ITEM_S (DECL_S2, H);          DB (XD_BO
DY_IS_REQUIRED, NODE, True);        end;    end case;  end WALK_HEADER;      --|------------------------------------
-------------------------------------------------------      --|       PROCEDURE WALK_UNIT_DESC  procedure WALK_UNIT_D
ESC (SOURCE_NAME : TREE; NODE : TREE; H : H_TYPE; HEADER : TREE := TREE_VOID) is  begin    if NODE = TREE_VOID then  
    return;    end if;떰    case CLASS_UNIT_DESC'(NODE.TY) is떰      when DN_RENAMES_UNIT | DN_NAME_DEFAULT =>        
declare          NAME : TREE := D (AS_NAME, NODE);        begin          if SOURCE_NAME.TY = DN_PACKAGE_ID then     
       NAME := WALK_NAME (DN_PACKAGE_ID, NAME);          else            NAME := WALK_HOMOGRAPH_UNIT (NAME, HEADER); 
         end if;          D (AS_NAME, NODE, NAME);        end;떰      when DN_INSTANTIATION =>        INSTANT.WALK_IN
STANTIATION (SOURCE_NAME, NODE, H);떰      when DN_BOX_DEFAULT | DN_NO_DEFAULT =>        null;떰      when DN_BLOCK_BOD
Y =>        declare          ITEM_S           : TREE := D (AS_ITEM_S, NODE);          STM_S            : TREE := D (A
S_STM_S, NODE);          ALTERNATIVE_S    : TREE := D (AS_ALTERNATIVE_S, NODE);          ALTERNATIVE_LIST : SEQ_TYPE;
          ALTERNATIVE      : TREE;        begin          WALK_ITEM_S (ITEM_S, H);          if STM_S /= TREE_VOID then
            DECLARE_LABEL_BLOCK_LOOP_IDS (STM_S, H);          end if;          if ALTERNATIVE_S /= TREE_VOID then   
         ALTERNATIVE_LIST := LIST (ALTERNATIVE_S);            while not IS_EMPTY (ALTERNATIVE_LIST) loop              
POP (ALTERNATIVE_LIST, ALTERNATIVE);              if ALTERNATIVE.TY = DN_ALTERNATIVE then                DECLARE_LABEL
_BLOCK_LOOP_IDS (D (AS_STM_S, ALTERNATIVE), H);              end if;            end loop;          end if;          
if STM_S /= TREE_VOID then            WALK_STM_S (STM_S, H);          end if;          WALK_ALTERNATIVE_S (ALTERNATIV
E_S, H);        end;떰      when DN_STUB =>        declare        begin          null;        end;떰      when DN_I
MPLICIT_NOT_EQ | DN_DERIVED_SUBPROG =>        Put_Line ("!! WALK_UNIT_DESC: INVALID NODE");        raise Program_Error
;떰    end case;  end WALK_UNIT_DESC;      --|------------------------------------------------------------------------
-------------------      --|       PROCEDURE CHECK_EQUALITY_OPERATOR  procedure CHECK_EQUALITY_OPERATOR (OPERATOR_ID :
 TREE; H : H_TYPE) is    SYMREP : TREE;    NEW_ID : TREE;  begin    if OPERATOR_ID.TY /= DN_OPERATOR_ID then      r
eturn;    end if;떰    if EQUAL_SYM = TREE_VOID then      EQUAL_SYM     := STORE_SYM ("""=""");      NOT_EQUAL_SYM :=
 STORE_SYM ("""/=""");    end if;떰    SYMREP := D (LX_SYMREP, OPERATOR_ID);    if SYMREP = NOT_EQUAL_SYM then      E
RROR (D (LX_SRCPOS, OPERATOR_ID), "DEFINITION OF ""/="" OPERATOR");    end if;떰    if SYMREP = EQUAL_SYM then      NE
W_ID := COPY_NODE (OPERATOR_ID);                        -- SET SM_FIRST TO THE CREATED ID      D (SM_FIRST, NEW_ID, NE
W_ID);      D (LX_SYMREP, NEW_ID, NOT_EQUAL_SYM);      D (SM_UNIT_DESC, NEW_ID, MAKE_IMPLICIT_NOT_EQ (SM_EQUAL => OPER
ATOR_ID));      MAKE_DEF_VISIBLE (MAKE_DEF_FOR_ID (NEW_ID, H), D (XD_HEADER, GET_DEF_FOR_ID (OPERATOR_ID)));      D (X
D_NOT_EQUAL, OPERATOR_ID, NEW_ID);                        -- CONSTRUCT NEW FORMAL PARAMETER ID'S      declare        
SPEC           : TREE     := COPY_NODE (D (SM_SPEC, NEW_ID));        PARAM_S        : TREE     := COPY_NODE (D (AS_PARA
M_S, SPEC));        PARAM_LIST     : SEQ_TYPE := LIST (PARAM_S);        PARAM          : TREE;        ID_S           
: TREE;        ID_LIST        : SEQ_TYPE;        ID             : TREE;        NEW_ID_LIST    : SEQ_TYPE;        NEW
_PARAM_LIST : SEQ_TYPE := (TREE_NIL, TREE_NIL);      begin        while not IS_EMPTY (PARAM_LIST) loop          POP (
PARAM_LIST, PARAM);          PARAM       := COPY_NODE (PARAM);          ID_S        := COPY_NODE (D (AS_SOURCE_NAME_S,
 PARAM));          ID_LIST     := LIST (ID_S);          NEW_ID_LIST := (TREE_NIL, TREE_NIL);          while not IS_EM
PTY (ID_LIST) loop            POP (ID_LIST, ID);            ID := COPY_NODE (ID);            D (SM_FIRST, ID, ID);  
          NEW_ID_LIST := APPEND (NEW_ID_LIST, ID);          end loop;          LIST (ID_S, NEW_ID_LIST);          D (
AS_SOURCE_NAME_S, PARAM, ID_S);          NEW_PARAM_LIST := APPEND (NEW_PARAM_LIST, PARAM);        end loop;        LI
ST (PARAM_S, NEW_PARAM_LIST);        D (AS_PARAM_S, SPEC, PARAM_S);        D (SM_SPEC, NEW_ID, SPEC);      end;    e
nd if;  end CHECK_EQUALITY_OPERATOR;      --|-------------------------------------------------------------------------
------------------      --|       FUNCTION IS_CONSTANT_EXP  function IS_CONSTANT_EXP (EXP : TREE) return Boolean is  
begin    if EXP.TY = DN_SELECTED then      return IS_CONSTANT_EXP (D (AS_DESIGNATOR, EXP));    elsif EXP.TY = DN_USED
_OBJECT_ID then      return D (SM_DEFN, EXP).TY = DN_CONSTANT_ID;    else      return False;    end if;  end IS_CON
STANT_EXP;      --|-------------------------------------------------------------------------------------------      --
|       FUNCTION SWITCH_REGION  procedure SWITCH_REGION (GENERIC_ID, REGION_DEF : TREE) is    ITEM_LIST : SEQ_TYPE := 
LIST (D (SM_GENERIC_PARAM_S, GENERIC_ID));    ITEM      : TREE;    NAME_LIST : SEQ_TYPE;    NAME      : TREE;  begin
    while not IS_EMPTY (ITEM_LIST) loop      POP (ITEM_LIST, ITEM);      case CLASS_ITEM'(ITEM.TY) is        when CL
ASS_DSCRMT_PARAM_DECL | CLASS_ID_S_DECL =>          NAME_LIST := LIST (D (AS_SOURCE_NAME_S, ITEM));          while not
 IS_EMPTY (NAME_LIST) loop            POP (NAME_LIST, NAME);            if D (LX_SYMREP, NAME).TY = DN_SYMBOL_REP then
              D (XD_REGION_DEF, GET_DEF_FOR_ID (NAME), REGION_DEF);            end if;          end loop;        whe
n CLASS_ID_DECL =>          if D (LX_SYMREP, D (AS_SOURCE_NAME, ITEM)).TY = DN_SYMBOL_REP then            D (XD_REGION
_DEF, GET_DEF_FOR_ID (D (AS_SOURCE_NAME, ITEM)), REGION_DEF);          end if;        when others =>          null; 
     end case;    end loop;  end SWITCH_REGION;      --|-------------------------------------------------------------
------------------------------      --|       PROCEDURE REPROCESS_USE_CLAUSES  procedure REPROCESS_USE_CLAUSES (DECL_S
 : TREE; H : H_TYPE) is           --| POUR LA VISIBILIT DANS LE CORPS DES CLAUSES DE LA DECL DE PACKAGE    DECL_LIST : 
SEQ_TYPE;    DECL      : TREE;    ITEM_LIST : SEQ_TYPE;    ITEM      : TREE;    ITEM_DEFN : TREE;    ITEM_DEF  : TR
EE;  begin    if DECL_S = TREE_VOID then      return;    end if;떰    DECL_LIST := LIST (DECL_S);    while not IS_E
MPTY (DECL_LIST) loop      POP (DECL_LIST, DECL);      if DECL.TY = DN_USE then        ITEM_LIST := LIST (D (AS_NAME_
S, DECL));        while not IS_EMPTY (ITEM_LIST) loop          POP (ITEM_LIST, ITEM);          if ITEM.TY = DN_SELECT
ED then            ITEM := D (AS_DESIGNATOR, ITEM);          end if;          if ITEM.TY = DN_USED_NAME_ID then     
       ITEM_DEFN := D (SM_DEFN, ITEM);          else            ITEM_DEFN := TREE_VOID;          end if;          if
 ITEM_DEFN.TY = DN_PACKAGE_ID then            ITEM_DEF := GET_DEF_FOR_ID (ITEM_DEFN);            if DI (XD_LEX_LEVEL, 
ITEM_DEF) <= 0 and then not DB (XD_IS_USED, ITEM_DEF) then              DB (XD_IS_USED, ITEM_DEF, True);              
SU.USED_PACKAGE_LIST := INSERT (SU.USED_PACKAGE_LIST, ITEM_DEF);            end if;          end if;        end loop;
      elsif DECL.TY = DN_TYPE_DECL and then (D (AS_TYPE_DEF, DECL).TY = DN_RECORD_DEF or else D (AS_TYPE_DEF, DECL).TY 
in DN_CONSTRAINED_ARRAY_DEF .. DN_UNCONSTRAINED_ARRAY_DEF) then        PRE_FCNS.GEN_PREDEFINED_OPERATORS (D (SM_TYPE_SP
EC, D (AS_SOURCE_NAME, DECL)), H);      elsif DECL.TY in CLASS_OBJECT_DECL and then D (AS_TYPE_DEF, DECL).TY = DN_CONST
RAINED_ARRAY_DEF then        declare          ID_LIST : SEQ_TYPE := LIST (D (AS_SOURCE_NAME_S, DECL));          ID   
   : TREE;        begin          while not IS_EMPTY (ID_LIST) loop            POP (ID_LIST, ID);            PRE_FCNS
.GEN_PREDEFINED_OPERATORS (D (SM_OBJ_TYPE, ID), H);          end loop;        end;      end if;    end loop;  end R
EPROCESS_USE_CLAUSES;떰땝К----  procedureК촜ALKК( NODE :TREE; H :H_TYPE )  isКК----떰  begin    if NODE = TREE_
VOID then      return;    end if;떰    case CLASS_ITEM'(NODE.TY) is떰      when DN_DSCRMT_DECL | DN_IN | DN_IN_OUT | D
N_OUT =>         --| DISCRIMINANT OU DIRECTION        declare          SOURCE_NAME_S : TREE := D (AS_SOURCE_NAME_S, NO
DE);        begin          WALK_SOURCE_NAME_S (SOURCE_NAME_S, H);        end;떰                         --| DECLARATI
ON DE CONSTANTE      when DN_CONSTANT_DECL =>        declare          SOURCE_NAME_S : TREE := D (AS_SOURCE_NAME_S, NO
DE);          EXP           : TREE := D (AS_EXP, NODE);          TYPE_DEF      : TREE := D (AS_TYPE_DEF, NODE);떰     
     TYPE_SPEC : TREE;          TYPESET   : TYPESET_TYPE;        begin          WALK_SOURCE_NAME_S (SOURCE_NAME_S, H)
;КККК--| INSRER LES NOMS DANS L'ENVIRONNEMENT떰          if TYPE_DEF.TY = DN_CONSTRAINED_ARRAY_DEF thenККК--| DC
LARATION DE TABLEAU CONTRAINT            TYPE_SPEC := EVAL_TYPE_DEF (TYPE_DEF, HEAD (LIST (SOURCE_NAME_S)), H);КК--| 
EVALUER LA DFINITION DE TYPE떰          elseККККК--| LA DCLARATION CONTIENT UNE SUBTYPE INDICATION            TYP
E_SPEC := EVAL_SUBTYPE_INDICATION (TYPE_DEF);            RESOLVE_SUBTYPE_INDICATION (TYPE_DEF, TYPE_SPEC);            
D (AS_TYPE_DEF, NODE, TYPE_DEF);          end if;떰          EVAL_EXP_TYPES (EXP, TYPESET);                      --| EV
ALUER L'EXPRESSION QUI DOIT TRE DONNE          REQUIRE_TYPE (GET_BASE_TYPE (TYPE_SPEC), EXP, TYPESET);          REQUIR
E_NONLIMITED_TYPE (EXP, TYPESET);          EXP := RESOLVE_EXP (EXP, TYPESET);          D (AS_EXP, NODE, EXP);        
                                -- COMPLETE SOURCE_NAME DEFINITIONS AND MAKE VISIBLE          INSERT_OBJ_TYPE_AND_INIT_
EXP_IN_S (SOURCE_NAME_S, OBJ_TYPE => TYPE_SPEC, INIT_EXP => EXP);                                        -- IF TYPE DEF
INITION IS A CONSTRAINED ARRAY DEFINITION          if TYPE_DEF.TY = DN_CONSTRAINED_ARRAY_DEF then            FIXUP_CON
STRAINED_ARRAY_OBJECTS (SOURCE_NAME_S, H);              --| COPIER LES ARRAY TYPE SPECS ET GNRER LES OPRATEURS PRDFINIS
          end if;        end;떰         --| DECLARATION DE VARIABLE      when DN_VARIABLE_DECL =>        declare    
      SOURCE_NAME_S : TREE := D (AS_SOURCE_NAME_S, NODE);          EXP           : TREE := D (AS_EXP, NODE);          
TYPE_DEF      : TREE := D (AS_TYPE_DEF, NODE);떰          TYPE_SPEC : TREE;          TYPESET   : TYPESET_TYPE;        
begin          WALK_SOURCE_NAME_S (SOURCE_NAME_S, H);КККК--| INSRER LES NOMS DANS L'ENVIRONNEMENT떰          if TYP
E_DEF.TY = DN_CONSTRAINED_ARRAY_DEF thenККК--| CONTIENT UNE DFINITION DE TABLEAU CONTRAINT            TYPE_SPEC := 
EVAL_TYPE_DEF (TYPE_DEF, HEAD (LIST (SOURCE_NAME_S)), H);КК--| EVALUER LA DFINITION DE TYPE떰          elseККККК
--| INDICATION DE SOUS TYPE            TYPE_SPEC := EVAL_SUBTYPE_INDICATION( TYPE_DEF );ККК--| EVALUER LA SUBTYPE IN
DICATION            RESOLVE_SUBTYPE_INDICATION( TYPE_DEF, TYPE_SPEC );ККК--| LA RSOUDRE            D (AS_TYPE_DEF, 
NODE, TYPE_DEF);떰          end if;떰          if EXP /= TREE_VOID then                      --| UNE EXPRESSION EST DONN
E            EVAL_EXP_TYPES (EXP, TYPESET);            REQUIRE_TYPE (GET_BASE_TYPE (TYPE_SPEC), EXP, TYPESET);       
     REQUIRE_NONLIMITED_TYPE (EXP, TYPESET);            EXP := RESOLVE_EXP (EXP, TYPESET);            D (AS_EXP, NODE,
 EXP);          end if;떰          INSERT_OBJ_TYPE_AND_INIT_EXP_IN_S           (SOURCE_NAME_S,    --| TERMINER LES DFI
NITIONS ET RENDRE VISIBLE            OBJ_TYPE => TYPE_SPEC, INIT_EXP => EXP);떰          if TYPE_DEF.TY = DN_CONSTRAINE
D_ARRAY_DEF then            FIXUP_CONSTRAINED_ARRAY_OBJECTS (SOURCE_NAME_S, H);          end if;        end;        
                  --| DECLARATION DE NOMBRE      when DN_NUMBER_DECL =>        declare          SOURCE_NAME_S : TREE 
:= D (AS_SOURCE_NAME_S, NODE);          EXP           : TREE := D (AS_EXP, NODE);          TYPE_SPEC     : TREE;     
     TYPESET       : TYPESET_TYPE;        begin          WALK_SOURCE_NAME_S (SOURCE_NAME_S, H);          EVAL_EXP_TYP
ES (EXP, TYPESET);          REQUIRE_UNIVERSAL_TYPE (EXP, TYPESET);          REQUIRE_UNIQUE_TYPE (EXP, TYPESET);      
    TYPE_SPEC := GET_THE_TYPE (TYPESET);          EXP       := RESOLVE_EXP (EXP, TYPE_SPEC);          INSERT_OBJ_TYPE_
AND_INIT_EXP_IN_S (SOURCE_NAME_S, OBJ_TYPE => TYPE_SPEC, INIT_EXP => EXP);        end;                          --| DE
CLARATION D'EXCEPTION      when DN_EXCEPTION_DECL =>        declare          SOURCE_NAME_S : TREE := D (AS_SOURCE_NAM
E_S, NODE);        begin          WALK_SOURCE_NAME_S (SOURCE_NAME_S, H);          CHECK_UNIQUE_SOURCE_NAME_S (SOURCE_
NAME_S);        end;                          --| DECLARATION DE CONSTANTE DIFFEREE      when DN_DEFERRED_CONSTANT_DE
CL =>        declare          SOURCE_NAME_S : TREE := D (AS_SOURCE_NAME_S, NODE);          NAME          : TREE := D 
(AS_NAME, NODE);          TYPE_SPEC     : TREE;        begin          WALK_SOURCE_NAME_S (SOURCE_NAME_S, H);        
  TYPE_SPEC := EVAL_TYPE_MARK (NAME);          if TYPE_SPEC /= TREE_VOID then            TYPE_SPEC := D (SM_TYPE_SPEC,
 GET_NAME_DEFN (NAME));          end if;          NAME := RESOLVE_TYPE_MARK (NAME);          D (AS_NAME, NODE, NAME);
                                        -- CHECK THAT CURRENT DECLARATION IS IN VISIBLE PART                          
              -- ... AND THAT TYPE IS PRIVATE TYPE IS DEFINED IN THIS REGION                                        -- 
... (OUTSIDE THE PACKAGE, SM_TYPE_SPEC IS NOT VOID)          if not H.IS_IN_SPEC or else GET_BASE_TYPE (TYPE_SPEC).TY n
ot in CLASS_PRIVATE_SPEC then            ERROR (D (LX_SRCPOS, NODE), "DEFERRED CONSTANT NOT ALLOWED");          end if
;떰          INSERT_OBJ_TYPE_AND_INIT_EXP_IN_S (SOURCE_NAME_S, OBJ_TYPE => TYPE_SPEC, INIT_EXP => TREE_VOID);        en
d;                          --| DECLARATION DE TYPE      when DN_TYPE_DECL =>        declare          SOURCE_NAME   
: TREE := D (AS_SOURCE_NAME, NODE);          DSCRMT_DECL_S : TREE := D (AS_DSCRMT_DECL_S, NODE);          TYPE_DEF    
  : TREE := D (AS_TYPE_DEF, NODE);떰          SOURCE_DEF : TREE := MAKE_DEF_FOR_ID (SOURCE_NAME, H);          TYPE_SPEC
  : TREE;떰          PRIOR_DEF         : TREE;          PRIOR_NAME        : TREE;          PRIOR_SPEC        : TREE   
:= TREE_VOID;          NEW_DSCRMT_DECL_S : TREE   := DSCRMT_DECL_S;          H                 : H_TYPE := WALK.H;   
       S                 : S_TYPE;        begin          PRIOR_DEF := GET_PRIOR_DEF (SOURCE_DEF);떰          if PRIOR_
DEF /= TREE_VOID then                        --| IL Y A UNE DFINITION ANTRIEURE            PRIOR_NAME := D (XD_SOURCE_N
AME, PRIOR_DEF);떰            if PRIOR_NAME.TY in DN_PRIVATE_TYPE_ID .. DN_L_PRIVATE_TYPE_ID then        --| TYPE PRIV (
LIMIT)              PRIOR_SPEC := D (SM_TYPE_SPEC, PRIOR_NAME);떰              if D (SM_TYPE_SPEC, PRIOR_SPEC) /= TREE_
VOID or else H.IS_IN_SPEC then        --| TYPE COMPLET ANTRIEUR ! OU ON EST DANS LA PARTIE VISIBLE                PRIOR
_SPEC := TREE_VOID;                     --| INDIQUER UNE ERREUR              end if;떰            elsif PRIOR_NAME.TY =
 DN_TYPE_ID then                      --| UN ID DE TYPE              PRIOR_SPEC := D (SM_TYPE_SPEC, PRIOR_NAME);       
    --| SPCIF DE TYPE CORRESPONDANTE              if PRIOR_SPEC.TY /= DN_INCOMPLETE                       --| CE N'EST 
PAS UN INCOMPLET               or else D (XD_FULL_TYPE_SPEC, PRIOR_SPEC) /= TREE_VOID then --| LE TYPE COMPLET EST DJ D
CLAR                PRIOR_SPEC := TREE_VOID;                     --| INDIQUER UNE ERREUR              end if;        
    end if;떰            if TYPE_DEF.TY not in DN_ENUMERATION_DEF .. DN_RECORD_DEF then     --| CE N'EST PAS UNE DFINITI
ON COMPLTE POSSIBLE              PRIOR_SPEC := TREE_VOID;                        --| INDIQUER UNE ERREUR            en
d if;떰            if PRIOR_SPEC = TREE_VOID then                     --| REDCLARATION INTERDITE              ERROR (D 
(LX_SRCPOS, NODE), "REDECLARATION OF TYPE NAME");              MAKE_DEF_IN_ERROR (PRIOR_DEF);                        --
| DFINITION ANTRIEURE INDIQUE EN ERREUR              PRIOR_DEF := TREE_VOID;                 --| FAIRE COMME S'IL N'Y A
VAIT PAS D'ENTRIEURE            end if;          end if;                                        -- IF DISCRIMINANTS W
ERE GIVEN          if DSCRMT_DECL_S /= TREE_VOID and then not IS_EMPTY (LIST (DSCRMT_DECL_S)) then떰                   
                             -- WALK THE DISCRIMINANTS                                                -- ... (IN THE RE
CORD'S DECLARATIVE REGION)            ENTER_REGION (SOURCE_DEF, H, S);                                                
--WALK_ITEM_S(DSCRMT_DECL_S, H);            FINISH_PARAM_S (DSCRMT_DECL_S, H);            LEAVE_REGION (SOURCE_DEF, S)
;            H := WALK.H;떰            if TYPE_DEF.TY not in DN_ACCESS_DEF .. DN_L_PRIVATE_DEF and then TYPE_DEF /= TRE
E_VOID then              ERROR (D (LX_SRCPOS, DSCRMT_DECL_S), "DISCRIMINANTS NOT ALLOWED");            elsif PRIOR_DEF
 /= TREE_VOID then              if D (SM_DISCRIMINANT_S, PRIOR_SPEC) = TREE_VOID or else IS_EMPTY (LIST (D (SM_DISCRIMI
NANT_S, PRIOR_SPEC))) then                ERROR (D (LX_SRCPOS, DSCRMT_DECL_S), "FIRST DECLARATION HAD NO DISCRIMINANTS"
);              else                NEW_DSCRMT_DECL_S := D (SM_DISCRIMINANT_S, PRIOR_SPEC);                CONFORM_PA
RAMETER_LISTS (NEW_DSCRMT_DECL_S, DSCRMT_DECL_S);                NEW_DSCRMT_DECL_S := D (SM_DISCRIMINANT_S, PRIOR_SPEC)
;                if TYPE_DEF.TY /= DN_RECORD_DEF then                  ERROR (D (LX_SRCPOS, DSCRMT_DECL_S), "FULL TYPE
 MUST BE RECORD");                end if;              end if;            end if;          end if;떰          if PRI
OR_DEF /= TREE_VOID then            D (SM_FIRST, SOURCE_NAME, PRIOR_NAME);          else            PRIOR_DEF  := SOU
RCE_DEF;            PRIOR_NAME := SOURCE_NAME;          end if;떰          if TYPE_DEF = TREE_VOID then            EN
TER_REGION (PRIOR_DEF, H, S);            TYPE_SPEC := MAKE_INCOMPLETE (SM_DISCRIMINANT_S => NEW_DSCRMT_DECL_S, XD_SOURC
E_NAME => SOURCE_NAME);            LEAVE_REGION (PRIOR_DEF, S);          else            TYPE_SPEC := EVAL_TYPE_DEF (
TYPE_DEF, PRIOR_NAME, H, NEW_DSCRMT_DECL_S);            if TYPE_DEF.TY = DN_DERIVED_DEF then              REMEMBER_DER
IVED_DECL (NODE);            end if;          end if;떰          D (SM_TYPE_SPEC, SOURCE_NAME, TYPE_SPEC);          i
f TYPE_SPEC /= TREE_VOID then            if PRIOR_DEF /= SOURCE_DEF then              REMOVE_DEF_FROM_ENVIRONMENT (SOU
RCE_DEF);              if PRIOR_SPEC /= TREE_VOID then                if PRIOR_SPEC.TY = DN_INCOMPLETE then          
        D (XD_FULL_TYPE_SPEC, PRIOR_SPEC, TYPE_SPEC);                else                  D (SM_TYPE_SPEC, PRIOR_SPEC
, TYPE_SPEC);                end if;              end if;            else              MAKE_DEF_VISIBLE (SOURCE_DEF)
;            end if;            PRE_FCNS.GEN_PREDEFINED_OPERATORS (GET_BASE_TYPE (TYPE_SPEC), H);          else     
       MAKE_DEF_IN_ERROR (SOURCE_DEF);          end if;        end;떰      when DN_SUBTYPE_DECL =>--put_line( "; NOD_
WALK 709 dn_subtype_decl" );        declare          SOURCE_NAME        : TREE:= D (AS_SOURCE_NAME, NODE);          
SUBTYPE_INDICATION : TREE:= D (AS_SUBTYPE_INDICATION, NODE);          SOURCE_DEF         : TREE:= MAKE_DEF_FOR_ID( SO
URCE_NAME, H );          TYPE_SPEC          : TREE;        begin          TYPE_SPEC := EVAL_TYPE_DEF( SUBTYPE_INDICAT
ION, SOURCE_NAME, H );          D( SM_TYPE_SPEC, SOURCE_NAME, TYPE_SPEC );떰-- MODIF V.MORIN 18/6/2025 le xd_source_nam
e d'un type_spec de subtype_decl pointait sur le type_id de base-- semble incorrect pour cet attribut non Diana--땝D( 
XD_SOURCE_NAME, TYPE_SPEC, SOURCE_NAME );--put_line( "; NOD_WALK 722 subtype_decl source_name : " & PRINT_NAME( D( LX_S
YMREP, SOURCE_NAME ) ) );--          if  TYPE_SPEC /= TREE_VOID  then            MAKE_DEF_VISIBLE( SOURCE_DEF );    
      else            MAKE_DEF_IN_ERROR( SOURCE_DEF );          end if;        end;떰      when DN_TASK_DECL =>     
   declare          SOURCE_NAME : TREE := D (AS_SOURCE_NAME, NODE);          DECL_S      : TREE := D (AS_DECL_S, NODE)
;떰          H          : H_TYPE := WALK.H;          S          : S_TYPE;          SOURCE_DEF : TREE   := MAKE_DEF_FOR
_ID (SOURCE_NAME, H);          PRIOR_DEF  : TREE;떰          TASK_SPEC : TREE := MAKE_TASK_SPEC (SM_DECL_S => DECL_S, X
D_SOURCE_NAME => SOURCE_NAME);        begin          if SOURCE_NAME.TY = DN_TYPE_ID then            D (SM_FIRST, SOUR
CE_NAME, SOURCE_NAME);            D (SM_TYPE_SPEC, SOURCE_NAME, TASK_SPEC);            PRIOR_DEF := GET_PRIOR_DEF (SOU
RCE_DEF);            if PRIOR_DEF /= TREE_VOID then              if D (XD_SOURCE_NAME, PRIOR_DEF).TY = DN_L_PRIVATE_TY
PE_ID then                REMOVE_DEF_FROM_ENVIRONMENT (SOURCE_DEF);                D (SM_FIRST, SOURCE_NAME, D (XD_SOU
RCE_NAME, PRIOR_DEF));                D (SM_TYPE_SPEC, D (SM_TYPE_SPEC, D (XD_SOURCE_NAME, PRIOR_DEF)), TASK_SPEC);   
             SOURCE_DEF := PRIOR_DEF;              elsif (D (XD_SOURCE_NAME, PRIOR_DEF).TY = DN_TYPE_ID and then D (SM_
TYPE_SPEC, D (XD_SOURCE_NAME, PRIOR_DEF)).TY = DN_INCOMPLETE) then                REMOVE_DEF_FROM_ENVIRONMENT (SOURCE_D
EF);                D (SM_FIRST, SOURCE_NAME, D (XD_SOURCE_NAME, PRIOR_DEF));                D (XD_FULL_TYPE_SPEC, D (
SM_TYPE_SPEC, D (XD_SOURCE_NAME, PRIOR_DEF)), TASK_SPEC);                SOURCE_DEF := PRIOR_DEF;              else  
              ERROR (D (LX_SRCPOS, SOURCE_NAME), "DUPLICATE NAME FOR TASK - " & PRINT_NAME (D (LX_SYMREP, SOURCE_NAME)))
;                MAKE_DEF_IN_ERROR (SOURCE_DEF);              end if;              D (XD_SOURCE_NAME, TASK_SPEC, D (X
D_SOURCE_NAME, SOURCE_DEF));            else              MAKE_DEF_VISIBLE (SOURCE_DEF);            end if;         
 else            D (SM_OBJ_TYPE, SOURCE_NAME, TASK_SPEC);            CHECK_UNIQUE_DEF (SOURCE_DEF);          end if;
          ENTER_REGION (SOURCE_DEF, H, S);          WALK_ITEM_S (DECL_S, H);          LEAVE_REGION (SOURCE_DEF, S); 
       end;떰      when DN_GENERIC_DECL =>        declare          SOURCE_NAME : TREE     := D (AS_SOURCE_NAME, NODE);
          HEADER      : TREE     := D (AS_HEADER, NODE);          ITEM_S      : TREE     := D (AS_ITEM_S, NODE);     
     ITEM_LIST   : SEQ_TYPE := LIST (ITEM_S);          ITEM        : TREE;떰          H          : H_TYPE := WALK.H;  
        S          : S_TYPE;          SOURCE_DEF : TREE   := MAKE_DEF_FOR_ID (SOURCE_NAME, H);        begin          
D (SM_FIRST, SOURCE_NAME, SOURCE_NAME);          D (SM_SPEC, SOURCE_NAME, HEADER);          D (SM_GENERIC_PARAM_S, SOU
RCE_NAME, ITEM_S);떰          CHECK_UNIQUE_DEF (SOURCE_DEF);떰          ENTER_REGION (SOURCE_DEF, H, S);          while
 not IS_EMPTY (ITEM_LIST) loop            POP (ITEM_LIST, ITEM);            WALK (ITEM, H);            if ITEM.TY in 
CLASS_PARAM then              FINISH_PARAM_DECL (ITEM, H);            end if;          end loop;          H.SUBP_SYM
REP := D (LX_SYMREP, SOURCE_NAME);                                        --IF KIND ( HEADER) IN CLASS_SUBP_ENTRY_HEADE
R THEN                                        --    WALK_ITEM_S(D ( AS_PARAM_S,HEADER), H);                           
             --END IF;          WALK_HEADER (HEADER, H);          LEAVE_REGION (SOURCE_DEF, S);          MAKE_DEF_VIS
IBLE (SOURCE_DEF, HEADER);        end;떰      when DN_SUBPROG_ENTRY_DECL =>        declare          SOURCE_NAME : TRE
E := D (AS_SOURCE_NAME, NODE);          HEADER      : TREE := D (AS_HEADER, NODE);          UNIT_KIND   : TREE := D (A
S_UNIT_KIND, NODE);떰          H          : H_TYPE := WALK.H;          S          : S_TYPE;          SOURCE_DEF : TREE
;          PRIOR_DEF  : TREE;        begin          if SOURCE_NAME.TY = DN_OPERATOR_ID then            FORCE_UPPER_C
ASE (SOURCE_NAME);          end if;          SOURCE_DEF := MAKE_DEF_FOR_ID (SOURCE_NAME, H);          D (SM_SPEC, SOU
RCE_NAME, HEADER);          if SOURCE_NAME.TY /= DN_ENTRY_ID then            D (SM_FIRST, SOURCE_NAME, SOURCE_NAME); 
           D (SM_UNIT_DESC, SOURCE_NAME, UNIT_KIND);          end if;떰          if HEADER /= TREE_VOID then          
  ENTER_REGION (SOURCE_DEF, H, S);            H.SUBP_SYMREP := D (LX_SYMREP, SOURCE_NAME);                            
                    --WALK_ITEM_S(D ( AS_PARAM_S,HEADER), H);            WALK_HEADER (HEADER, H);            LEAVE_REG
ION (SOURCE_DEF, S);            H := WALK.H;          end if;          WALK_UNIT_DESC (SOURCE_NAME, UNIT_KIND, H, HEA
DER);          HEADER := D (SM_SPEC, SOURCE_NAME);                                        -- IN CASE INSTANTIATION   
       if HEADER.TY = DN_ENTRY and then D (AS_DISCRETE_RANGE, HEADER) /= TREE_VOID then                                
                -- IT IS AN ENTRY FAMILY            MAKE_DEF_VISIBLE (SOURCE_DEF);            PRIOR_DEF := GET_PRIOR_D
EF (SOURCE_DEF);          else            MAKE_DEF_VISIBLE (SOURCE_DEF, HEADER);            PRIOR_DEF := GET_PRIOR_HO
MOGRAPH_DEF (SOURCE_DEF);          end if;          if PRIOR_DEF /= TREE_VOID then            if D (XD_HEADER, PRIOR_
DEF) /= TREE_FALSE then              ERROR (D (LX_SRCPOS, SOURCE_NAME), "DUPLICATE DEF FOR SUBPROGRAM NAME - " & PRINT_
NAME (D (LX_SYMREP, SOURCE_NAME)));            end if;            MAKE_DEF_IN_ERROR (SOURCE_DEF);          else     
       CHECK_EQUALITY_OPERATOR (SOURCE_NAME, H);          end if;        end;떰      when DN_PACKAGE_DECL =>        d
eclare          SOURCE_NAME : TREE := D (AS_SOURCE_NAME, NODE);          HEADER      : TREE := D (AS_HEADER, NODE);  
        UNIT_KIND   : TREE := D (AS_UNIT_KIND, NODE);떰          H          : H_TYPE := WALK.H;          S          : S
_TYPE;          SOURCE_DEF : TREE   := MAKE_DEF_FOR_ID (SOURCE_NAME, H);        begin          D (SM_FIRST, SOURCE_NA
ME, SOURCE_NAME);          D (SM_SPEC, SOURCE_NAME, HEADER);          D (SM_UNIT_DESC, SOURCE_NAME, UNIT_KIND);떰     
     CHECK_UNIQUE_DEF (SOURCE_DEF);          WALK_UNIT_DESC (SOURCE_NAME, UNIT_KIND, H);          MAKE_DEF_VISIBLE (SO
URCE_DEF);          if HEADER /= TREE_VOID then            ENTER_REGION (SOURCE_DEF, H, S);            WALK_HEADER (H
EADER, H);            LEAVE_REGION (SOURCE_DEF, S);          end if;        end;                        -- FOR A REN
AMING DECLARATION FOR AN OBJECT      when DN_RENAMES_OBJ_DECL =>        declare          SOURCE_NAME    : TREE := D (
AS_SOURCE_NAME, NODE);          NAME           : TREE := D (AS_NAME, NODE);          TYPE_MARK_NAME : TREE := D (AS_TY
PE_MARK_NAME, NODE);떰          SOURCE_DEF : TREE := MAKE_DEF_FOR_ID (SOURCE_NAME, H);          BASE_TYPE  : TREE;    
      TYPESET    : TYPESET_TYPE;        begin                                        -- EVALUATE AND RESOLVE THE TYPE 
MARK          BASE_TYPE      := GET_BASE_TYPE (EVAL_TYPE_MARK (TYPE_MARK_NAME));          TYPE_MARK_NAME := RESOLVE_TY
PE_MARK (TYPE_MARK_NAME);          D (AS_TYPE_MARK_NAME, NODE, TYPE_MARK_NAME);                                       
 -- EVALUATE THE NAME BEING REDEFINED; REQUIRE SAME BASE TYPE          EVAL_EXP_TYPES (NAME, TYPESET);          REQUIR
E_TYPE (BASE_TYPE, NAME, TYPESET);          NAME := RESOLVE_EXP (NAME, TYPESET);                                      
  -- IF A CONSTANT (OR IN PARAMETER) IS BEING RENAMED          if IS_CONSTANT_EXP (NAME) then                         
                       -- REPLACE VARIABLE_ID WITH CONSTANT_ID                                                -- SM_FIR
ST ADDED 8-17-91 WBE            SOURCE_NAME := MAKE_CONSTANT_ID (LX_SRCPOS => D (LX_SRCPOS, SOURCE_NAME), LX_SYMREP => 
D (LX_SYMREP, SOURCE_NAME), XD_REGION => D (XD_REGION, SOURCE_NAME));            D (SM_FIRST, SOURCE_NAME, SOURCE_NAME)
;            D (AS_SOURCE_NAME, NODE, SOURCE_NAME);                                                -- FIX UP DEF TO PO
INT TO NEWLY-CREATED CONSTANT_ID            D (XD_SOURCE_NAME, SOURCE_DEF, SOURCE_NAME);          end if;            
                            -- STORE REMAINING ATTRIBUTES OF SOURCE NAME          D (SM_INIT_EXP, SOURCE_NAME, NAME); 
         DB (SM_RENAMES_OBJ, SOURCE_NAME, True);          D (SM_OBJ_TYPE, SOURCE_NAME, D (SM_EXP_TYPE, NAME));        
                                -- CHECK THAT SOURCE NAME IS UNIQUE AND MAKE IT VISIBLE          CHECK_UNIQUE_DEF (SOUR
CE_DEF);        end;떰      when DN_RENAMES_EXC_DECL =>        declare          SOURCE_NAME : TREE := D (AS_SOURCE_NA
ME, NODE);          NAME        : TREE := D (AS_NAME, NODE);떰          SOURCE_DEF : TREE := MAKE_DEF_FOR_ID (SOURCE_NA
ME, H);        begin떰                                        -- WALK THE REDEFINED EXCEPTION NAME          NAME := WA
LK_NAME (DN_EXCEPTION_ID, NAME);          D (AS_NAME, NODE, NAME);떰                                        -- $$$$ WHA
T ABOUT WHEN NAME IS A RENAMED EXCEPTION ?떰                                        -- INSERT REDEFINED NAME IN SOURCE N
AME          if NAME.TY = DN_SELECTED then            NAME := D (AS_DESIGNATOR, NAME);          end if;          D (
SM_RENAMES_EXC, SOURCE_NAME, D (SM_DEFN, NAME));떰                                        -- ADDED 6/29/90 (OMITTED.  WH
Y WASN'T IT FOUND BY ACVC?)                                        -- CHECK FOR UNIQUE NAMES AND MAKE VISIBLE         
 CHECK_UNIQUE_DEF (SOURCE_DEF);        end;떰      when DN_NULL_COMP_DECL =>        declare        begin          nu
ll;        end;떰      when DN_LENGTH_ENUM_REP =>        declare          NAME : TREE := D (AS_NAME, NODE);         
 EXP  : TREE := D (AS_EXP, NODE);        begin                                        -- IF IT IS A LENGTH CLAUSE    
      if NAME.TY = DN_ATTRIBUTE then            REP_CLAU.RESOLVE_LENGTH_REP (NAME, EXP, H);            D (AS_EXP, NODE
, EXP);떰                                                -- ELSE -- IT IS AN ENUMERATION REPRESENTATION CLAUSE         
                                       -- ... (BY SYNTAX -- NAME IS USED_OBJECT_ID, EXP IS AGGREGATE)          else   
         REP_CLAU.RESOLVE_ENUM_REP (NAME, EXP, H);            D (AS_NAME, NODE, NAME);          end if;        end;떰
      when DN_ADDRESS =>        declare          NAME : TREE := D (AS_NAME, NODE);          EXP  : TREE := D (AS_EXP,
 NODE);        begin          REP_CLAU.RESOLVE_ADDRESS_REP (NAME, EXP, H);          D (AS_NAME, NODE, NAME);        
  D (AS_EXP, NODE, EXP);        end;떰      when DN_RECORD_REP =>        declare          NAME             : TREE := 
D (AS_NAME, NODE);          ALIGNMENT_CLAUSE : TREE := D (AS_ALIGNMENT_CLAUSE, NODE);          COMP_REP_S       : TREE
 := D (AS_COMP_REP_S, NODE);        begin          REP_CLAU.RESOLVE_RECORD_REP (NAME, ALIGNMENT_CLAUSE, COMP_REP_S, H)
;          D (AS_NAME, NODE, NAME);          D (AS_ALIGNMENT_CLAUSE, NODE, ALIGNMENT_CLAUSE);          D (AS_COMP_REP
_S, NODE, COMP_REP_S);          if D (SM_DEFN, NAME).TY in CLASS_TYPE_NAME and GET_BASE_TYPE (NAME).TY = DN_RECORD then
            D (SM_REPRESENTATION, GET_BASE_TYPE (NAME), NODE);          end if;        end;                        -
- FOR A USE CLAUSE (NOT PART OF A CONTEXT CLAUSE)      when DN_USE =>        declare          NAME_S : TREE := D (AS_
NAME_S, NODE);떰          NAME_LIST     : SEQ_TYPE := LIST (NAME_S);          NAME          : TREE;          NAME_DEFN
     : TREE;          NEW_NAME_LIST : SEQ_TYPE := (TREE_NIL, TREE_NIL);          PACKAGE_DEF   : TREE;        begin떰
                                        -- FOR EACH USED NAME          while not IS_EMPTY (NAME_LIST) loop            
POP (NAME_LIST, NAME);                                                -- EVALUATE AND RESOLVE PACKAGE NAME            
NAME          := WALK_NAME (DN_PACKAGE_ID, NAME);            NEW_NAME_LIST := APPEND (NEW_NAME_LIST, NAME);           
                                     -- GET THE PACKAGE ID OF THE ORIGINAL (UNRENAMED) PACKAGE            loop        
      if NAME.TY = DN_SELECTED then                NAME := D (AS_DESIGNATOR, NAME);              end if;             
 NAME_DEFN := D (SM_DEFN, NAME);              exit when NAME_DEFN.TY /= DN_PACKAGE_ID or else D (SM_UNIT_DESC, NAME_DEF
N).TY /= DN_RENAMES_UNIT;              NAME := D (AS_NAME, D (SM_UNIT_DESC, NAME_DEFN));            end loop;        
                                        -- IF IT IS INDEED A PACKAGE ID            if NAME_DEFN.TY = DN_PACKAGE_ID then
                                                        -- GET THE DEF CORRESPONDING TO THE PACKAGE              PACKA
GE_DEF := GET_DEF_FOR_ID (NAME_DEFN);떰                                                        -- IF IT IS NOT AN ENCLOS
ING REGION AND NOT USED              if DI (XD_LEX_LEVEL, PACKAGE_DEF) <= 0 and then not DB (XD_IS_USED, PACKAGE_DEF) t
hen떰                                                                -- MARK IT USED                DB (XD_IS_USED, PAC
KAGE_DEF, True);떰                                                                -- ADD IT TO LIST OF USED REGIONS    
            SU.USED_PACKAGE_LIST := INSERT (SU.USED_PACKAGE_LIST, PACKAGE_DEF);              end if;            end if
;          end loop;떰                                        -- REPLACE NAME LIST WITH LIST OF RESOLVED NAMES        
  LIST (NAME_S, NEW_NAME_LIST);        end;떰      when DN_PRAGMA =>        declare          USED_NAME_ID    : TREE :
= D (AS_USED_NAME_ID, NODE);          GENERAL_ASSOC_S : TREE := D (AS_GENERAL_ASSOC_S, NODE);        begin          W
ALK_PRAGMA (USED_NAME_ID, GENERAL_ASSOC_S, H);        end;떰      when DN_SUBPROGRAM_BODY =>        declare          
SOURCE_NAME  : TREE := D (AS_SOURCE_NAME, NODE);          FIRST_NAME   : TREE := D (SM_FIRST, SOURCE_NAME);          B
ODY_NODE    : TREE := D (AS_BODY, NODE);          FIRST_HEADER : TREE := TREE_VOID;          HEADER       : TREE := D 
(AS_HEADER, NODE);떰          H          : H_TYPE := WALK.H;          S          : S_TYPE;          SOURCE_DEF : TREE;
          PRIOR_DEF  : TREE;        begin          if SOURCE_NAME.TY = DN_OPERATOR_ID then            FORCE_UPPER_CA
SE (SOURCE_NAME);          end if;          SOURCE_DEF := MAKE_DEF_FOR_ID (SOURCE_NAME, H);          D (SM_SPEC, SOUR
CE_NAME, HEADER);          D (SM_UNIT_DESC, SOURCE_NAME, TREE_VOID);                                        --D ( XD_B
ODY, SOURCE_NAME, BODY_NODE);떰          if FIRST_NAME = SOURCE_NAME then            PRIOR_DEF := GET_PRIOR_DEF (SOURCE
_DEF);            if PRIOR_DEF /= TREE_VOID and then D (XD_SOURCE_NAME, PRIOR_DEF).TY = DN_GENERIC_ID then            
  FIRST_NAME := D (XD_SOURCE_NAME, PRIOR_DEF);              PRIOR_DEF  := GET_DEF_FOR_ID (FIRST_NAME);            else
              PRIOR_DEF := SOURCE_DEF;            end if;          else            PRIOR_DEF := GET_DEF_FOR_ID (FIRS
T_NAME);                                                -- LIBRARY UNIT WITH EXISTING SUBPROGRAM SPEC                 
                               -- $$$$ WORRY ABOUT KILLING PRIOR BODY IN THIS COMPILATION            D (XD_REGION_DEF, 
PRIOR_DEF, H.REGION_DEF);          end if;떰          if SOURCE_DEF /= PRIOR_DEF and then D (SM_SPEC, D (XD_SOURCE_NAME
, SOURCE_DEF)) = D (SM_SPEC, D (XD_SOURCE_NAME, PRIOR_DEF)) then                                                -- (SPE
C WAS GENERATED IN LIBPHASE; DO NOT REDO IT)            null;          else            ENTER_REGION (SOURCE_DEF, H, S
);                                                --WALK_ITEM_S(D ( AS_PARAM_S,HEADER), H);            H.SUBP_SYMREP :
= D (LX_SYMREP, SOURCE_NAME);            if SOURCE_DEF /= PRIOR_DEF and then FIRST_NAME.TY = DN_GENERIC_ID then       
                                                 -- (SPEC IS GENERIC) - $$$$              SWITCH_REGION (FIRST_NAME, SO
URCE_DEF);              WALK_HEADER (HEADER, H);              SWITCH_REGION (FIRST_NAME, PRIOR_DEF);            else
              WALK_HEADER (HEADER, H);            end if;            LEAVE_REGION (SOURCE_DEF, S);            H := WA
LK.H;          end if;떰          if FIRST_NAME = SOURCE_NAME then                                                -- (
LOOK FOR A SUBPROGRAM DECLARATION)            MAKE_DEF_VISIBLE (SOURCE_DEF, HEADER);            PRIOR_DEF := GET_PRIOR
_HOMOGRAPH_DEF (SOURCE_DEF);            if PRIOR_DEF /= TREE_VOID then              REMOVE_DEF_FROM_ENVIRONMENT (SOURC
E_DEF);              FIRST_NAME := D (XD_SOURCE_NAME, PRIOR_DEF);            end if;          end if;          if PR
IOR_DEF = TREE_VOID then            MAKE_DEF_VISIBLE (SOURCE_DEF, HEADER);            CHECK_EQUALITY_OPERATOR (SOURCE_
NAME, H);          else            if FIRST_NAME.TY in CLASS_SUBPROG_NAME or FIRST_NAME.TY = DN_GENERIC_ID then      
        FIRST_HEADER := D (SM_SPEC, FIRST_NAME);            end if;            if FIRST_HEADER.TY /= HEADER.TY then  
            if D (XD_HEADER, PRIOR_DEF) /= TREE_FALSE then                ERROR (D (LX_SRCPOS, SOURCE_NAME), "DUPLICATE
 DEF FOR SUBPROGRAM NAME - " & PRINT_NAME (D (LX_SYMREP, SOURCE_NAME)));              end if;              MAKE_DEF_IN
_ERROR (SOURCE_DEF);              FIRST_NAME := SOURCE_NAME;            else              D (SM_FIRST, SOURCE_NAME, F
IRST_NAME);            end if;          end if;떰          if FIRST_NAME /= SOURCE_NAME then                         
                       --D ( XD_BODY, FIRST_NAME, BODY_NODE);            D (SM_SPEC, SOURCE_NAME, D (SM_SPEC, FIRST_NAM
E));            CONFORM_PARAMETER_LISTS (D (AS_PARAM_S, D (SM_SPEC, FIRST_NAME)), D (AS_PARAM_S, HEADER));            
REMOVE_DEF_FROM_ENVIRONMENT (SOURCE_DEF);            SOURCE_DEF := PRIOR_DEF;          end if;떰          ENTER_BODY (
SOURCE_DEF, H, S);          if FIRST_NAME.TY = DN_GENERIC_ID then            MAKE_DEF_VISIBLE (SOURCE_DEF, D (SM_SPEC,
 FIRST_NAME));          end if;          if D (XD_HEADER, SOURCE_DEF).TY = DN_FUNCTION_SPEC then            H.RETURN_
TYPE := GET_BASE_TYPE (D (AS_NAME, D (XD_HEADER, SOURCE_DEF)));          end if;          WALK_UNIT_DESC (SOURCE_NAME,
 BODY_NODE, H);          if FIRST_NAME.TY = DN_GENERIC_ID then            MAKE_DEF_VISIBLE (SOURCE_DEF);          end
 if;          LEAVE_BODY (SOURCE_DEF, S);        end;떰      when DN_PACKAGE_BODY =>        declare          SOURCE_
NAME : TREE := D (AS_SOURCE_NAME, NODE);          BODY_NODE   : TREE := D (AS_BODY, NODE);떰          FIRST_NAME : TREE
;          H          : H_TYPE := WALK.H;          S          : S_TYPE;          SOURCE_DEF : TREE;        begin   
                                     -- CHECK FOR LIBRARY UNIT WITH EXISTING PACKAGE SPEC                              
          -- $$$$ WORRY ABOUT KILLING PRIOR BODY IN THIS COMPILATION          FIRST_NAME := D (SM_FIRST, SOURCE_NAME);
          if FIRST_NAME /= SOURCE_NAME then            SOURCE_DEF := GET_DEF_FOR_ID (D (SM_FIRST, SOURCE_NAME));      
      D (XD_REGION_DEF, SOURCE_DEF, H.REGION_DEF);          end if;떰          SOURCE_DEF := GET_DEF_IN_REGION (SOURCE_
NAME, H);          if SOURCE_DEF = TREE_VOID then            ERROR (D (LX_SRCPOS, NODE), "NO SPECIFICATION FOUND FOR P
ACKAGE - " & PRINT_NAME (D (LX_SYMREP, SOURCE_NAME)));            SOURCE_DEF := MAKE_DEF_FOR_ID (SOURCE_NAME, H);     
       D (SM_SPEC, SOURCE_NAME, TREE_VOID);                                                -- AVOID CRASH            M
AKE_DEF_IN_ERROR (SOURCE_DEF);          else            FIRST_NAME := D (XD_SOURCE_NAME, SOURCE_DEF);            if F
IRST_NAME.TY /= DN_PACKAGE_ID and then (FIRST_NAME.TY /= DN_GENERIC_ID or else D (SM_SPEC, FIRST_NAME).TY /= DN_PACKAGE_
SPEC) then              ERROR (D (LX_SRCPOS, NODE), "DUPLICATE NAME FOR PACKAGE - " & PRINT_NAME (D (LX_SYMREP, SOURCE_
NAME)));              SOURCE_DEF := MAKE_DEF_FOR_ID (SOURCE_NAME, H);              MAKE_DEF_IN_ERROR (SOURCE_DEF);   
           FIRST_NAME := SOURCE_NAME;            elsif D (XD_BODY, FIRST_NAME) /= TREE_VOID then              ERROR (D
 (LX_SRCPOS, NODE), "DUPLICATE BODY FOR PACKAGE - " & PRINT_NAME (D (LX_SYMREP, SOURCE_NAME)));            end if;    
      end if;떰          D (SM_FIRST, SOURCE_NAME, FIRST_NAME);          D (SM_SPEC, SOURCE_NAME, D (SM_SPEC, FIRST_NAM
E));          D (SM_UNIT_DESC, SOURCE_NAME, TREE_VOID);          D (XD_REGION, SOURCE_NAME, D (XD_REGION, FIRST_NAME))
;          if BODY_NODE.TY = DN_STUB then            null;                                                -- D ( XD_S
TUB, SOURCE_NAME, SOURCE_NAME);                                                -- D ( XD_STUB, FIRST_NAME, SOURCE_NAME)
;          else                                                -- D ( XD_BODY, FIRST_NAME, NODE);                    
                            -- D ( XD_BODY, SOURCE_NAME, NODE);                                                -- D ( X
D_STUB, SOURCE_NAME, D ( XD_STUB, FIRST_NAME));            ENTER_BODY (SOURCE_DEF, H, S);                             
                   -- SCAN SPEC FOR USE CLAUSES            declare              SPEC : TREE := D (SM_SPEC, SOURCE_NAME
);            begin              if SPEC /= TREE_VOID then                REPROCESS_USE_CLAUSES (D (AS_DECL_S1, SPEC)
, H);                REPROCESS_USE_CLAUSES (D (AS_DECL_S2, SPEC), H);              end if;            end;          
  WALK_UNIT_DESC (SOURCE_NAME, BODY_NODE, H);            LEAVE_BODY (SOURCE_DEF, S);          end if;        end;떰  
    when DN_TASK_BODY =>        declare          SOURCE_NAME : TREE := D (AS_SOURCE_NAME, NODE);          BODY_NODE  
 : TREE := D (AS_BODY, NODE);떰          H : H_TYPE := WALK.H;          S : S_TYPE;떰          SOURCE_DEF : TREE := MAK
E_DEF_FOR_ID (SOURCE_NAME, H);          PRIOR_DEF  : TREE;          PRIOR_NAME : TREE;          TASK_TYPE  : TREE := 
TREE_VOID;        begin떰          PRIOR_DEF := GET_PRIOR_DEF (SOURCE_DEF);          if PRIOR_DEF /= TREE_VOID then  
          TASK_TYPE := GET_BASE_TYPE (D (XD_SOURCE_NAME, PRIOR_DEF));          end if;떰          D (SM_TYPE_SPEC, SOUR
CE_NAME, TASK_TYPE);          D (SM_BODY, SOURCE_NAME, BODY_NODE);          if TASK_TYPE.TY /= DN_TASK_SPEC then     
       ERROR (D (LX_SRCPOS, NODE), "NO TASK [TYPE] DECLARATION");            MAKE_DEF_IN_ERROR (SOURCE_DEF);          
  PRIOR_NAME := SOURCE_NAME;            TASK_TYPE  := TREE_VOID;          else            REMOVE_DEF_FROM_ENVIRONMENT
 (SOURCE_DEF);            PRIOR_NAME := D (XD_SOURCE_NAME, PRIOR_DEF);            D (SM_FIRST, SOURCE_NAME, PRIOR_NAME
);            if D (XD_BODY, TASK_TYPE) /= TREE_VOID or else (D (XD_STUB, TASK_TYPE) /= TREE_VOID and then BODY_NODE.TY
 = DN_STUB) then              ERROR (D (LX_SRCPOS, SOURCE_NAME), "DUPLICATE BODY OR STUB DECLARATION");              T
ASK_TYPE := TREE_VOID;            else              SOURCE_DEF := PRIOR_DEF;                                         
               --D ( SM_BODY, TASK_TYPE, BODY_NODE);            end if;          end if;떰          if BODY_NODE.TY /=
 DN_STUB then            if TASK_TYPE /= TREE_VOID then              null;                                           
             -- D ( XD_BODY, TASK_TYPE, BODY_NODE);            end if;          else            if TASK_TYPE /= TREE_
VOID then              null;                                                        -- D ( XD_STUB, TASK_TYPE, SOURCE_
NAME);            end if;          end if;떰          ENTER_BODY (SOURCE_DEF, H, S);          WALK_UNIT_DESC (SOURCE_
NAME, BODY_NODE, H);          LEAVE_BODY (SOURCE_DEF, S);        end;떰    end case;떰  end WALK;      --||||||||||||
||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||      --|       PROCEDURE WALK_SOURCE_N
AME_S  procedure WALK_SOURCE_NAME_S (SOURCE_NAME_S : TREE; H : H_TYPE) is    SOURCE_NAME_LIST : SEQ_TYPE := LIST (SOUR
CE_NAME_S);    SOURCE_NAME      : TREE;    DUMMY_DEF        : TREE;  begin    while not IS_EMPTY (SOURCE_NAME_LIST) 
loop      POP (SOURCE_NAME_LIST, SOURCE_NAME);      DUMMY_DEF := MAKE_DEF_FOR_ID (SOURCE_NAME, H);    end loop;  end
 WALK_SOURCE_NAME_S;떰      --||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
||      --|       PROCEDURE ENTER_REGION  procedure ENTER_REGION (DEF : TREE; H : in out H_TYPE; S : out S_TYPE) is  
begin    S.SB         := SB;    S.SU         := SU;    H.REGION_DEF := DEF;    H.LEX_LEVEL  := H.LEX_LEVEL + 1;    
DI (XD_LEX_LEVEL, DEF, H.LEX_LEVEL);    H.IS_IN_SPEC         := True;    H.IS_IN_BODY         := False;    H.RETURN_T
YPE        := TREE_VOID;    SU.USED_PACKAGE_LIST := (TREE_NIL, TREE_NIL);  end ENTER_REGION;      --|||||||||||||||||
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||      --|       PROCEDURE LEAVE_REGION  pro
cedure LEAVE_REGION (DEF : TREE; S : S_TYPE) is    PACKAGE_DEF : TREE;  begin    DI (XD_LEX_LEVEL, DEF, 0);    while
 not IS_EMPTY (SU.USED_PACKAGE_LIST) loop      POP (SU.USED_PACKAGE_LIST, PACKAGE_DEF);      DB (XD_IS_USED, PACKAGE_D
EF, False);    end loop;    SB := S.SB;    SU := S.SU;  end LEAVE_REGION;      --||||||||||||||||||||||||||||||||||
||||||||||||||||||||||||||||||||||||||||||||||||||||||||||      --|       PROCEDURE ENTER_BODY  procedure ENTER_BODY (
DEF : TREE; H : in out H_TYPE; S : out S_TYPE) is  begin    ENTER_REGION (DEF, H, S);    H.IS_IN_SPEC := False;    H
.IS_IN_BODY := True;    if D (XD_SOURCE_NAME, DEF).TY = DN_GENERIC_ID and then D (XD_HEADER, DEF) /= TREE_FALSE then  
    MAKE_DEF_VISIBLE (DEF, D (SM_SPEC, D (XD_SOURCE_NAME, DEF)));    end if;  end ENTER_BODY;      --||||||||||||||||
||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||      --|       PROCEDURE LEAVE_BODY  proc
edure LEAVE_BODY (DEF : TREE; S : S_TYPE) is  begin    LEAVE_REGION (DEF, S);    if D (XD_SOURCE_NAME, DEF).TY = DN_G
ENERIC_ID and then D (XD_HEADER, DEF) /= TREE_FALSE then      MAKE_DEF_VISIBLE (DEF);    end if;  end LEAVE_BODY;떰  
procedure FINISH_VARIABLE_DECL (NODE : TREE; H : H_TYPE) is    SOURCE_NAME_S : TREE := D (AS_SOURCE_NAME_S, NODE);    
EXP           : TREE := D (AS_EXP, NODE);    TYPE_DEF      : TREE := D (AS_TYPE_DEF, NODE);떰    TYPE_SPEC : TREE;    
TYPESET   : TYPESET_TYPE;  begin    TYPE_SPEC := EVAL_SUBTYPE_INDICATION (TYPE_DEF);    RESOLVE_SUBTYPE_INDICATION (T
YPE_DEF, TYPE_SPEC);    D (AS_TYPE_DEF, NODE, TYPE_DEF);떰    if EXP /= TREE_VOID then      if not IS_NONLIMITED_TYPE 
(TYPE_SPEC) then        ERROR (D (LX_SRCPOS, TYPE_DEF), "INITIAL VALUE FOR LIMITED TYPE");        TYPE_SPEC := TREE_VO
ID;      end if;떰      EVAL_EXP_TYPES (EXP, TYPESET);      REQUIRE_TYPE (GET_BASE_TYPE (TYPE_SPEC), EXP, TYPESET);  
    EXP := RESOLVE_EXP (EXP, TYPESET);    end if;떰    INSERT_OBJ_TYPE_AND_INIT_EXP_IN_S (SOURCE_NAME_S, OBJ_TYPE => TY
PE_SPEC, INIT_EXP => EXP);  end FINISH_VARIABLE_DECL;떰  function WALK_EXP_MUST_BE_NAME (NAME : TREE) return TREE is  
  NAME_KIND : NODE_NAME := NAME.TY;    DEFSET    : DEFSET_TYPE;  begin    if NAME_KIND = DN_USED_OBJECT_ID or NAME_KI
ND = DN_SELECTED then      FIND_VISIBILITY (NAME, DEFSET);      REQUIRE_UNIQUE_DEF (NAME, DEFSET);      return RESOLV
E_NAME (NAME, GET_THE_ID (DEFSET));    else      ERROR (D (LX_SRCPOS, NAME), "NAME REQUIRED");      return WALK_ERRON
EOUS_EXP (NAME);    end if;  end WALK_EXP_MUST_BE_NAME;떰  function WALK_NAME (ID_KIND : NODE_NAME; NAME : TREE) retur
n TREE is    NEW_NAME  : constant TREE := WALK_EXP_MUST_BE_NAME (NAME);    NAME_DEFN : TREE          := GET_NAME_DEFN 
(NEW_NAME);  begin떰    if NAME_DEFN = TREE_VOID or else NAME_DEFN.TY = ID_KIND then      null;    elsif ID_KIND = DN
_PACKAGE_ID and then NAME_DEFN.TY = DN_GENERIC_ID and then D (SM_SPEC, NAME_DEFN).TY = DN_PACKAGE_SPEC and then DI (XD_L
EX_LEVEL, GET_DEF_FOR_ID (NAME_DEFN)) > 0 then      null;    else      ERROR (D (LX_SRCPOS, NAME), "NAME MUST BE " & 
NODE_IMAGE (ID_KIND));                        -- ADDED WBE 9/21/90                        -- CLEAR DEFN IF WRONG KIND
      if NEW_NAME.TY = DN_SELECTED then        D (SM_DEFN, D (AS_DESIGNATOR, NEW_NAME), TREE_VOID);      else        
D (SM_DEFN, NEW_NAME, TREE_VOID);      end if;    end if;떰    return NEW_NAME;  end WALK_NAME;떰  function WALK_TYPE
_MARK (NAME : TREE) return TREE is    NEW_NAME  : constant TREE := WALK_EXP_MUST_BE_NAME (NAME);    NAME_DEFN : TREE  
        := GET_NAME_DEFN (NEW_NAME);  begin떰    if NAME_DEFN.TY not in CLASS_TYPE_NAME and then NAME_DEFN /= TREE_VOID
 then      ERROR (D (LX_SRCPOS, NAME), "TYPE MARK REQUIRED");    end if;떰    return NEW_NAME;  end WALK_TYPE_MARK;떰
  procedure WALK_DISCRETE_CHOICE_S (CHOICE_S : TREE; TYPE_SPEC : TREE) is    CHOICE_LIST : SEQ_TYPE := LIST (CHOICE_S);
    CHOICE      : TREE;떰    NEW_CHOICE_LIST : SEQ_TYPE := (TREE_NIL, TREE_NIL);    EXP             : TREE;    TYPESE
T         : TYPESET_TYPE;    IS_SUBTYPE      : Boolean;  begin    while not IS_EMPTY (CHOICE_LIST) loop      POP (CH
OICE_LIST, CHOICE);떰      case CLASS_CHOICE'(CHOICE.TY) is        when DN_CHOICE_EXP =>          EXP := D (AS_EXP, CH
OICE);          EVAL_EXP_SUBTYPE_TYPES (EXP, TYPESET, IS_SUBTYPE);          REQUIRE_TYPE (TYPE_SPEC, EXP, TYPESET);  
        if not IS_SUBTYPE then            EXP := RESOLVE_EXP (EXP, GET_THE_TYPE (TYPESET));            D (AS_EXP, CHOI
CE, EXP);          else            EXP    := RESOLVE_DISCRETE_RANGE (EXP, GET_THE_TYPE (TYPESET));            CHOICE 
:= MAKE_CHOICE_RANGE (LX_SRCPOS => D (LX_SRCPOS, CHOICE), AS_DISCRETE_RANGE => EXP);떰          end if;        when DN_
CHOICE_RANGE =>          EXP := D (AS_DISCRETE_RANGE, CHOICE);          EVAL_DISCRETE_RANGE (EXP, TYPESET);          
REQUIRE_TYPE (TYPE_SPEC, EXP, TYPESET);          EXP := RESOLVE_DISCRETE_RANGE (EXP, GET_THE_TYPE (TYPESET));         
 D (AS_DISCRETE_RANGE, CHOICE, EXP);떰        when DN_CHOICE_OTHERS =>          null;      end case;떰      NEW_CHOICE
_LIST := APPEND (NEW_CHOICE_LIST, CHOICE);    end loop;    LIST (CHOICE_S, NEW_CHOICE_LIST);  end WALK_DISCRETE_CHOIC
E_S;떰땝К-----------  procedureКWALK_ITEM_SК( ITEM_S :TREE; H :H_TYPE )  isК-----------떰    ITEM_LIST: SEQ_TYPE
:= LIST (ITEM_S);    ITEMК: TREE;떰  begin    while  not IS_EMPTY( ITEM_LIST )  loop      POP( ITEM_LIST, ITEM ); 
     WALK( ITEM, H );    end loop;떰  end촜ALK_ITEM_S;땝-----------떰턤nd촏OD_WALK;땝--------
