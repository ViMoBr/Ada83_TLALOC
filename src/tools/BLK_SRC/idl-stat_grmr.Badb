SEPARATE( IDL )--|---------------------------------------------------------------------------------------------------|
КPROCEDURE STAT_GRMR--|-----------------------------------------------------------------------------------------------
--턕ROCEDURE STAT_GRMR ( NOM_TEXTE :STRING ) IS   턆EGIN  OPEN_IDL_TREE_FILE( NOM_TEXTE & ".lar" );ККК--| COMMENCER
 PAR OUVRIR CELA POUR POUVOIR TRAVAILLER !떰  DECLAREККККК--| PUIS DECLARER/INITIALISER CE DONT ON A BESOIN    USE
R_ROOTК: TREEК:= D( XD_USER_ROOT, TREE_ROOT);    GRAMMARК: TREEК:= D( XD_GRAMMAR, USER_ROOT);    GR_RULE_SК: SEQ_
TYPE:= LIST( GRAMMAR);             STATE_SEQК: SEQ_TYPE:= (TREE_NIL,TREE_NIL);К--| LISTE DE TOUS LES ETATS ENGEND
RES    WORK_LISTК: SEQ_TYPE:= STATE_SEQ;КК--| ETATS RESTANT  TRAITER    STATE_COUNTК: INTEGERК:= 0;КК--| NOMB
RE D'ETATS    DUMMY_FOLLOWК: TREEК:= MAKE( DN_TERMINAL_S );К--| LISTE DE SUIVI VIDE POUR PRNTSTAT          HASH_S
IZEК: CONSTANT INTEGER:= 2999;КК-- A PRIME    HASHК: ARRAY (0 .. HASH_SIZE-1) OF TREE:= (OTHERS=> TREE_VOID);  
      -- DEFINED STATES              -- DATA FOR TABLES TO SPEED UP NEW STATE CALCULATION        -- FOR EACH SYMBOL, 
INDEX POINTS TO A CHAIN OF ITEMS WITH THE        -- GIVEN SYMBOL FOLLOWING THE POSITION MARKER (I.E., THOSE ITEMS     
   -- WHICH, AFTER SHIFTING, FORM THE CORE OF A NEW STATE).    TYPE INDEX_TYPE촇S RECORDКККК-- ONE FOR EACH SYMBOL 
(- TER, + NONTER)땝  TIMEК: INTEGER:= 0;КК--| PASS (FROM STATE) AT WHICH USED땝  F, LК: INTEGER;КК--| PREMIER
 ET DERNIER ITEMS (N)땝촃ND RECORD;    TYPE CHAIN_TYPE촇S RECORD땝  NК: INTEGER;КК--| ITEM SUIVANT (0 POUR LA FIN 
DE CHANE)땝  TК: TREE;ККК--| UN ITEM땝  FIRSTК: BOOLEAN;КК--| PREMIER ITEM POUR LE SYMBOLE땝촃ND RECORD;     
     INDEXК: ARRAY( -INTEGER( 170 ) .. 400 ) OF INDEX_TYPE;    CHAINК: ARRAY( 1 .. 100 ) OF CHAIN_TYPE;    CHAIN_LA
ST: INTEGER;          --|--------------------------------------------------------------------------------------------
-    --|КPROCEDURE MAKE_ITEM    FUNCTION MAKE_ITEM ( ALTERNATIVE :TREE; SYLLABE_S :SEQ_TYPE; SYLLABE_NBR :INTEGER ) R
ETURN TREE IS      ITEM: TREE:= MAKE( DN_ITEM );ККК--| FABRIQUER UN NOEUD ITEM    BEGIN      D   ( XD_ALTERNATIV
E, ITEM, ALTERNATIVE );ККК--| Y MENTIONNER L'ALTERNATIVE DONT IL VIENT      LIST( ITEM, SYLLABE_S );ККК--| Y MET
TRE LA LISTE DES SYLLABES DE L'ALTERNATIVE      DI  ( XD_SYL_NBR, ITEM, SYLLABE_NBR );ККК--| PORTER UN N DE SYLLABE 
INITIAL      D   ( XD_GOTO, ITEM, TREE_VOID );ККК--| CHAMP INITIALISE  VIDE      D   ( XD_FOLLOW, ITEM, DUMMY_FOLL
OW );ККК--| CHAMP INITIALISE  LISTE VIDE      RETURN ITEM;    END;    --|-----------------------------------------
----------------------------------------------------    --|КPROCEDURE MAKE_STATE    FUNCTION MAKE_STATE RETURN TREE I
S      STATE: TREE:= MAKE( DN_STATE );    BEGIN      STATE_COUNT := STATE_COUNT + 1;ККК--| UN ETAT DE PLUS    
  DI( XD_STATE_NBR, STATE, STATE_COUNT );ККК--| METTRE LE N D'ETAT      STATE_SEQ := APPEND( STATE_SEQ, STATE );КК
К--| AJOUTER  LA LISTE D'ETATS               IF WORK_LIST.FIRST.TY /= DN_LIST THENККК--| SI LA LISTE N'EST PAS INI
TIALISEE OU VIDE        IF WORK_LIST.FIRST.TY = DN_NIL THENККК--| SI ELLE EST VIDE          WORK_LIST.FIRST := STAT
E;ККК--| POINTER L'ETAT CRE        ELSEКККК--| LA LISTE DE TRAVAIL EST NON VIDE          WORK_LIST.FIRST := S
TATE_SEQ.NEXT;ККК--| LA LISTE DE TRAVAIL POINTE LE RESTE DE LA LISTE DES ETATS        END IF;      END IF;      RE
TURN STATE;    END;    --|--------------------------------------------------------------------------------------------
-    --|КPROCEDURE FORM_CLOSURE    PROCEDURE FORM_CLOSURE ( ITEM_SEQ :IN OUT SEQ_TYPE ) IS      INIT_NONTER_SК: SEQ
_TYPE:= (TREE_NIL,TREE_NIL);К--| LISTE DES RGLES DE NON TERMINAUX QUI FORME LA FERMETURE    BEGIN         턊IND_RUL
ES_FOR_CLOSURE:КККК--| CHERCHER LES RGLES QUI VONT ALLER DANS LA FERMETURE DE L'ITEM      DECLARE        ITEM_S: 
SEQ_TYPE:= ITEM_SEQ;        ITEM: TREE;      BEGIN        WHILE NOT IS_EMPTY( ITEM_S ) LOOPККК--| TANT QU'IL Y A
 DES ITEMS          POP( ITEM_S, ITEM );ККК--| EN EXTRAIRE UN          DECLARE            SYLLABE_S: SEQ_TYPE:=
 LIST( ITEM );КК--| PRENDRE SA LISTE DE SYLLABES            SYLLABEК: TREE;          BEGIN            IF NOT IS_EM
PTY( SYLLABE_S ) THENККК--| S'IL Y A DES SYLLABES              SYLLABE:= HEAD( SYLLABE_S );ККК--| PRENDRE LA PREM
IRE              IF SYLLABE.TY = DN_NONTERMINAL THENККК--| SI C'EST UN NON TERMINAL                DECLARE        
          RULE : TREE := D( XD_RULE, SYLLABE );КК--| PRENDRE SA RGLE DE DEFINITION                BEGIN            
      IF RULE.TY /= DN_VOID THENККК--| S'IL Y EN A UNE                     INIT_NONTER_S := TERM_LIST.R_UNION( INIT_
NONTER_S,К--| MENTIONNER DANS LA LISTE DES NON TERMINAUX                     촍IST( D( XD_INIT_NONTER_S, D( XD_RULEIN
FO, RULE ) ) )                                    );                   END IF;                 END;               EN
D IF;             END IF;           END;         END LOOP;       END FIND_RULES_FOR_CLOSURE;            턎NSERT_RUL
ES_IN_CLOSURE:КККК--| PORTER LES ALTERNATIVES DES RGLES TROUVEES DANS DES ITEMS CONSTITUANT LA FERMETURE       DECL
ARE         RULEК: TREE;       BEGIN         WHILE NOT IS_EMPTY( INIT_NONTER_S ) LOOPККК--| TANT QU'IL Y A DES RG
LES           POP( INIT_NONTER_S, RULE );ККК--| EN EXTRAIRE UNE           DECLARE             ALTERNATIVE_S: SEQ
_TYPE := LIST( RULE );КК--| PRENDRE LA LISTE DE SES ALTERNATIVES             ALTERNATIVE: TREE;           BEGIN  
           WHILE NOT IS_EMPTY( ALTERNATIVE_S ) LOOPКК--| TANT QU'IL Y A DES ALTERNATIVES               POP( ALTERNAT
IVE_S, ALTERNATIVE );ККК--| EN EXTRAIRE UNE               ITEM_SEQ := APPEND( ITEM_SEQ,ККК--| PEFIXER  LA LISTE D
'ITEMS                       촎AKE_ITEM( ALTERNATIVE, LIST( ALTERNATIVE ), 0 )К--| UN NOUVEL ITEM POUR CETTE ALTERNAT
IVE                           );             END LOOP;           END;         END LOOP;       END INSERT_RULES_IN_
CLOSURE;                 END FORM_CLOSURE;     --|-------------------------------------------------------------------
-------------------------     --|КPROCEDURE MAKE_NEW_STATE     FUNCTION MAKE_NEW_STATE ( FROM_INDEX :INTEGER ) RETURN
 TREE IS       IIК: INTEGERК:= INDEX( FROM_INDEX ).F;       STATEК: TREEК:= MAKE_STATE;КК--| FABRIQUER UN ETAT
       NEW_ITEM_SEQК: SEQ_TYPE:= (TREE_NIL,TREE_NIL);К--| LISTE D'ITEMS VIDE     BEGIN       WHILE II /= 0 LOOP  
       DECLARE           OLD_ITEMК: TREEК:= CHAIN( II ).T;           OLD_TAIL : SEQ_TYPE:= LIST( OLD_ITEM );     
      NEW_ITEMК: TREEК:= MAKE_ITEM(                 К촂( XD_ALTERNATIVE, OLD_ITEM ),К--| POUR L'ALTERNATIVE DE L'I
TEM PRE                  К촖AIL( OLD_TAIL ),КК--| AVEC LE RESTE DE LA LISTE DE SYLLABES                  К촂I( XD
_SYL_NBR, OLD_ITEM) + 1КК--| UN N DE SYLLABE INCREMENTE DE 1                  К);         BEGIN           NEW_ITE
M_SEQ := APPEND( NEW_ITEM_SEQ, NEW_ITEM );КК--| PREFIXER L'ITEM  LA LISTE           II := CHAIN( II ).N;ККК--| IN
DICE D'ITEM SUIVANT         END;       END LOOP;                FORM_CLOSURE( NEW_ITEM_SEQ );ККК--| CALCULER LA 
FERMETURE DES ITEMS MIS EN LISTE       LIST( STATE, NEW_ITEM_SEQ );ККК--| AJOUTER L'ETAT  LA LISTE D'ETATS       R
ETURN STATE;     END;    --|------------------------------------------------------------------------------------------
---    --|КPROCEDURE MAKE_STATES    PROCEDURE MAKE_STATES IS      FROM_STATEК: TREE;      FROM_NBRК: INTEGER;   
   FROM_ITEM_SEQК: SEQ_TYPE;      FROM_ITEMК: TREE;      FROM_INDEXК: INTEGER;                  --|--------------
-----------------------------------------------------------------------------      --|КPROCEDURE ITEM_INDEX      FUNC
TION ITEM_INDEX ( IT :TREE ) RETURN INTEGER IS        SYLLABE_SК: SEQ_TYPE:= LIST( IT );      BEGIN        IF IS_EM
PTY( SYLLABE_S ) THEN          RETURN 0;        ELSE          DECLARE            SYLLABEК: TREE:= HEAD( SYLLABE_S 
);          BEGIN            IF SYLLABE.TY = DN_TERMINAL THENККК--| SYLLABE TERMINALE              RETURN - DI( XD
_TER_NBR, SYLLABE );ККК--| OPPOSE DU N DE TERMINAL            ELSEКККК--| NON TERMINALE              DECLARE 
               RULE : TREE:= D( XD_RULE, SYLLABE );КК--| RGLE DE DEFINITION              BEGIN                IF R
ULE.TY = DN_VOID THENККК--| PAS DE RGLE DE DEFINITION                  RETURN 0;КККК--| N 0                ELSE
КККК--| RGLE PRESENTE                  RETURN DI( XD_RULE_NBR, D( XD_RULEINFO, RULE ) );КК--| LE N DE RGLE      
          END IF;              END;            END IF;          END;        END IF;      END ITEM_INDEX;      --|-
------------------------------------------------------------------------------------------      --|КPROCEDURE CALCULAT
E_GOTO      PROCEDURE CALCULATE_GOTO IS        TO_STATEК: TREEК:= TREE_VOID;        FROM_ALTК: TREEК:= D( XD_ALTE
RNATIVE, FROM_ITEM );        POSSIBLE_TOК: TREE;        TEMP_ITEMК: TREE;        HASH_CODEК: INTEGERК:= 0;      
  HASH_DELTAК: INTEGERК:= 1;        ELEMENT_COUNT: INTEGERК:= 0;        IIК: INTEGER;ККК-- ITEM CHAIN NUMBER떰
        --|-----------------------------------------------------------------------------------------        --|촒ROCEDU
RE CHECK_POSSIBLE_TO        FUNCTION CHECK_POSSIBLE_TO ( FROM_INDEX :INTEGER; POSSIBLE_TO :TREE ) RETURN BOOLEAN IS   
       IIК: INTEGERК:= INDEX( FROM_INDEX ).F;          NEW_ITEM_SEQ: SEQ_TYPE:= LIST ( POSSIBLE_TO );          OLD
_ITEMК: TREE;          NEW_ITEMК: TREE;        BEGIN          LOOP            IF IS_EMPTY( NEW_ITEM_SEQ )ККК--
| PLUS D'ITEM               OR ELSE DI( XD_SYL_NBR, ( HEAD( NEW_ITEM_SEQ ) ) ) = 0КК--| OU PLUS DE SYLLABE          
  THEN              RETURN II = 0;            END IF;            IF II = 0 THEN              RETURN FALSE;         
   END IF;            OLD_ITEM := CHAIN( II ).T;            NEW_ITEM := HEAD ( NEW_ITEM_SEQ );            IF D( XD_AL
TERNATIVE, OLD_ITEM ) /= D( XD_ALTERNATIVE, NEW_ITEM )               OR ELSE DI( XD_SYL_NBR,OLD_ITEM) +1 /= DI( XD_SYL_
NBR, NEW_ITEM )            THEN              RETURN FALSE;            END IF;            II := CHAIN( II ).N;      
      NEW_ITEM_SEQ := TAIL( NEW_ITEM_SEQ );          END LOOP;        END CHECK_POSSIBLE_TO;                  BEGIN
        II := INDEX( FROM_INDEX ).F;        WHILE II /= 0 LOOP          ELEMENT_COUNT := ELEMENT_COUNT + 1;          
TEMP_ITEM := CHAIN( II ).T;          HASH_CODE := ABS(                     촆ASH_CODE                     - 28 * DI( 
XD_ALT_NBR, D( XD_ALTERNATIVE, TEMP_ITEM ) )                     - 3  * DI( XD_SYL_NBR, TEMP_ITEM )                   
  - 11 * ELEMENT_COUNT                     );           II := CHAIN( II ).N;        END LOOP;        HASH_CODE := HA
SH_CODE MOD HASH_SIZE;                    WHILE HASH( HASH_CODE ) /= TREE_VOID LOOP          POSSIBLE_TO := HASH( HAS
H_CODE );          IF CHECK_POSSIBLE_TO( FROM_INDEX, POSSIBLE_TO ) THEN            TO_STATE := POSSIBLE_TO;          
  EXIT;          END IF;          IF HASH_DELTA >= HASH_SIZE THEN            PUT_LINE( "HASH TABLE OVERFLOW." );    
        RAISE PROGRAM_ERROR;          END IF;          HASH_CODE := (HASH_CODE + HASH_DELTA) MOD HASH_SIZE;          
HASH_DELTA := HASH_DELTA + 2;ККК-- SO HASH_CODE INCREASES BY N ** 2        END LOOP;                    IF TO_STAT
E = TREE_VOID THENК-- DIDN'T FIND ONE          TO_STATE := MAKE_NEW_STATE ( FROM_INDEX );          HASH( HASH_CODE )
 := TO_STATE;        END IF;                        -- INSERT NEW STATE AS GOTO FOR ALL RULES WITH GIVEN NEXT SYMBOL 
       II := INDEX( FROM_INDEX ).F;        WHILE II /= 0 LOOP          FROM_ITEM := CHAIN( II ).T;          D( XD_GOT
O, FROM_ITEM, TO_STATE );          II := CHAIN( II ).N;        END LOOP;      END CALCULATE_GOTO;             BEGIN
      WHILE NOT IS_EMPTY( WORK_LIST ) LOOP        POP( WORK_LIST, FROM_STATE );        FROM_NBR := DI( XD_STATE_NBR, 
FROM_STATE );        IF STATE_COUNT MOD 20 = 0 THEN          PUT( '*');        END IF;                        -- CON
STRUCT CHAIN STRUCTURE FOR THIS STATE        CHAIN_LAST := 0;        FROM_ITEM_SEQ := LIST( FROM_STATE );        WHIL
E NOT IS_EMPTY( FROM_ITEM_SEQ ) LOOP          POP( FROM_ITEM_SEQ, FROM_ITEM );                            FROM_INDEX 
:= ITEM_INDEX( FROM_ITEM );          IF FROM_INDEX /= 0 THEN            CHAIN_LAST := CHAIN_LAST + 1;            DECL
ARE              CHAIN_I: CHAIN_TYPE RENAMES CHAIN(CHAIN_LAST);              INDEX_I: INDEX_TYPE RENAMES INDEX(FROM_
INDEX);            BEGIN              IF INDEX_I.TIME /= FROM_NBR THEN                INDEX_I := (TIME=> FROM_NBR, F=
> CHAIN_LAST, L=> CHAIN_LAST);                CHAIN_I := (N=> 0, T=> FROM_ITEM, FIRST=> TRUE);              ELSE     
           CHAIN( INDEX_I.L ).N := CHAIN_LAST;                CHAIN_I := (N=> 0, T=> FROM_ITEM, FIRST=> FALSE);       
       END IF;              INDEX_I.L := CHAIN_LAST;            END;          END IF;        END LOOP;떰        FOR 
CH IN 1 .. CHAIN_LAST LOOP          IF CHAIN( CH ).FIRST THEN            FROM_ITEM := CHAIN( CH ).T;            FROM_
INDEX := ITEM_INDEX( FROM_ITEM );            CALCULATE_GOTO;          END IF;        END LOOP;                     
END LOOP;    END MAKE_STATES;        BEGIN          DECLARE      RULE_SК: SEQ_TYPE:= GR_RULE_S;      RULEК: TR
EEК:= HEAD( GR_RULE_S );К--| PREMIRE RGLE      ALTERNATIVE_SК: SEQ_TYPE:= LIST( RULE );КК--| SA LISTE D'ALTERNAT
IVES      ALTERNATIVEК: TREEК:= HEAD( ALTERNATIVE_S );К--| LA PREMIRE ALTERNATIVE      SYLLABE_SК: SEQ_TYPE:= LI
ST( ALTERNATIVE );К--| SA LISTE DE SYLLABES      ITEM_SEQК: SEQ_TYPE:= APPEND( (TREE_NIL,TREE_NIL),К--| METTRE EN 
LISTE            КК     MAKE_ITEM( ALTERNATIVE, SYLLABE_S, 0 )--| LE PREMIER ITEM            КК);    BEGIN    
  LIST( DUMMY_FOLLOW, (TREE_NIL,TREE_NIL) );ККК--| METTRE UNE LISTE VIDE DANS LE SUIVI      FORM_CLOSURE( ITEM_SEQ )
;ККК--| CALCULER LA FERMETURE DU PREMIER ITEM      LIST( MAKE_STATE, ITEM_SEQ );ККК--| FABRIQUER UN PREMIER ETA
T AVEC L'ITEM INTERESSANT L'ALTERNATIVE 1 DE LA RGLE 1    END;          MAKE_STATES;          DECLARE      STATE_S
: TREE:= MAKE( DN_STATE_S );КК--| FABRIQUER UN ACCS POUR LA LISTE D'ETAT    BEGIN      LIST( STATE_S, STATE_SEQ )
;ККК--| Y PORTER LA LISTE CONSTITUEE      D( XD_STATELIST, USER_ROOT, STATE_S );ККК--| METTRE DANS LA LISTE DE L
A STRUCTURE DE DONNEES    END;  END;        CLOSE_IDL_TREE_FILE;턉ND STAT_GRMR;
