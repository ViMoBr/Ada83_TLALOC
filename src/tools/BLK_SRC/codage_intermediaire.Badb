------------------------------------------------------------------------------------------------------------------------
¶-- CC BY SA¬CODAGE_INTERMEDIAIRE.ADB¬VINCENT MORIN¬6/5/2025¬UNIVERSITE DE BRETAGNE OCCIDENTALE¶------------------------
------------------------------------------------------------------------------------------------¶--¬1¬2¬3¬4¬5¬6¬7¬8¬9¬0¬
1¬2¶¶¶with DIANA_NODE_ATTR_CLASS_NAMES;¶use  DIANA_NODE_ATTR_CLASS_NAMES;¶¶¬¬¬--------------------¶¬package body¬CODAGE_
INTERMEDIAIRE¶¬¬¬--------------------¶is¶¶¶--  use OP_CODE_IO;¶--  use CODE_DATA_TYPE_IO;¶ ¶  INACTIVE : BOOLEAN renames
 TRUE;¶¶  INT_LABEL¬: LABEL_TYPE¬:= 1;¶  FS¬¬: FILE_TYPE;¶¶--  LAST_LBL¬¬¬: TARGET_LBL_REF;¶--  LAST_BRANCH¬¬¬: NUM_BRAN
CH;¶--  DERNIERE_REPRISE_CALL¬¬: TARGET_LBL_REF¬:= 0;¶¶¶¶¶¬¬¬¬--============--¶  procedure¬¬¬OPEN_OUTPUT_FILE¬¬( FILE_NA
ME :STRING )¶  is¶  begin¶    CREATE ( FS, OUT_FILE, FILE_NAME( FILE_NAME'FIRST .. FILE_NAME'LAST-4 ) & ".FINC" );¬¬¬¬--
 FASM INCLUDE¶    SET_OUTPUT ( FS );¬¬¬¬¬¬¬¬¬¬--| CODAGE SUR SORTIE STANDARD¶    INT_LABEL := 1;¶¶  end¬OPEN_OUTPUT_FILE
;¶¬--============--¶¶¶¶¬¬¬¬--=============--¶  procedure¬¬¬CLOSE_OUTPUT_FILE¶  is¶  begin¶    SET_OUTPUT ( STANDARD_OUTP
UT );¶    CLOSE ( FS );¶¶  end¬CLOSE_OUTPUT_FILE;¶¬--=============--¶¶¶¶  package INT_IO¬is new INTEGER_IO ( INTEGER ); 
use INT_IO;¶  package LBL_IO¬is new INTEGER_IO ( LABEL_TYPE ); use LBL_IO;¶¶¬¬¬¬--====--¶  function¬¬¬NEW_LABEL¬¬¬return
 LABEL_TYPE¶  is¶    LBL¬: LABEL_TYPE¬:= INT_LABEL;¶  begin¶    INT_LABEL := INT_LABEL + 1;¶    return LBL;¶¶  end¬NEW_L
ABEL;¶¬--====--¶¶¶¬¬¬¬--====--¶  function¬¬¬NEW_LABEL¬¬¬return STRING¶  is¶    LSTR¬:constant STRING¬:= LABEL_TYPE'IMAGE
( INT_LABEL );¶  begin¶    INT_LABEL := INT_LABEL + 1;¶    return 'L' & LSTR( LSTR'FIRST+1 .. LSTR'LAST );¶¶  end¬NEW_LA
BEL;¶¬--====--¶¶¶¬¬¬¬--=====--¶  function¬¬¬LABEL_STR¬¬( LBL : LABEL_TYPE )¬return STRING¶  is¶    LSTR¬:constant STRING
¬:= LABEL_TYPE'IMAGE( LBL );¶  begin¶    return 'L' & LSTR( LSTR'FIRST+1 .. LSTR'LAST );¶¶  end¬LABEL_STR;¶¬--=====--¶¶¶
¶¬¬¬¬--=====--¶  procedure¬¬¬INC_LEVEL¶  is¶  begin¶    CUR_LEVEL := CUR_LEVEL + 1;¶¶--    if DEBUG then put_line( "inc 
lvl cur= " & LEVEL_NUM'IMAGE( CUR_LEVEL ) ); end if;¶¶--   exception¶--     when CONSTRAINT_ERROR => raise STATIC_LEVEL_
OVERFLOW;¶¶  end¬INC_LEVEL;¶¬--=====--¶¶¶¶¬¬¬¬--=====--¶  procedure¬¬¬DEC_LEVEL¶  is¶  begin¶    CUR_LEVEL := CUR_LEVEL 
- 1;¶¶--    if DEBUG then put_line( "dec lvl cur= " & LEVEL_NUM'IMAGE( CUR_LEVEL ) ); end if;¶¶--   exception¶--     whe
n CONSTRAINT_ERROR => raise STATIC_LEVEL_UNDERFLOW;¶-- ¶  end¬DEC_LEVEL;¶¬--=====--¶¶¬¬¬¬--=====--¶  function¬¬¬TYPE_SIZ
E¬¬¬( TYPE_SPEC :TREE )¶¬¬¬¬¬¬¬return NATURAL¶  is¶  begin¶    case TYPE_SPEC.TY is¶    when DN_ACCESS¬¬¬=> return ADDR_
SIZE;¶    when DN_ARRAY¬¬¬=> return 2 * ADDR_SIZE;¶    when DN_ENUMERATION | DN_INTEGER¬=> return INTG_SIZE;¶    when DN
_L_PRIVATE¬¬=> return TYPE_SIZE( D( SM_TYPE_SPEC, TYPE_SPEC ) );¶    when others =>¶      PUT_LINE( "CODAGE_INTERMEDIAIR
E.TYPE_SIZE : TYPE_SPEC.TY ILLICITE " & NODE_NAME'IMAGE( TYPE_SPEC.TY ) );¶--      raise PROGRAM_ERROR;¶    end case;¶  
  return 0;¶  end¬TYPE_SIZE;¶¬--=====--¶¶¶¶¬¬¬¬--=============--¶  function¬¬¬CODE_DATA_TYPE_OF¬¬( EXP_OR_TYPE_SPEC :TRE
E )¶¬¬¬¬¬¬¬return CHARACTER¶  is¶  begin¶    if EXP_OR_TYPE_SPEC.TY in CLASS_EXP then¶      declare¶        EXP¬: TREE¬r
enames EXP_OR_TYPE_SPEC;¶      begin¶        case EXP.TY is¶        when DN_FUNCTION_CALL | DN_PARENTHESIZED | DN_USED_O
BJECT_ID =>¶          return CODE_DATA_TYPE_OF( D( SM_EXP_TYPE, EXP ) );¶                     ¶        when others =>¶  
        PUT_LINE( "ERREUR CODE_DATA_TYPE_OF : EXP.TY ILLICITE " & NODE_NAME'IMAGE( EXP.TY ) );¶          raise PROGRAM_E
RROR;¶        end case;¶      end;¶            ¶    elsif EXP_OR_TYPE_SPEC.TY in CLASS_TYPE_SPEC then¶      declare¶    
    TYPE_SPEC¬: TREE¬renames EXP_OR_TYPE_SPEC;¶      begin¶        case TYPE_SPEC.TY is¶        when DN_ACCESS =>¶      
    return 'A';¶                  ¶        when DN_ENUMERATION =>¶          declare¶            TYPE_SOURCE_NAME¬: TREE¬
¬:= D( XD_SOURCE_NAME, TYPE_SPEC );¶            TYPE_SYMREP¬: TREE¬¬:= D( LX_SYMREP, TYPE_SOURCE_NAME );¶            NAM
E¬¬: constant STRING¬:= PRINT_NAME( TYPE_SYMREP );¶          begin¶            if NAME = "BOOLEAN" then¶              re
turn 'B';¶            elsif NAME = "CHARACTER" then¶              return 'B';¶            else¶              return 'I';
¶            end if;¶          end;¶                  ¶        when DN_INTEGER | DN_NUMERIC_LITERAL =>¶          return 
'I';¶                  ¶        when others =>¶          PUT_LINE( "ERREUR CODE_DATA_TYPE_OF : TYPE_SPEC.TY ILLICITE " &
 NODE_NAME'IMAGE( TYPE_SPEC.TY ) );¶          raise PROGRAM_ERROR;¶        end case;¶      end;¶            ¶    else¶  
    PUT_LINE ( "!!! CODE_DATA_TYPE_OF : EXP_OR_TYPE_SPEC.TY ILLICITE " & NODE_NAME'IMAGE ( EXP_OR_TYPE_SPEC.TY ) );¶    
  raise PROGRAM_ERROR;¶    end if;¶¶  end¬CODE_DATA_TYPE_OF;¶   ¬--=============--¶¶¬¬¬¬--================--¶  function¬
¬¬NUMBER_OF_DIMENSIONS¬( EXP :TREE )¶¬¬¬¬¬¬¬return NATURAL¶  is¶  begin¶    if EXP.TY in CLASS_CONSTRAINED then¶      re
turn NUMBER_OF_DIMENSIONS( D( SM_BASE_TYPE, EXP ) );¶            ¶    elsif EXP.TY = DN_FUNCTION_CALL or EXP.TY = DN_USE
D_OBJECT_ID then¶      return NUMBER_OF_DIMENSIONS( D( SM_EXP_TYPE, EXP ) );¶            ¶    elsif EXP.TY = DN_ARRAY th
en¶      return DI( CD_DIMENSIONS, EXP );¶            ¶    else¶      PUT_LINE( "ERREUR NUMBER_OF_DIMENSIONS : TYPE EXPR
ESSION ILLICITE" & NODE_NAME'IMAGE( EXP.TY ) );¶      raise PROGRAM_ERROR;¶    end if;¶¶  end¬NUMBER_OF_DIMENSIONS;¶¬--=
===============--¶¶¶¬¬¬¬--=======--¶  function¬¬¬CONSTRAINED¬¬( TYPE_SPEC :TREE )¶¬¬¬¬¬¬¬return BOOLEAN¶  is¶  begin¶   
 return not ( TYPE_SPEC.TY in CLASS_UNCONSTRAINED );¶¶  end¬CONSTRAINED;¶¬--=======--¶¶¶¶¬¬¬¬--==========--¶  procedure¬
¬¬LOAD_TYPE_SIZE¬¬( TYPE_SPEC :TREE )¶  is¶  begin¶    if CONSTRAINED( TYPE_SPEC ) then¶      PUT_LINE( ASCII.HT & "LI" 
& ASCII.HT &  INTEGER'IMAGE( TYPE_SIZE( TYPE_SPEC ) ) );¶¶    else¶      PUT_LINE( "ERREUR LOAD_TYPE_SIZE : TYPE_SPEC NO
N CONTRAINT" );¶      raise PROGRAM_ERROR;¶    end if;¶¶  end¬LOAD_TYPE_SIZE;¶¬--==========--¶¶¬¬¬-------------¶  functi
on¬¬OPER_SIZ_CHAR¬( DEFN :TREE ) return CHARACTER¶  is¬¬¬-------------¶¶    SIZ¬¬: NATURAL¬¬:= DI( CD_IMPL_SIZE, DEFN );
¶  begin¶   if SIZ <= 8¬then return 'b';¶    elsif SIZ <= 16¬then return 'w';¶    elsif SIZ <= 32¬then return 'd';¶    e
lsif SIZ <= 64¬then return 'q';¶    else return 'v';¶    end if;¶¶  end¬OPER_SIZ_CHAR;¶¬-------------¶¶¬¬¬-------------¶
  function¬¬EXP_TYPE_CHAR¬( EXP :TREE ) return CHARACTER¶  is¶    SIZ¬¬: NATURAL¬¬:= DI( CD_IMPL_SIZE, D( SM_EXP_TYPE, E
XP ) );¶  begin¶   if SIZ <= 8¬then return 'b';¶    elsif SIZ <= 16¬then return 'w';¶    elsif SIZ <= 32¬then return 'd'
;¶    elsif SIZ <= 64¬then return 'q';¶    else return 'v';¶    end if;¶¶  end¬EXP_TYPE_CHAR;¶¬-------------¶¶¶¬¬¬¬--===
=--¶  procedure¬¬¬LOAD_MEM¬¬¬( DEFN :TREE )¶  is¶  begin¶¶    if  DEFN.TY in CLASS_PARAM_NAME  then¬¬¬¬¬¬¬¬-- in_id in_o
ut_id out_id¶      if  (DEFN.TY = DN_IN_ID) and (D( SM_OBJ_TYPE, DEFN ).TY in CLASS_SCALAR)  then¶¶        declare¶¬SIZ_
CHAR¬: CHARACTER¬:= OPER_SIZ_CHAR( D( SM_OBJ_TYPE, DEFN ) );¶        begin¶¬PUT( tab & "L" & SIZ_CHAR & ' ' & INTEGER'IM
AGE( DI( CD_LEVEL, DEFN ) ) & ',' & tab );¶¬PUT( '-' & PRINT_NAME( D( LX_SYMREP, DEFN ) ) );¬¬¬¬¬¬¬-- ATTENTION signe of
fset de params oppos aux vars¶¬PUT_LINE( "_ofs" );¬¬¬¬¬¬¬¬¬¬-- offset de parametre scalaire¶        end;¶¶      else¬¬¬¬
¬¬¬¬¬¬¬-- pas scalaire ou out in/out¶        PUT( tab & "La " & INTEGER'IMAGE( DI( CD_LEVEL, DEFN ) ) & ',' & tab );¶   
     PUT( '-' & PRINT_NAME( D( LX_SYMREP, DEFN ) ) );¬¬¬¬¬¬¬-- ATTENTION signe offset de params oppos aux vars¶        P
UT_LINE( "_ofs" );¬¬¬¬¬¬¬¬¬¬-- offset de parametre adresse¶      end if;¶¶    else¶      if  D( SM_OBJ_TYPE, DEFN ).TY i
n CLASS_SCALAR  then¶        declare¶¬SIZ_CHAR¬: CHARACTER¬:= OPER_SIZ_CHAR( D( SM_OBJ_TYPE, DEFN ) );¶        begin¶¬PU
T( tab & "L" & SIZ_CHAR & ' ' & INTEGER'IMAGE( DI( CD_LEVEL, DEFN ) ) & ',' & tab );¶¬PUT_LINE( PRINT_NAME( D( LX_SYMREP
, DEFN ) ) & "_disp" );¬¬¬¬¬¬-- deplacement de variable locale¶        end;¶¶     else¬¬¬¬¬¬¬¬¬¬¬¬-- variable non scalai
re¶        PUT( tab & "LVa " & INTEGER'IMAGE( DI( CD_LEVEL, DEFN ) ) & ',' & tab );¶        PUT_LINE( PRINT_NAME( D( LX_
SYMREP, DEFN ) )  & "_disp" );¶¶     end if;¶¶    end if;¶¶  end¬LOAD_MEM;¶¬--====--¶¶¶¬¬¬¬--=--¶  procedure¬¬¬STORE¬¬¬(
 DEST_DEFN¬:TREE )¶  is¶    SIZ_CHAR¬: CHARACTER¬:= OPER_SIZ_CHAR( D( SM_OBJ_TYPE, DEST_DEFN ) );¶  begin¶    if DEST_DE
FN.TY = DN_OUT_ID or DEST_DEFN.TY = DN_IN_OUT_ID then¶      PUT_LINE( tab & "SI" & SIZ_CHAR & ' ' & INTEGER'IMAGE( DI( C
D_LEVEL, DEST_DEFN ) ) & ',' & tab & '-' & PRINT_NAME( D( LX_SYMREP, DEST_DEFN ) ) & "_ofs" );¶    else¶      PUT_LINE( 
tab & "S" & SIZ_CHAR & ' ' & INTEGER'IMAGE( DI( CD_LEVEL, DEST_DEFN ) ) & ',' & tab & PRINT_NAME( D( LX_SYMREP, DEST_DEF
N ) ) & "_disp" );¶    end if;¶  end¬STORE; ¶¬--=--¶¶¬¬¬¬--=--¶  function¬¬¬TAB50¬¬return STRING¶  is¶    NTABS¬¬: INTEG
ER¬¬:= (50 - NATURAL(TEXT_IO.COL) ) / 10;¶  begin¶    if NTABS < 0 then NTABS := 1; else NTABS := NTABS + 1; end if;¶   
 declare¶      ESPACEMENT¬: STRING( 1.. NATURAL(NTABS) )¬:= (others => tab );¶    begin¶      return ESPACEMENT;¶    end
;¶  end¬TAB50;¶¬--=--¶¶¬¬¬¬--=--¶  function¬¬¬IMAGE¬¬( I : NATURAL )¬return STRING¶  is¶    STR¬:constant STRING¬:= NATU
RAL'IMAGE( I );¶  begin¶    return STR( STR'FIRST+1 .. STR'LAST );¶¶  end¬IMAGE;¶¬--=--¶¶¬¬¬--========--¶  procedure¬¬RE
GIONS_PATH¬( ID : TREE; WITH_DOT :BOOLEAN := TRUE )¶  is¬¬¬------------¶    REGION¬: TREE¬¬:= D( XD_REGION, ID );¶    RG
N_NAME¬:constant STRING¬:= PRINT_NAME( D( LX_SYMREP, REGION ) );¶  begin¶    if  RGN_NAME = "STANDARD"  then¶      PUT( 
"STANDARD." );¶    else¶      REGIONS_PATH( REGION );¶      PUT( RGN_NAME );¶      if  REGION.TY = DN_PROCEDURE_ID  then
¶        PUT( '_' & LABEL_STR( LABEL_TYPE( DI( CD_LABEL, REGION ) ) ) );¶      end if;¶      if  WITH_DOT  then PUT( '.'
 ); end if;¶    end if;¶¶  end¬REGIONS_PATH;¶¬------------¶¶end¬CODAGE_INTERMEDIAIRE;¶¬--------------------¶¶-----------
--------------------------------------------------------------------------------------------------------------¶--¬1¬2¬3¬
4¬5¬6¬7¬8¬9¬0¬1¬2¶
