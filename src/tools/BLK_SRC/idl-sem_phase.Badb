separate( IDL )떰КК---------땝촳rocedureК촕EM_PHASE턨sКК---------떰땝К--------땝촳ackageКSEM_GLOB땝К--------
  is          type SB_TYPE촫s recordКККК--| SAUVE ET RESTAURE AUTOUR DES CORPS땝  null;땝촦nd record;         
 type SU_TYPE촫s recordКККК--| SAUVE ET RESTAURE AUTOUR DES REGIONS땝  USED_PACKAGE_LISTК: SEQ_TYPE;땝  INCOMPLET
E_TYPE_LIST: SEQ_TYPE;땝  PRIVATE_TYPE_LISTК: SEQ_TYPE;땝촦nd record;          type H_TYPE촫s recordКККК--| INF
ORMATION HEREDITAIRE땝  REGION_DEF: TREE;땝  LEX_LEVEL: NATURAL;땝  IS_IN_SPEC: BOOLEAN;땝  IS_IN_BODY: BOOLEAN;
땝  SUBP_SYMREP: TREE;땝  RETURN_TYPE: TREE;땝  ENCLOSING_LOOP_ID: TREE;땝촦nd record;떰    SBК: SB_TYPE;    SU
К: SU_TYPE;    INITIAL_HК: H_TYPE;          PREDEFINED_BOOLEANК: TREE;    PREDEFINED_SHORT_INTEGERК: TREE;    
PREDEFINED_INTEGERК: TREE;    PREDEFINED_LONG_INTEGERК: TREE;    PREDEFINED_LARGEST_INTEGER: TREE;    PREDEFINED_F
LOATК: TREE;    PREDEFINED_LONG_FLOATК: TREE;    PREDEFINED_LARGEST_FLOATК: TREE;    PREDEFINED_STRINGК: TREE;  
  PREDEFINED_DURATIONК: TREE;    PREDEFINED_ADDRESSК: TREE;          PREDEFINED_STANDARD_DEFК: TREE;    PREDEFINE
D_STANDARD_IDК: TREE;          PREDEFINED_SHORT_INTEGER_FIRST: TREE;    PREDEFINED_SHORT_INTEGER_LAST: TREE;    P
REDEFINED_INTEGER_FIRSTК: TREE;    PREDEFINED_INTEGER_LASTК: TREE;    PREDEFINED_LONG_INTEGER_FIRST: TREE;    PRED
EFINED_LONG_INTEGER_LAST: TREE;    PREDEFINED_FLOAT_FIRSTК: TREE;    PREDEFINED_FLOAT_LASTК: TREE;    PREDEFINED_F
LOAT_ACCURACYК: TREE;    PREDEFINED_LONG_FLOAT_FIRST: TREE;    PREDEFINED_LONG_FLOAT_LAST: TREE;    PREDEFINED_LON
G_FLOAT_ACCURACY: TREE;                procedure INITIALIZE_GLOBAL_DATA;    procedure INITIALIZE_PREDEFINED_TYPES;
       땝--------  end촕EM_GLOB;땝--------  use SEM_GLOB;                 --|-----------------------------------
-------------------------------------------------------------떰  --КUNIV_OPS떰  --|------------------------------------
------------------------------------------------------------  package UNIV_OPS is          URADIXК: constant := 10_0
00;떰    type UDIGITКis range -32_768 .. 32_767;Кfor UDIGIT'SIZE use 16;떰    type VECTOR_DIGITS촫s array( 1..252 ) of
 UDIGIT;Кpragma PACK( VECTOR_DIGITS );떰    type VECTORКis record땝К  L: NATURAL;КК--| NOMBRE DE "CHIFFRES" 10_00
0 AIRES땝К  S: UDIGIT;ККК--| SIGNE +1 OR -1땝К  D: VECTOR_DIGITS;КК--| CHIFFRES EN BASE 10_000땝Кend record;
Кpragma PACK( VECTOR );          function  U_INTК( V :VECTOR )К촵eturn TREE;К--| FABRIQUE UN ENTIER UNIVERSEL  PAR
TIR D'UN VECTEUR    function  U_REAL( NUMER, DENOM :VECTOR )Кreturn TREE;К--| UNIVERSAL REAL  PARTIR DE VECTEURS DEJ
 REDUITS AUX TERMES LES PLUS BAS    function  U_REAL( NUMER, DENOM :TREE )Кreturn TREE;К--| UNIVERSAL REAL AVEC DEUX
 ENTIERS UNIVERSELS (NON NECESSAIREMENT REDUITS)    procedure SPREAD( T :TREE; V :in out VECTOR );    procedure SPREA
D( I :INTEGER; V :in out VECTOR );    procedure NORMALIZE( V :in out VECTOR );            --| LES SIGNES SONT IGNOR
ES : OPERATIONS SUR VALEURS ABSOLUES            procedure V_ADDК( A :VECTOR; R :in out VECTOR );КК-- |R| + |A| --> 
|R|    procedure V_SUBК( A :VECTOR; R :in out VECTOR );КК-- |R| - |A| --> |R| ; ASSUME |A| < |R|    procedure V_MUL
К( A,B :VECTOR; R :in out VECTOR );КК-- |A| * |B| --> R    procedure V_SCALE( A :INTEGER; R :in out VECTOR );КК--
 A * R --> R ; ASSUME A > 0    procedure V_DIVК( A :VECTOR; R, Q :in out VECTOR );КК-- |R| / |A| --> Q REMAINDER |R|
 ASSUME A /= 0    procedure V_REMК( A :VECTOR; R :in out VECTOR );КК-- |R| / |A| --> ... REMAINDER |R| ; ASSUME A /=
 0    procedure V_GCDК( A,B :VECTOR; R :in out VECTOR );КК-- GCD(|A|,|B|) --> R    procedure V_LOWEST_TERMS( A,B :
 in out VECTOR );КК-- REDUCE |A|/|B| TO LOWEST TERMS, ASSUME B /= 0    function  V_EQUAL( A,B : VECTOR )К촵eturn B
OOLEAN;К-- TEST |A| = |B|, |A| < |B|    function  V_LESS( A,B : VECTOR )К촵eturn BOOLEAN;        --|--------------
---------------------------------------------------------------------------------  end UNIV_OPS;                 
--|------------------------------------------------------------------------------------------------떰  --КUARITH떰  --|
------------------------------------------------------------------------------------------------  package UARITH is   
       function  U_VALК( A :INTEGER )К촵eturn TREE;    function  U_VALUE( TXT :STRING )К촵eturn TREE;    function
  U_POSК( A : TREE )К촵eturn INTEGER;          function  U_EQUAL( LEFT, RIGHT: TREE )Кreturn TREE;    function  U
_NOT_EQUAL( LEFT, RIGHT: TREE )Кreturn TREE;    function  "<"К( LEFT, RIGHT: TREE )Кreturn TREE;    function  "<="
К( LEFT, RIGHT :TREE )Кreturn TREE;    function  ">"К( LEFT, RIGHT :TREE )Кreturn TREE;    function  ">="К( LEFT,
 RIGHT :TREE )Кreturn TREE;    function  U_MEMBER( VALUE, DISCRETE_RANGE :TREE )촵eturn TREE;              -- FOLLO
WING RETURN BOOLEAN (FOR COMPILER RANGE TESTS)    function  "<="К( LEFT, RIGHT :TREE )Кreturn BOOLEAN;    function  
">="К( LEFT, RIGHT :TREE )Кreturn BOOLEAN;    function  U_EQUAL( LEFT, RIGHT :TREE )Кreturn BOOLEAN;    function  
U_MEMBER( VALUE, DISCRETE_RANGE :TREE )촵eturn BOOLEAN;              -- FOLLOWING EXPECT 0 OR 1 AS ARGUMENT -- BOOLEA
N OPERATORS    function "AND"К( LEFT, RIGHT :TREE )Кreturn TREE;    function "OR"К( LEFT, RIGHT :TREE )Кreturn TRE
E;    function "XOR"К( LEFT, RIGHT :TREE )Кreturn TREE;    function "NOT"К( RIGHT :TREE )К촵eturn TREE;         
     -- UNARY FUNCTIONS    function "-"К( RIGHT :TREE )К촵eturn TREE;    function "ABS"К( RIGHT :TREE )К촵eturn TR
EE;              -- BINARY FUNCTIONS    function "+"К( LEFT, RIGHT :TREE ) 촵eturn TREE;    function "-"К( LEFT, 
RIGHT :TREE )Кreturn TREE;    function "*"К( LEFT, RIGHT :TREE )Кreturn TREE;К-- I*I, I*R, R*I, R*R    function "/
"К( LEFT, RIGHT :TREE )Кreturn TREE;К-- I/I, R/I, R/R    function "MOD"К( LEFT, RIGHT :TREE )Кreturn TREE;    fun
ction "REM"К( LEFT, RIGHT :TREE )Кreturn TREE;    function "**"К( LEFT, RIGHT :TREE )Кreturn TREE;К-- I**I, R**I 
       --|-----------------------------------------------------------------------------------------------  end UARITH;
                                --|-------------------------------------------------------------------------------
-----------------떰  --КFIX_WITH떰  --|--------------------------------------------------------------------------------
----------------  package FIX_WITH is          USED_PACKAGE_LIST: SEQ_TYPE;          procedure FIX_WITH_CLAUSES( 
COMPLTN_UNIT :TREE );    function  IS_ANCESTORК( UNIT_ID, SUBUNIT :TREE )촵eturn BOOLEAN;        --|----------------
--------------------------------------------------------------------------------  end FIX_WITH;                    
            --|------------------------------------------------------------------------------------------------떰  --
촂EF_UTIL떰  --|------------------------------------------------------------------------------------------------  packa
ge DEF_UTIL is          function  MAKE_DEF_FOR_IDК( ID :TREE; H :H_TYPE )Кreturn TREE;    procedure CHECK_UNIQUE_S
OURCE_NAME_S( SOURCE_NAME_S :TREE );    procedure CHECK_CONSTANT_ID_SК( SOURCE_NAME_S :TREE; H :H_TYPE );    functio
n  GET_DEF_FOR_IDК( ID :TREE )К촵eturn TREE;    function  GET_PRIOR_DEFК( DEF :TREE )К촵eturn TREE;    function 
 GET_PRIOR_HOMOGRAPH_DEFК( DEF :TREE )К촵eturn TREE;    function  GET_PRIOR_HOMOGRAPH_DEFК( DEF, PARAM_S :TREE;땝К
  RESULT_TYPE :TREE := TREE_VOID )촵eturn TREE;    function  GET_DEF_IN_REGIONК( ID :TREE; H :H_TYPE )Кreturn TREE;
    procedure CHECK_UNIQUE_DEFК( SOURCE_DEF :TREE);    procedure CHECK_CONSTANT_DEFК( SOURCE_DEF :TREE; H :H_TYPE );
    procedure CHECK_TYPE_DEFК( SOURCE_DEF :TREE; H :H_TYPE );    function  ARE_HOMOGRAPH_HEADERSК( HEADER_1, HEADER_
2 :TREE )Кreturn BOOLEAN;    function  IS_SAME_PARAMETER_PROFILEК( PARAM_S_1, PARAM_S_2 :TREE )촵eturn BOOLEAN;    p
rocedure CONFORM_PARAMETER_LISTSК( PARAM_S_1, PARAM_S_2 :TREE );    function  IS_COMPATIBLE_EXPRESSIONК( EXP_1, EXP_2
 :TREE )Кreturn BOOLEAN;    procedure MAKE_DEF_VISIBLEК( DEF :TREE; HEADER :TREE := TREE_VOID );    procedure MAKE_D
EF_IN_ERRORК( DEF :TREE );    procedure REMOVE_DEF_FROM_ENVIRONMENT( DEF :TREE );          function  GET_DEF_EXP_TY
PEК( DEF :TREE )К촵eturn TREE;    function  GET_BASE_TYPEК( TYPE_SPEC_OR_EXP_OR_ID :TREE )촵eturn TREE;    functio
n  GET_BASE_PACKAGEК( PACKAGE_ID :TREE )Кreturn TREE;        --|----------------------------------------------------
--------------------------------------------  end DEF_UTIL;                                --|-------------------
-----------------------------------------------------------------------------떰  --КSET_UTIL떰  --|--------------------
----------------------------------------------------------------------------  package SET_UTIL is          type DEFSE
T_TYPE촫s private;    type TYPESET_TYPE촫s private;    type DEFINTERP_TYPE촫s private;    type TYPEINTERP_TYPE촫s pri
vate;    type EXTRAINFO_TYPE촫s private;          EMPTY_DEFSETК: constant DEFSET_TYPE;    EMPTY_TYPESETК: constant
 TYPESET_TYPE;    NULL_EXTRAINFOК: constant EXTRAINFO_TYPE;떰땝К--  OPERATIONS SUR LES LISTES DE DEFINITIONS  --떰   
 function  IS_EMPTYК( DEFSET     :DEFSET_TYPE )Кreturn BOOLEAN;    procedure POPК( DEFSET     :in out DEFSET_TYPE;
КК  DEFINTERP  :out DEFINTERP_TYPE );    function  HEADК( DEFSET     :DEFSET_TYPE )Кreturn DEFINTERP_TYPE;    fun
ction  GET_THE_IDК( DEFSET     :DEFSET_TYPE )Кreturn TREE;    function  THE_ID_IS_NULLARY( DEFSET     :DEFSET_TYPE )
Кreturn BOOLEAN;    procedure ADD_TO_DEFSETК( DEFSET     :in out DEFSET_TYPE;땝К  DEF        :TREE;땝К  EXTRAINFO
  :EXTRAINFO_TYPE := NULL_EXTRAINFO;땝К  IS_NULLARY :BOOLEAN        := FALSE );떰    procedure ADD_TO_DEFSETК( DEFSET
     :in out DEFSET_TYPE;땝К  DEFINTERP  :DEFINTERP_TYPE );    function  INSERTК( DEFSET     :DEFSET_TYPE;땝К  DEF
INTERP :DEFINTERP_TYPE )К촵eturn DEFSET_TYPE;    function  GET_DEFК( DEFINTERP  :DEFINTERP_TYPE )Кreturn TREE;    f
unction  IS_NULLARYК( DEFINTERP  :DEFINTERP_TYPE )Кreturn BOOLEAN;    function  GET_EXTRAINFOК( DEFINTERP  :DEFINTER
P_TYPE )Кreturn EXTRAINFO_TYPE;    procedure ADD_EXTRAINFOК( DEFINTERP  :in out DEFINTERP_TYPE;  EXTRAINFO    :EXTRAI
NFO_TYPE );    procedure ADD_EXTRAINFOК( DEFINTERP  :in out DEFINTERP_TYPE;  EXTRAINFO_OF :TYPEINTERP_TYPE );    proc
edure ADD_EXTRAINFOК( EXTRAINFO  :in out EXTRAINFO_TYPE;  EXTRAINFO_IN :EXTRAINFO_TYPE );땝떰К--  OPERATIONS SUR LES 
LISTES DE TYPES  --떰    function  IS_EMPTYК( TYPESET    :TYPESET_TYPE )Кreturn BOOLEAN;    procedure POPК( TYPESET
    :in out TYPESET_TYPE;땝К  TYPEINTERP :out TYPEINTERP_TYPE);    function  HEADК( TYPESET    :TYPESET_TYPE )Кret
urn TYPEINTERP_TYPE;    function  GET_THE_TYPEК( TYPESET    :TYPESET_TYPE )Кreturn TREE;    procedure ADD_TO_TYPESET
К( TYPESET    :in out TYPESET_TYPE;땝К  TYPE_SPEC  :TREE;땝К  EXTRAINFO  :EXTRAINFO_TYPE := NULL_EXTRAINFO );떰    
procedure ADD_TO_TYPESETК( TYPESET    :in out TYPESET_TYPE;땝К  TYPEINTERP :TYPEINTERP_TYPE );    function  INSERTК
( TYPESET    :TYPESET_TYPE;땝К  TYPEINTERP :TYPEINTERP_TYPE )촵eturn TYPESET_TYPE;    function  GET_TYPEК( TYPEINTER
P :TYPEINTERP_TYPE ) 촵eturn TREE;    function  GET_EXTRAINFOК( TYPEINTERP :TYPEINTERP_TYPE )촵eturn EXTRAINFO_TYPE; 
   procedure ADD_EXTRAINFOК( TYPEINTERP :in out TYPEINTERP_TYPE; EXTRAINFO    :EXTRAINFO_TYPE );    procedure ADD_EXTR
AINFOК( TYPEINTERP :in out TYPEINTERP_TYPE; EXTRAINFO_OF :TYPEINTERP_TYPE );떰떰          procedure REQUIRE_UNIQUE_DEF
( EXP :TREE; DEFSET :in out DEFSET_TYPE );    procedure REQUIRE_UNIQUE_TYPE( EXP :TREE; TYPESET :in out TYPESET_TYPE 
);떰    procedure REDUCE_OPERATOR_DEFS( EXP :TREE; DEFSET :in out DEFSET_TYPE );떰    procedure STASH_DEFSET( EXP :TREE
; DEFSET :DEFSET_TYPE );    function  FETCH_DEFSET( EXP :TREE )К촵eturn DEFSET_TYPE;    procedure STASH_TYPESET( EX
P :TREE; TYPESET :TYPESET_TYPE );    function  FETCH_TYPESET( EXP :TREE )К촵eturn TYPESET_TYPE;떰떰떰  private      
    type DEFSET_TYPE촫s new SEQ_TYPE;    type TYPESET_TYPE촫s new SEQ_TYPE;    type DEFINTERP_TYPE촫s new TREE;    t
ype TYPEINTERP_TYPE촫s new TREE;    type EXTRAINFO_TYPE촫s new SEQ_TYPE;          EMPTY_DEFSET: constant DEFSET_TYPE
:= (TREE_NIL,TREE_NIL);    EMPTY_TYPESET: constant TYPESET_TYPE:= (TREE_NIL,TREE_NIL);    NULL_EXTRAINFO: constant
 EXTRAINFO_TYPE:= (TREE_NIL,TREE_NIL);        --|--------------------------------------------------------------------
------------------------------  end SET_UTIL;                                --|---------------------------------
---------------------------------------------------------------떰  --КREQ_UTIL떰  --|----------------------------------
--------------------------------------------------------------  package REQ_UTIL is           --|--------------------
--------------------------------------------------------------------------    --|촔EQ_GENE    --|---------------------
-------------------------------------------------------------------------    package REQ_GENE is      use SET_UTIL;  
             generic        with function IS_XXX ( ITEM :TREE ) return BOOLEAN;          MESSAGE :in STRING;        
procedure REQ_DEF_XXXК( EXP :TREE; DEFSET :in out DEFSET_TYPE );                 generic          with function IS_X
XX ( ITEM :TREE ) return BOOLEAN;          MESSAGE: in STRING;        procedure REQ_TYPE_XXX( EXP :TREE; TYPESET :in 
out TYPESET_TYPE );             --|-----------------------------------------------------------------------------------
-----    end REQ_GENE;    use SET_UTIL, REQ_GENE;          function  GET_BASE_STRUCTК( TYPE_SPEC :TREE )К촵eturn 
TREE;    function  GET_ANCESTOR_TYPEК( TYPE_SPEC :TREE )К촵eturn TREE;    procedure REQUIRE_SAME_TYPESК( EXP_1 :TRE
E; TYPESET_1 :TYPESET_TYPE;땝КК  EXP_2 :TREE; TYPESET_2 :TYPESET_TYPE;땝КК  TYPESET_OUT :out TYPESET_TYPE );    pro
cedure REQUIRE_TYPEК( TYPE_SPEC :TREE; EXP :TREE;땝КК  TYPESET :in out TYPESET_TYPE );    function  IS_NONLIMITED_T
YPEК( ITEM :TREE )К촵eturn BOOLEAN;    function  IS_LIMITED_TYPEК( ITEM :TREE )К촵eturn BOOLEAN;    function  IS_
PRIVATE_TYPEК( ITEM :TREE )К촵eturn BOOLEAN;    function  IS_INTEGER_TYPEК( ITEM :TREE )К촵eturn BOOLEAN;    fun
ction  IS_BOOLEAN_TYPEК( ITEM :TREE )К촵eturn BOOLEAN;    function  IS_REAL_TYPEК( ITEM :TREE )К촵eturn BOOLEAN;
    function  IS_SCALAR_TYPEК( ITEM :TREE )К촵eturn BOOLEAN;    function  IS_MEMBER_OF_UNSPECIFIEDК( SPEC_TYPE :TRE
E; UNSPEC_TYPE :TREE )촵eturn BOOLEAN;    function  IS_NONLIMITED_COMPOSITE_TYPE( TYPE_SPEC :TREE )К촵eturn BOOLEAN;
    function  IS_STRING_TYPEК( TYPE_SPEC :TREE )К촵eturn BOOLEAN;    function  IS_CHARACTER_TYPEК( TYPE_SPEC :TREE 
)К촵eturn BOOLEAN;    function  IS_UNIVERSAL_TYPEК( ITEM :TREE )К촵eturn BOOLEAN;    function  IS_NON_UNIVERSAL_TYP
EК( ITEM :TREE )К촵eturn BOOLEAN;    function  IS_DISCRETE_TYPEК( ITEM :TREE )К촵eturn BOOLEAN;    function  IS_TA
SK_TYPEК( ITEM :TREE )К촵eturn BOOLEAN;    procedure REQUIRE_IDК( ID_KIND :NODE_NAME; EXP :TREE;땝КК  DEFSET :in
 out DEFSET_TYPE );    function  IS_TYPE_DEFК( ITEM :TREE )К촵eturn BOOLEAN;    function  IS_ENTRY_DEFК( ITEM :TR
EE )К촵eturn BOOLEAN;    function  IS_PROC_OR_ENTRY_DEFК( ITEM :TREE )К촵eturn BOOLEAN;    function  IS_FUNCTION_OR
_ARRAY_DEFК( ITEM :TREE )К촵eturn BOOLEAN;    function  IS_FUNCTION_OR_ENUMERATION_DEF( ITEM :TREE )К촵eturn BOOLEA
N;          procedure REQUIRE_NONLIMITED_TYPEК( EXP :TREE; TYPESET :in out TYPESET_TYPE );    procedure REQUIRE_INTE
GER_TYPEК( EXP :TREE; TYPESET :in out TYPESET_TYPE );    procedure REQUIRE_BOOLEAN_TYPEК( EXP :TREE; TYPESET :in out 
TYPESET_TYPE );    procedure REQUIRE_REAL_TYPEК( EXP :TREE; TYPESET :in out TYPESET_TYPE );    procedure REQUIRE_SCAL
AR_TYPEК( EXP :TREE; TYPESET :in out TYPESET_TYPE );    procedure REQUIRE_UNIVERSAL_TYPEК( EXP :TREE; TYPESET :in out
 TYPESET_TYPE );    procedure REQUIRE_NON_UNIVERSAL_TYPE( EXP :TREE; TYPESET :in out TYPESET_TYPE );    procedure REQ
UIRE_DISCRETE_TYPEК( EXP :TREE; TYPESET :in out TYPESET_TYPE );    procedure REQUIRE_TASK_TYPEК( EXP :TREE; TYPESET :
in out TYPESET_TYPE );    procedure REQUIRE_TYPE_DEFК( EXP :TREE; DEFSET :in out DEFSET_TYPE );    procedure REQUIRE_
ENTRY_DEFК( EXP :TREE; DEFSET :in out DEFSET_TYPE );    procedure REQUIRE_PROC_OR_ENTRY_DEFК( EXP :TREE; DEFSET :in o
ut DEFSET_TYPE );    procedure REQUIRE_FUNCTION_OR_ARRAY_DEF( EXP :TREE; DEFSET :in out DEFSET_TYPE );    procedure R
EQUIRE_FUNCTION_OR_ENUMERATION_DEF( EXP :TREE; DEFSET :in out DEFSET_TYPE );        --|------------------------------
-------------------------------------------------------------  end REQ_UTIL;  use REQ_UTIL, REQ_UTIL.REQ_GENE;      
                  떰  --|---------------------------------------------------------------------------------------------
---떰  --КAGGRESO떰  --|-----------------------------------------------------------------------------------------------
-  package AGGRESO is    use SET_UTIL, DEF_UTIL, REQ_UTIL;          type AGGREGATE_ITEM_TYPEКis private;         
 type AGGREGATE_ARRAY_TYPEКis array (POSITIVE range <>) of AGGREGATE_ITEM_TYPE;          function  COUNT_AGGREGATE_CH
OICES( ASSOC_S :TREE )ККreturn NATURAL;    procedure SPREAD_ASSOC_SК( ASSOC_S :TREE; AGGREGATE_ARRAY :in out AGGREG
ATE_ARRAY_TYPE );    procedure WALK_RECORD_DECL_S( EXP :TREE; DECL_S :TREE; AGGREGATE_ARRAY :in out AGGREGATE_ARRAY_TY
PE;          К  NORMALIZED_LIST :in out SEQ_TYPE; LAST_POSITIONAL :in out NATURAL );    procedure RESOLVE_RECORD_ASS
OC_S( ASSOC_S :TREE; AGGREGATE_ARRAY :in out AGGREGATE_ARRAY_TYPE );    function  RESOLVE_EXP_OR_AGGREGATE( EXP :TREE
; SUBTYPE_SPEC :TREE; NAMED_OTHERS_OK :BOOLEAN )Кreturn TREE;    procedure RESOLVE_AGGREGATE( EXP :TREE; TYPE_SPEC :T
REE );    procedure RESOLVE_STRINGК( EXP :TREE; TYPE_SPEC :TREE );        --|- - - - - - - - - - - - - - - - - - - -
 - - - - - - - - - - - - - - - - - - - - - - - - - - - -떰떰떰  private          type AGGREGATE_ITEM_TYPEКis record땝
К  FIRSTК: POSITIVE;К--| POSITION OF FIRST CHOICE IN CHOICE_S땝К  CHOICEК: TREE;КК--| FROM CHOICE_EXP땝К  ID
К: TREE;КК--| DSCRMT OR COMPONENT ID땝К  ASSOCК: TREE;КК--| ONLY FOR FIRST CHOICE땝К  EXPК: TREE;КК--| ONLY
 FOR FIRST CHOICE땝К  TYPESETК: TYPESET_TYPE;К--| ONLY FOR FIRST CHOICE땝К  SEENК: BOOLEAN;К--| USED TO MARK W
HEN FORMAL SEEN FOR CHOICE땝К  RESOLVED: BOOLEAN;К--| USED TO MARK WHEN EXP RESOLVED FOR ASSOC땝К촦nd record;    
    --|-----------------------------------------------------------------------------------------------  end AGGRESO; 
                               --|---------------------------------------------------------------------------------
---------------떰  --КEXPRESO떰  --|-----------------------------------------------------------------------------------
-------------  package EXPRESO is    use SET_UTIL;          function  GET_NAME_DEFNК( NAME :TREE )К촵eturn TREE;
    function  GET_STATIC_VALUEК( EXP  :TREE )К촵eturn TREE;    function  RESOLVE_EXPК( EXP  :TREE; TYPE_SPEC :TREE 
)촵eturn TREE;    function  RESOLVE_DISCRETE_RANGEК( EXP  :TREE; TYPE_SPEC :TREE )촵eturn TREE;    function  RESOLVE_
TYPE_MARKК( EXP  :TREE)К촵eturn TREE;    procedure RESOLVE_SUBTYPE_INDICATION( EXP  :in out TREE;땝КК  SUBTYPE_SPE
C :out TREE );    function  RESOLVE_EXPК( EXP  :TREE; TYPESET :TYPESET_TYPE )촵eturn TREE;    function  RESOLVE_NAME
К( NAME :TREE; DEFN :TREE )Кreturn TREE;    function  WALK_ERRONEOUS_EXPК( EXP  :TREE )К촵eturn TREE;         --
|------------------------------------------------------------------------------------------------  end EXPRESO;      
           --|------------------------------------------------------------------------------------------------떰  --
КVIS_UTIL떰  --|------------------------------------------------------------------------------------------------  pack
age VIS_UTIL is    use SET_UTIL;          type PARAM_CURSOR_TYPE촫s record땝К  PARAM_LIST: SEQ_TYPE;땝К  PARAMК: 
TREE;땝К  ID_LISTК: SEQ_TYPE;땝К  IDК: TREE;땝Кend record;떰    procedure INIT_PARAM_CURSORК( CURSOR     :out PARA
M_CURSOR_TYPE;땝КК  PARAM_LIST :SEQ_TYPE );    procedure ADVANCE_PARAM_CURSORК( CURSOR     :in out PARAM_CURSOR_TYPE
 );              --- $$$$ TEMPORARY $$$$$$$$$$$$$$    function IS_OVERLOADABLE_HEADERК( HEADER :TREE )К촵eturn BOOL
EAN;        -- $$$$$          procedure FIND_VISIBILITYК( EXP :TREE; DEFSET :out DEFSET_TYPE );    procedure FIND_
DIRECT_VISIBILITYК( ID  :TREE; DEFSET :out DEFSET_TYPE );    procedure FIND_SELECTED_VISIBILITYК( SELECTED :TREE;땝К
К  DEFSET :out DEFSET_TYPE );          function  GET_ENCLOSING_DEFК( USED_NAME :TREE; DEFSET :DEFSET_TYPE )return TR
EE;    function  MAKE_USED_NAME_ID_FROM_OBJECT( USED_OBJECT_ID :TREE )Кreturn TREE;    function  MAKE_USED_OP_FROM_S
TRINGК( STRING_NODE :TREE )Кreturn TREE;    function  EXPRESSION_TYPE_OF_DEFК( DEF :TREE )К촵eturn TREE;    functi
on  ALL_PARAMETERS_HAVE_DEFAULTS( HEADER :TREE )К촵eturn BOOLEAN;    function  CAST_TREEК( ARG  :SEQ_TYPE )К촵etur
n TREE;    function  CAST_SEQ_TYPEК( ARG  :TREE )К촵eturn SEQ_TYPE;    function  COPY_NODEК( T : TREE )К촵eturn 
TREE;        --|--------------------------------------------------------------------------------------------------  e
nd VIS_UTIL;떰떰떰  --|------------------------------------------------------------------------------------------------
  --КDEF_WALK떰  --|------------------------------------------------------------------------------------------------ 
 package DEF_WALK is          function  EVAL_TYPE_DEFК( TYPE_DEF :TREE; ID :TREE; H :H_TYPE;땝КК  DSCRMT_DECL_S :T
REE := TREE_VOID )촵eturn TREE;    function  GET_SUBTYPE_OF_DISCRETE_RANGE( DISCRETE_RANGE :TREE )Кreturn TREE;     
   --|------------------------------------------------------------------------------------------------  end DEF_WALK;
                 --|-----------------------------------------------------------------------------------------------
-떰  --КNOD_WALK떰  --|------------------------------------------------------------------------------------------------
  package NOD_WALK is          type S_TYPE촫s record땝  SBК: SB_TYPE;땝  SUК: SU_TYPE;땝촦nd record;          p
rocedure WALKК( NODE :TREE; H :H_TYPE );    procedure FINISH_PARAM_SК( DECL_S :TREE; H :H_TYPE );    function  WALK
_NAMEК( ID_KIND :NODE_NAME; NAME :TREE )Кreturn TREE;    function  WALK_TYPE_MARKК( NAME :TREE )ККreturn TREE;   
 procedure WALK_DISCRETE_CHOICE_S( CHOICE_S :TREE; TYPE_SPEC :TREE );    procedure ENTER_REGIONК( DEF :TREE; H :in ou
t H_TYPE; S :out S_TYPE );    procedure LEAVE_REGIONК( DEF :TREE; S :S_TYPE );    procedure ENTER_BODYК( DEF :TREE; 
H :in out H_TYPE; S :out S_TYPE );    procedure LEAVE_BODYК( DEF :TREE; S :S_TYPE );    procedure WALK_ITEM_SК( ITEM
_S :TREE; H :H_TYPE );    procedure WALK_SOURCE_NAME_S( SOURCE_NAME_S :TREE; H :H_TYPE );        --|----------------
--------------------------------------------------------------------------------  end NOD_WALK;                 -
-|------------------------------------------------------------------------------------------------떰  --КATT_WALK떰  --
|------------------------------------------------------------------------------------------------  package ATT_WALK is
    use SET_UTIL;          procedure EVAL_ATTRIBUTEК( EXP :TREE; TYPESET :out TYPESET_TYPE;땝К  IS_SUBTYPE :out BOO
LEAN; IS_FUNCTION : BOOLEAN := FALSE );    function  RESOLVE_ATTRIBUTE( EXP :TREE )Кreturn TREE;    function  EVAL_A
TTRIBUTE_IDENTIFIER( ATTRIBUTE_NODE :TREE )촵eturn TREE;              --PROCEDURE WALK_ATTRIBUTE_FUNCTION(EXP: TREE);
        --|------------------------------------------------------------------------------------------------  end ATT_
WALK;                 --|-----------------------------------------------------------------------------------------
-------떰  --КSTM_WALK떰  --|------------------------------------------------------------------------------------------
------  package STM_WALK is          procedure DECLARE_LABEL_BLOCK_LOOP_IDS( STM_S :TREE; H :H_TYPE );    procedure
 WALK_STM_SК( STM_S :TREE; H :H_TYPE );    procedure WALK_ALTERNATIVE_SК( ALTERNATIVE_S :TREE; H :H_TYPE );    func
tion  WALK_STMК( STM_IN :TREE; H :H_TYPE )촵eturn TREE;        --|--------------------------------------------------
----------------------------------------------  end STM_WALK;떰떰     --|--------------------------------------------
----------------------------------------------------떰  --КPRA_WALK떰  --|---------------------------------------------
---------------------------------------------------  package PRA_WALK is           procedure WALK_PRAGMA( USED_NAME_
ID :TREE; GEN_ASSOC_S :TREE; H :H_TYPE );            --|--------------------------------------------------------------
----------------------------------  end PRA_WALK;떰떰떰  --|-----------------------------------------------------------
-------------------------------------떰  --КCHK_STAT떰  --|------------------------------------------------------------
------------------------------------  package CHK_STAT is          function  IS_STATIC_RANGEК( A :TREE )Кreturn BO
OLEAN;    function  IS_STATIC_SUBTYPEК( A :TREE )Кreturn BOOLEAN;    function  IS_STATIC_DISCRETE_RANGEК( A :TREE )
Кreturn BOOLEAN;    function  IS_STATIC_INDEX_CONSTRAINT( ARRAY_TYPE, INDEX_CONSTRAINT :TREE )촵eturn BOOLEAN;      
  -- FUNCTION IS_STATIC_DISCRIMINANT_CONSTRAINT ... (NOT USED)          --|-------------------------------------------
-----------------------------------------------------  end CHK_STAT;떰떰떰  --|----------------------------------------
--------------------------------------------------------떰  --КDERIVED떰  --|------------------------------------------
------------------------------------------------------  package DERIVED is           function  MAKE_DERIVED_SUBPROGRA
M_LIST( DERIVED_SUBTYPE :TREE; PARENT_SUBTYPE :TREE;땝КК  H :H_TYPE )Кreturn SEQ_TYPE;    procedure REMEMBER_DERIVE
D_DECLК( DECL :TREE );        -- (CALLED FROM FIXWITH -- REMEMBERS DERIVED DECL WITH DERIVED SUBP)        --|-------
-----------------------------------------------------------------------------------------  end DERIVED;            
     --|------------------------------------------------------------------------------------------------떰  --КEXP_TY
PE떰  --|------------------------------------------------------------------------------------------------  package EXP_
TYPE is    use SET_UTIL;          procedure EVAL_EXP_TYPESК( EXP :TREE; TYPESET :out TYPESET_TYPE );    procedure 
EVAL_EXP_SUBTYPE_TYPESК( EXP :TREE; TYPESET :out TYPESET_TYPE;땝КК  IS_SUBTYPE_OUT :out BOOLEAN );    function  EVAL
_TYPE_MARKК( EXP :TREE )Кreturn TREE;    function  EVAL_SUBTYPE_INDICATIONК( EXP :TREE )Кreturn TREE;    procedur
e EVAL_RANGEК( EXP :TREE; TYPESET :out TYPESET_TYPE );    procedure EVAL_DISCRETE_RANGEК( EXP :TREE; TYPESET :out TY
PESET_TYPE );    procedure EVAL_NON_UNIVERSAL_DISCRETE_RANGE( EXP :TREE; TYPESET :out TYPESET_TYPE );        --|----
--------------------------------------------------------------------------------------------  end EXP_TYPE;떰떰떰  --|-
-----------------------------------------------------------------------------------------------떰  --КHOM_UNIT떰  --|--
----------------------------------------------------------------------------------------------  package HOM_UNIT is   
       function WALK_HOMOGRAPH_UNIT( UNIT_NAME :TREE; HEADER :TREE )촵eturn TREE;        --|------------------------
-------------------------------------------------------------------  end HOM_UNIT;떰떰떰  --|--------------------------
----------------------------------------------------------------------떰  --КINSTANT떰  --|----------------------------
--------------------------------------------------------------------  package INSTANT is          procedure WALK_INST
ANTIATION( UNIT_ID :TREE; INSTANTIATION :TREE; H :H_TYPE );            --|-------------------------------------------
-----------------------------------------------------  end INSTANT;떰떰떰  --|-----------------------------------------
-------------------------------------------------------떰  --КMAKE_NOD떰  --|------------------------------------------
------------------------------------------------------  package MAKE_NOD is                function MAKE_VARIABLE_ID
                ( LX_SRCPOS: TREE := TREE_VOID;                LX_SYMREP: TREE := TREE_VOID;                SM_OBJ_TYP
E: TREE := TREE_VOID;                SM_INIT_EXP: TREE := TREE_VOID;                SM_RENAMES_OBJ: BOOLEAN := FALSE;
                SM_ADDRESS: TREE := TREE_VOID;                SM_IS_SHARED: BOOLEAN := FALSE;                XD_REGION
: TREE := TREE_VOID)                return TREE;                function MAKE_CONSTANT_ID                ( LX_SRCPOS
: TREE := TREE_VOID;                LX_SYMREP: TREE := TREE_VOID;                SM_OBJ_TYPE: TREE := TREE_VOID;     
           SM_INIT_EXP: TREE := TREE_VOID;                SM_RENAMES_OBJ: BOOLEAN := FALSE;                SM_ADDRESS:
 TREE := TREE_VOID;                SM_FIRST: TREE := TREE_VOID;                XD_REGION: TREE := TREE_VOID)         
       return TREE;                function MAKE_NUMBER_ID                ( LX_SRCPOS: TREE := TREE_VOID;           
     LX_SYMREP: TREE := TREE_VOID;                SM_OBJ_TYPE: TREE := TREE_VOID;                SM_INIT_EXP: TREE := 
TREE_VOID;                XD_REGION: TREE := TREE_VOID)                return TREE;                function MAKE_COM
PONENT_ID                ( LX_SRCPOS: TREE := TREE_VOID;                LX_SYMREP: TREE := TREE_VOID;                
SM_OBJ_TYPE: TREE := TREE_VOID;                SM_INIT_EXP: TREE := TREE_VOID;                SM_COMP_REP: TREE := TRE
E_VOID;                XD_REGION: TREE := TREE_VOID)                return TREE;                function MAKE_DISCRI
MINANT_ID                ( LX_SRCPOS: TREE := TREE_VOID;                LX_SYMREP: TREE := TREE_VOID;                
SM_OBJ_TYPE: TREE := TREE_VOID;                SM_INIT_EXP: TREE := TREE_VOID;                SM_COMP_REP: TREE := TRE
E_VOID;                SM_FIRST: TREE := TREE_VOID;                XD_REGION: TREE := TREE_VOID)                retur
n TREE;                function MAKE_IN_ID                ( LX_SRCPOS: TREE := TREE_VOID;                LX_SYMREP: 
TREE := TREE_VOID;                SM_OBJ_TYPE: TREE := TREE_VOID;                SM_INIT_EXP: TREE := TREE_VOID;     
           SM_FIRST: TREE := TREE_VOID;                XD_REGION: TREE := TREE_VOID)                return TREE;     
           function MAKE_IN_OUT_ID                ( LX_SRCPOS: TREE := TREE_VOID;                LX_SYMREP: TREE := T
REE_VOID;                SM_OBJ_TYPE: TREE := TREE_VOID;                SM_INIT_EXP: TREE := TREE_VOID;              
  SM_FIRST: TREE := TREE_VOID;                XD_REGION: TREE := TREE_VOID)                return TREE;             
   function MAKE_OUT_ID                ( LX_SRCPOS: TREE := TREE_VOID;                LX_SYMREP: TREE := TREE_VOID;  
              SM_OBJ_TYPE: TREE := TREE_VOID;                SM_INIT_EXP: TREE := TREE_VOID;                SM_FIRST: 
TREE := TREE_VOID;                XD_REGION: TREE := TREE_VOID)                return TREE;                function 
MAKE_ENUMERATION_ID                ( LX_SRCPOS: TREE := TREE_VOID;                LX_SYMREP: TREE := TREE_VOID;      
          SM_OBJ_TYPE: TREE := TREE_VOID;                SM_POS: INTEGER := 0;                SM_REP: INTEGER := 0;  
              XD_REGION: TREE := TREE_VOID)                return TREE;                function MAKE_CHARACTER_ID   
             ( LX_SRCPOS: TREE := TREE_VOID;                LX_SYMREP: TREE := TREE_VOID;                SM_OBJ_TYPE: 
TREE := TREE_VOID;                SM_POS: INTEGER := 0;                SM_REP: INTEGER := 0;                XD_REGION
: TREE := TREE_VOID)                return TREE;                function MAKE_ITERATION_ID                ( LX_SRCPO
S: TREE := TREE_VOID;                LX_SYMREP: TREE := TREE_VOID;                SM_OBJ_TYPE: TREE := TREE_VOID;    
            XD_REGION: TREE := TREE_VOID)                return TREE;                function MAKE_TYPE_ID          
      ( LX_SRCPOS: TREE := TREE_VOID;                LX_SYMREP: TREE := TREE_VOID;                SM_TYPE_SPEC: TREE :
= TREE_VOID;                SM_FIRST: TREE := TREE_VOID;                XD_REGION: TREE := TREE_VOID)                
return TREE;                function MAKE_SUBTYPE_ID                ( LX_SRCPOS: TREE := TREE_VOID;                L
X_SYMREP: TREE := TREE_VOID;                SM_TYPE_SPEC: TREE := TREE_VOID;                XD_REGION: TREE := TREE_VO
ID)                return TREE;                function MAKE_PRIVATE_TYPE_ID                ( LX_SRCPOS: TREE := TRE
E_VOID;                LX_SYMREP: TREE := TREE_VOID;                SM_TYPE_SPEC: TREE := TREE_VOID;                X
D_REGION: TREE := TREE_VOID)                return TREE;                function MAKE_L_PRIVATE_TYPE_ID             
   ( LX_SRCPOS: TREE := TREE_VOID;                LX_SYMREP: TREE := TREE_VOID;                SM_TYPE_SPEC: TREE := T
REE_VOID;                XD_REGION: TREE := TREE_VOID)                return TREE;                function MAKE_PROC
EDURE_ID                ( LX_SRCPOS: TREE := TREE_VOID;                LX_SYMREP: TREE := TREE_VOID;                S
M_FIRST: TREE := TREE_VOID;                SM_SPEC: TREE := TREE_VOID;                SM_UNIT_DESC: TREE := TREE_VOID;
                SM_ADDRESS: TREE := TREE_VOID;                SM_IS_INLINE: BOOLEAN := FALSE;                SM_INTER
FACE: TREE := TREE_VOID;                XD_REGION: TREE := TREE_VOID;                XD_STUB: TREE := TREE_VOID;     
           XD_BODY: TREE := TREE_VOID)                return TREE;                function MAKE_FUNCTION_ID         
       ( LX_SRCPOS: TREE := TREE_VOID;                LX_SYMREP: TREE := TREE_VOID;                SM_FIRST: TREE := T
REE_VOID;                SM_SPEC: TREE := TREE_VOID;                SM_UNIT_DESC: TREE := TREE_VOID;                S
M_ADDRESS: TREE := TREE_VOID;                SM_IS_INLINE: BOOLEAN := FALSE;                SM_INTERFACE: TREE := TREE
_VOID;                XD_REGION: TREE := TREE_VOID;                XD_STUB: TREE := TREE_VOID;                XD_BODY
: TREE := TREE_VOID)                return TREE;                function MAKE_OPERATOR_ID                ( LX_SRCPOS
: TREE := TREE_VOID;                LX_SYMREP: TREE := TREE_VOID;                SM_FIRST: TREE := TREE_VOID;        
        SM_SPEC: TREE := TREE_VOID;                SM_UNIT_DESC: TREE := TREE_VOID;                SM_ADDRESS: TREE :=
 TREE_VOID;                SM_IS_INLINE: BOOLEAN := FALSE;                SM_INTERFACE: TREE := TREE_VOID;           
     XD_REGION: TREE := TREE_VOID;                XD_STUB: TREE := TREE_VOID;                XD_BODY: TREE := TREE_VOI
D;                XD_NOT_EQUAL: TREE := TREE_VOID)                return TREE;                function MAKE_PACKAGE_
ID                ( LX_SRCPOS: TREE := TREE_VOID;                LX_SYMREP: TREE := TREE_VOID;                SM_FIRS
T: TREE := TREE_VOID;                SM_SPEC: TREE := TREE_VOID;                SM_UNIT_DESC: TREE := TREE_VOID;     
           SM_ADDRESS: TREE := TREE_VOID;                XD_REGION: TREE := TREE_VOID;                XD_STUB: TREE :=
 TREE_VOID;                XD_BODY: TREE := TREE_VOID)                return TREE;                function MAKE_GENE
RIC_ID                ( LX_SRCPOS: TREE := TREE_VOID;                LX_SYMREP: TREE := TREE_VOID;                SM_
FIRST: TREE := TREE_VOID;                SM_SPEC: TREE := TREE_VOID;                SM_GENERIC_PARAM_S: TREE := TREE_V
OID;                SM_BODY: TREE := TREE_VOID;                SM_IS_INLINE: BOOLEAN := FALSE;                XD_REGI
ON: TREE := TREE_VOID)                return TREE;                function MAKE_TASK_BODY_ID                ( LX_SRC
POS: TREE := TREE_VOID;                LX_SYMREP: TREE := TREE_VOID;                SM_FIRST: TREE := TREE_VOID;     
           SM_TYPE_SPEC: TREE := TREE_VOID;                SM_BODY: TREE := TREE_VOID;                XD_REGION: TREE 
:= TREE_VOID)                return TREE;                function MAKE_LABEL_ID                ( LX_SRCPOS: TREE := 
TREE_VOID;                LX_SYMREP: TREE := TREE_VOID;                SM_STM: TREE := TREE_VOID;                XD_R
EGION: TREE := TREE_VOID)                return TREE;                function MAKE_BLOCK_LOOP_ID                ( LX
_SRCPOS: TREE := TREE_VOID;                LX_SYMREP: TREE := TREE_VOID;                SM_STM: TREE := TREE_VOID;   
             XD_REGION: TREE := TREE_VOID)                return TREE;                function MAKE_ENTRY_ID        
        ( LX_SRCPOS: TREE := TREE_VOID;                LX_SYMREP: TREE := TREE_VOID;                SM_SPEC: TREE := T
REE_VOID;                SM_ADDRESS: TREE := TREE_VOID;                XD_REGION: TREE := TREE_VOID)                r
eturn TREE;                function MAKE_EXCEPTION_ID( LX_SRCPOS, LX_SYMREP, SM_RENAMES_EXC, XD_REGION: TREE := TREE_
VOID )촵eturn TREE;          function MAKE_ATTRIBUTE_ID( LX_SRCPOS, LX_SYMREP: TREE := TREE_VOID; XD_POS: INTEGER )촵e
turn TREE;          function MAKE_PRAGMA_ID( LX_SRCPOS, LX_SYMREP, SM_ARGUMENT_ID_S :TREE := TREE_VOID; XD_POS :INTEGE
R )촵eturn TREE;          function MAKE_ARGUMENT_ID( LX_SRCPOS, LX_SYMREP :TREE := TREE_VOID; XD_POS :INTEGER )촵eturn
 TREE;          function MAKE_BLTN_OPERATOR_ID( LX_SRCPOS, LX_SYMREP: TREE := TREE_VOID; SM_OPERATOR: INTEGER )촵eturn 
TREE;                function MAKE_BLOCK_MASTER                ( LX_SRCPOS: TREE := TREE_VOID;                SM_STM
: TREE := TREE_VOID)                return TREE;                function MAKE_DSCRMT_DECL                ( AS_SOURCE
_NAME_S: TREE := TREE_VOID;                AS_NAME: TREE := TREE_VOID;                AS_EXP: TREE := TREE_VOID;     
           LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function MAKE_IN                
( AS_SOURCE_NAME_S: TREE := TREE_VOID;                AS_NAME: TREE := TREE_VOID;                AS_EXP: TREE := TREE_
VOID;                LX_SRCPOS: TREE := TREE_VOID;                LX_DEFAULT: BOOLEAN := FALSE)                return
 TREE;                function MAKE_OUT                ( AS_SOURCE_NAME_S: TREE := TREE_VOID;                AS_NAME
: TREE := TREE_VOID;                AS_EXP: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID)          
      return TREE;                function MAKE_IN_OUT                ( AS_SOURCE_NAME_S: TREE := TREE_VOID;        
        AS_NAME: TREE := TREE_VOID;                AS_EXP: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_V
OID)                return TREE;                function MAKE_CONSTANT_DECL                ( AS_SOURCE_NAME_S: TREE 
:= TREE_VOID;                AS_EXP: TREE := TREE_VOID;                AS_TYPE_DEF: TREE := TREE_VOID;               
 LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function MAKE_VARIABLE_DECL               
 ( AS_SOURCE_NAME_S: TREE := TREE_VOID;                AS_EXP: TREE := TREE_VOID;                AS_TYPE_DEF: TREE := 
TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function MAKE_NUM
BER_DECL                ( AS_SOURCE_NAME_S: TREE := TREE_VOID;                AS_EXP: TREE := TREE_VOID;             
   LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function MAKE_EXCEPTION_DECL            
    ( AS_SOURCE_NAME_S: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID)                return TREE;  
              function MAKE_DEFERRED_CONSTANT_DECL                ( AS_SOURCE_NAME_S: TREE := TREE_VOID;             
   AS_NAME: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID)                return TREE;             
   function MAKE_TYPE_DECL                ( AS_SOURCE_NAME: TREE := TREE_VOID;                AS_DSCRMT_DECL_S: TREE :
= TREE_VOID;                AS_TYPE_DEF: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID)             
   return TREE;                function MAKE_SUBTYPE_DECL                ( AS_SOURCE_NAME: TREE := TREE_VOID;       
         AS_SUBTYPE_INDICATION: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID)                return 
TREE;                function MAKE_TASK_DECL                ( AS_SOURCE_NAME: TREE := TREE_VOID;                AS_D
ECL_S: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID)                return TREE;                fu
nction MAKE_GENERIC_DECL                ( AS_SOURCE_NAME: TREE := TREE_VOID;                AS_HEADER: TREE := TREE_VO
ID;                AS_ITEM_S: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID)                return T
REE;                function MAKE_SUBPROG_ENTRY_DECL                ( AS_SOURCE_NAME: TREE := TREE_VOID;            
    AS_HEADER: TREE := TREE_VOID;                AS_UNIT_KIND: TREE := TREE_VOID;                LX_SRCPOS: TREE := TR
EE_VOID)                return TREE;                function MAKE_PACKAGE_DECL                ( AS_SOURCE_NAME: TREE
 := TREE_VOID;                AS_HEADER: TREE := TREE_VOID;                AS_UNIT_KIND: TREE := TREE_VOID;          
      LX_SRCPOS: TREE := TREE_VOID )                return TREE;                function MAKE_RENAMES_OBJ_DECL      
          ( AS_SOURCE_NAME: TREE := TREE_VOID;                AS_NAME: TREE := TREE_VOID;                AS_TYPE_MARK_
NAME: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID)                return TREE;                fun
ction MAKE_RENAMES_EXC_DECL                ( AS_SOURCE_NAME: TREE := TREE_VOID;                AS_NAME: TREE := TREE_V
OID;                LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function MAKE_NULL_COMP
_DECL                ( LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function MAKE_LENGTH
_ENUM_REP                ( AS_NAME: TREE := TREE_VOID;                AS_EXP: TREE := TREE_VOID;                LX_SR
CPOS: TREE := TREE_VOID)                return TREE;                function MAKE_ADDRESS                ( AS_NAME: 
TREE := TREE_VOID;                AS_EXP: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID)            
    return TREE;                function MAKE_RECORD_REP                ( AS_NAME: TREE := TREE_VOID;               
 AS_ALIGNMENT_CLAUSE: TREE := TREE_VOID;                AS_COMP_REP_S: TREE := TREE_VOID;                LX_SRCPOS: TR
EE := TREE_VOID)                return TREE;                function MAKE_USE                ( AS_NAME_S: TREE := TR
EE_VOID;                LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function MAKE_PRAGM
A                ( AS_USED_NAME_ID: TREE := TREE_VOID;                AS_GENERAL_ASSOC_S: TREE := TREE_VOID;         
       LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function MAKE_SUBPROGRAM_BODY       
         ( AS_SOURCE_NAME: TREE := TREE_VOID;                AS_BODY: TREE := TREE_VOID;                AS_HEADER: TRE
E := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function MAK
E_PACKAGE_BODY                ( AS_SOURCE_NAME: TREE := TREE_VOID;                AS_BODY: TREE := TREE_VOID;        
        LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function MAKE_TASK_BODY            
    ( AS_SOURCE_NAME: TREE := TREE_VOID;                AS_BODY: TREE := TREE_VOID;                LX_SRCPOS: TREE := 
TREE_VOID)                return TREE;                function MAKE_SUBUNIT                ( AS_NAME: TREE := TREE_V
OID;                AS_SUBUNIT_BODY: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID)                r
eturn TREE;                function MAKE_ENUMERATION_DEF                ( AS_ENUM_LITERAL_S: TREE := TREE_VOID;     
           LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function MAKE_SUBTYPE_INDICATION
                ( AS_CONSTRAINT: TREE := TREE_VOID;                AS_NAME: TREE := TREE_VOID;                LX_SRCPO
S: TREE := TREE_VOID)                return TREE;                function MAKE_INTEGER_DEF                ( AS_CONST
RAINT: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID)                return TREE;                fu
nction MAKE_FLOAT_DEF                ( AS_CONSTRAINT: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID)
                return TREE;                function MAKE_FIXED_DEF                ( AS_CONSTRAINT: TREE := TREE_VOID
;                LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function MAKE_CONSTRAINED_
ARRAY_DEF                ( AS_SUBTYPE_INDICATION: TREE := TREE_VOID;                AS_CONSTRAINT: TREE := TREE_VOID;
                LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function MAKE_UNCONSTRAINED_
ARRAY_DEF                ( AS_SUBTYPE_INDICATION: TREE := TREE_VOID;                AS_INDEX_S: TREE := TREE_VOID;   
             LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function MAKE_ACCESS_DEF      
          ( AS_SUBTYPE_INDICATION: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID)                retu
rn TREE;                function MAKE_DERIVED_DEF                ( AS_SUBTYPE_INDICATION: TREE := TREE_VOID;        
        LX_SRCPOS: TREE := TREE_VOID;                LIST: SEQ_TYPE := (TREE_NIL,TREE_NIL) )                return TRE
E;                function MAKE_RECORD_DEF                ( AS_COMP_LIST: TREE := TREE_VOID;                LX_SRCPO
S: TREE := TREE_VOID)                return TREE;                function MAKE_PRIVATE_DEF                ( LX_SRCPO
S: TREE := TREE_VOID)                return TREE;                function MAKE_L_PRIVATE_DEF                ( LX_SRC
POS: TREE := TREE_VOID)                return TREE;                function MAKE_FORMAL_DSCRT_DEF                ( L
X_SRCPOS: TREE := TREE_VOID)                return TREE;                function MAKE_FORMAL_INTEGER_DEF            
    ( LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function MAKE_FORMAL_FIXED_DEF       
         ( LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function MAKE_FORMAL_FLOAT_DEF  
              ( LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function MAKE_ALTERNATIVE_S
                ( LIST: SEQ_TYPE := (TREE_NIL,TREE_NIL);                LX_SRCPOS: TREE := TREE_VOID)                r
eturn TREE;                function MAKE_ARGUMENT_ID_S                ( LIST: SEQ_TYPE := (TREE_NIL,TREE_NIL);      
          LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function MAKE_CHOICE_S           
     ( LIST: SEQ_TYPE := (TREE_NIL,TREE_NIL);                LX_SRCPOS: TREE := TREE_VOID)                return TREE;
                function MAKE_COMP_REP_S                ( LIST: SEQ_TYPE := (TREE_NIL,TREE_NIL);                LX_S
RCPOS: TREE := TREE_VOID)                return TREE;                function MAKE_COMPLTN_UNIT_S                ( L
IST: SEQ_TYPE := (TREE_NIL,TREE_NIL);                LX_SRCPOS: TREE := TREE_VOID)                return TREE;      
          function MAKE_CONTEXT_ELEM_S                ( LIST: SEQ_TYPE := (TREE_NIL,TREE_NIL);                LX_SRCPO
S: TREE := TREE_VOID)                return TREE;                function MAKE_DECL_S                ( LIST: SEQ_TYP
E := (TREE_NIL,TREE_NIL);                LX_SRCPOS: TREE := TREE_VOID)                return TREE;                fu
nction MAKE_DSCRMT_DECL_S                ( LIST: SEQ_TYPE := (TREE_NIL,TREE_NIL);                LX_SRCPOS: TREE := TR
EE_VOID)                return TREE;                function MAKE_GENERAL_ASSOC_S                ( LIST: SEQ_TYPE :=
 (TREE_NIL,TREE_NIL);                LX_SRCPOS: TREE := TREE_VOID)                return TREE;                functi
on MAKE_DISCRETE_RANGE_S                ( LIST: SEQ_TYPE := (TREE_NIL,TREE_NIL);                LX_SRCPOS: TREE := TRE
E_VOID)                return TREE;                function MAKE_ENUM_LITERAL_S                ( LIST: SEQ_TYPE := (
TREE_NIL,TREE_NIL);                LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function
 MAKE_EXP_S                ( LIST: SEQ_TYPE := (TREE_NIL,TREE_NIL);                LX_SRCPOS: TREE := TREE_VOID)     
           return TREE;                function MAKE_ITEM_S                ( LIST: SEQ_TYPE := (TREE_NIL,TREE_NIL); 
               LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function MAKE_INDEX_S       
         ( LIST: SEQ_TYPE := (TREE_NIL,TREE_NIL);                LX_SRCPOS: TREE := TREE_VOID)                return T
REE;                function MAKE_NAME_S                ( LIST: SEQ_TYPE := (TREE_NIL,TREE_NIL);                LX_S
RCPOS: TREE := TREE_VOID)                return TREE;                function MAKE_PARAM_S                ( LIST: SE
Q_TYPE := (TREE_NIL,TREE_NIL);                LX_SRCPOS: TREE := TREE_VOID)                return TREE;             
   function MAKE_PRAGMA_S                ( LIST: SEQ_TYPE := (TREE_NIL,TREE_NIL);                LX_SRCPOS: TREE := TR
EE_VOID)                return TREE;                function MAKE_SCALAR_S                ( LIST: SEQ_TYPE := (TREE_
NIL,TREE_NIL);                LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function MAKE
_SOURCE_NAME_S                ( LIST: SEQ_TYPE := (TREE_NIL,TREE_NIL);                LX_SRCPOS: TREE := TREE_VOID)  
              return TREE;                function MAKE_STM_S                ( LIST: SEQ_TYPE := (TREE_NIL,TREE_NIL);
                LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function MAKE_TEST_CLAUSE_E
LEM_S                ( LIST: SEQ_TYPE := (TREE_NIL,TREE_NIL);                LX_SRCPOS: TREE := TREE_VOID)           
     return TREE;                function MAKE_USE_PRAGMA_S                ( LIST: SEQ_TYPE := (TREE_NIL,TREE_NIL); 
               LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function MAKE_VARIANT_S     
           ( LIST: SEQ_TYPE := (TREE_NIL,TREE_NIL);                LX_SRCPOS: TREE := TREE_VOID)                return
 TREE;                function MAKE_LABELED                ( AS_SOURCE_NAME_S: TREE := TREE_VOID;                AS_
PRAGMA_S: TREE := TREE_VOID;                AS_STM: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID)  
              return TREE;                function MAKE_NULL_STM                ( LX_SRCPOS: TREE := TREE_VOID)     
           return TREE;                function MAKE_ABORT                ( AS_NAME_S: TREE := TREE_VOID;           
     LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function MAKE_RETURN                ( 
AS_EXP: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID)                return TREE;                f
unction MAKE_DELAY                ( AS_EXP: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID)          
      return TREE;                function MAKE_ASSIGN                ( AS_EXP: TREE := TREE_VOID;                AS
_NAME: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID)                return TREE;                fu
nction MAKE_EXIT                ( AS_EXP: TREE := TREE_VOID;                AS_NAME: TREE := TREE_VOID;              
  LX_SRCPOS: TREE := TREE_VOID;                SM_STM: TREE := TREE_VOID)                return TREE;               
 function MAKE_CODE                ( AS_EXP: TREE := TREE_VOID;                AS_NAME: TREE := TREE_VOID;           
     LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function MAKE_CASE                ( AS
_EXP: TREE := TREE_VOID;                AS_ALTERNATIVE_S: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VO
ID)                return TREE;                function MAKE_GOTO                ( AS_NAME: TREE := TREE_VOID;     
           LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function MAKE_RAISE             
   ( AS_NAME: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID)                return TREE;           
     function MAKE_ENTRY_CALL                ( AS_NAME: TREE := TREE_VOID;                AS_GENERAL_ASSOC_S: TREE := 
TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID;                SM_NORMALIZED_PARAM_S: TREE := TREE_VOID)     
           return TREE;                function MAKE_PROCEDURE_CALL                ( AS_NAME: TREE := TREE_VOID;    
            AS_GENERAL_ASSOC_S: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID;                SM_NORM
ALIZED_PARAM_S: TREE := TREE_VOID)                return TREE;                function MAKE_ACCEPT                ( 
AS_NAME: TREE := TREE_VOID;                AS_PARAM_S: TREE := TREE_VOID;                AS_STM_S: TREE := TREE_VOID;
                LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function MAKE_LOOP         
       ( AS_SOURCE_NAME: TREE := TREE_VOID;                AS_ITERATION: TREE := TREE_VOID;                AS_STM_S: T
REE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function M
AKE_BLOCK                ( AS_SOURCE_NAME: TREE := TREE_VOID;                AS_BLOCK_BODY: TREE := TREE_VOID;       
         LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function MAKE_COND_ENTRY          
      ( AS_STM_S1: TREE := TREE_VOID;                AS_STM_S2: TREE := TREE_VOID;                LX_SRCPOS: TREE := T
REE_VOID)                return TREE;                function MAKE_TIMED_ENTRY                ( AS_STM_S1: TREE := T
REE_VOID;                AS_STM_S2: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID)                re
turn TREE;                function MAKE_IF                ( AS_TEST_CLAUSE_ELEM_S: TREE := TREE_VOID;               
 AS_STM_S: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID)                return TREE;              
  function MAKE_SELECTIVE_WAIT                ( AS_TEST_CLAUSE_ELEM_S: TREE := TREE_VOID;                AS_STM_S: TRE
E := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function MAK
E_TERMINATE                ( LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function MAKE_
STM_PRAGMA                ( AS_PRAGMA: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID)               
 return TREE;                function MAKE_NAMED                ( AS_EXP: TREE := TREE_VOID;                AS_CHOIC
E_S: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID)                return TREE;                func
tion MAKE_ASSOC                ( AS_EXP: TREE := TREE_VOID;                AS_USED_NAME: TREE := TREE_VOID;          
      LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function MAKE_USED_CHAR              
  ( LX_SRCPOS: TREE := TREE_VOID;                LX_SYMREP: TREE := TREE_VOID;                SM_DEFN: TREE := TREE_VO
ID;                SM_EXP_TYPE: TREE := TREE_VOID;                SM_VALUE: TREE := TREE_VOID)                return 
TREE;                function MAKE_USED_OBJECT_ID                ( LX_SRCPOS: TREE := TREE_VOID;                LX_S
YMREP: TREE := TREE_VOID;                SM_DEFN: TREE := TREE_VOID;                SM_EXP_TYPE: TREE := TREE_VOID;  
              SM_VALUE: TREE := TREE_VOID)                return TREE;                function MAKE_USED_OP         
       ( LX_SRCPOS: TREE := TREE_VOID;                LX_SYMREP: TREE := TREE_VOID;                SM_DEFN: TREE := TR
EE_VOID)                return TREE;                function MAKE_USED_NAME_ID                ( LX_SRCPOS: TREE := T
REE_VOID;                LX_SYMREP: TREE := TREE_VOID;                SM_DEFN: TREE := TREE_VOID)                retu
rn TREE;                function MAKE_ATTRIBUTE                ( AS_NAME: TREE := TREE_VOID;                AS_USED_
NAME_ID: TREE := TREE_VOID;                AS_EXP: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID;   
             SM_EXP_TYPE: TREE := TREE_VOID;                SM_VALUE: TREE := TREE_VOID)                return TREE; 
               function MAKE_SELECTED                ( AS_NAME: TREE := TREE_VOID;                AS_DESIGNATOR: TREE
 := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID;                SM_EXP_TYPE: TREE := TREE_VOID;           
     SM_VALUE: TREE := TREE_VOID)                return TREE;                function MAKE_FUNCTION_CALL            
    ( AS_NAME: TREE := TREE_VOID;                AS_GENERAL_ASSOC_S: TREE := TREE_VOID;                LX_SRCPOS: TREE
 := TREE_VOID;                LX_PREFIX: BOOLEAN := FALSE;                SM_EXP_TYPE: TREE := TREE_VOID;            
    SM_VALUE: TREE := TREE_VOID;                SM_NORMALIZED_PARAM_S: TREE := TREE_VOID)                return TREE;
                function MAKE_INDEXED                ( AS_NAME: TREE := TREE_VOID;                AS_EXP_S: TREE := T
REE_VOID;                LX_SRCPOS: TREE := TREE_VOID;                SM_EXP_TYPE: TREE := TREE_VOID)                
return TREE;                function MAKE_SLICE                ( AS_NAME: TREE := TREE_VOID;                AS_DISCR
ETE_RANGE: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID;                SM_EXP_TYPE: TREE := TREE_VO
ID)                return TREE;                function MAKE_ALL                ( AS_NAME: TREE := TREE_VOID;      
          LX_SRCPOS: TREE := TREE_VOID;                SM_EXP_TYPE: TREE := TREE_VOID)                return TREE;   
             function MAKE_SHORT_CIRCUIT                ( AS_EXP1: TREE := TREE_VOID;                AS_SHORT_CIRCUIT
_OP: TREE := TREE_VOID;                AS_EXP2: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID;      
          SM_EXP_TYPE: TREE := TREE_VOID;                SM_VALUE: TREE := TREE_VOID)                return TREE;    
            function MAKE_NUMERIC_LITERAL                ( LX_SRCPOS: TREE := TREE_VOID;                LX_NUMREP: TR
EE := TREE_VOID;                SM_EXP_TYPE: TREE := TREE_VOID;                SM_VALUE: TREE := TREE_VOID)          
      return TREE;                function MAKE_NULL_ACCESS                ( LX_SRCPOS: TREE := TREE_VOID;          
      SM_EXP_TYPE: TREE := TREE_VOID;                SM_VALUE: TREE := TREE_VOID)                return TREE;       
         function MAKE_RANGE_MEMBERSHIP                ( AS_EXP: TREE := TREE_VOID;                AS_MEMBERSHIP_OP: T
REE := TREE_VOID;                AS_RANGE: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID;           
     SM_EXP_TYPE: TREE := TREE_VOID;                SM_VALUE: TREE := TREE_VOID)                return TREE;        
        function MAKE_TYPE_MEMBERSHIP                ( AS_EXP: TREE := TREE_VOID;                AS_MEMBERSHIP_OP: TRE
E := TREE_VOID;                AS_NAME: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID;              
  SM_EXP_TYPE: TREE := TREE_VOID;                SM_VALUE: TREE := TREE_VOID)                return TREE;           
     function MAKE_CONVERSION                ( AS_EXP: TREE := TREE_VOID;                AS_NAME: TREE := TREE_VOID; 
               LX_SRCPOS: TREE := TREE_VOID;                SM_EXP_TYPE: TREE := TREE_VOID;                SM_VALUE: T
REE := TREE_VOID)                return TREE;                function MAKE_QUALIFIED                ( AS_EXP: TREE :
= TREE_VOID;                AS_NAME: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID;                S
M_EXP_TYPE: TREE := TREE_VOID;                SM_VALUE: TREE := TREE_VOID)                return TREE;              
  function MAKE_PARENTHESIZED                ( AS_EXP: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID;
                SM_EXP_TYPE: TREE := TREE_VOID;                SM_VALUE: TREE := TREE_VOID)                return TRE
E;                function MAKE_AGGREGATE                ( AS_GENERAL_ASSOC_S: TREE := TREE_VOID;                LX_
SRCPOS: TREE := TREE_VOID;                SM_EXP_TYPE: TREE := TREE_VOID;                SM_DISCRETE_RANGE: TREE := TR
EE_VOID;                SM_NORMALIZED_COMP_S: TREE := TREE_VOID)                return TREE;                function
 MAKE_STRING_LITERAL                ( LX_SRCPOS: TREE := TREE_VOID;                LX_SYMREP: TREE := TREE_VOID;     
           SM_EXP_TYPE: TREE := TREE_VOID;                SM_DISCRETE_RANGE: TREE := TREE_VOID)                return 
TREE;                function MAKE_QUALIFIED_ALLOCATOR                ( AS_QUALIFIED: TREE := TREE_VOID;            
    LX_SRCPOS: TREE := TREE_VOID;                SM_EXP_TYPE: TREE := TREE_VOID)                return TREE;        
        function MAKE_SUBTYPE_ALLOCATOR                ( AS_SUBTYPE_INDICATION: TREE := TREE_VOID;                LX_S
RCPOS: TREE := TREE_VOID;                SM_EXP_TYPE: TREE := TREE_VOID;                SM_DESIG_TYPE: TREE := TREE_VO
ID)                return TREE;                function MAKE_RANGE                ( AS_EXP1: TREE := TREE_VOID;    
            AS_EXP2: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID;                SM_TYPE_SPEC: TREE
 := TREE_VOID)                return TREE;                function MAKE_RANGE_ATTRIBUTE                ( AS_NAME: TR
EE := TREE_VOID;                AS_USED_NAME_ID: TREE := TREE_VOID;                AS_EXP: TREE := TREE_VOID;        
        LX_SRCPOS: TREE := TREE_VOID;                SM_TYPE_SPEC: TREE := TREE_VOID)                return TREE;    
            function MAKE_DISCRETE_SUBTYPE                ( AS_SUBTYPE_INDICATION: TREE := TREE_VOID;                
LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function MAKE_FLOAT_CONSTRAINT             
   ( AS_EXP: TREE := TREE_VOID;                AS_RANGE: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOI
D;                SM_TYPE_SPEC: TREE := TREE_VOID)                return TREE;                function MAKE_FIXED_CO
NSTRAINT                ( AS_EXP: TREE := TREE_VOID;                AS_RANGE: TREE := TREE_VOID;                LX_SR
CPOS: TREE := TREE_VOID;                SM_TYPE_SPEC: TREE := TREE_VOID)                return TREE;                
function MAKE_INDEX_CONSTRAINT                ( AS_DISCRETE_RANGE_S: TREE := TREE_VOID;                LX_SRCPOS: TREE
 := TREE_VOID)                return TREE;                function MAKE_DSCRMT_CONSTRAINT                ( AS_GENERA
L_ASSOC_S: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID)                return TREE;              
  function MAKE_CHOICE_EXP                ( AS_EXP: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID)  
              return TREE;                function MAKE_CHOICE_RANGE                ( AS_DISCRETE_RANGE: TREE := TREE
_VOID;                LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function MAKE_CHOICE_
OTHERS                ( LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function MAKE_PROCE
DURE_SPEC                ( AS_PARAM_S: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID)               
 return TREE;                function MAKE_FUNCTION_SPEC                ( AS_PARAM_S: TREE := TREE_VOID;            
    AS_NAME: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID)                return TREE;            
    function MAKE_ENTRY                ( AS_PARAM_S: TREE := TREE_VOID;                AS_DISCRETE_RANGE: TREE := TREE
_VOID;                LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function MAKE_PACKAGE
_SPEC                ( AS_DECL_S1: TREE := TREE_VOID;                AS_DECL_S2: TREE := TREE_VOID;                LX
_SRCPOS: TREE := TREE_VOID;                XD_BODY_IS_REQUIRED: BOOLEAN := FALSE)                return TREE;       
         function MAKE_RENAMES_UNIT                ( AS_NAME: TREE := TREE_VOID;                LX_SRCPOS: TREE := TRE
E_VOID)                return TREE;                function MAKE_INSTANTIATION                ( AS_NAME: TREE := TRE
E_VOID;                AS_GENERAL_ASSOC_S: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID;           
     SM_DECL_S: TREE := TREE_VOID)                return TREE;                function MAKE_NAME_DEFAULT            
    ( AS_NAME: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID)                return TREE;          
      function MAKE_BOX_DEFAULT                ( LX_SRCPOS: TREE := TREE_VOID)                return TREE;          
      function MAKE_NO_DEFAULT                ( LX_SRCPOS: TREE := TREE_VOID)                return TREE;           
     function MAKE_BLOCK_BODY                ( AS_ITEM_S: TREE := TREE_VOID;                AS_STM_S: TREE := TREE_VOI
D;                AS_ALTERNATIVE_S: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID)                re
turn TREE;                function MAKE_STUB                ( LX_SRCPOS: TREE := TREE_VOID)                return TR
EE;                function MAKE_IMPLICIT_NOT_EQ                ( LX_SRCPOS: TREE := TREE_VOID;                SM_EQ
UAL: TREE := TREE_VOID)                return TREE;                function MAKE_DERIVED_SUBPROG                ( LX
_SRCPOS: TREE := TREE_VOID;                SM_DERIVABLE: TREE := TREE_VOID)                return TREE;             
   function MAKE_COND_CLAUSE                ( AS_EXP: TREE := TREE_VOID;                AS_STM_S: TREE := TREE_VOID; 
               LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function MAKE_SELECT_ALTERNAT
IVE                ( AS_EXP: TREE := TREE_VOID;                AS_STM_S: TREE := TREE_VOID;                LX_SRCPOS:
 TREE := TREE_VOID)                return TREE;                function MAKE_SELECT_ALT_PRAGMA                ( AS_P
RAGMA: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID)                return TREE;                fu
nction MAKE_IN_OP                ( LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function
 MAKE_NOT_IN                ( LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function MAKE
_AND_THEN                ( LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function MAKE_OR
_ELSE                ( LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function MAKE_FOR  
              ( AS_SOURCE_NAME: TREE := TREE_VOID;                AS_DISCRETE_RANGE: TREE := TREE_VOID;               
 LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function MAKE_REVERSE                ( AS_
SOURCE_NAME: TREE := TREE_VOID;                AS_DISCRETE_RANGE: TREE := TREE_VOID;                LX_SRCPOS: TREE :=
 TREE_VOID)                return TREE;                function MAKE_WHILE                ( AS_EXP: TREE := TREE_VOI
D;                LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function MAKE_ALTERNATIVE
                ( AS_CHOICE_S: TREE := TREE_VOID;                AS_STM_S: TREE := TREE_VOID;                LX_SRCPO
S: TREE := TREE_VOID)                return TREE;                function MAKE_ALTERNATIVE_PRAGMA                ( A
S_PRAGMA: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID)                return TREE;               
 function MAKE_COMP_REP                ( AS_NAME: TREE := TREE_VOID;                AS_EXP: TREE := TREE_VOID;       
         AS_RANGE: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID)                return TREE;      
          function MAKE_COMP_REP_PRAGMA                ( AS_PRAGMA: TREE := TREE_VOID;                LX_SRCPOS: TREE 
:= TREE_VOID)                return TREE;                function MAKE_CONTEXT_PRAGMA                ( AS_PRAGMA: TR
EE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function MA
KE_WITH                ( AS_NAME_S: TREE := TREE_VOID;                AS_USE_PRAGMA_S: TREE := TREE_VOID;            
    LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function MAKE_VARIANT                ( 
AS_CHOICE_S: TREE := TREE_VOID;                AS_COMP_LIST: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE
_VOID)                return TREE;                function MAKE_VARIANT_PRAGMA                ( AS_PRAGMA: TREE := T
REE_VOID;                LX_SRCPOS: TREE := TREE_VOID)                return TREE;                function MAKE_ALIG
NMENT                ( AS_PRAGMA_S: TREE := TREE_VOID;                AS_EXP: TREE := TREE_VOID;                LX_SR
CPOS: TREE := TREE_VOID)                return TREE;                function MAKE_VARIANT_PART                ( AS_N
AME: TREE := TREE_VOID;                AS_VARIANT_S: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID) 
               return TREE;                function MAKE_COMP_LIST                ( AS_DECL_S: TREE := TREE_VOID;   
             AS_VARIANT_PART: TREE := TREE_VOID;                AS_PRAGMA_S: TREE := TREE_VOID;                LX_SRCP
OS: TREE := TREE_VOID)                return TREE;                function MAKE_COMPILATION                ( AS_COMP
LTN_UNIT_S: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID)                return TREE;             
   function MAKE_COMPILATION_UNIT                ( AS_CONTEXT_ELEM_S: TREE := TREE_VOID;                AS_ALL_DECL: T
REE := TREE_VOID;                AS_PRAGMA_S: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID;        
        XD_TIMESTAMP: INTEGER := 0;                LIST: SEQ_TYPE := (TREE_NIL,TREE_NIL);                XD_NBR_PAGES:
 INTEGER := 0;                XD_LIB_NAME: TREE := TREE_VOID)                return TREE;                function MA
KE_INDEX                ( AS_NAME: TREE := TREE_VOID;                LX_SRCPOS: TREE := TREE_VOID;                SM_
TYPE_SPEC: TREE := TREE_VOID)                return TREE;                function MAKE_TASK_SPEC                ( SM
_DERIVED: TREE := TREE_VOID;                SM_IS_ANONYMOUS: BOOLEAN := FALSE;                SM_DECL_S: TREE := TREE_
VOID;                SM_BODY: TREE := TREE_VOID;                SM_ADDRESS: TREE := TREE_VOID;                SM_SIZE
: TREE := TREE_VOID;                SM_STORAGE_SIZE: TREE := TREE_VOID;                XD_SOURCE_NAME: TREE := TREE_VO
ID;                XD_STUB: TREE := TREE_VOID;                XD_BODY: TREE := TREE_VOID)                return TREE;
                function MAKE_ENUMERATION                ( SM_DERIVED: TREE := TREE_VOID;                SM_IS_ANONY
MOUS: BOOLEAN := FALSE;                SM_BASE_TYPE: TREE := TREE_VOID;                SM_RANGE: TREE := TREE_VOID;  
              SM_LITERAL_S: TREE := TREE_VOID;                XD_SOURCE_NAME: TREE := TREE_VOID;                CD_IMP
L_SIZE: INTEGER := 0)                return TREE;                function MAKE_INTEGER (촕M_DERIVED, SM_BASE_TYPE, SM
_RANGE, XD_SOURCE_NAME :TREE := TREE_VOID;          КCD_IMPL_SIZE: INTEGER := 0; SM_IS_ANONYMOUS :BOOLEAN := FALSE   
             ) return TREE;                function MAKE_FLOAT                ( SM_DERIVED: TREE := TREE_VOID;     
           SM_IS_ANONYMOUS: BOOLEAN := FALSE;                SM_BASE_TYPE: TREE := TREE_VOID;                SM_RANGE:
 TREE := TREE_VOID;                SM_ACCURACY: TREE := TREE_VOID;                XD_SOURCE_NAME: TREE := TREE_VOID; 
               CD_IMPL_SIZE: INTEGER := 0)                return TREE;                function MAKE_FIXED           
     ( SM_DERIVED: TREE := TREE_VOID;                SM_IS_ANONYMOUS: BOOLEAN := FALSE;                SM_BASE_TYPE: T
REE := TREE_VOID;                SM_RANGE: TREE := TREE_VOID;                SM_ACCURACY: TREE := TREE_VOID;         
       XD_SOURCE_NAME: TREE := TREE_VOID;                CD_IMPL_SIZE: INTEGER := 0;                CD_IMPL_SMALL: TRE
E := TREE_VOID)                return TREE;                function MAKE_ARRAY                ( SM_DERIVED: TREE := 
TREE_VOID;                SM_IS_ANONYMOUS: BOOLEAN := FALSE;                SM_BASE_TYPE: TREE := TREE_VOID;         
       SM_SIZE: TREE := TREE_VOID;                SM_IS_LIMITED: BOOLEAN := FALSE;                SM_IS_PACKED: BOOLEA
N := FALSE;                SM_INDEX_S: TREE := TREE_VOID;                SM_COMP_TYPE: TREE := TREE_VOID;            
    XD_SOURCE_NAME: TREE := TREE_VOID)                return TREE;                function MAKE_RECORD              
  ( SM_DERIVED: TREE := TREE_VOID;                SM_IS_ANONYMOUS: BOOLEAN := FALSE;                SM_BASE_TYPE: TREE
 := TREE_VOID;                SM_SIZE: TREE := TREE_VOID;                SM_IS_LIMITED: BOOLEAN := FALSE;            
    SM_IS_PACKED: BOOLEAN := FALSE;                SM_DISCRIMINANT_S: TREE := TREE_VOID;                SM_COMP_LIST: 
TREE := TREE_VOID;                SM_REPRESENTATION: TREE := TREE_VOID;                XD_SOURCE_NAME: TREE := TREE_VO
ID)                return TREE;                function MAKE_ACCESS                ( SM_DERIVED: TREE := TREE_VOID;
                SM_IS_ANONYMOUS: BOOLEAN := FALSE;                SM_BASE_TYPE: TREE := TREE_VOID;                SM_S
IZE: TREE := TREE_VOID;                SM_STORAGE_SIZE: TREE := TREE_VOID;                SM_IS_CONTROLLED: BOOLEAN :=
 FALSE;                SM_DESIG_TYPE: TREE := TREE_VOID;                SM_MASTER: TREE := TREE_VOID;                
XD_SOURCE_NAME: TREE := TREE_VOID)                return TREE;                function MAKE_CONSTRAINED_ARRAY       
         ( SM_DERIVED: TREE := TREE_VOID;                SM_IS_ANONYMOUS: BOOLEAN := FALSE;                SM_BASE_TYP
E: TREE := TREE_VOID;                SM_DEPENDS_ON_DSCRMT: BOOLEAN := FALSE;                SM_INDEX_SUBTYPE_S: TREE :
= TREE_VOID;                XD_SOURCE_NAME: TREE := TREE_VOID)                return TREE;                function M
AKE_CONSTRAINED_RECORD                ( SM_DERIVED: TREE := TREE_VOID;                SM_IS_ANONYMOUS: BOOLEAN := FALS
E;                SM_BASE_TYPE: TREE := TREE_VOID;                SM_DEPENDS_ON_DSCRMT: BOOLEAN := FALSE;            
    SM_NORMALIZED_DSCRMT_S: TREE := TREE_VOID;                XD_SOURCE_NAME: TREE := TREE_VOID)                return
 TREE;                function MAKE_CONSTRAINED_ACCESS                ( SM_DERIVED: TREE := TREE_VOID;              
  SM_IS_ANONYMOUS: BOOLEAN := FALSE;                SM_BASE_TYPE: TREE := TREE_VOID;                SM_DEPENDS_ON_DSCR
MT: BOOLEAN := FALSE;                SM_DESIG_TYPE: TREE := TREE_VOID;                XD_SOURCE_NAME: TREE := TREE_VOI
D)                return TREE;                function MAKE_PRIVATE                ( SM_DERIVED: TREE := TREE_VOID;
                SM_IS_ANONYMOUS: BOOLEAN := FALSE;                SM_DISCRIMINANT_S: TREE := TREE_VOID;               
 SM_TYPE_SPEC: TREE := TREE_VOID;                XD_SOURCE_NAME: TREE := TREE_VOID)                return TREE;      
          function MAKE_L_PRIVATE                ( SM_DERIVED: TREE := TREE_VOID;                SM_IS_ANONYMOUS: BOO
LEAN := FALSE;                SM_DISCRIMINANT_S: TREE := TREE_VOID;                SM_TYPE_SPEC: TREE := TREE_VOID;  
              XD_SOURCE_NAME: TREE := TREE_VOID)                return TREE;                function MAKE_INCOMPLETE
                ( SM_DISCRIMINANT_S: TREE := TREE_VOID;                XD_SOURCE_NAME: TREE := TREE_VOID;             
   XD_FULL_TYPE_SPEC: TREE := TREE_VOID)                return TREE;                function MAKE_UNIVERSAL_INTEGER 
               ( XD_SOURCE_NAME: TREE := TREE_VOID)                return TREE;                function MAKE_UNIVERSA
L_FIXED                ( XD_SOURCE_NAME: TREE := TREE_VOID)                return TREE;                function MAKE
_UNIVERSAL_REAL                ( XD_SOURCE_NAME: TREE := TREE_VOID)                return TREE;        --|----------
--------------------------------------------------------------------------------------  end MAKE_NOD;떰떰떰  --|-------
-----------------------------------------------------------------------------------------떰  --КGEN_SUBS떰  --|--------
----------------------------------------------------------------------------------------  package GEN_SUBS is        
  NODE_HASH_SIZEК: constant:= 131;    type NODE_ARRAY_TYPE촫s array( 0 .. INTEGER( NODE_HASH_SIZE - 1 ) ) of TREE;  
  type NODE_HASH_TYPE촫s record땝К  LIMIT: NATURALК:= 32000;땝К  A: NODE_ARRAY_TYPE:= (others => TREE_VOID);땝Кen
d record;          procedure INSERT_NODE_HASH( NODE_HASH :in out NODE_HASH_TYPE; NEW_NODE :TREE;땝К  OLD_NODE :TREE
 );    procedure REPLACE_NODEК( NODE :in out TREE; NODE_HASH :in out NODE_HASH_TYPE );    procedure SUBSTITUTE_ATTRIB
UTES( NODE :in out TREE; NODE_HASH :in out NODE_HASH_TYPE;땝К  H_IN :H_TYPE );    procedure SUBSTITUTEК( NODE :in o
ut TREE; NODE_HASH :in out NODE_HASH_TYPE;땝К  H_IN :H_TYPE );        --|-------------------------------------------
-----------------------------------------------------  end GEN_SUBS;떰떰떰  --|----------------------------------------
--------------------------------------------------------떰  --КNEWSNAM떰  --|------------------------------------------
------------------------------------------------------  package NEWSNAM is    use GEN_SUBS;          procedure REPLA
CE_SOURCE_NAME( SOURCE_NAME :in out TREE; NODE_HASH :in out NODE_HASH_TYPE;땝К  H_IN :H_TYPE; DECL :TREE := TREE_VOID
 );            --|------------------------------------------------------------------------------------------------  e
nd NEWSNAM;떰떰떰  --|------------------------------------------------------------------------------------------------떰
  --КPRE_FCNS떰  --|------------------------------------------------------------------------------------------------  
package PRE_FCNS is          procedure GEN_PREDEFINED_OPERATORS( TYPE_SPEC :TREE; H_IN :H_TYPE );         --|------
------------------------------------------------------------------------------------------  end PRE_FCNS;떰떰떰  --|---
---------------------------------------------------------------------------------------------떰  --КPRENAME떰  --|-----
-------------------------------------------------------------------------------------------  package PRENAME is      
    type DEFINED_PRAGMAS촫s (땝КCONTROLLED,촃LABORATE,촇NLINE,촇NTERFACE,땝КLIST,КMEMORY_SIZE,촑PTIMIZE,촒ACK,땝КPAG
E,КPRIORITY,촕HARED,촕TORAGE_UNIT,땝КSUPPRESS,КSYSTEM_NAME,땝КDEBUGККК--| PRAGMA DEBUG ( ON|OFF ) -- ENABLES/DIS
ABLES TRACE IN COMPILER땝К);          type LIST_ARGUMENTS촫s ( OFF, ON );          type OPTIMIZE_ARGUMENTS촫s ( TIM
E, SPACE );          type SUPPRESS_ARGUMENTS촫s (땝КON,땝КACCESS_CHECK,촇NDEX_CHECK,촂ISCRIMINANT_CHECK,땝КLENGTH_C
HECK,촔ANGE_CHECK,촃LABORATION_CHECK,땝КDIVISION_CHECK,촑VERFLOW_CHECK,촕TORAGE_CHECK땝К);          type INTERFACE_A
RGUMENTS촫s ( ADA, ASM );          type DEFINED_ATTRIBUTES촫s (땝КADDRESS,КAFT,КBASE,땝КCALLABLE,КCONSTRAINED,촀O
UNT,땝КDELTA_X,КDIGITS_X,КEMAX,땝КEPSILON,КFIRST,КFIRST_BIT,땝КFORE,КIMAGE,КLARGE,땝КLAST,КLAST_BIT,КLENGTH,
땝КMACHINE_EMAX,촎ACHINE_EMIN,땝КMACHINE_MANTISSA,촎ACHINE_OVERFLOWS,땝КMACHINE_RADIX, 촎ACHINE_ROUNDS,땝КMANTISSA,
촒OS,КPOSITION,땝КPRED,КRANGE_X,КSAFE_EMAX,땝КSAFE_LARGE,촕AFE_SMALL,촕IZE,땝КSMALL, КSTORAGE_SIZE,촕UCC,땝КTERM
INATED,촚AL,КVALUE,땝КWIDTH땝К);          type OP_CLASSКis (땝КOP_AND,КOP_OR,КOP_XOR,촑P_NOT,땝КOP_UNARY_PLUS,
촑P_UNARY_MINUS,촑P_ABS,촑P_EQ,땝КOP_NE,КOP_LT,КOP_LE,촑P_GT,땝КOP_GE,КOP_PLUS,КOP_MINUS,촑P_MULT,땝КOP_DIV,КOP_
MOD,КOP_REM,촑P_CAT,땝КOP_EXP땝К);          subtype CLASS_BOOLEAN_OPКis OP_CLASS range OP_AND .. OP_XOR;    subty
pe CLASS_EQUALITY_OPКis OP_CLASS range OP_EQ  .. OP_NE;    subtype CLASS_RELATIONAL_OP촫s OP_CLASS range OP_LT  .. OP_
GE;    subtype CLASS_EQ_RELATIONAL_OP촫s OP_CLASS range OP_EQ  .. OP_GE;          subtype CLASS_UNARY_OPКis OP_CLASS
 range OP_NOT        .. OP_ABS;    subtype CLASS_UNARY_NUMERIC_OP촫s OP_CLASS range OP_UNARY_PLUS .. OP_ABS;    subtyp
e CLASS_FIXED_OPКis OP_CLASS range OP_PLUS       .. OP_MINUS;    subtype CLASS_FLOAT_OPКis OP_CLASS range OP_PLUS    
   .. OP_DIV;    subtype CLASS_INTEGER_OPКis OP_CLASS range OP_PLUS       .. OP_REM;          subtype STRING_3촫s ST
RING(1..3);          BLTN_TEXT_ARRAY: constant array (OP_CLASS) of STRING_3 := (땝OP_AND => "AND",촑P_OR => "OR!",촑P
_XOR => "XOR",촑P_EQ => "=!!",땝OP_NE => "/=!",촑P_LT => "<!!",촑P_LE => "<=!",촑P_GT => ">!!",땝OP_GE => ">=!",촑P_PLUS
 => "+!!",촑P_MINUS => "-!!",촑P_CAT => "&!!",땝OP_UNARY_PLUS => "+!!",촑P_UNARY_MINUS => "-!!",땝OP_ABS => "ABS",촑P_NO
T => "NOT",촑P_MULT => "*!!",촑P_DIV => "/!!",땝OP_MOD => "MOD",촑P_REM => "REM",촑P_EXP => "**!"땝);          BLTN_ID
_ARRAY: array (OP_CLASS) of TREE:= (others => TREE_VOID);떰  --|------------------------------------------------------
-----------------------------------------  end PRENAME;              --|------------------------------------------
------------------------------------------------------떰  --КRED_SUBP떰  --|-------------------------------------------
-----------------------------------------------------  package RED_SUBP is    use SET_UTIL;떰    procedure EVAL_SUBP_C
ALLК( EXP :TREE; TYPESET :out TYPESET_TYPE );    function  RESOLVE_FUNCTION_CALLК( EXP :TREE; TYPE_SPEC :TREE )촵etu
rn TREE;    procedure REDUCE_APPLY_NAMESК( NAME :TREE; NAME_DEFSET :in out DEFSET_TYPE;땝КК  GEN_ASSOC_S :TREE; INDE
X :TREE := TREE_VOID );    function  RESOLVE_SUBP_PARAMETERSК( DEF :TREE; GEN_ASSOC_S :TREE )촵eturn TREE;    procedu
re RESOLVE_ERRONEOUS_PARAM_SК( GENERAL_ASSOC_S :TREE);    procedure CHECK_ACTUAL_TYPEК( FORMAL_TYPE :TREE; ACTUAL_TYP
ESET :TYPESET_TYPE;땝КК  ACTUALS_OK :out BOOLEAN;땝КК  EXTRAINFO :out EXTRAINFO_TYPE );    function  GET_TYPE_OF_DI
SCRETE_RANGE( DISCRETE_RANGE :TREE )Кreturn TREE;        --|--------------------------------------------------------
----------------------------------------  end RED_SUBP;떰떰떰  --|-----------------------------------------------------
-------------------------------------------떰  --КREP_CLAU떰  --|------------------------------------------------------
------------------------------------------  package REP_CLAU is          procedure RESOLVE_LENGTH_REP( ATTRIBUTE :TR
EE; EXP :in out TREE; H :H_TYPE );    procedure RESOLVE_ENUM_REP( SIMPLE_NAME :in out TREE; EXP :TREE; H :H_TYPE );  
  procedure RESOLVE_ADDRESS_REP( SIMPLE_NAME :in out TREE; EXP :in out TREE; H :H_TYPE );    procedure RESOLVE_RECORD_
REP( SIMPLE_NAME :in out TREE; ALIGNMENT :TREE;땝К  COMP_REP_S :TREE; H :H_TYPE );        --|----------------------
--------------------------------------------------------------------------  end REP_CLAU;떰떰떰  USED_PACKAGE_LIST: SE
Q_TYPE촵enames FIX_WITH.USED_PACKAGE_LIST;                    package body SEM_GLOB촫s separate;  package body UNIV_
OPS촫s separate;  function  EVAL_NUM( TXT :STRING )촵eturn TREE촫s separate;  package body UARITH촫s separate;  pack
age body FIX_WITH촫s separate;  package body DEF_UTIL촫s separate;  package body SET_UTIL촫s separate;  package body 
REQ_UTIL촫s separate;  package body AGGRESO촫s separate;  package body EXPRESO촫s separate;  package body VIS_UTIL촫s
 separate;  package body DEF_WALK촫s separate;  package body NOD_WALK촫s separate;  package body ATT_WALK촫s separate
;  package body STM_WALK촫s separate;  package body PRA_WALK촫s separate;  package body CHK_STAT촫s separate;  packa
ge body DERIVED촫s separate;  package body EXP_TYPE촫s separate;  package body HOM_UNIT촫s separate;  package body IN
STANT촫s separate;  package body MAKE_NOD촫s separate;  package body GEN_SUBS촫s separate;  package body NEWSNAM촫s s
eparate;  package body PRE_FCNS촫s separate;  package body RED_SUBP촫s separate;  package body REP_CLAU촫s separate;
떰땝К--------------------------------땝procedureКINITIALIZE_PRAGMA_ATTRIBUTE_DEFS떰  is    STD_PACK_SYMК: TREEК:= S
TORE_SYM( "_STANDRD.DCL" );    STD_PACK_IDК: TREEК:= HEAD( LIST( STD_PACK_SYM ) );    ALL_DECLК: TREEК:= D( AS_ALL
_DECL, STD_PACK_ID );    STD_PACK_HEADERК: TREEК:= D( AS_HEADER, ALL_DECL );    DECL_PRIVК: TREEК:= D( AS_DECL_S2,
 STD_PACK_HEADER );    ID_LISTК: SEQ_TYPE:= LIST( DECL_PRIV );К--| LA LISTE DES DECLARATIONS PRIVEES DE _STANDRD  
  IDК: TREE;    DEFК: TREE;  begin    while not IS_EMPTY( ID_LIST ) loopККК--| TANT QU'IL Y A DES ELEMENTS PR
IVES      POP( ID_LIST, ID );КККК--| EN EXTRAIRE UN      if ID.TY in DN_ATTRIBUTE_ID .. DN_PRAGMA_IDККК--| SI C
'EST UN ID D'ATTRIBUT OU DE PRAGMA         and then D( LX_SYMREP, ID ).TY = DN_SYMBOL_REP      then        DEF := DEF
_UTIL.MAKE_DEF_FOR_ID( ID, SEM_GLOB.INITIAL_H );        D( XD_REGION_DEF, DEF, TREE_VOID );        DB( XD_IS_IN_SPEC, 
DEF, FALSE );      end if;    end loop;떰  end촇NITIALIZE_PRAGMA_ATTRIBUTE_DEFS;땝--------------------------------떰떰
КК------------------------  procedureК촀OMPILE_COMPILATION_UNIT( COMPILATION_UNIT :TREE;땝ККК  H         :H_TYP
E )땝К------------------------  is떰    CONTEXT_ELEM_SК: constant TREE:= D( AS_CONTEXT_ELEM_S, COMPILATION_UNIT );
    ALL_DECLК: constant TREE:= D( AS_ALL_DECL,       COMPILATION_UNIT );    PRAGMA_SК: constant TREE:= D( AS_PRAGMA
_S,       COMPILATION_UNIT );    WITH_LISTК: constant SEQ_TYPE:= LIST( COMPILATION_UNIT );떰땝К------------------- 
   procedureКPROCESS_WITH_NAME_SК( NAME_S :TREE )    is      NAME_LISTК: SEQ_TYPE:= LIST( NAME_S );      NAMEК: 
TREE;      NEW_NAME_LISTК: SEQ_TYPE:= (TREE_NIL, TREE_NIL);    begin               while not IS_EMPTY( NAME_LIST )
 loop        POP( NAME_LIST, NAME );        declare                  NAME_DEFNК:constant TREE:= D( SM_DEFN, NAME );
          NAME_DEFК:constant TREE:= DEF_UTIL.GET_DEF_FOR_ID( NAME_DEFN );땝NEW_NAMEК: TREE;        begin          
D( XD_REGION_DEF, NAME_DEF, DEF_UTIL.GET_DEF_FOR_ID( D( XD_REGION, NAME_DEFN ) ) );          NEW_NAME := VIS_UTIL.MAKE_
USED_NAME_ID_FROM_OBJECT( NAME );          NEW_NAME_LIST := APPEND( NEW_NAME_LIST, NEW_NAME );        end;      end l
oop;               LIST( NAME_S, NEW_NAME_LIST );떰    end촒ROCESS_WITH_NAME_S;땝-------------------떰땝К------------
-------------    procedureКPROCESS_WITH_USE_PRAGMA_S( USE_PRAGMA_S :TREE )땝К-------------------------    is      
USE_PRAGMA_LIST: SEQ_TYPE:= LIST( USE_PRAGMA_S );      USE_PRAGMAК: TREE;    begin떰      while not IS_EMPTY( USE_P
RAGMA_LIST ) loop        POP( USE_PRAGMA_LIST, USE_PRAGMA );                    if USE_PRAGMA.TY = DN_PRAGMA        
then NOD_WALK.WALK( USE_PRAGMA, INITIAL_H );        else땝КCONVERT_USE_NAMES_TO_IDS:땝declare            NAME_LIST: 
SEQ_TYPEК:= LIST( D( AS_NAME_S, USE_PRAGMA ) );땝  NAMEК: TREE;            NEW_NAME_LIST: SEQ_TYPEК:= (TREE_NIL,TRE
E_NIL);            NAME_DEFN: TREE; 촢egin            while not IS_EMPTY( NAME_LIST) loop              POP( NAME_LI
ST, NAME );땝    if  NAME.TY = DN_SELECTED땝    then NAME_DEFN := D( AS_DESIGNATOR, NAME );땝    else NAME_DEFN := D( SM
_DEFN, NAME );땝    end if;땝    declare                NAME_DEF:constant TREEК:= DEF_UTIL.GET_DEF_FOR_ID( NAME_DEFN 
);땝      NEW_NAME: TREE;땝    begin                DB( XD_IS_USED, NAME_DEF, TRUE );                NEW_NAME      :=
 VIS_UTIL.MAKE_USED_NAME_ID_FROM_OBJECT( NAME );                NEW_NAME_LIST := APPEND( NEW_NAME_LIST, NEW_NAME );땝  
  end;            end loop;                           LIST( D( AS_NAME_S, USE_PRAGMA), NEW_NAME_LIST );땝endКCONVERT
_USE_NAMES_TO_IDS;        end if;                    end loop;떰    end촒ROCESS_WITH_USE_PRAGMA_S;땝-----------------
--------떰떰К-----------------------    procedureКPROCESS_CONTEXT_CLAUSESК( COMPILATION_UNIT :TREE )땝К-----------
------------    is      CONTEXT_ELEM_S: constant TREE:= D( AS_CONTEXT_ELEM_S, COMPILATION_UNIT );      CONTEXT_ELEM
_LIST: SEQ_TYPE:= LIST( CONTEXT_ELEM_S );      CONTEXT_ELEMК: TREE;      TRANS_WITH_LIST: SEQ_TYPE:= LIST( COMPIL
ATION_UNIT );      TRANS_WITHК: TREE;떰К------------------------      procedureКPROCESS_ANCESTOR_CONTEXT( ANCESTO
R_UNIT, COMPILATION_UNIT :TREE )땝К------------------------      is떰땝К-----------        functionКIS_ANCESTOR ( 
ANC_ALL_DECL, COMP_ALL_DECL :TREE ) return BOOLEAN땝К-----------        is        begin          if COMP_ALL_DECL.TY
 in CLASS_SUBUNIT_BODY then            return (    ANC_ALL_DECL.TY in CLASS_UNIT_DECL                        and then 
D( SM_FIRST, D( AS_SOURCE_NAME, COMP_ALL_DECL ) ) = D ( AS_SOURCE_NAME, ANC_ALL_DECL)                        );       
   elsif COMP_ALL_DECL.TY = DN_SUBUNIT then            declare              COMP_NAME: TREE:= D( AS_NAME, COMP_ALL_D
ECL );              ANC_ID: TREE:= TREE_VOID;            begin              if ANC_ALL_DECL.TY = DN_SUBUNIT then  
              ANC_ID := D( SM_FIRST, D(  AS_SOURCE_NAME, D( AS_SUBUNIT_BODY, ANC_ALL_DECL ) ) );                return 
FIX_WITH.IS_ANCESTOR( ANC_ID, COMP_ALL_DECL );              elsif ANC_ALL_DECL /= TREE_VOID then                ANC_ID
 := D( SM_FIRST, D(  AS_SOURCE_NAME, ANC_ALL_DECL ) );                while COMP_NAME.TY = DN_SELECTED loop           
       COMP_NAME := D( AS_NAME, COMP_NAME );                end loop;                return D( LX_SYMREP, ANC_ID ) = D
( LX_SYMREP, COMP_NAME );              end if;            end;          end if;          return FALSE;        end촇
S_ANCESTOR;땝-----------떰К-----------------        procedureКREPROCESS_CONTEXTК ( CONTEXT_ELEM_S :TREE )땝К-----
------------        is              -- GIVEN CONTEXT_ELEM_S FOR AN ANCESTOR UNIT,                -- ... REPROCESS WIT
H'S AND USE'S IN FOR USE IN CURRENT UNIT          CONTEXT_ELEM_LIST: SEQ_TYPE:= LIST( CONTEXT_ELEM_S );          CON
TEXT_ELEM: TREE;          USE_PRAGMA_LIST: SEQ_TYPE;          USE_PRAGMA: TREE;          ITEM_LISTК: SEQ_TYPE;  
        ITEMК: TREE;        begin          while not IS_EMPTY( CONTEXT_ELEM_LIST ) loop            POP( CONTEXT_ELEM
_LIST, CONTEXT_ELEM);            if CONTEXT_ELEM.TY = DN_WITH then              ITEM_LIST := LIST( D( AS_NAME_S, CONTE
XT_ELEM ) );              while not IS_EMPTY( ITEM_LIST) loop                POP( ITEM_LIST, ITEM);                if
 D( SM_DEFN, ITEM ) /= TREE_VOID then                  D( XD_REGION_DEF, DEF_UTIL.GET_DEF_FOR_ID( D( SM_DEFN,ITEM ) ), 
PREDEFINED_STANDARD_DEF );                end if;              end loop;              USE_PRAGMA_LIST := LIST( D( AS_
USE_PRAGMA_S, CONTEXT_ELEM ) );              while not IS_EMPTY( USE_PRAGMA_LIST) loop                POP( USE_PRAGMA_
LIST, USE_PRAGMA);                if USE_PRAGMA.TY = DN_USE then                  ITEM_LIST := LIST( D( AS_NAME_S, USE
_PRAGMA ) );                  while not IS_EMPTY( ITEM_LIST ) loop                    POP( ITEM_LIST, ITEM );        
            if D( SM_DEFN, ITEM ) /= TREE_VOID then                      DB( XD_IS_USED, DEF_UTIL.GET_DEF_FOR_ID( D( SM
_DEFN, ITEM ) ), TRUE );                    end if;                  end loop;                end if;              e
nd loop;            end if;          end loop;떰        end촔EPROCESS_CONTEXT;땝-----------------                  
begin        if IS_ANCESTOR( D( AS_ALL_DECL, ANCESTOR_UNIT ), D( AS_ALL_DECL, COMPILATION_UNIT ) ) then          REPRO
CESS_CONTEXT( D( AS_CONTEXT_ELEM_S, ANCESTOR_UNIT ) );        end if;떰      end촒ROCESS_ANCESTOR_CONTEXT;땝-----------
-------------떰    begin떰      while  not IS_EMPTY( CONTEXT_ELEM_LIST )  loop        POP( CONTEXT_ELEM_LIST, CONTEXT_E
LEM );                    if  CONTEXT_ELEM.TY = DN_WITH  then떰          PROCESS_WITH_NAME_S( D( AS_NAME_S, CONTEXT_EL
EM ) );          PROCESS_WITH_USE_PRAGMA_S( D( AS_USE_PRAGMA_S, CONTEXT_ELEM ) );                       else        
  PUT_LINE( "SEM_PHASE.PROCESS_CONTEXT_CLAUSES!! $$$$ CONTEXT PRAGMA." );          raise PROGRAM_ERROR;        end if;
      end loop;               while  not IS_EMPTY( TRANS_WITH_LIST )  loop        POP( TRANS_WITH_LIST, TRANS_WITH);
        PROCESS_ANCESTOR_CONTEXT( D( TW_COMP_UNIT, TRANS_WITH ), COMPILATION_UNIT );      end loop;             end
PROCESS_CONTEXT_CLAUSES;땝-----------------------떰땝К---------------------    procedureКENTER_ANCESTOR_REGIONК( NAM
E :TREE; H :in out H_TYPE )땝К---------------------    is      SК: NOD_WALK.S_TYPE;      DESIGNATORК: TREE;     
 DEFNК: TREE;      DES_DEFК: TREE;      DEFLISTК: SEQ_TYPE;      DEFК: TREE;    begin      if NAME.TY = DN_SEL
ECTED then        ENTER_ANCESTOR_REGION( D( AS_NAME, NAME ), H );        DESIGNATOR := D( AS_DESIGNATOR, NAME );     
 else        DESIGNATOR := NAME;      end if;떰      D( SM_DEFN, DESIGNATOR, TREE_VOID );      DEFLIST := LIST( D( LX
_SYMREP, DESIGNATOR ) );       while not IS_EMPTY( DEFLIST ) loop        POP( DEFLIST, DEF );떰        if D( XD_REGIO
N, D( XD_SOURCE_NAME, DEF ) ) = D( XD_SOURCE_NAME, H.REGION_DEF ) then          DEFN := D( XD_SOURCE_NAME, DEF);      
    if DEFN.TY = DN_TYPE_ID or else DEFN.TY in CLASS_UNIT_NAME then            DEFN := D( SM_FIRST, DEFN );          e
nd if;          D( SM_DEFN, DESIGNATOR, DEFN );          exit;        end if;떰      end loop;떰      DEFN := D( SM_D
EFN, DESIGNATOR );      if DEFN = TREE_VOID then        PUT_LINE( "!! DEFN NOT FOUND FOR ANCESTOR" );        raise PR
OGRAM_ERROR;      end if;      DES_DEF := DEF_UTIL.GET_DEF_FOR_ID( DEFN );      D( XD_REGION_DEF, DES_DEF, H.REGION_D
EF );      NOD_WALK.ENTER_BODY( DES_DEF, H, S );떰    end촃NTER_ANCESTOR_REGION;땝---------------------떰떰К---------
땝procedureКWALK_ITEMК( ITEM :TREE; H_IN :H_TYPE )    is      H: H_TYPE:= H_IN;    begin      NOD_WALK.WALK( ITE
M, H );    end촜ALK_ITEM;땝---------떰        begin    if  ALL_DECL.TY = DN_VOID  then      ERROR( D( LX_SRCPOS, CO
MPILATION_UNIT ), "$$$ EMPTY UNIT NOT IMPLEMENTED YET" );      return;    end if;떰    USED_PACKAGE_LIST := (TREE_NIL,
 TREE_NIL);    FIX_WITH.FIX_WITH_CLAUSES( COMPILATION_UNIT );    INITIALIZE_PREDEFINED_TYPES;떰    PROCESS_CONTEXT_CLA
USES( COMPILATION_UNIT );떰    declare      HК: H_TYPEК:= INITIAL_H;    begin      H.REGION_DEF := PREDEFINED_STAND
ARD_DEF;      H.LEX_LEVEL  := 2;      H.IS_IN_SPEC := TRUE;      H.IS_IN_BODY := FALSE;떰      if  ALL_DECL.TY = DN_S
UBUNIT  then        ENTER_ANCESTOR_REGION( D( AS_NAME, ALL_DECL ), H );        WALK_ITEM( D( AS_SUBUNIT_BODY, ALL_DECL
 ), H );      else        WALK_ITEM( ALL_DECL, H);      end if;떰      NOD_WALK.WALK_ITEM_S( PRAGMA_S, H );떰      wh
ile  not IS_EMPTY( USED_PACKAGE_LIST )  loop        DB( XD_IS_USED, HEAD( USED_PACKAGE_LIST ), FALSE );        USED_PA
CKAGE_LIST := TAIL( USED_PACKAGE_LIST );      end loop;    end;떰  end촀OMPILE_COMPILATION_UNIT;땝--------------------
----떰떰К------------------  procedureКCANCEL_TRANS_WITHSК( COMPILATION_UNIT :TREE )땝К------------------  is   
 use DEF_UTIL;    TRANS_WITH_LISTК: SEQ_TYPE := LIST( COMPILATION_UNIT );    TRANS_WITHК: TREE;    ALL_DECLК: TRE
E;    UNIT_IDК: TREE;  begin    while not IS_EMPTY( TRANS_WITH_LIST ) loop      POP( TRANS_WITH_LIST, TRANS_WITH );
떰      ALL_DECL := D( AS_ALL_DECL, D( TW_COMP_UNIT, TRANS_WITH ) );      if ALL_DECL.TY /= DN_SUBUNIT then        UNI
T_ID := D( AS_SOURCE_NAME, ALL_DECL );        if UNIT_ID.TY in CLASS_UNIT_NAME and then D( SM_FIRST, UNIT_ID ) = UNIT_I
D then          DEF_UTIL.REMOVE_DEF_FROM_ENVIRONMENT( GET_DEF_FOR_ID( UNIT_ID ) );        end if;      else        U
NIT_ID := D( SM_FIRST, D( AS_SOURCE_NAME, D( AS_SUBUNIT_BODY, ALL_DECL ) ) );        REMOVE_DEF_FROM_ENVIRONMENT( GET_D
EF_FOR_ID( UNIT_ID ) );      end if;떰    end loop;    REMOVE_DEF_FROM_ENVIRONMENT( PREDEFINED_STANDARD_DEF );떰  end
CANCEL_TRANS_WITHS;땝------------------떰땝К-------  procedureКFIX_PREКis separate;땝К-------떰턡egin  OPEN_IDL_TR
EE_FILE( IDL.LIB_PATH( 1..LIB_PATH_LENGTH ) & "$$$.TMP" );        if  DI( XD_ERR_COUNT, TREE_ROOT ) = 0  then    decl
are      USER_ROOTК: TREEК:= D( XD_USER_ROOT, TREE_ROOT );      COMPILATIONК: TREEК:= D( XD_STRUCTURE, USER_ROOT )
;      COMPLTN_UNIT_LIST: SEQ_TYPE:= LIST( D( AS_COMPLTN_UNIT_S, COMPILATION ) );      COMPILATION_UNIT: TREE;    
  SRC_NAMEК:constant STRING:= PRINT_NAME( D( XD_SOURCENAME, USER_ROOT ) );    begin              if  SRC_NAME = "_s
tandrd.ads"  then떰        FIX_PRE;                     else        SEM_GLOB.INITIALIZE_GLOBAL_DATA;        INITIALI
ZE_PRAGMA_ATTRIBUTE_DEFS;                    while  not IS_EMPTY( COMPLTN_UNIT_LIST )  loop          POP( COMPLTN_UNI
T_LIST, COMPILATION_UNIT );떰          COMPILE_COMPILATION_UNIT( COMPILATION_UNIT, INITIAL_H );떰          if  not IS_EM
PTY( COMPLTN_UNIT_LIST )  then            CANCEL_TRANS_WITHS( COMPILATION_UNIT );          end if;        end loop; 
     end if;    end;  end if;        CLOSE_PAGE_MANAGER;떰end촕EM_PHASE;땝---------
