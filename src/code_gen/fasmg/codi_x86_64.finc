;				-----------------------------
;				MACROS FASMG POUR CODI x86 64
;				-----------------------------

	; sur processeur x86 64 les push et pop se font en 64 bits (qword)
	; mais on a choisi de faire les opérations en 32 bits pour rester comme sur une architecture 32 bits

postpone					; sera fait en toute toute fin car c'est le premier postpone
  ASM_SIZE = $-0x400078
end postpone

macro show description, value

  repeat 1, d:value
    display description,`d,13,10
  end repeat

end macro


macro push_T
  db 0x50						; push rax
end macro


macro DROP
  db 0x58						; pop rax
end macro


macro pop_N
  db 0x5B						; pop rbx
end macro


macro align_b
end macro

macro align_w
  desalign = $ mod 2
  if desalign <> 0
    repeat 2-desalign
      db 0x90
    end repeat
  end if
end macro


macro align_d
  desalign = $ mod 4
  if desalign <> 0
    repeat 4-desalign
      db 0x90
    end repeat
  end if
end macro


macro align_q
  desalign = $ mod 8
  if desalign <> 0
    repeat 8-desalign
      db 0x90
    end repeat
  end if
end macro

last_instr_was_POP = 0				; sert à faire du peep-hole sur POP - PUSH
last_instr_was_PUSH = 0				; sert à faire du peep-hole sur PUSH - POP

;			-------
macro			PUT_STR?			; affiche une chaine sur stdout
;			-------
  db 0x48, 0x89, 0xC6				; mov rsi, rax  (esi=T  adresse des caracteres a afficher)
  db 0x8B, 0x50, 0xFC				; mov EDX, dword ptr[rax-4]   EDX=last
  db 0xFF, 0xC2					; inc EDX
  db 0x2B, 0x50, 0xF8				; sub EDX, dword ptr [rax-8]   EDX=length
  db 0x6A, 0x01					; push 1 (sys_write rax=1)
  db 0x58						; pop rax
  db 0x48, 0x89,0xC7				; mov rdi,rax (stdout=1)
  db 0x0F, 0x05					; syscall
  DROP						; pop rax   T:=N
end macro


;			-------
macro			SYSEXIT?			; retour au systeme
;			-------
  db 0x6A, 0x3C					; push x3C  (sys_exit rax=60)
  db 0x58						; pop rax
  db 0x31, 0xFF					; xor edi, edi (err_code=0)
  db 0x0F, 0x05					; syscall

end macro

;				--------------------------------------------------------------------------------
;				CONSTANTES IMMEDIATES
;				--------------------------------------------------------------------------------

;			-------------
macro			LI?	val		; Load Immediate
;			-------------
  push_T
  if val > -128 & val < 127
    db 0x6A, val					; push byte val8
  else
    db 0x68					; push double val32
    dd val
  end if
end macro

;			-------------
macro			LIF?	val		; Load Immediate Float
;			-------------
  if val = 1.0
    db 0xD9, 0xE8					; fld1
  else
    db 0x68					; push double val32
    dd val
  end if
end macro

;			-------------
macro			LCA?	ptr		; Load Constant Address
;			-------------
  db 0x48, 0x8D, 0x04, 0x25				; lea rax, qword ptr [ptr]
  dd ptr
  db 0x50						; push rax
end macro

;				--------------------------------------------------------------------------------
;				LOAD (relatif pointeurs de frame du display R8..r15 suivant lvl)
;				--------------------------------------------------------------------------------

;			-------------------
macro			Lb?	lvl, disp		; Load Byte 8 bits
;			-------------------
  assert lvl >= 0 & lvl <= 7
    ofs = -disp					; pile croissante vers adresses decroissantes
  push_T
  if ofs > -128 & ofs < 127
    db 0x49, 0x0F, 0xBE, 0x40+lvl			; movsx rax, byte ptr [r(8+lvl)+ofs8]   T:=ofs(FP)
    db ofs
  else
    db 0x49, 0x0F, 0xBE, 0x80+lvl			; movsx rax, byte ptr [r(8+lvl)+ofs32]
    dd ofs
  end if
  db 0x50						; push rax

end macro

;			-------------------
macro			LIb?	lvl, disp		; Load Indirect byte
;			-------------------
  assert lvl >= 0 & lvl <= 7
  if disp > -128 & disp < 127
    db 0x49, 0x8B, 0x40+lvl				; mov rax, qword ptr [r(8+lvl)+ofs8]   T:=ofs(FP)
    db disp
  else
    db 0x49, 0x8B, 0x80+lvl				; mov rax, qword ptr [r(8=lvl)+ofs32]
    dd disp
  end if
  db 0x48, 0x0F, 0xBE, 0x00				; movsx rax, byte ptr [rax]
  db 0x50						; push rax

end macro

;			-------------------
macro			Lw?	lvl, disp		; Load Word 16 bits
;			-------------------
  assert lvl >= 0 & lvl <= 7
    ofs = -disp					; pile croissante vers adresses decroissantes
  push_T
  if ofs > -128 & ofs < 127
    db 0x49, 0x0F, 0xBF, 0x40+lvl			; movsx rax, word ptr [r(8+lvl)+ofs8]   T:=ofs(FP)
    db ofs
  else
    db 0x49, 0x0F, 0xBF, 0x80+lvl			; movsx rax, word ptr [r(8+lvl)+ofs32]
    dd ofs
  end if
  db 0x50						; push rax

end macro

;			-------------------
macro			LIw?	lvl, disp		; Load Indirect word 
;			-------------------
  assert lvl >= 0 & lvl <= 7
  if disp > -128 & disp < 127
    db 0x49, 0x8B, 0x40+lvl				; mov rax, qword ptr [r(8+lvl)+ofs8]   T:=ofs(FP)
    db disp
  else
    db 0x49, 0x8B, 0x80+lvl				; mov rax, qword ptr [r(8=lvl)+ofs32]
    dd disp
  end if
  db 0x48, 0x0F, 0xBF, 0x00				; movsx rax, word ptr [rax]
  db 0x50						; push rax

end macro

;			-------------------
macro			Ld?	lvl, disp		; Load doubleword 32 bits
;			-------------------
  assert lvl >= 0 & lvl <= 7
    ofs = -disp					; pile croissante vers adresses decroissantes
  push_T
  if ofs > -128 & ofs < 127
    db 0x49, 0x63, 0x40+lvl				; movsx rax, dword ptr [r(8+lvl)+ofs8]   T:=ofs(FP)
    db ofs
  else
    db 0x49, 0x63, 0x80+lvl				; movsx rax, dword ptr [r(8+lvl)+ofs32]
    dd ofs
  end if
  db 0x50						; push rax

end macro

;			-------------------
macro			LId?	lvl, disp		; Load Indirect doubleword
;			-------------------
  assert lvl >= 0 & lvl <= 7
  if disp > -128 & disp < 127
    db 0x49, 0x8B, 0x40+lvl				; mov rax, qword ptr [r(8+lvl)+ofs8]   T:=ofs(FP)
    db disp
  else
    db 0x49, 0x8B, 0x80+lvl				; mov rax, qword ptr [r(8=lvl)+ofs32]
    dd disp
  end if
  db 0x48, 0x63, 0x00				; movsx rax, dword ptr [rax]
  db 0x50						; push rax

end macro

;			-------------------
macro			Lq?	lvl, disp		; Load quadword 64 bits
;			-------------------
  assert lvl >= 0 & lvl <= 7
  ofs = -disp					; pile croissante vers adresses decroissantes
  push_T
  if ofs > -128 & ofs < 127
    db 0x49, 0x8B, 0x40+lvl				; mov rax, qword ptr [r(8+lvl)+ofs8]   T:=ofs(FP)
    db ofs
  else
    db 0x49, 0x8B, 0x80+lvl				; mov rax, qword ptr [r(8=lvl)+ofs32]
    dd ofs
  end if
  db 0x50						; push rax

end macro

;			-------------------
macro			LIq?	lvl, disp		; Load Indirect quadword 
;			-------------------
  assert lvl >= 0 & lvl <= 7
  if disp > -128 & disp < 127
    db 0x49, 0x8B, 0x40+lvl				; mov rax, qword ptr [r(8+lvl)+ofs8]   T:=ofs(FP)
    db disp
  else
    db 0x49, 0x8B, 0x80+lvl				; mov rax, qword ptr [r(8=lvl)+ofs32]
    dd disp
  end if
  db 0x48, 0x8B, 0x00				; mov rax, qword ptr [rax]
  db 0x50						; push rax

end macro

;			-------------------
macro			La?	lvl, disp		; Load Address 64 bits
;			-------------------
  Lq lvl, disp
end macro

;			-------------------
macro			LVa?	lvl, disp		; Load Variable Address pour lvl et disp
;			-------------------
  assert lvl >= 0 & lvl <= 7
  ofs = -disp					; pile croissante vers adresses decroissantes
  push_T
  if ofs > -128 & ofs < 127
    db 0x49, 0x8D, 0x40+lvl				; lea rax, [r(8+lvl)+ofs8]   T:=ofs(FP)
    db ofs
  else
    db 0x49, 0x8D, 0x80+lvl				; lea rax, qword ptr [r(8=lvl)+ofs32]
    dd ofs
  end if
  db 0x50						; push rax

end macro

;				--------------------------------------------------------------------------------
;				STORE (relatif pointeurs de frame du display R8..r15 suivant lvl)
;				--------------------------------------------------------------------------------

;			------------------------
macro			Sb?	lvl:-1, disp:0	; Store byte 8 bits
;			------------------------
  if lvl = -1					; top stacked adress
    db 0x58					; pop rax   adress for data
    db 0x5B					; pop rbx   data
    db 0x88, 0x18					; mov byte ptr [rax], BL   store
  else						; regular framed byte
    assert lvl >= 0 & lvl <= 7
    ofs = -disp					; pile croissante vers adresses decroissantes
    db 0x58					; pop rax   data
    if ofs > -128 & ofs < 127
      db 0x41, 0x88, 0x40+lvl				; mov byte ptr [r(8+lvl)+ofs8], AL   store
      db ofs
    else
      db 0x41, 0x88, 0x80+lvl				; mov byte ptr [r(8+lvl)+ofs32], AL   store
      dd ofs
    end if
  end if
end macro

;			------------------------
macro			SIb?	lvl:-1, disp:0	; Store Indirect byte
;			------------------------
  if lvl = -1					; top stacked adress of adress
    db 0x58					; pop rax   adress of adress for data
    db 0x48, 0x8B, 0x00				; mov rax, qword ptr [rax]   fetch adress
  else						; regular framed adress of byte
    assert lvl >= 0 & lvl <= 7
    if disp > -128 & disp < 127
      db 0x49, 0x8B, 0x40+lvl				; mov rax, qword ptr [r(8+lvl)+ofs8]   fetch adress
      db disp
    else
      db 0x49, 0x8B, 0x80+lvl				; mov rax, qword ptr [r(8=lvl)+ofs32]   fetch adress
      dd disp
    end if
  end if
  db 0x5B						; pop rbx   data
  db 0x88, 0x18					; mov byte ptr [rax], BL   store

end macro

;			------------------------
macro			Sw?	lvl:-1, disp:0	; Store word 16 bits
;			------------------------
  if lvl = -1					; top stacked adress
    db 0x58					; pop rax   adress for data
    db 0x5B					; pop rbx   data
    db 0x66, 0x89, 0x18				; mov word ptr [rax], BX   store
  else						; regular framed byte
    assert lvl >= 0 & lvl <= 7
    ofs = -disp					; pile croissante vers adresses decroissantes
    db 0x58					; pop rax
    if ofs > -128 & ofs < 127
      db 0x66, 0x41, 0x89, 0x40+lvl			; mov word ptr [r(8+lvl)+ofs8], AX
      db ofs
    else
      db 0x66, 0x41, 0x89, 0x80+lvl			; mov word ptr [r(8+lvl)+ofs32], AX
      dd ofs
    end if
  end if

end macro

;			-------------------
macro			SIw?	lvl, disp		; Store Indirect word
;			-------------------
  assert lvl >= 0 & lvl <= 7
  db 0x5B						; pop rbx
  if disp > -128 & disp < 127
    db 0x49, 0x8B, 0x40+lvl				; mov rax, qword ptr [r(8+lvl)+ofs8]   T:=ofs(FP)
    db disp
  else
    db 0x49, 0x8B, 0x80+lvl				; mov rax, qword ptr [r(8=lvl)+ofs32]
    dd disp
  end if
  db 0x66, 0x89, 0x18				; mov word ptr [rax], BX

end macro

;			------------------------
macro			Sd?	lvl:-1, disp:0	; Store doubleword 32 bits
;			------------------------
  if lvl = -1					; top stacked adress
    db 0x58					; pop rax   adress for data
    db 0x5B					; pop rbx   data
    db 0x89, 0x18					; mov dword ptr [rax], EBX   store
  else						; regular framed byte
    assert lvl >= 0 & lvl <= 7
    ofs = -disp					; pile croissante vers adresses decroissantes
    db 0x58					; pop rax
    if ofs > -128 & ofs < 127
      db 0x41, 0x89, 0x40+lvl				; mov dword ptr [r(8+lvl)+ofs8], EAX
      db ofs
    else
      db 0x41, 0x89, 0x80+lvl				; mov dword ptr [r(8+lvl)+ofs32], EAX
      dd ofs
    end if
  end if

end macro

;			-------------------
macro			SId?	lvl, disp		; Store Indirect doubleword 
;			-------------------
  assert lvl >= 0 & lvl <= 7
  db 0x5B						; pop rbx
  if disp > -128 & disp < 127
    db 0x49, 0x8B, 0x40+lvl				; mov rax, qword ptr [r(8+lvl)+ofs8]   T:=ofs(FP)
    db disp
  else
    db 0x49, 0x8B, 0x80+lvl				; mov rax, qword ptr [r(8=lvl)+ofs32]
    dd disp
  end if
  db 0x89, 0x18					; mov dword ptr [rax], EBX

end macro

;			-------------------
macro			Sq?	lvl, disp		; Store Quadword 64 bits
;			-------------------
  assert lvl >= 0 & lvl <= 7
  ofs = -disp					; pile croissante vers adresses decroissantes
  db 0x58						; pop rax
  if ofs > -128 & ofs < 127
    db 0x49, 0x89, 0x40+lvl				; mov qword ptr [rbp+ofs8], rax
    db ofs
  else
    db 0x49, 0x89, 0x80+lvl				; mov qword ptr [rbp+ofs32], rax
    dd ofs
  end if

end macro

;			-------------------
macro			SIq?	lvl, disp		; Store Indirect quadword
;			-------------------
  assert lvl >= 0 & lvl <= 7
  db 0x5B						; pop rbx
  if disp > -128 & disp < 127
    db 0x49, 0x8B, 0x40+lvl				; mov rax, qword ptr [r(8+lvl)+ofs8]   T:=ofs(FP)
    db disp
  else
    db 0x49, 0x8B, 0x80+lvl				; mov rax, qword ptr [r(8=lvl)+ofs32]
    dd disp
  end if
  db 0x48, 0x89, 0x18				; mov qword ptr [rax], rbx

end macro

;			-------------------
macro			Sa?	lvl, disp		; Store Address 64 bits
;			-------------------
  Sq lvl, disp
end macro

;				--------------------------------------------------------------------------------
;				OPERATIONS LOGIQUES
;				--------------------------------------------------------------------------------
;			---
macro			ET?
;			---
  db 0x58, 0x48, 0x21, 0x04, 0x24			; pop rax     and qword ptr [rsp], rax

end macro

;			--
macro			OU?
;			--
  db 0x58, 0x48, 0x09, 0x04, 0x24			; pop rax     or qword ptr [rsp], rax

end macro

;			---
macro			NON?
;			---
  db 0x48, 0xF7, 0x14, 0x24				; not qword ptr [rsp]

end macro

;			---
macro			OUX?
;			---
  db 0x58, 0x48, 0x31, 0x04, 0x24			; pop rax     xor qword ptr [rsp], rax

end macro

;				--------------------------------------------------------------------------------
;				OPERATIONS ARITHMETIQUE ENTIERE
;				--------------------------------------------------------------------------------

;			---
macro			NEG?
;			---
  db 0x48, 0xF7, 0x1C, 0x24				; neg qword ptr [rsp]
end macro

;			---
macro			ADD?
;			---
  db 0x58, 0x48, 0x01, 0x04, 0x24			; pop rax     add qword ptr [rsp], rax
end macro

;			---
macro			SUB?
;			---
  db 0x58, 0x48, 0x29, 0x04, 0x24			; pop rax     sub qword ptr [rsp], rax

end macro

;			---
macro			MUL?
;			---
  db 0x58						; pop rax
  db 0x48, 0xF7, 0x2C, 0x24				; imul qword ptr [rsp]
  db 0x50						; push rax

end macro

;			---
macro			DIV?
;			---
  db 0x5B						; pop rbx
  db 0x58						; pop rax
  db 0x48, 0x31, 0xD2				; xor rdx, rdx
  db 0x48, 0xF7, 0xFB				; idiv rbx
  db 0x50						; push rax

end macro

;			---
macro			REM?
;			---
  db 0x5B						; pop rbx
  db 0x58						; pop rax
  db 0x48, 0x31, 0xD2				; xor rdx, rdx
  db 0x48, 0xF7, 0xFB				; idiv rbx
  db 0x52						; push rdx

end macro

;			---
macro			CGT?
;			---
  db 0x5B						; pop rbx   (TOP)
  db 0x48, 0x39, 0x1C, 0x24				; cmp [rsp], rbx   (NXT > TOP ?)
  db 0x0F, 0x9F, 0x04, 0x24				; setg [rsp]

end macro

;			---
macro			CEQ?
;			---
  db 0x5B						; pop rbx   (TOP)
  db 0x48, 0x39, 0x1C, 0x24				; cmp [rsp], rbx   (NXT = TOP ?)
  db 0x0F, 0x94, 0x04, 0x24				; sete [rsp]

end macro

;			---
macro			DEC?
; 			---
  db 0x48, 0xFF, 0x0C, 0x24				; dec qword ptr [rsp]

end macro

;			---
macro			INC?
;			---
  db 0x48, 0xFF, 0x04, 0x24				; inc qword ptr [rsp]
end macro

;				--------------------------------------------------------------------------------
;				OPERATIONS CONTROLE DE FLOT
;				--------------------------------------------------------------------------------

;			-------------
macro			BRA?	lbl
;			-------------
  local disp
  if disp > -128 & disp < 127
    db 0xEB					; jmp rel8
    db disp
  else
    db 0xE9					; jmp rel32
    dd disp
  end if
  disp = lbl-$

end macro

;			-------------
macro			BT?	lbl
;			-------------
  db 0x58						; pop rax
  db 0x08, 0xC0					; or AL, AL
  local disp
  if disp > -128 & disp < 127
    db 0x75					; jnz rel8
    db disp
  else
    db 0x0F, 0x85					; jnz rel32
    dd disp
  end if
  disp = lbl-$

end macro

;			-------------
macro			BF?	lbl
;			-------------
  db 0x58						; pop rax
  db 0x08, 0xC0					; or AL, AL
  local disp
  if disp > -128 & disp < 127
    db 0x74					; jz rel8
    db disp
  else
    db 0x0F, 0x84					; jz rel32
    dd disp
  end if
  disp = lbl-$

end macro



;			---------------
macro			CALL?	entry
;			---------------
  local disp
  db 0xE8
  dd disp
  disp = entry-$

end macro


;			--------------------
macro			LINK?	lvl, alloc	; ALLOCATION POUR VARIABLES LOCALES SOUS FRAME PTR
;			--------------------
  assert lvl>=0 & lvl<=7
  db 0x41, 0x50+lvl					; push r(8+lvl)   store FP(lvl)
  db 0x49, 0x89, 0xE0+lvl				; mov r(8+lvl), rsp   update FP
  assert alloc >= 0
  if alloc <> 0
    if alloc < 256
      db 0x48, 0x83, 0xEC, alloc			; sub rsp, alloc
    else
      db 0x48, 0x81, 0xEC
      dd alloc
    end if
  end if

end macro


;			-------------
macro			UNLINK?	lvl		; DISPOSE VARS LOCALES ET RESTORE FRAME PTR
;			-------------
  db 0x4C, 0x89, 0xC4+8*lvl				; mov rsp, r(8+lvl)   throw locals
  db 0x41, 0x58+lvl					; pop r(8+lvl)  restore stored FP

end macro

;			--------------------
macro			RTD?	prm_size:0
;			--------------------
  if prm_size <> 0
    assert prm_size > 0 & prm_size < 32768
    db 0xC2
    dw prm_size
  else
    db 0xC3
  end if

end macro

;			-------------
macro			SUBP	sub_name_lbl	; Début de procédure
;			-------------
  namespace sub_name_lbl
  BRA post

end macro

;			----
macro			PRMS			; En tête de la définition des paramètres
;			----
  virtual at 16
    PRMzone::
  end virtual

end macro

;			---
macro			PRM	name_adrofs	; Définition de paramètre
;			---
  virtual PRMzone
    name_adrofs = $
    dq ?
  end virtual

end macro

;			-------
macro			endPRMS			; Fin de la définition des paramètres
;			-------
  virtual PRMzone
    prm_siz = $
  end virtual

end macro

;			-------------
macro			ELAB	lvl		; En tête de la partie élaboration de procédure
;			-------------
elab:
  virtual at 8
    VARzone::
  end virtual
	LINK lvl,	loc_siz

end macro

;			-----------------------
macro			VAR	name_disp, sizChar	; Définition d'un lieu de variable
;			-----------------------
  virtual VARzone
    align_#sizChar
    name_disp = $
    d#sizChar ?
  end virtual

end macro

;			-------
macro			endSUBP			; Fin de procédure
;			-------
post:
  virtual VARzone
    loc_siz = $
  end virtual
  end namespace

end macro

;				---------------------------------------------
;				MISE EN PLACE ENTETE ELF 64 POUR LINUX X86-64
;				---------------------------------------------

ELFCLASS64	= 2
ELFDATA2LSB	= 1
EV_CURRENT	= 1
ET_EXEC		= 2
SYSTEM_V		= 0
EM_X86_64		= 62

org 0x400000				; adresse entree programme linux

Elf64_Header:
	e_ident		db 0x7F,'ELF', ELFCLASS64, ELFDATA2LSB, EV_CURRENT, SYSTEM_V, (0x400010-$) dup 0
	e_type		dw ET_EXEC
	e_machine		dw EM_X86_64
	e_version		dd EV_CURRENT
	e_entry		dq 0x00400078
	e_phoff		dq 64
	e_shoff		dq 0
	e_flags		dd 0
	e_ehsize		dw 64
	e_phentsize	dw 56
	e_phnum		dw 1
	e_shentsize	dw 0
	e_shnum		dw 0
	e_shstrndx	dw 0
Elf64_Phdr:
	p_type		dd 1		; PT_LOAD
	p_flags		dd 7		; RWX
	p_offset		dq 0x78
	p_vaddr		dq 0x00400078
	p_paddr		dq 0
	p_filesz		dq ASM_SIZE
	p_memsz		dq 1024*1024
	p_align		dq 4096


virtual at 8
  VARzone::
  VARzone.DISP = $
end virtual


