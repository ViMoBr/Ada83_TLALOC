with EMITS, DIANA_NODE_ATTR_CLASS_NAMES, IDL, Text_IO;
use EMITS, DIANA_NODE_ATTR_CLASS_NAMES, IDL, Text_IO;
--------
procedure CODE_GEN
         --------
         is

         procedure CODE_root (root : TREE);
         procedure CODE_user_root (user_root : TREE);
         procedure CODE_compilation (compilation : TREE);
         procedure CODE_compltn_unit_s (compltn_unit_s : TREE);
         procedure CODE_compilation_unit (compilation_unit : TREE);
         procedure CODE_context_elem_s (context_elem_s : TREE);
         procedure CODE_CONTEXT_ELEM (CONTEXT_ELEM : TREE);
         procedure CODE_context_pragma (context_pragma : TREE);
         procedure CODE_with (ada_with : TREE);
         procedure CODE_ALL_DECL (ALL_DECL : TREE);
         procedure CODE_subunit (subunit : TREE);
         procedure CODE_block_master (block_master : TREE);
         procedure CODE_item_s (item_s : TREE);
         procedure CODE_ITEM (ITEM : TREE);
         procedure CODE_SUBUNIT_BODY (SUBUNIT_BODY : TREE);
         procedure CODE_subprogram_body (subprogram_body : TREE);
         procedure CODE_package_body (package_body : TREE);
         procedure CODE_task_body (task_body : TREE);
         procedure CODE_DECL (DECL : TREE);
         procedure CODE_null_comp_decl (null_comp_decl : TREE);
         procedure CODE_ID_DECL (ID_DECL : TREE);
         procedure CODE_type_decl (type_decl : TREE);
         procedure CODE_subtype_decl (subtype_decl : TREE);
         procedure CODE_task_decl (task_decl : TREE);
         procedure CODE_SIMPLE_RENAME_DECL (SIMPLE_RENAME_DECL : TREE);
         procedure CODE_renames_obj_decl (renames_obj_decl : TREE);
         procedure CODE_renames_exc_decl (renames_exc_decl : TREE);
         procedure CODE_UNIT_DECL (UNIT_DECL : TREE);
         procedure CODE_generic_decl (generic_decl : TREE);
         procedure CODE_NON_GENERIC_DECL (NON_GENERIC_DECL : TREE);
         procedure CODE_subprog_entry_decl (subprog_entry_decl : TREE);
         procedure CODE_package_decl (package_decl : TREE);
         procedure CODE_USE_PRAGMA (USE_PRAGMA : TREE);
         procedure CODE_use (ada_use : TREE);
         procedure CODE_pragma (ada_pragma : TREE);
         procedure CODE_ID_S_DECL (ID_S_DECL : TREE);
         procedure CODE_exception_decl (exception_decl : TREE);
         procedure CODE_deferred_constant_decl (deferred_constant_decl : TREE);
         procedure CODE_EXP_DECL (EXP_DECL : TREE);
         procedure CODE_number_decl (number_decl : TREE);
         procedure CODE_OBJECT_DECL (OBJECT_DECL : TREE);
         procedure CODE_constant_decl (constant_decl : TREE);
         procedure CODE_variable_decl (variable_decl : TREE);
         procedure CODE_REP (REP : TREE);
         procedure CODE_record_rep (record_rep : TREE);
         procedure CODE_ALIGNMENT_CLAUSE (ALIGNMENT_CLAUSE : TREE);
         procedure CODE_alignment (alignment : TREE);
         procedure CODE_NAMED_REP (NAMED_REP : TREE);
         procedure CODE_address (address : TREE);
         procedure CODE_length_enum_rep (length_enum_rep : TREE);
         procedure CODE_dscrmt_decl_s (dscrmt_decl_s : TREE);
         procedure CODE_dscrmt_decl (dscrmt_decl : TREE);
         procedure CODE_param_s (param_s : TREE);
         procedure CODE_PARAM (PARAM : TREE);
         procedure CODE_in (ada_in : TREE);
         procedure CODE_in_out (ada_in_out : TREE);
         procedure CODE_out (ada_out : TREE);
         procedure CODE_HEADER (HEADER : TREE);
         procedure CODE_package_spec (package_spec : TREE);
         procedure CODE_decl_s (decl_s : TREE);
         procedure CODE_SUBP_ENTRY_HEADER (SUBP_ENTRY_HEADER : TREE);
         procedure CODE_procedure_spec (procedure_spec : TREE);
         procedure CODE_function_spec (function_spec : TREE);
         procedure CODE_UNIT_DESC (UNIT_DESC : TREE);
         procedure CODE_derived_subprog (derived_subprog : TREE);
         procedure CODE_implicit_not_eq (implicit_not_eq : TREE);
         procedure CODE_BODY (ada_BODY : TREE);
         procedure CODE_block_body (block_body : TREE);
         procedure CODE_alternative_s (alternative_s : TREE);
         procedure CODE_ALTERNATIVE_ELEM (ALTERNATIVE_ELEM : TREE);
         procedure CODE_alternative (alternative : TREE);
         procedure CODE_alternative_pragma (alternative_pragma : TREE);
         procedure CODE_choice_s (choice_s : TREE);
         procedure CODE_CHOICE (CHOICE : TREE);
         procedure CODE_choice_exp (choice_exp : TREE);
         procedure CODE_choice_range (choice_range : TREE);
         procedure CODE_choice_others (choice_others : TREE);
         procedure CODE_stub (stub : TREE);
         procedure CODE_UNIT_KIND (UNIT_KIND : TREE);
         procedure CODE_RENAME_INSTANT (RENAME_INSTANT : TREE);
         procedure CODE_renames_unit (renames_unit : TREE);
         procedure CODE_instantiation (instantiation : TREE);
         procedure CODE_GENERIC_PARAM (GENERIC_PARAM : TREE);
         procedure CODE_name_default (name_default : TREE);
         procedure CODE_box_default (box_default : TREE);
         procedure CODE_no_default (no_default : TREE);
         procedure CODE_TYPE_DEF (TYPE_DEF, TYPE_DECL : TREE);
         procedure CODE_enumeration_def (enumeration_def : TREE);
         procedure CODE_enum_literal_s (enum_literal_s : TREE);
         procedure CODE_ENUM_LITERAL (ENUM_LITERAL : TREE);
         procedure CODE_enumeration_id (enumeration_id : TREE);
         procedure CODE_character_id (character_id : TREE);
         procedure CODE_formal_integer_def (formal_integer_def : TREE);
         procedure CODE_formal_fixed_def (formal_fixed_def : TREE);
         procedure CODE_formal_float_def (formal_float_def : TREE);
         procedure CODE_formal_dscrt_def (formal_dscrt_def : TREE);
         procedure CODE_private_def (private_def : TREE);
         procedure CODE_l_private_def (l_private_def : TREE);
         procedure CODE_record_def (record_def : TREE);
         procedure CODE_CONSTRAINED_DEF (CONSTRAINED_DEF, TYPE_DECL : TREE);
         procedure CODE_subtype_indication (subtype_indication : TREE);
         procedure CODE_integer_def (integer_def, TYPE_DECL : TREE);
         procedure CODE_fixed_def (fixed_def : TREE);
         procedure CODE_float_def (float_def : TREE);
         procedure CODE_ARR_ACC_DER_DEF (ARR_ACC_DER_DEF : TREE);
         procedure CODE_constrained_array_def (constrained_array_def : TREE);
         procedure CODE_unconstrained_array_def
                 (unconstrained_array_def : TREE);
         procedure CODE_access_def (access_def : TREE);
         procedure CODE_derived_def (derived_def : TREE);
         procedure CODE_SOURCE_NAME (SOURCE_NAME : TREE);
         procedure CODE_OBJECT_NAME (OBJECT_NAME : TREE);
         procedure CODE_UNIT_NAME (UNIT_NAME : TREE);
         procedure CODE_VC_NAME (VC_NAME : TREE);
         procedure CODE_variable_id (variable_id : TREE);
         procedure CODE_constant_id (constant_id : TREE);
         procedure CODE_number_id (number_id : TREE);
         procedure CODE_source_name_s (source_name_s : TREE);
         procedure CODE_TYPE_NAME (TYPE_NAME : TREE);
         procedure CODE_type_id (type_id : TREE);
         procedure CODE_subtype_id (subtype_id : TREE);
         procedure CODE_COMP_NAME (COMP_NAME : TREE);
         procedure CODE_component_id (component_id : TREE);
         procedure CODE_discriminant_id (discriminant_id : TREE);
         procedure CODE_NAME (NAME : TREE);
         procedure CODE_NAME_EXP (NAME_EXP : TREE);
         procedure CODE_DESIGNATOR (DESIGNATOR : TREE);
         procedure CODE_USED_NAME (USED_NAME : TREE);
         procedure CODE_used_op (used_op : TREE);
         procedure CODE_used_name_id (used_name_id : TREE);
         procedure CODE_USED_OBJECT (USED_OBJECT : TREE);
         procedure CODE_used_char (used_char : TREE);
         procedure CODE_used_object_id (used_object_id : TREE);
         procedure CODE_INDEXED (INDEXED : TREE);
         procedure CODE_slice (slice : TREE);
         procedure CODE_all (ada_all : TREE);
         procedure CODE_aggregate (aggregate : TREE);
         procedure CODE_short_circuit (short_circuit : TREE);
         procedure CODE_MEMBERSHIP (MEMBERSHIP : TREE);
         procedure CODE_range_membership (range_membership : TREE);
         procedure CODE_type_membership (type_membership : TREE);
         procedure CODE_EXP (EXP : TREE);
         procedure CODE_EXP_EXP (EXP_EXP : TREE);
         procedure CODE_EXP_VAL (EXP_VAL : TREE);
         procedure CODE_EXP_VAL_EXP (EXP_VAL_EXP : TREE);
         procedure CODE_AGG_EXP (AGG_EXP : TREE);
         procedure CODE_parenthesized (parenthesized : TREE);
         procedure CODE_numeric_literal (numeric_literal : TREE);
         procedure CODE_string_literal (string_literal : TREE);
         procedure CODE_null_access (null_access : TREE);
         procedure CODE_QUAL_CONV (QUAL_CONV : TREE);
         procedure CODE_conversion (conversion : TREE);
         procedure CODE_qualified (qualified : TREE);
         procedure CODE_qualified_allocator (qualified_allocator : TREE);
         procedure CODE_subtype_allocator (subtype_allocator : TREE);
         procedure CODE_stm_s (stm_s : TREE);
         procedure CODE_STM_ELEM (STM_ELEM : TREE);
         procedure CODE_stm_pragma (stm_pragma : TREE);
         procedure CODE_STM (STM : TREE);
         procedure CODE_labeled (labeled : TREE);
         procedure CODE_STM_WITH_EXP (STM_WITH_EXP : TREE);
         procedure CODE_STM_WITH_EXP_NAME (STM_WITH_EXP_NAME : TREE);
         procedure CODE_STM_WITH_NAME (STM_WITH_NAME : TREE);
         procedure CODE_CALL_STM (CALL_STM : TREE);
         procedure CODE_CLAUSES_STM (CLAUSES_STM : TREE);
         procedure CODE_LABEL_NAME (LABEL_NAME : TREE);
         procedure CODE_label_id (label_id : TREE);
         procedure CODE_null_stm (null_stm : TREE);
         procedure CODE_OBJECT (OBJECT : TREE);
         procedure CODE_ADRESSE (ADRESSE : TREE);
         procedure CODE_assign (assign : TREE);
         procedure CODE_if (ada_if : TREE);
         procedure CODE_TEST_CLAUSE (TEST_CLAUSE : TREE);
         procedure CODE_cond_clause (cond_clause : TREE);
         procedure CODE_case (ada_case : TREE);
         procedure CODE_BLOCK_LOOP (BLOCK_LOOP : TREE);
         procedure CODE_block_loop_id (block_loop_id : TREE);
         procedure CODE_ITERATION (ITERATION : TREE);
         procedure CODE_loop (ada_loop : TREE);
         procedure CODE_FOR_REV (FOR_REV : TREE);
         procedure CODE_for (ada_for : TREE);
         procedure CODE_reverse (ada_reverse : TREE);
         procedure CODE_iteration_id (iteration_id : TREE);
         procedure CODE_while (ada_while : TREE);
         procedure CODE_block (block : TREE);
         procedure CODE_exit (ada_exit : TREE);
         procedure CODE_return (ada_return : TREE);
         procedure CODE_goto (ada_goto : TREE);
         procedure CODE_NON_TASK_NAME (NON_TASK_NAME : TREE);
         procedure CODE_SUBPROG_PACK_NAME (SUBPROG_PACK_NAME : TREE);
         procedure CODE_SUBPROG_NAME (SUBPROG_NAME : TREE);
         procedure CODE_procedure_id (procedure_id : TREE);
         procedure CODE_function_id (function_id : TREE);
         procedure CODE_operator_id (operator_id : TREE);
         procedure CODE_INIT_OBJECT_NAME (INIT_OBJECT_NAME : TREE);
         procedure CODE_PARAM_NAME (PARAM_NAME : TREE);
         procedure CODE_PARAM_IO_O (PARAM_IO_O : TREE);
         procedure CODE_in_id (in_id : TREE);
         procedure CODE_in_out_id (in_out_id : TREE);
         procedure CODE_out_id (out_id : TREE);
         procedure CODE_procedure_call (procedure_call : TREE);
         procedure CODE_function_call (function_call : TREE);
         procedure CODE_package_id (package_id : TREE);
         procedure CODE_private_type_id (private_type_id : TREE);
         procedure CODE_l_private_type_id (l_private_type_id : TREE);
         procedure CODE_task_body_id (task_body_id : TREE);
         procedure CODE_entry_id (entry_id : TREE);
         procedure CODE_entry_call (entry_call : TREE);
         procedure CODE_accept (ada_accept : TREE);
         procedure CODE_delay (ada_delay : TREE);
         procedure CODE_selective_wait (selective_wait : TREE);
         procedure CODE_TEST_CLAUSE_ELEM (TEST_CLAUSE_ELEM : TREE);
         procedure CODE_test_clause_elem_s (test_clause_elem_s : TREE);
         procedure CODE_select_alternative (select_alternative : TREE);
         procedure CODE_select_alt_pragma (select_alt_pragma : TREE);
         procedure CODE_terminate (ada_terminate : TREE);
         procedure CODE_ENTRY_STM (ENTRY_STM : TREE);
         procedure CODE_cond_entry (cond_entry : TREE);
         procedure CODE_timed_entry (timed_entry : TREE);
         procedure CODE_name_s (name_s : TREE);
         procedure CODE_abort (ada_abort : TREE);
         procedure CODE_exception_id (exception_id : TREE);
         procedure CODE_raise (ada_raise : TREE);
         procedure CODE_generic_id (generic_id : TREE);
         procedure CODE_code (code : TREE);
         --|-------------------------------------------------------------------------------------------
         procedure CODE_root (root : TREE) is
         begin
                  CODE_user_root (D (xd_user_root, root));
         end CODE_root;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_user_root (user_root : TREE) is
         begin
                  CODE_compilation (D (xd_structure, user_root));
         end CODE_user_root;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_compilation (compilation : TREE) is
         begin
                  CODE_compltn_unit_s (D (as_compltn_unit_s, compilation));
         end CODE_compilation;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_compltn_unit_s (compltn_unit_s : TREE) is
         begin
                  declare
                           compltn_unit_seq : SEQ_TYPE :=
                                   LIST (compltn_unit_s);
                           compltn_unit     : TREE;
                  begin
                           while not IS_EMPTY (compltn_unit_seq) loop
                                    POP (compltn_unit_seq, compltn_unit);
                                    EMITS.OPEN_OUTPUT_FILE
                                            (GET_LIB_PREFIX &
                                             PRINT_NAME
                                                     (D (XD_LIB_NAME,
                                                               COMPLTN_UNIT)));
                                    CODE_compilation_unit (compltn_unit);
                                    EMITS.CLOSE_OUTPUT_FILE;
                           end loop;
                  end;
         end CODE_compltn_unit_s;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_compilation_unit (compilation_unit : TREE) is
         begin
                  EMITS.TOP_ACT        := 0;
                  EMITS.TOP_MAX        := 0;
                  EMITS.OFFSET_ACT     := 0;
                  EMITS.OFFSET_MAX     := 0;
                  EMITS.LEVEL          := 0;
                  EMITS.GENERATE_CODE  := False;
                  EMITS.CUR_COMP_UNIT  := 2;
                  EMITS.ENCLOSING_BODY := TREE_VOID;
                  CODE_context_elem_s
                          (D (as_context_elem_s, compilation_unit));
                  EMITS.CUR_COMP_UNIT := 0;
                  EMITS.GENERATE_CODE := True;
                  CODE_ALL_DECL (D (as_all_decl, compilation_unit));
                  EMIT (QUIT);
         end CODE_compilation_unit;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_context_elem_s (context_elem_s : TREE) is
         begin
                  declare
                           context_elem_seq : SEQ_TYPE :=
                                   LIST (context_elem_s);
                           context_elem     : TREE;
                  begin
                           while not IS_EMPTY (context_elem_seq) loop
                                    POP (context_elem_seq, context_elem);
                                    CODE_CONTEXT_ELEM (context_elem);
                           end loop;
                  end;
         end CODE_context_elem_s;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_CONTEXT_ELEM (CONTEXT_ELEM : TREE) is
         begin

                  if CONTEXT_ELEM.TY = DN_context_pragma then
                           CODE_context_pragma (CONTEXT_ELEM);

                  elsif CONTEXT_ELEM.TY = DN_with then
                           CODE_with (CONTEXT_ELEM);

                  end if;
         end CODE_CONTEXT_ELEM;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_context_pragma (context_pragma : TREE) is
         begin
                  null;
         end CODE_context_pragma;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_with (ADA_with : TREE) is
         begin
                  CODE_name_s (D (as_NAME_S, ADA_with));
         end CODE_with;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_ALL_DECL (ALL_DECL : TREE) is
         begin

                  if ALL_DECL.TY in CLASS_ITEM then
                           CODE_ITEM (ALL_DECL);

                  elsif ALL_DECL.TY = DN_subunit then
                           CODE_subunit (ALL_DECL);

                  elsif ALL_DECL.TY = DN_block_master then
                           CODE_block_master (ALL_DECL);

                  end if;
         end CODE_ALL_DECL;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_subunit (subunit : TREE) is
         begin
                  CODE_SUBUNIT_BODY (D (as_subunit_body, subunit));
         end CODE_subunit;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_block_master (block_master : TREE) is
         begin
                  null;
         end CODE_block_master;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_item_s (item_s : TREE) is
         begin
                  declare
                           item_seq : SEQ_TYPE := LIST (item_s);
                           item     : TREE;
                  begin
                           while not IS_EMPTY (item_seq) loop
                                    POP (item_seq, item);
                                    CODE_ITEM (item);
                           end loop;
                  end;
         end CODE_item_s;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_ITEM (ITEM : TREE) is
         begin

                  if ITEM.TY in CLASS_DECL then
                           CODE_DECL (ITEM);

                  elsif ITEM.TY in CLASS_SUBUNIT_BODY then
                           CODE_SUBUNIT_BODY (ITEM);

                  end if;
         end CODE_ITEM;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_SUBUNIT_BODY (SUBUNIT_BODY : TREE) is
         begin
                  declare
                           POST_LBL : LABEL_TYPE;
                  begin
                           if ENCLOSING_BODY /= TREE_VOID then
                                    POST_LBL := NEXT_LABEL;
                                    EMIT (JMP, POST_LBL,
                                             COMMENT => "CONTOURNEMENT");
                           end if;

                           if SUBUNIT_BODY.TY = DN_subprogram_body then
                                    CODE_subprogram_body (SUBUNIT_BODY);

                           elsif SUBUNIT_BODY.TY = DN_package_body then
                                    CODE_package_body (SUBUNIT_BODY);

                           elsif SUBUNIT_BODY.TY = DN_task_body then
                                    CODE_task_body (SUBUNIT_BODY);

                           end if;
                           if ENCLOSING_BODY /= TREE_VOID then
                                    WRITE_LABEL
                                            (POST_LBL,
                                             COMMENT =>
                                                     "FIN DE CONTOURNEMENT");
                           end if;
                  end;
         end CODE_SUBUNIT_BODY;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_subprogram_body (subprogram_body : TREE) is
         begin
                  declare
                           OLD_OFFSET_ACT : OFFSET_TYPE := EMITS.OFFSET_ACT;
                           OLD_OFFSET_MAX : OFFSET_TYPE := EMITS.OFFSET_MAX;
                           SOURCE_NAME    : TREE        :=
                                   D (AS_SOURCE_NAME, SUBPROGRAM_BODY);
                           START_LABEL    : LABEL_TYPE  := NEXT_LABEL;
                  begin
                           if EMITS.ENCLOSING_BODY = TREE_VOID then
                                    EMIT (PRO,
                                             S => PRINT_NAME
                                                             (D (LX_SYMREP,
                                                                       SOURCE_NAME)));
                           end if;
                           EMITS.OFFSET_ACT := EMITS.FIRST_PARAM_OFFSET;
                           EMITS.OFFSET_MAX := EMITS.OFFSET_ACT;
                           INC_LEVEL;
                           DI (CD_LABEL, SOURCE_NAME, INTEGER (START_LABEL));
                           DI (CD_LEVEL, SOURCE_NAME, EMITS.LEVEL);
                           WRITE_LABEL (START_LABEL, "Etiquette entree");
                           CODE_HEADER (D (as_header, subprogram_body));
                           DI (CD_PARAM_SIZE, SOURCE_NAME, PARAM_SIZE);
                           EMITS.OFFSET_ACT := EMITS.FIRST_LOCAL_VAR_OFFSET;
                           EMITS.OFFSET_MAX := EMITS.OFFSET_ACT;
                           CODE_BODY (D (as_BODY, subprogram_body));
                           DEC_LEVEL;
                           EMITS.OFFSET_MAX := OLD_OFFSET_MAX;
                           EMITS.OFFSET_ACT := OLD_OFFSET_ACT;
                  end;
         end CODE_subprogram_body;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_package_body (package_body : TREE) is
         begin
                  EMIT (PKB,
                           S => PRINT_NAME
                                           (D (LX_SYMREP,
                                                    D (AS_SOURCE_NAME,
                                                              PACKAGE_BODY))));
                  EMITS.GENERATE_CODE := False;
                  CODE_package_spec
                          (D (sm_spec, D (as_source_name, package_body)));
                  EMITS.GENERATE_CODE := True;
                  WRITE_LABEL (1);
                  CODE_BODY (D (as_body, package_body));
         end CODE_package_body;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_task_body (task_body : TREE) is
         begin
                  null;
         end CODE_task_body;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_DECL (DECL : TREE) is
         begin

                  if DECL.TY = DN_null_comp_decl then
                           CODE_null_comp_decl (DECL);

                  elsif DECL.TY in CLASS_ID_DECL then
                           CODE_ID_DECL (DECL);

                  elsif DECL.TY in CLASS_ID_S_DECL then
                           CODE_ID_S_DECL (DECL);

                  elsif DECL.TY in CLASS_REP then
                           CODE_REP (DECL);

                  elsif DECL.TY in CLASS_USE_PRAGMA then
                           CODE_USE_PRAGMA (DECL);

                  end if;
         end CODE_DECL;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_null_comp_decl (null_comp_decl : TREE) is
         begin
                  null;
         end CODE_null_comp_decl;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_ID_DECL (ID_DECL : TREE) is
         begin

                  if ID_DECL.TY = DN_type_decl then
                           CODE_type_decl (ID_DECL);

                  elsif ID_DECL.TY = DN_subtype_decl then
                           CODE_subtype_decl (ID_DECL);

                  elsif ID_DECL.TY = DN_task_decl then
                           CODE_task_decl (ID_DECL);

                  elsif ID_DECL.TY in CLASS_UNIT_DECL then
                           CODE_UNIT_DECL (ID_DECL);

                  elsif ID_DECL.TY in CLASS_SIMPLE_RENAME_DECL then
                           CODE_SIMPLE_RENAME_DECL (ID_DECL);

                  end if;
         end CODE_ID_DECL;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_type_decl (type_decl : TREE) is
         begin

                  if type_decl.TY = DN_type_decl then
                           CODE_TYPE_DEF
                                   (D (as_type_def, type_decl), type_decl);

                  end if;
         end CODE_type_decl;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_subtype_decl (subtype_decl : TREE) is
         begin
                  null;
         end CODE_subtype_decl;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_task_decl (task_decl : TREE) is
         begin
                  null;
         end CODE_task_decl;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_SIMPLE_RENAME_DECL (SIMPLE_RENAME_DECL : TREE) is
         begin

                  if SIMPLE_RENAME_DECL.TY = DN_renames_obj_decl then
                           CODE_renames_obj_decl (SIMPLE_RENAME_DECL);

                  elsif SIMPLE_RENAME_DECL.TY = DN_renames_exc_decl then
                           CODE_renames_exc_decl (SIMPLE_RENAME_DECL);

                  end if;
         end CODE_SIMPLE_RENAME_DECL;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_renames_obj_decl (renames_obj_decl : TREE) is
         begin
                  null;
         end CODE_renames_obj_decl;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_renames_exc_decl (renames_exc_decl : TREE) is
         begin
                  null;
         end CODE_renames_exc_decl;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_UNIT_DECL (UNIT_DECL : TREE) is
         begin

                  if UNIT_DECL.TY = DN_generic_decl then
                           CODE_generic_decl (UNIT_DECL);

                  elsif UNIT_DECL.TY in CLASS_NON_GENERIC_DECL then
                           CODE_NON_GENERIC_DECL (UNIT_DECL);

                  end if;
         end CODE_UNIT_DECL;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_generic_decl (generic_decl : TREE) is
         begin
                  null;
         end CODE_generic_decl;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_NON_GENERIC_DECL (NON_GENERIC_DECL : TREE) is
         begin

                  if NON_GENERIC_DECL.TY = DN_subprog_entry_decl then
                           CODE_subprog_entry_decl (NON_GENERIC_DECL);

                  elsif NON_GENERIC_DECL.TY = DN_package_decl then
                           CODE_package_decl (NON_GENERIC_DECL);

                  end if;
         end CODE_NON_GENERIC_DECL;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_subprog_entry_decl (subprog_entry_decl : TREE) is
         begin
                  declare
                           OLD_OFFSET_ACT : OFFSET_TYPE := EMITS.OFFSET_ACT;
                           OLD_OFFSET_MAX : OFFSET_TYPE := EMITS.OFFSET_MAX;
                           SOURCE_NAME    : TREE        :=
                                   D (AS_SOURCE_NAME, SUBPROG_ENTRY_DECL);
                           HEADER : TREE := D (AS_HEADER, SUBPROG_ENTRY_DECL);
                  begin
                           EMITS.OFFSET_ACT := EMITS.FIRST_PARAM_OFFSET;
                           EMITS.OFFSET_MAX := EMITS.OFFSET_ACT;
                           INC_LEVEL;
                           if SOURCE_NAME.TY in CLASS_SUBPROG_NAME then
                                    declare
                                             LBL : LABEL_TYPE := NEXT_LABEL;
                                    begin
                                             DI (CD_LABEL, SOURCE_NAME,
                                                      INTEGER (LBL));
                                             DI (CD_LEVEL, SOURCE_NAME,
                                                      EMITS.LEVEL);
                                             DB (CD_COMPILED, SOURCE_NAME,
                                                      TRUE);
                                             if not EMITS.GENERATE_CODE then
                                                      EMITS.GENERATE_CODE :=
                                                              True;
                                                      EMIT (RFL, LBL);
                                                      EMITS.GENERATE_CODE :=
                                                              False;
                                             end if;
                                             CODE_HEADER
                                                     (D (as_header,
                                                               subprog_entry_decl));
                                             DI (CD_PARAM_SIZE, SOURCE_NAME,
                                                      OFFSET_ACT -
                                                      FIRST_PARAM_OFFSET);
                                    end;
                                    if SOURCE_NAME.TY = DN_FUNCTION_ID or
                                            SOURCE_NAME.TY = DN_OPERATOR_ID
                                    then
                                             declare
                                                      USED_OBJECT_ID : TREE :=
                                                              D (AS_NAME,
                                                                       HEADER);
                                                      RESULT_TYPE_SPEC :
                                                              TREE :=
                                                              D (SM_EXP_TYPE,
                                                                       USED_OBJECT_ID);
                                             begin
                                                      DI (CD_RESULT_SIZE,
                                                               SOURCE_NAME,
                                                               EMITS.TYPE_SIZE
                                                                       (RESULT_TYPE_SPEC));
                                             end;
                                    end if;
                           end if;
                           DEC_LEVEL;
                           EMITS.OFFSET_MAX := OLD_OFFSET_MAX;
                           EMITS.OFFSET_ACT := OLD_OFFSET_ACT;
                  end;
         end CODE_subprog_entry_decl;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_package_decl (package_decl : TREE) is
         begin
                  EMIT (PKG,
                           S => PRINT_NAME
                                           (D (LX_SYMREP,
                                                    D (AS_SOURCE_NAME,
                                                              PACKAGE_DECL))));
                  WRITE_LABEL (1);
                  declare
                           L1 : LABEL_TYPE := NEXT_LABEL;
                           L2 : LABEL_TYPE := NEXT_LABEL;
                  begin
                           EMIT (ENT, Integer (1), L1);
                           EMIT (ENT, Integer (2), L2);
                           EMITS.OFFSET_ACT := 0;
                           EMITS.OFFSET_MAX := 0;
                           CODE_HEADER (D (as_header, package_decl));
                           declare
                                    EXC_LBL : LABEL_TYPE := NEXT_LABEL;
                           begin
                                    EMIT (EXH, EXC_LBL,
                                             COMMENT =>
                                                     "ETIQUETTE EXCEPTION HANDLE DU PACKAGE");
                                    EMIT (RET, RELATIVE_RESULT_OFFSET);
                                    WRITE_LABEL (EXC_LBL);
                           end;
                           EMIT (EEX);
                           GEN_LBL_ASSIGNMENT (L1, OFFSET_MAX);
                           GEN_LBL_ASSIGNMENT (L2, TOP_MAX + OFFSET_MAX);
                  end;
         end CODE_package_decl;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_USE_PRAGMA (USE_PRAGMA : TREE) is
         begin

                  if USE_PRAGMA.TY = DN_use then
                           CODE_use (USE_PRAGMA);

                  elsif USE_PRAGMA.TY = DN_pragma then
                           CODE_pragma (USE_PRAGMA);

                  end if;
         end CODE_USE_PRAGMA;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_use (ADA_use : TREE) is
         begin
                  null;
         end CODE_use;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_pragma (ADA_pragma : TREE) is
         begin
                  null;
         end CODE_pragma;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_ID_S_DECL (ID_S_DECL : TREE) is
         begin

                  if ID_S_DECL.TY in CLASS_EXP_DECL then
                           CODE_EXP_DECL (ID_S_DECL);

                  elsif ID_S_DECL.TY = DN_exception_decl then
                           CODE_exception_decl (ID_S_DECL);

                  elsif ID_S_DECL.TY = DN_deferred_constant_decl then
                           CODE_deferred_constant_decl (ID_S_DECL);

                  end if;
         end CODE_ID_S_DECL;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_exception_decl (exception_decl : TREE) is
         begin
                  CODE_source_name_s (D (as_source_name_s, exception_decl));
         end CODE_exception_decl;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_deferred_constant_decl (deferred_constant_decl : TREE)
         is
         begin
                  null;
         end CODE_deferred_constant_decl;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_EXP_DECL (EXP_DECL : TREE) is
         begin

                  if EXP_DECL.TY in CLASS_OBJECT_DECL then
                           CODE_OBJECT_DECL (EXP_DECL);

                  elsif EXP_DECL.TY = DN_number_decl then
                           CODE_number_decl (EXP_DECL);

                  end if;
         end CODE_EXP_DECL;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_number_decl (number_decl : TREE) is
         begin
                  null;
         end CODE_number_decl;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_OBJECT_DECL (OBJECT_DECL : TREE) is
         begin
                  declare
                           SRC_NAME_SEQ : SEQ_TYPE :=
                                   LIST (D (AS_SOURCE_NAME_S, OBJECT_DECL));
                           SRC_NAME     : TREE;
                           TYPE_DEF     : TREE := D (AS_TYPE_DEF, OBJECT_DECL);
                           TYPE_NAME    : TREE     := D (AS_NAME, TYPE_DEF);
                  begin
                           EMITS.TYPE_SYMREP := D (LX_SYMREP, TYPE_NAME);
                           while not IS_EMPTY (SRC_NAME_SEQ) loop
                                    POP (SRC_NAME_SEQ, SRC_NAME);
                                    CODE_VC_NAME (SRC_NAME);
                           end loop;
                  end;
         end CODE_OBJECT_DECL;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_constant_decl (constant_decl : TREE) is
         begin
                  null;
         end CODE_constant_decl;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_variable_decl (variable_decl : TREE) is
         begin
                  null;
         end CODE_variable_decl;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_REP (REP : TREE) is
         begin

                  if REP.TY in CLASS_NAMED_REP then
                           CODE_NAMED_REP (REP);

                  elsif REP.TY = DN_record_rep then
                           CODE_record_rep (REP);

                  end if;
         end CODE_REP;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_record_rep (record_rep : TREE) is
         begin
                  CODE_ALIGNMENT_CLAUSE (D (as_alignment_clause, record_rep));
         end CODE_record_rep;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_ALIGNMENT_CLAUSE (ALIGNMENT_CLAUSE : TREE) is
         begin
                  CODE_alignment (ALIGNMENT_CLAUSE);
         end CODE_ALIGNMENT_CLAUSE;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_alignment (alignment : TREE) is
         begin
                  null;
         end CODE_alignment;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_NAMED_REP (NAMED_REP : TREE) is
         begin

                  if NAMED_REP.TY = DN_address then
                           CODE_address (NAMED_REP);

                  elsif NAMED_REP.TY = DN_length_enum_rep then
                           CODE_length_enum_rep (NAMED_REP);

                  end if;
         end CODE_NAMED_REP;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_address (address : TREE) is
         begin
                  null;
         end CODE_address;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_length_enum_rep (length_enum_rep : TREE) is
         begin
                  null;
         end CODE_length_enum_rep;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_dscrmt_decl_s (dscrmt_decl_s : TREE) is
         begin
                  declare
                           dscrmt_decl_seq : SEQ_TYPE := LIST (dscrmt_decl_s);
                           dscrmt_decl     : TREE;
                  begin
                           while not IS_EMPTY (dscrmt_decl_seq) loop
                                    POP (dscrmt_decl_seq, dscrmt_decl);
                                    CODE_dscrmt_decl (dscrmt_decl);
                           end loop;
                  end;
         end CODE_dscrmt_decl_s;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_dscrmt_decl (dscrmt_decl : TREE) is
         begin
                  null;
         end CODE_dscrmt_decl;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_param_s (param_s : TREE) is
         begin
                  declare
                           param_seq : SEQ_TYPE := LIST (param_s);
                           param     : TREE;
                  begin
                           while not IS_EMPTY (param_seq) loop
                                    POP (param_seq, param);
                                    CODE_PARAM (param);
                           end loop;
                  end;
         end CODE_param_s;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_PARAM (PARAM : TREE) is
         begin

                  if PARAM.TY = DN_in then
                           CODE_in (PARAM);

                  elsif PARAM.TY = DN_out then
                           CODE_out (PARAM);

                  elsif PARAM.TY = DN_in_out then
                           CODE_in_out (PARAM);

                  end if;
         end CODE_PARAM;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_in (ADA_in : TREE) is
         begin
                  null;
         end CODE_in;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_in_out (ADA_in_out : TREE) is
         begin
                  null;
         end CODE_in_out;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_out (ADA_out : TREE) is
         begin
                  null;
         end CODE_out;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_HEADER (HEADER : TREE) is
         begin

                  if HEADER.TY in CLASS_SUBP_ENTRY_HEADER then
                           CODE_param_s (D (as_param_s, HEADER));
                           CODE_SUBP_ENTRY_HEADER (HEADER);

                  elsif HEADER.TY = DN_package_spec then
                           CODE_package_spec (HEADER);

                  end if;
         end CODE_HEADER;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_package_spec (package_spec : TREE) is
         begin
                  CODE_decl_s (D (as_decl_s1, package_spec));
         end CODE_package_spec;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_decl_s (decl_s : TREE) is
         begin
                  declare
                           decl_seq : SEQ_TYPE := LIST (decl_s);
                           decl     : TREE;
                  begin
                           while not IS_EMPTY (decl_seq) loop
                                    POP (decl_seq, decl);
                                    CODE_DECL (decl);
                           end loop;
                  end;
         end CODE_decl_s;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_SUBP_ENTRY_HEADER (SUBP_ENTRY_HEADER : TREE) is
         begin

                  if SUBP_ENTRY_HEADER.TY = DN_procedure_spec then
                           CODE_procedure_spec (SUBP_ENTRY_HEADER);

                  elsif SUBP_ENTRY_HEADER.TY = DN_function_spec then
                           CODE_function_spec (SUBP_ENTRY_HEADER);

                  end if;
         end CODE_SUBP_ENTRY_HEADER;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_procedure_spec (procedure_spec : TREE) is
         begin
                  EMITS.PARAM_SIZE :=
                          (EMITS.OFFSET_ACT - EMITS.FIRST_PARAM_OFFSET +
                           EMITS.RELATIVE_RESULT_OFFSET);
         end CODE_procedure_spec;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_function_spec (function_spec : TREE) is
         begin
                  INC_OFFSET (EMITS.RELATIVE_RESULT_OFFSET);
                  EMITS.PARAM_SIZE :=
                          (EMITS.OFFSET_ACT - EMITS.FIRST_PARAM_OFFSET);
                  DI (CD_RESULT_SIZE, D (AS_NAME, FUNCTION_SPEC),
                           EMITS.RESULT_SIZE);
                  INC_OFFSET (EMITS.RESULT_SIZE);
                  ALIGN (STACK_AL);
                  DI (CD_RESULT_OFFSET, FUNCTION_SPEC, EMITS.OFFSET_ACT);
                  EMITS.FUN_RESULT_OFFSET := EMITS.OFFSET_ACT;
         end CODE_function_spec;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_UNIT_DESC (UNIT_DESC : TREE) is
         begin

                  if UNIT_DESC.TY = DN_derived_subprog then
                           CODE_derived_subprog (UNIT_DESC);

                  elsif UNIT_DESC.TY = DN_implicit_not_eq then
                           CODE_implicit_not_eq (UNIT_DESC);

                  elsif UNIT_DESC.TY in CLASS_BODY then
                           CODE_BODY (UNIT_DESC);

                  elsif UNIT_DESC.TY in CLASS_UNIT_KIND then
                           CODE_UNIT_KIND (UNIT_DESC);

                  end if;
         end CODE_UNIT_DESC;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_derived_subprog (derived_subprog : TREE) is
         begin
                  null;
         end CODE_derived_subprog;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_implicit_not_eq (implicit_not_eq : TREE) is
         begin
                  null;
         end CODE_implicit_not_eq;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_BODY (ADA_BODY : TREE) is
         begin

                  if ADA_BODY.TY = DN_block_body then
                           CODE_block_body (ADA_BODY);

                  elsif ADA_BODY.TY = DN_stub then
                           CODE_stub (ADA_BODY);

                  end if;
         end CODE_BODY;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_block_body (block_body : TREE) is
         begin
                  declare
                           SAVE_ENCLOSING_BODY : TREE        := ENCLOSING_BODY;
                           OLD_TOP_ACT         : OFFSET_TYPE := EMITS.TOP_ACT;
                           OLD_TOP_MAX         : OFFSET_TYPE := EMITS.TOP_MAX;
                  begin
                           ENCLOSING_BODY := block_body;
                           EMITS.TOP_ACT  := 0;
                           EMITS.TOP_MAX  := 0;
                           DI (CD_LEVEL, BLOCK_BODY, INTEGER (EMITS.LEVEL));
                           DI (CD_RETURN_LABEL, BLOCK_BODY,
                             INTEGER (NEXT_LABEL));
                           declare
                                    ENT_1_LBL : LABEL_TYPE := NEXT_LABEL;
                                    ENT_2_LBL : LABEL_TYPE := NEXT_LABEL;
                           begin
                                    EMIT (ENT, Integer (1), ENT_1_LBL);
                                    EMIT (ENT, Integer (2), ENT_2_LBL);
                                    if FUNCTION_RESULT /= TREE_VOID then
                                             if FUNCTION_RESULT.TY = DN_ARRAY
                                             then
                                                      GEN_LOAD_ADDR
                                                              (DI (CD_COMP_UNIT,
                                                                        FUNCTION_RESULT),
                                                               DI (CD_LEVEL,
                                                                        FUNCTION_RESULT),
                                                               DI (CD_OFFSET,
                                                                        FUNCTION_RESULT));
                                                      EMIT (DPL, A);
                                                      EMIT (STR, A, 0,
                                                               FUN_RESULT_OFFSET -
                                                               EMITS.ADDR_SIZE);
                                                      EMIT (IND, I, 0);
                                                      EMIT (ALO, Integer (-1));
                                                      EMIT (STR, A, 0,
                                                               FUN_RESULT_OFFSET);
                                             end if;
                                    end if;
                                    CODE_item_s (D (as_ITEM_S, block_body));
                                    declare
                                             EXC_LBL : LABEL_TYPE :=
                                                     NEXT_LABEL;
                                    begin
                                             EMIT (EXH, EXC_LBL,
                                                      COMMENT =>
                                                              "EXCEPTION HANDLERS");
                                             CODE_stm_s
                                                     (D (as_STM_S,
                                                               block_body));
                                             WRITE_LABEL
                                                     (LABEL_TYPE
                                                              (DI (CD_RETURN_LABEL,
                                                                        BLOCK_BODY)));
                                             EMIT (RET, PARAM_SIZE);
                                             WRITE_LABEL (EXC_LBL);
                                    end;
                                    if not IS_EMPTY
                                                    (LIST (D
                                                                      (AS_ALTERNATIVE_S,
                                                                       BLOCK_BODY)))
                                    then
                                             CODE_alternative_s
                                                     (D (as_ALTERNATIVE_S,
                                                               block_body));
                                    else
                                             EMIT (EEX);
                                    end if;
                                    GEN_LBL_ASSIGNMENT
                                            (ENT_1_LBL, EMITS.OFFSET_MAX);
                                    GEN_LBL_ASSIGNMENT
                                            (ENT_2_LBL,
                                             EMITS.OFFSET_MAX + EMITS.TOP_MAX);
                           end;
                           EMITS.TOP_MAX  := OLD_TOP_MAX;
                           EMITS.TOP_ACT  := OLD_TOP_ACT;
                           ENCLOSING_BODY := SAVE_ENCLOSING_BODY;
                  end;
         end CODE_block_body;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_alternative_s (alternative_s : TREE) is
         begin
                  declare
                           alternative_seq  : SEQ_TYPE := LIST (alternative_s);
                           alternative_elem : TREE;
                  begin
                           while not IS_EMPTY (alternative_seq) loop
                                    POP (alternative_seq, alternative_elem);
                                    CODE_ALTERNATIVE_ELEM (alternative_elem);
                           end loop;
                  end;
         end CODE_alternative_s;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_ALTERNATIVE_ELEM (ALTERNATIVE_ELEM : TREE) is
         begin

                  if ALTERNATIVE_ELEM.TY = DN_alternative then
                           CODE_alternative (ALTERNATIVE_ELEM);

                  elsif ALTERNATIVE_ELEM.TY = DN_alternative_pragma then
                           CODE_alternative_pragma (ALTERNATIVE_ELEM);

                  end if;
         end CODE_ALTERNATIVE_ELEM;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_alternative (alternative : TREE) is
         begin
                  declare
                           SKIP_LBL          : LABEL_TYPE := NEXT_LABEL;
                           HANDLER_BEGIN_LBL : LABEL_TYPE := NEXT_LABEL;
                           CHOICE_S : TREE := D (AS_CHOICE_S, ALTERNATIVE);
                  begin
                           DI (CD_LABEL, CHOICE_S,
                                    INTEGER (HANDLER_BEGIN_LBL));
                           CODE_choice_s (CHOICE_S);
                           if not CHOICE_OTHERS_FLAG then
                                    EMIT (JMP, SKIP_LBL,
                                             COMMENT =>
                                                     "SKIP ALTERNATIVE SUIVANTE");
                                    WRITE_LABEL
                                            (HANDLER_BEGIN_LBL,
                                             COMMENT =>
                                                     "LABEL DEBUT INSTRUCTIONS");
                           end if;
                           CODE_stm_s (D (as_STM_S, alternative));
                           if not CHOICE_OTHERS_FLAG then
                                    WRITE_LABEL
                                            (SKIP_LBL,
                                             COMMENT =>
                                                     "ALTERNATIVE SUIVANTE");
                           end if;
                  end;
         end CODE_alternative;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_alternative_pragma (alternative_pragma : TREE) is
         begin
                  null;
         end CODE_alternative_pragma;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_choice_s (choice_s : TREE) is
         begin
                  declare
                           choice_seq : SEQ_TYPE := LIST (choice_s);
                           choice     : TREE;
                  begin
                           while not IS_EMPTY (choice_seq) loop
                                    POP (choice_seq, choice);
                                    CODE_CHOICE (choice);
                                    if not CHOICE_OTHERS_FLAG then
                                             EMIT (JMPT,
                                                      LABEL_TYPE
                                                              (DI (CD_LABEL,
                                                                        CHOICE_S)),
                                                      COMMENT =>
                                                              "TRAITE EXCEPTION");
                                    end if;
                           end loop;
                  end;
         end CODE_choice_s;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_CHOICE (CHOICE : TREE) is
         begin

                  if CHOICE.TY = DN_choice_exp then
                           CODE_choice_exp (CHOICE);

                  elsif CHOICE.TY = DN_choice_range then
                           CODE_choice_range (CHOICE);

                  elsif CHOICE.TY = DN_choice_others then
                           CODE_choice_others (CHOICE);

                  end if;
         end CODE_CHOICE;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_choice_exp (choice_exp : TREE) is
         begin
                  CODE_EXP (D (as_EXP, choice_exp));
         end CODE_choice_exp;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_choice_range (choice_range : TREE) is
         begin
                  null;
         end CODE_choice_range;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_choice_others (choice_others : TREE) is
         begin
                  CHOICE_OTHERS_FLAG := True;
         end CODE_choice_others;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_stub (stub : TREE) is
         begin
                  null;
         end CODE_stub;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_UNIT_KIND (UNIT_KIND : TREE) is
         begin

                  if UNIT_KIND.TY in CLASS_RENAME_INSTANT then
                           CODE_RENAME_INSTANT (UNIT_KIND);

                  elsif UNIT_KIND.TY in CLASS_GENERIC_PARAM then
                           CODE_GENERIC_PARAM (UNIT_KIND);

                  end if;
         end CODE_UNIT_KIND;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_RENAME_INSTANT (RENAME_INSTANT : TREE) is
         begin

                  if RENAME_INSTANT.TY = DN_renames_unit then
                           CODE_renames_unit (RENAME_INSTANT);

                  elsif RENAME_INSTANT.TY = DN_instantiation then
                           CODE_instantiation (RENAME_INSTANT);

                  end if;
         end CODE_RENAME_INSTANT;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_renames_unit (renames_unit : TREE) is
         begin
                  null;
         end CODE_renames_unit;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_instantiation (instantiation : TREE) is
         begin
                  null;
         end CODE_instantiation;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_GENERIC_PARAM (GENERIC_PARAM : TREE) is
         begin

                  if GENERIC_PARAM.TY = DN_name_default then
                           CODE_name_default (GENERIC_PARAM);

                  elsif GENERIC_PARAM.TY = DN_box_default then
                           CODE_box_default (GENERIC_PARAM);

                  elsif GENERIC_PARAM.TY = DN_no_default then
                           CODE_no_default (GENERIC_PARAM);

                  end if;
         end CODE_GENERIC_PARAM;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_name_default (name_default : TREE) is
         begin
                  null;
         end CODE_name_default;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_box_default (box_default : TREE) is
         begin
                  null;
         end CODE_box_default;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_no_default (no_default : TREE) is
         begin
                  null;
         end CODE_no_default;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_TYPE_DEF (TYPE_DEF, TYPE_DECL : TREE) is
         begin

                  if TYPE_DEF.TY = DN_enumeration_def then
                           CODE_enumeration_def (TYPE_DEF);

                  elsif TYPE_DEF.TY = DN_record_def then
                           CODE_record_def (TYPE_DEF);

                  elsif TYPE_DEF.TY = DN_formal_dscrt_def then
                           CODE_formal_dscrt_def (TYPE_DEF);

                  elsif TYPE_DEF.TY = DN_formal_integer_def then
                           CODE_formal_integer_def (TYPE_DEF);

                  elsif TYPE_DEF.TY = DN_formal_fixed_def then
                           CODE_formal_fixed_def (TYPE_DEF);

                  elsif TYPE_DEF.TY = DN_formal_float_def then
                           CODE_formal_float_def (TYPE_DEF);

                  elsif TYPE_DEF.TY = DN_private_def then
                           CODE_private_def (TYPE_DEF);

                  elsif TYPE_DEF.TY = DN_l_private_def then
                           CODE_l_private_def (TYPE_DEF);

                  elsif TYPE_DEF.TY in CLASS_CONSTRAINED_DEF then
                           CODE_CONSTRAINED_DEF (TYPE_DEF, TYPE_DECL);

                  elsif TYPE_DEF.TY in CLASS_ARR_ACC_DER_DEF then
                           CODE_ARR_ACC_DER_DEF (TYPE_DEF);

                  end if;
         end CODE_TYPE_DEF;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_enumeration_def (enumeration_def : TREE) is
         begin
                  CODE_enum_literal_s (D (as_enum_literal_s, enumeration_def));
         end CODE_enumeration_def;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_enum_literal_s (enum_literal_s : TREE) is
         begin
                  declare
                           LAST_LITERAL : TREE;
                  begin
                           declare
                                    enum_literal_seq : SEQ_TYPE :=
                                            LIST (enum_literal_s);
                                    enum_literal     : TREE;
                           begin
                                    while not IS_EMPTY (enum_literal_seq) loop
                                             POP (enum_literal_seq,
                                                      enum_literal);
                                             LAST_LITERAL := enum_literal;
                                    end loop;
                           end;
                           DI (CD_LAST, ENUM_LITERAL_S,
                                    DI (SM_REP, LAST_LITERAL));
                  end;
         end CODE_enum_literal_s;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_ENUM_LITERAL (ENUM_LITERAL : TREE) is
         begin

                  if ENUM_LITERAL.TY = DN_enumeration_id then
                           CODE_enumeration_id (ENUM_LITERAL);

                  elsif ENUM_LITERAL.TY = DN_character_id then
                           CODE_character_id (ENUM_LITERAL);

                  end if;
         end CODE_ENUM_LITERAL;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_enumeration_id (enumeration_id : TREE) is
         begin
                  null;
         end CODE_enumeration_id;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_character_id (character_id : TREE) is
         begin
                  null;
         end CODE_character_id;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_formal_integer_def (formal_integer_def : TREE) is
         begin
                  null;
         end CODE_formal_integer_def;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_formal_fixed_def (formal_fixed_def : TREE) is
         begin
                  null;
         end CODE_formal_fixed_def;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_formal_float_def (formal_float_def : TREE) is
         begin
                  null;
         end CODE_formal_float_def;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_formal_dscrt_def (formal_dscrt_def : TREE) is
         begin
                  null;
         end CODE_formal_dscrt_def;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_private_def (private_def : TREE) is
         begin
                  null;
         end CODE_private_def;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_l_private_def (l_private_def : TREE) is
         begin
                  null;
         end CODE_l_private_def;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_record_def (record_def : TREE) is
         begin
                  null;
         end CODE_record_def;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_CONSTRAINED_DEF (CONSTRAINED_DEF, TYPE_DECL : TREE) is
         begin

                  if CONSTRAINED_DEF.TY = DN_subtype_indication then
                           CODE_subtype_indication (CONSTRAINED_DEF);

                  elsif CONSTRAINED_DEF.TY = DN_integer_def then
                           CODE_integer_def (CONSTRAINED_DEF, TYPE_DECL);

                  elsif CONSTRAINED_DEF.TY = DN_fixed_def then
                           CODE_fixed_def (CONSTRAINED_DEF);

                  elsif CONSTRAINED_DEF.TY = DN_float_def then
                           CODE_float_def (CONSTRAINED_DEF);

                  end if;
         end CODE_CONSTRAINED_DEF;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_subtype_indication (subtype_indication : TREE) is
         begin
                  null;
         end CODE_subtype_indication;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_integer_def (integer_def, TYPE_DECL : TREE) is
         begin
                  declare
                           TYPE_ID : TREE := D (AS_SOURCE_NAME, TYPE_DECL);
                           INTEGER_SPEC : TREE := D (SM_TYPE_SPEC, TYPE_ID);
                           LOWER        : OFFSET_TYPE;
                           UPPER        : OFFSET_TYPE;
                           INT_RANGE : TREE := D (AS_CONSTRAINT, INTEGER_DEF);
                           EXP_BORNE    : TREE;
                  begin
                           ALIGN (INTG_AL);
                           LOWER := -EMITS.OFFSET_ACT;
                           INC_OFFSET (INTG_SIZE);
                           UPPER := -EMITS.OFFSET_ACT;
                           INC_OFFSET (INTG_SIZE);
                           DI (CD_OFFSET, INTEGER_SPEC, LOWER);
                           DI (CD_LEVEL, INTEGER_SPEC, EMITS.LEVEL);
                           DI (CD_COMP_UNIT, INTEGER_SPEC, CUR_COMP_UNIT);
                           DB (CD_COMPILED, INTEGER_SPEC, TRUE);
                           EXP_BORNE := D (AS_EXP1, INT_RANGE);
                           CODE_EXP (EXP_BORNE);
                           GEN_STORE
                                   (I, EMITS.CUR_COMP_UNIT, EMITS.LEVEL, LOWER,
                                    "BORNE BASSE");
                           EXP_BORNE := D (AS_EXP2, INT_RANGE);
                           CODE_EXP (EXP_BORNE);
                           GEN_STORE
                                   (I, EMITS.CUR_COMP_UNIT, EMITS.LEVEL, UPPER,
                                    "BORNE HAUTE");
                  end;
         end CODE_integer_def;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_fixed_def (fixed_def : TREE) is
         begin
                  null;
         end CODE_fixed_def;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_float_def (float_def : TREE) is
         begin
                  null;
         end CODE_float_def;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_ARR_ACC_DER_DEF (ARR_ACC_DER_DEF : TREE) is
         begin

                  if ARR_ACC_DER_DEF.TY = DN_constrained_array_def then
                           CODE_constrained_array_def (ARR_ACC_DER_DEF);

                  elsif ARR_ACC_DER_DEF.TY = DN_unconstrained_array_def then
                           CODE_unconstrained_array_def (ARR_ACC_DER_DEF);

                  elsif ARR_ACC_DER_DEF.TY = DN_access_def then
                           CODE_access_def (ARR_ACC_DER_DEF);

                  elsif ARR_ACC_DER_DEF.TY = DN_derived_def then
                           CODE_derived_def (ARR_ACC_DER_DEF);

                  end if;
         end CODE_ARR_ACC_DER_DEF;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_constrained_array_def (constrained_array_def : TREE) is
         begin
                  null;
         end CODE_constrained_array_def;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_unconstrained_array_def
                 (unconstrained_array_def : TREE)
         is
         begin
                  null;
         end CODE_unconstrained_array_def;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_access_def (access_def : TREE) is
         begin
                  null;
         end CODE_access_def;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_derived_def (derived_def : TREE) is
         begin
                  null;
         end CODE_derived_def;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_SOURCE_NAME (SOURCE_NAME : TREE) is
         begin

                  if SOURCE_NAME.TY in CLASS_OBJECT_NAME then
                           CODE_OBJECT_NAME (SOURCE_NAME);

                  elsif SOURCE_NAME.TY in CLASS_TYPE_NAME then
                           CODE_TYPE_NAME (SOURCE_NAME);

                  elsif SOURCE_NAME.TY in CLASS_UNIT_NAME then
                           CODE_UNIT_NAME (SOURCE_NAME);

                  elsif SOURCE_NAME.TY in CLASS_LABEL_NAME then
                           CODE_LABEL_NAME (SOURCE_NAME);

                  elsif SOURCE_NAME.TY = DN_entry_id then
                           CODE_entry_id (SOURCE_NAME);

                  elsif SOURCE_NAME.TY = DN_exception_id then
                           CODE_exception_id (SOURCE_NAME);

                  end if;
         end CODE_SOURCE_NAME;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_OBJECT_NAME (OBJECT_NAME : TREE) is
         begin

                  if OBJECT_NAME.TY = DN_iteration_id then
                           CODE_iteration_id (OBJECT_NAME);

                  elsif OBJECT_NAME.TY in CLASS_INIT_OBJECT_NAME then
                           CODE_INIT_OBJECT_NAME (OBJECT_NAME);

                  elsif OBJECT_NAME.TY in CLASS_ENUM_LITERAL then
                           CODE_ENUM_LITERAL (OBJECT_NAME);

                  end if;
         end CODE_OBJECT_NAME;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_UNIT_NAME (UNIT_NAME : TREE) is
         begin

                  if UNIT_NAME.TY = DN_task_body_id then
                           CODE_task_body_id (UNIT_NAME);

                  elsif UNIT_NAME.TY in CLASS_NON_TASK_NAME then
                           CODE_NON_TASK_NAME (UNIT_NAME);

                  end if;
         end CODE_UNIT_NAME;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_VC_NAME (VC_NAME : TREE) is
         begin
                  declare
                           TYPE_SPEC : TREE := D (SM_OBJ_TYPE, VC_NAME);
                           --|---------------------------------------------------------------------------
                           procedure COMPILE_VC_NAME_INTEGER (VC_NAME : TREE)
                           is
                           begin
                                    ALIGN (INTG_AL);
                                    declare
                                             LVL : LEVEL_TYPE := EMITS.LEVEL;
                                             OFS      : OFFSET_TYPE   :=
                                                     -EMITS.OFFSET_ACT;
                                             CPU      : COMP_UNIT_NBR :=
                                                     EMITS.CUR_COMP_UNIT;
                                             INIT_EXP : TREE          :=
                                                     D (SM_INIT_EXP, VC_NAME);
                                    begin
                                             DI (CD_LEVEL, VC_NAME, LVL);
                                             DI (CD_OFFSET, VC_NAME, OFS);
                                             DI (CD_COMP_UNIT, VC_NAME, CPU);
                                             DB (CD_COMPILED, VC_NAME, TRUE);
                                             INC_OFFSET (INTG_SIZE);
                                             if INIT_EXP /= TREE_VOID then
                                                      CODE_EXP (INIT_EXP);
                                                      GEN_STORE
                                                              (I, CPU, LVL,
                                                               OFS,
                                                               "STO " &
                                                               PRINT_NAME
                                                                       (D (LX_SYMREP,
                                                                                 VC_NAME)) &
                                                               " VAL INIT");
                                             end if;
                                    end;
                           end COMPILE_VC_NAME_INTEGER;
                           --|---------------------------------------------------------------------------
                           procedure COMPILE_VC_NAME_ENUMERATION
                                   (VC_NAME, TYPE_SPEC : TREE)
                           is
                                    NAME : constant String :=
                                            PRINT_NAME (EMITS.TYPE_SYMREP);
                                    procedure COMPILE_VC_NAME_BOOL_CHAR
                                            (VC_NAME  : TREE; CT : CODE_TYPE;
                                             SIZ, ALI : Natural)
                                    is
                                    begin
                                             ALIGN (ALI);
                                             declare
                                                      LVL      : LEVEL_TYPE :=
                                                              EMITS.LEVEL;
                                                      OFS      : OFFSET_TYPE :=
                                                              -EMITS.OFFSET_ACT;
                                                      CPU : COMP_UNIT_NBR :=
                                                              EMITS.CUR_COMP_UNIT;
                                                      INIT_EXP : TREE :=
                                                              D (SM_INIT_EXP,
                                                                       VC_NAME);
                                             begin
                                                      DI (CD_LEVEL, VC_NAME,
                                                               LVL);
                                                      DI (CD_OFFSET, VC_NAME,
                                                               OFS);
                                                      DI (CD_COMP_UNIT,
                                                               VC_NAME, CPU);
                                                      DB (CD_COMPILED, VC_NAME,
                                                               TRUE);
                                                      INC_OFFSET (SIZ);
                                                      if INIT_EXP /= TREE_VOID
                                                      then
                                                               CODE_EXP (INIT_EXP);
                                                      end if;
                                                      GEN_STORE
                                                              (CT, CPU, LVL,
                                                               OFS,
                                                               PRINT_NAME
                                                                       (D (LX_SYMREP,
                                                                                 VC_NAME)) &
                                                               " := VAL INIT");
                                             end;
                                    end COMPILE_VC_NAME_BOOL_CHAR;
                           begin
                                    if NAME = "BOOLEAN" then
                                             COMPILE_VC_NAME_BOOL_CHAR
                                                     (VC_NAME, B, BOOL_SIZE,
                                                      BOOL_AL);
                                    elsif NAME = "CHARACTER" then
                                             COMPILE_VC_NAME_BOOL_CHAR
                                                     (VC_NAME, C, CHAR_SIZE,
                                                      CHAR_AL);
                                    else
                                             COMPILE_VC_NAME_INTEGER (VC_NAME);
                                    end if;
                           end COMPILE_VC_NAME_ENUMERATION;
                           --|---------------------------------------------------------------------------
                           procedure COMPILE_ACCESS_VAR
                                   (VAR_ID, TYPE_SPEC : TREE)
                           is
                           begin
                                    ALIGN (ADDR_AL);
                                    declare
                                             LVL : LEVEL_TYPE := EMITS.LEVEL;
                                             OFS : OFFSET_TYPE   :=
                                                     -EMITS.OFFSET_ACT;
                                             CPU : COMP_UNIT_NBR :=
                                                     EMITS.CUR_COMP_UNIT;
                                    begin
                                             DI (CD_LEVEL, VAR_ID, LVL);
                                             DI (CD_OFFSET, VAR_ID, OFS);
                                             DI (CD_COMP_UNIT, VAR_ID, CPU);
                                             DB (CD_COMPILED, VAR_ID, TRUE);
                                             INC_OFFSET (ADDR_SIZE);
                                             declare
                                                      INIT_EXP : TREE :=
                                                              D (SM_INIT_EXP,
                                                                       VAR_ID);
                                             begin
                                                      if INIT_EXP = TREE_VOID
                                                      then
                                                               EMIT (LDC, A,
                                                                        -1,
                                                                        "INIT NIL DE " &
                                                                        PRINT_NAME
                                                                                (D (LX_SYMREP,
                                                                                          VAR_ID)));
                                                      else
                                                               LOAD_TYPE_SIZE
                                                                       (TYPE_SPEC);
                                                               EMIT (ALO,
                                                                        LVL - DI
                                                                                (CD_LEVEL,
                                                                                 TYPE_SPEC));
                                                      end if;
                                             end;
                                             GEN_STORE
                                                     (A, CPU, LVL, OFS,
                                                      "STO " &
                                                      PRINT_NAME
                                                              (D (LX_SYMREP,
                                                                        VAR_ID)) &
                                                      " VAL INIT");
                                    end;
                           end COMPILE_ACCESS_VAR;
                           --|---------------------------------------------------------------------------
                           procedure COMPILE_ARRAY_VAR
                                   (VC_NAME, TYPE_SPEC : TREE)
                           is
                                    DESCR_PTR : OFFSET_TYPE;
                           begin
                                    ALIGN (ADDR_AL);
                                    declare
                                             LVL : LEVEL_TYPE := EMITS.LEVEL;
                                             VALUE_PTR : OFFSET_TYPE   :=
                                                     -EMITS.OFFSET_ACT;
                                             CPU       : COMP_UNIT_NBR :=
                                                     EMITS.CUR_COMP_UNIT;
                                    begin
                                             DI (CD_LEVEL, VC_NAME, LVL);
                                             DI (CD_OFFSET, VC_NAME,
                                                      VALUE_PTR);
                                             DI (CD_COMP_UNIT, VC_NAME, CPU);
                                             DB (CD_COMPILED, VC_NAME, TRUE);
                                             INC_OFFSET (ADDR_SIZE);
                                             ALIGN (ADDR_AL);
                                             DESCR_PTR := -EMITS.OFFSET_ACT;
                                             INC_OFFSET (ADDR_SIZE);
                                             if DB (CD_COMPILED, TYPE_SPEC)
                                             then
                                                      GEN_LOAD_ADDR
                                                              (DI (CD_COMP_UNIT,
                                                                        TYPE_SPEC),
                                                               DI (CD_LEVEL,
                                                                        TYPE_SPEC),
                                                               DI (CD_OFFSET,
                                                                        TYPE_SPEC));
                                                      EMIT (DPL, A,
                                                               "DUPLICATE " &
                                                               PRINT_NAME
                                                                       (D (LX_SYMREP,
                                                                                 VC_NAME)) &
                                                               " ARRAY DESCRIPTOR TYPE_SPEC");
                                                      GEN_STORE
                                                              (A, EMITS
                                                                       .CUR_COMP_UNIT,
                                                               EMITS.LEVEL,
                                                               DESCR_PTR,
                                                               "STO ADRESSE DESCRIPTEUR");
                                                      EMIT (IND, I, 0,
                                                               "CHARGE INDEXE TAILLE TABLEAU DE DESCRIPTEUR");
                                                      EMIT (ALO, Integer (0),
                                                               COMMENT =>
                                                                       "ALLOC TABLEAU");
                                                      GEN_STORE
                                                              (A, EMITS
                                                                       .CUR_COMP_UNIT,
                                                               EMITS.LEVEL,
                                                               VALUE_PTR,
                                                               "STO ADRESSE TABLEAU ALLOUE");
                                             else
                                                      Put_Line ("!!! COMPILE_ARRAY_VAR : TYPE_SPEC NON COMPILE");
                                                      raise Program_Error;
                                             end if;
                                    end;
                           end COMPILE_ARRAY_VAR;
                           --|---------------------------------------------------------------------------
                           procedure COMPILE_RECORD_VAR
                                   (VC_NAME, TYPE_SPEC : TREE)
                           is
                                    INIT_EXP : TREE :=
                                            D (SM_INIT_EXP, VC_NAME);
                           begin
                                    ALIGN (RECORD_AL);
                                    declare
                                             LVL : LEVEL_TYPE := EMITS.LEVEL;
                                             OFS : OFFSET_TYPE   :=
                                                     -EMITS.OFFSET_ACT;
                                             CPU : COMP_UNIT_NBR :=
                                                     EMITS.CUR_COMP_UNIT;
                                    begin
                                             DI (CD_LEVEL, VC_NAME, LVL);
                                             DI (CD_OFFSET, VC_NAME, OFS);
                                             DI (CD_COMP_UNIT, VC_NAME, CPU);
                                             DB (CD_COMPILED, VC_NAME, TRUE);
                                             if INIT_EXP.TY = DN_AGGREGATE then
                                                      declare
                                                               GENERAL_ASSOC_SEQ :
                                                                       SEQ_TYPE :=
                                                                       LIST (D
                                                                                        (SM_NORMALIZED_COMP_S,
                                                                                         INIT_EXP));
                                                               COMP_EXP : TREE;
                                                      begin
                                                               while not IS_EMPTY
                                                                               (GENERAL_ASSOC_SEQ)
                                                               loop
                                                                        POP (GENERAL_ASSOC_SEQ,
                                                                                 COMP_EXP);
                                                                        CODE_EXP (COMP_EXP);
                                                               end loop;
                                                      end;
                                             end if;
                                    end;
                           end COMPILE_RECORD_VAR;
                           --|---------------------------------------------------------------------------
                  begin
                           case TYPE_SPEC.TY is
                                    when DN_INTEGER =>
                                             COMPILE_VC_NAME_INTEGER (VC_NAME);
                                    when DN_ENUMERATION =>
                                             COMPILE_VC_NAME_ENUMERATION
                                                     (VC_NAME, TYPE_SPEC);
                                    when DN_ACCESS =>
                                             COMPILE_ACCESS_VAR
                                                     (VC_NAME, TYPE_SPEC);
                                    when DN_CONSTRAINED_ARRAY =>
                                             COMPILE_ARRAY_VAR
                                                     (VC_NAME, TYPE_SPEC);
                                    when DN_RECORD =>
                                             COMPILE_RECORD_VAR
                                                     (VC_NAME, TYPE_SPEC);
                                    when others =>
                                             PUT_LINE ("!!! CODE_VC_NAME, TYPE_SPEC.TY = " &
                                                      NODE_NAME'Image
                                                              (TYPE_SPEC.TY));
                                             raise Program_Error;
                           end case;
                  end;
         end CODE_VC_NAME;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_variable_id (variable_id : TREE) is
         begin
                  null;
         end CODE_variable_id;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_constant_id (constant_id : TREE) is
         begin
                  null;
         end CODE_constant_id;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_number_id (number_id : TREE) is
         begin
                  null;
         end CODE_number_id;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_source_name_s (source_name_s : TREE) is
         begin
                  declare
                           source_name_seq : SEQ_TYPE := LIST (source_name_s);
                           source_name     : TREE;
                  begin
                           while not IS_EMPTY (source_name_seq) loop
                                    POP (source_name_seq, source_name);
                                    CODE_SOURCE_NAME (source_name);
                           end loop;
                  end;
         end CODE_source_name_s;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_TYPE_NAME (TYPE_NAME : TREE) is
         begin

                  if TYPE_NAME.TY = DN_type_id then
                           CODE_type_id (TYPE_NAME);

                  elsif TYPE_NAME.TY = DN_subtype_id then
                           CODE_subtype_id (TYPE_NAME);

                  elsif TYPE_NAME.TY = DN_private_type_id then
                           CODE_private_type_id (TYPE_NAME);

                  elsif TYPE_NAME.TY = DN_l_private_type_id then
                           CODE_l_private_type_id (TYPE_NAME);

                  end if;
         end CODE_TYPE_NAME;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_type_id (type_id : TREE) is
         begin
                  null;
         end CODE_type_id;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_subtype_id (subtype_id : TREE) is
         begin
                  null;
         end CODE_subtype_id;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_COMP_NAME (COMP_NAME : TREE) is
         begin

                  if COMP_NAME.TY = DN_component_id then
                           CODE_component_id (COMP_NAME);

                  elsif COMP_NAME.TY = DN_discriminant_id then
                           CODE_discriminant_id (COMP_NAME);

                  end if;
         end CODE_COMP_NAME;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_component_id (component_id : TREE) is
         begin
                  null;
         end CODE_component_id;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_discriminant_id (discriminant_id : TREE) is
         begin
                  null;
         end CODE_discriminant_id;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_NAME (NAME : TREE) is
         begin

                  if NAME.TY in CLASS_DESIGNATOR then
                           CODE_DESIGNATOR (NAME);

                  elsif NAME.TY in CLASS_NAME_EXP then
                           CODE_NAME_EXP (NAME);

                  end if;
         end CODE_NAME;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_NAME_EXP (NAME_EXP : TREE) is
         begin

                  if NAME_EXP.TY = DN_indexed then
                           CODE_INDEXED (NAME_EXP);

                  elsif NAME_EXP.TY = DN_slice then
                           CODE_slice (NAME_EXP);

                  elsif NAME_EXP.TY = DN_all then
                           CODE_all (NAME_EXP);

                  end if;
         end CODE_NAME_EXP;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_DESIGNATOR (DESIGNATOR : TREE) is
         begin

                  if DESIGNATOR.TY in CLASS_USED_OBJECT then
                           CODE_USED_OBJECT (DESIGNATOR);

                  elsif DESIGNATOR.TY in CLASS_USED_NAME then
                           CODE_USED_NAME (DESIGNATOR);

                  end if;
         end CODE_DESIGNATOR;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_USED_NAME (USED_NAME : TREE) is
         begin

                  if USED_NAME.TY = DN_used_op then
                           CODE_used_op (USED_NAME);

                  elsif USED_NAME.TY = DN_used_name_id then
                           CODE_used_name_id (USED_NAME);

                  end if;
         end CODE_USED_NAME;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_used_op (used_op : TREE) is
         begin
                  null;
         end CODE_used_op;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_used_name_id (used_name_id : TREE) is
         begin
                  declare
                           DEFN   : TREE := D (SM_DEFN, USED_NAME_ID);
                           SYMREP : TREE := D (LX_SYMREP, USED_NAME_ID);
                  begin
                           if DEFN.TY = DN_EXCEPTION_ID then
                                    declare
                                             LABEL : TREE :=
                                                     D (CD_LABEL, DEFN);
                                             LBL   : LABEL_TYPE;
                                    begin
                                             if LABEL.TY /= DN_NUM_VAL then
                                                      LBL := NEXT_LABEL;
                                                      DI (CD_LABEL, DEFN,
                                                               INTEGER (LBL));
                                                      EMIT (EXL, LBL,
                                                               S => PRINT_NAME
                                                                               (SYMREP),
                                                               COMMENT =>
                                                                       "NUM D EXCEPTION EXTERNE ATTRIBUE SUR USED_NAME_ID");
                                             end if;
                                             EMIT (DPL, I,
                                                      COMMENT =>
                                                              "CODE D EXCEPTION EMPILE");
                                             EMIT (LDC, I, DI (CD_LABEL, DEFN),
                                                      COMMENT =>
                                                              "EXCEPTION " &
                                                              PRINT_NAME
                                                                      (SYMREP));
                                             EMIT (EQ, I);
                                    end;
                           elsif DEFN.TY = DN_PACKAGE_ID then
                                    if not DB (CD_COMPILED, DEFN) then
                                             declare
                                                      PACKAGE_SPEC : TREE :=
                                                              D (SM_SPEC,
                                                                       DEFN);
                                             begin
                                                      EMIT (RFP,
                                                               EMITS.CUR_COMP_UNIT,
                                                               S => PRINT_NAME
                                                                               (SYMREP));
                                                      EMITS.GENERATE_CODE :=
                                                              False;
                                                      DB (CD_COMPILED, DEFN,
                                                               TRUE);
                                                      CODE_decl_s
                                                              (D (as_DECL_S1,
                                                                        package_Spec));
                                             end;
                                    end if;
                                    EMITS.CUR_COMP_UNIT := CUR_COMP_UNIT + 1;
                           elsif DEFN.TY = DN_PROCEDURE_ID then
                                    if not DB (CD_COMPILED, DEFN) then
                                             declare
                                                      PROC_LBL : LABEL_TYPE :=
                                                              NEXT_LABEL;
                                             begin
                                                      EMITS.GENERATE_CODE :=
                                                              True;
                                                      EMIT (RFP, Integer (0),
                                                               S => PRINT_NAME
                                                                               (SYMREP));
                                                      DI (CD_LABEL, DEFN,
                                                        INTEGER (PROC_LBL));
                                                      DI (CD_LEVEL, DEFN, 1);
                                                      DI (CD_PARAM_SIZE, DEFN,
                                                               0);
                                                      DB (CD_COMPILED, DEFN,
                                                               TRUE);
                                                      EMIT (RFL, PROC_LBL);
                                             end;
                                    end if;
                           end if;
                  end;
         end CODE_used_name_id;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_USED_OBJECT (USED_OBJECT : TREE) is
         begin

                  if USED_OBJECT.TY = DN_used_char then
                           CODE_used_char (USED_OBJECT);

                  elsif USED_OBJECT.TY = DN_used_object_id then
                           CODE_used_object_id (USED_OBJECT);

                  end if;
         end CODE_USED_OBJECT;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_used_char (used_char : TREE) is
         begin
                  null;
         end CODE_used_char;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_used_object_id (used_object_id : TREE) is
         begin
                  null;
         end CODE_used_object_id;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_INDEXED (INDEXED : TREE) is
         begin
                  declare
                           procedure INDEX (EXP_SEQ : SEQ_TYPE) is
                                    EXP_S : SEQ_TYPE := EXP_SEQ;
                                    EXP   : TREE;
                           begin
                                    POP (EXP_S, EXP);
                                    CODE_EXP (EXP);
                                    if IS_EMPTY (EXP_S) then
                                             EMIT (AR2,
                                                      "ADRESSE POUR LE DERNIER INDICE (RAPIDE)");
                                    else
                                             EMIT (AR1,
                                                      "ADRESSE POUR INDICE INTERMEDIAIRE");
                                             EMIT (DEC, A, 3 * INTG_SIZE,
                                                      "PTR DESCRIPTEUR AU TRIPLET INDICE SUIVANT");
                                             INDEX (EXP_S);
                                             EMIT (ADD, I,
                                                      "AJOUTER LE DECALAGE A L ADRESSE DES INDICES PRECEDENTS");
                                    end if;
                           end INDEX;
                  begin
                           CODE_OBJECT (D (AS_NAME, INDEXED));
                           EMIT (DPL, A, "DUP ADRESS OBJET");
                           EMIT (IND, A, 0, "CHARGE INDEXE D ADRESSE TABLEAU");
                           EMIT (SWP, A, "ADRESSE OBJET AU TOP");
                           EMIT (IND, A, -ADDR_SIZE,
                                    "CHARGE INDEXE ADRESSE DU DESCRIPTEUR TABLEAU");
                           EMIT (DEC, A, INTG_SIZE,
                                    "ADRESSE DESCRIPTEUR - TAILLE ENTIER");
                           declare
                                    EXP_SEQ : SEQ_TYPE :=
                                            LIST (D (AS_EXP_S, INDEXED));
                           begin
                                    if not IS_EMPTY (EXP_SEQ) then
                                             INDEX (EXP_SEQ);
                                    end if;
                           end;
                           EMIT (IXA, Integer (1));
                  end;
         end CODE_INDEXED;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_slice (slice : TREE) is
         begin
                  null;
         end CODE_slice;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_all (ADA_all : TREE) is
         begin
                  null;
         end CODE_all;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_aggregate (aggregate : TREE) is
         begin
                  null;
         end CODE_aggregate;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_short_circuit (short_circuit : TREE) is
         begin
                  null;
         end CODE_short_circuit;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_MEMBERSHIP (MEMBERSHIP : TREE) is
         begin

                  if MEMBERSHIP.TY = DN_range_membership then
                           CODE_range_membership (MEMBERSHIP);

                  elsif MEMBERSHIP.TY = DN_type_membership then
                           CODE_type_membership (MEMBERSHIP);

                  end if;
         end CODE_MEMBERSHIP;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_range_membership (range_membership : TREE) is
         begin
                  null;
         end CODE_range_membership;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_type_membership (type_membership : TREE) is
         begin
                  null;
         end CODE_type_membership;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_EXP (EXP : TREE) is
         begin

                  if EXP.TY in CLASS_NAME then
                           CODE_NAME (EXP);

                  elsif EXP.TY in CLASS_EXP_EXP then
                           CODE_EXP_EXP (EXP);

                  end if;
         end CODE_EXP;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_EXP_EXP (EXP_EXP : TREE) is
         begin

                  if EXP_EXP.TY in CLASS_EXP_VAL then
                           CODE_EXP_VAL (EXP_EXP);

                  elsif EXP_EXP.TY in CLASS_AGG_EXP then
                           CODE_AGG_EXP (EXP_EXP);

                  elsif EXP_EXP.TY = DN_qualified_allocator then
                           CODE_qualified_allocator (EXP_EXP);

                  elsif EXP_EXP.TY = DN_subtype_allocator then
                           CODE_subtype_allocator (EXP_EXP);

                  end if;
         end CODE_EXP_EXP;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_EXP_VAL (EXP_VAL : TREE) is
         begin

                  if EXP_VAL.TY in CLASS_EXP_VAL_EXP then
                           CODE_EXP_VAL_EXP (EXP_VAL);

                  elsif EXP_VAL.TY = DN_numeric_literal then
                           CODE_numeric_literal (EXP_VAL);

                  elsif EXP_VAL.TY = DN_null_access then
                           CODE_null_access (EXP_VAL);

                  elsif EXP_VAL.TY = DN_short_circuit then
                           CODE_short_circuit (EXP_VAL);

                  end if;
         end CODE_EXP_VAL;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_EXP_VAL_EXP (EXP_VAL_EXP : TREE) is
         begin

                  if EXP_VAL_EXP.TY in CLASS_QUAL_CONV then
                           CODE_QUAL_CONV (EXP_VAL_EXP);

                  elsif EXP_VAL_EXP.TY in CLASS_MEMBERSHIP then
                           CODE_MEMBERSHIP (EXP_VAL_EXP);

                  elsif EXP_VAL_EXP.TY = DN_parenthesized then
                           CODE_parenthesized (EXP_VAL_EXP);

                  end if;
         end CODE_EXP_VAL_EXP;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_AGG_EXP (AGG_EXP : TREE) is
         begin

                  if AGG_EXP.TY = DN_aggregate then
                           CODE_aggregate (AGG_EXP);

                  elsif AGG_EXP.TY = DN_string_literal then
                           CODE_string_literal (AGG_EXP);

                  end if;
         end CODE_AGG_EXP;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_parenthesized (parenthesized : TREE) is
         begin
                  null;
         end CODE_parenthesized;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_numeric_literal (numeric_literal : TREE) is
         begin
                  null;
         end CODE_numeric_literal;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_string_literal (string_literal : TREE) is
         begin
                  null;
         end CODE_string_literal;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_null_access (null_access : TREE) is
         begin
                  null;
         end CODE_null_access;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_QUAL_CONV (QUAL_CONV : TREE) is
         begin

                  if QUAL_CONV.TY = DN_conversion then
                           CODE_conversion (QUAL_CONV);

                  elsif QUAL_CONV.TY = DN_qualified then
                           CODE_qualified (QUAL_CONV);

                  end if;
         end CODE_QUAL_CONV;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_conversion (conversion : TREE) is
         begin
                  null;
         end CODE_conversion;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_qualified (qualified : TREE) is
         begin
                  null;
         end CODE_qualified;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_qualified_allocator (qualified_allocator : TREE) is
         begin
                  null;
         end CODE_qualified_allocator;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_subtype_allocator (subtype_allocator : TREE) is
         begin
                  null;
         end CODE_subtype_allocator;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_stm_s (stm_s : TREE) is
         begin
                  declare
                           stm_seq  : SEQ_TYPE := LIST (stm_s);
                           stm_elem : TREE;
                  begin
                           while not IS_EMPTY (stm_seq) loop
                                    POP (stm_seq, stm_elem);
                                    CODE_STM_ELEM (stm_elem);
                           end loop;
                  end;
         end CODE_stm_s;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_STM_ELEM (STM_ELEM : TREE) is
         begin

                  if STM_ELEM.TY in CLASS_STM then
                           CODE_STM (STM_ELEM);

                  elsif STM_ELEM.TY = DN_stm_pragma then
                           CODE_stm_pragma (STM_ELEM);

                  end if;
         end CODE_STM_ELEM;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_stm_pragma (stm_pragma : TREE) is
         begin
                  null;
         end CODE_stm_pragma;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_STM (STM : TREE) is
         begin

                  if STM.TY = DN_labeled then
                           CODE_labeled (STM);

                  elsif STM.TY = DN_null_stm then
                           CODE_null_stm (STM);

                  elsif STM.TY = DN_accept then
                           CODE_accept (STM);

                  elsif STM.TY = DN_terminate then
                           CODE_terminate (STM);

                  elsif STM.TY = DN_abort then
                           CODE_abort (STM);

                  elsif STM.TY in CLASS_CLAUSES_STM then
                           CODE_CLAUSES_STM (STM);

                  elsif STM.TY in CLASS_BLOCK_LOOP then
                           CODE_BLOCK_LOOP (STM);

                  elsif STM.TY in CLASS_ENTRY_STM then
                           CODE_ENTRY_STM (STM);

                  elsif STM.TY in CLASS_STM_WITH_NAME then
                           CODE_STM_WITH_NAME (STM);

                  elsif STM.TY in CLASS_STM_WITH_EXP then
                           CODE_STM_WITH_EXP (STM);

                  end if;
         end CODE_STM;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_labeled (labeled : TREE) is
         begin
                  null;
         end CODE_labeled;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_STM_WITH_EXP (STM_WITH_EXP : TREE) is
         begin

                  if STM_WITH_EXP.TY = DN_return then
                           CODE_return (STM_WITH_EXP);

                  elsif STM_WITH_EXP.TY = DN_delay then
                           CODE_delay (STM_WITH_EXP);

                  elsif STM_WITH_EXP.TY = DN_case then
                           CODE_case (STM_WITH_EXP);

                  elsif STM_WITH_EXP.TY in CLASS_STM_WITH_EXP_NAME then
                           CODE_STM_WITH_EXP_NAME (STM_WITH_EXP);

                  end if;
         end CODE_STM_WITH_EXP;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_STM_WITH_EXP_NAME (STM_WITH_EXP_NAME : TREE) is
         begin

                  if STM_WITH_EXP_NAME.TY = DN_code then
                           CODE_code (STM_WITH_EXP_NAME);

                  elsif STM_WITH_EXP_NAME.TY = DN_assign then
                           CODE_assign (STM_WITH_EXP_NAME);

                  elsif STM_WITH_EXP_NAME.TY = DN_exit then
                           CODE_exit (STM_WITH_EXP_NAME);

                  end if;
         end CODE_STM_WITH_EXP_NAME;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_STM_WITH_NAME (STM_WITH_NAME : TREE) is
         begin

                  if STM_WITH_NAME.TY = DN_goto then
                           CODE_goto (STM_WITH_NAME);

                  elsif STM_WITH_NAME.TY = DN_raise then
                           CODE_raise (STM_WITH_NAME);

                  elsif STM_WITH_NAME.TY in CLASS_CALL_STM then
                           CODE_CALL_STM (STM_WITH_NAME);

                  end if;
         end CODE_STM_WITH_NAME;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_CALL_STM (CALL_STM : TREE) is
         begin

                  if CALL_STM.TY = DN_procedure_call then
                           CODE_procedure_call (CALL_STM);

                  elsif CALL_STM.TY = DN_entry_call then
                           CODE_entry_call (CALL_STM);

                  end if;
         end CODE_CALL_STM;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_CLAUSES_STM (CLAUSES_STM : TREE) is
         begin

                  if CLAUSES_STM.TY = DN_if then
                           CODE_if (CLAUSES_STM);

                  elsif CLAUSES_STM.TY = DN_selective_wait then
                           CODE_selective_wait (CLAUSES_STM);

                  end if;
         end CODE_CLAUSES_STM;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_LABEL_NAME (LABEL_NAME : TREE) is
         begin

                  if LABEL_NAME.TY = DN_label_id then
                           CODE_label_id (LABEL_NAME);

                  elsif LABEL_NAME.TY = DN_block_loop_id then
                           CODE_block_loop_id (LABEL_NAME);

                  end if;
         end CODE_LABEL_NAME;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_label_id (label_id : TREE) is
         begin
                  null;
         end CODE_label_id;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_null_stm (null_stm : TREE) is
         begin
                  null;
         end CODE_null_stm;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_OBJECT (OBJECT : TREE) is
         begin
                  case OBJECT.TY is
                           when DN_VARIABLE_ID =>
                                    GEN_LOAD_ADDR
                                            (DI (CD_COMP_UNIT, OBJECT),
                                             DI (CD_LEVEL, OBJECT),
                                             DI (CD_OFFSET, OBJECT),
                                             "EMPILE ADRESSE DE VARIABLE");
                           when DN_IN_ID =>
                                    EMIT (LDA, LEVEL - DI (CD_LEVEL, OBJECT),
                                             DI (CD_OFFSET, OBJECT),
                                             "EMPILE ADRESSE DE PARAM IN");
                           when DN_IN_OUT_ID | DN_OUT_ID =>
                                    EMIT (LDA, LEVEL - DI (CD_LEVEL, OBJECT),
                                             DI (CD_VAL_OFFSET, OBJECT),
                                             "EMPILE ADRESSE PARAM IN_OUT/OUT");
                           when DN_INDEXED =>
                                    CODE_INDEXED (OBJECT);
                           when DN_USED_OBJECT_ID =>
                                    CODE_OBJECT (D (SM_DEFN, OBJECT));
                           when others =>
                                    PUT_LINE ("!!! LOAD_OBJECT_ADDRESS : OBJECT.TY ILLICITE " &
                                             NODE_NAME'Image (OBJECT.TY));
                                    raise Program_Error;
                  end case;
         end CODE_OBJECT;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_ADRESSE (ADRESSE : TREE) is
         begin
                  case ADRESSE.TY is
                           when DN_VARIABLE_ID =>
                                    GEN_LOAD (A, DI (CD_COMP_UNIT, ADRESSE),
                                             DI (CD_LEVEL, ADRESSE),
                                             DI (CD_OFFSET, ADRESSE));
                           when DN_IN_ID =>
                                    GEN_LOAD (A, 0, DI (CD_LEVEL, ADRESSE),
                                             DI (CD_OFFSET, ADRESSE));
                           when DN_IN_OUT_ID | DN_OUT_ID =>
                                    GEN_LOAD (A, 0, DI (CD_LEVEL, ADRESSE),
                                             DI (CD_VAL_OFFSET, ADRESSE));
                           when DN_INDEXED =>
                                    CODE_INDEXED (ADRESSE);
                           when DN_USED_OBJECT_ID =>
                                    CODE_ADRESSE (D (SM_DEFN, ADRESSE));
                           when others =>
                                    PUT_LINE ("!!! CODE_ADRESSE : OBJECT.TY ILLICITE " &
                                             NODE_NAME'Image (ADRESSE.TY));
                                    raise Program_Error;
                  end case;
         end CODE_ADRESSE;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_assign (assign : TREE) is
         begin
                  declare
                           NAME : TREE := D (AS_NAME, ASSIGN);
                           procedure STORE_VAL (TYPE_SPEC : TREE) is
                           begin
                                    case TYPE_SPEC.TY is
                                             when DN_ACCESS =>
                                                      EMIT (STO, A);
                                             when DN_ENUMERATION =>
                                                      declare
                                                               TYPE_SOURCE_NAME :
                                                                       TREE :=
                                                                       D (XD_SOURCE_NAME,
                                                                                TYPE_SPEC);
                                                               TYPE_SYMREP :
                                                                       TREE :=
                                                                       D (LX_SYMREP,
                                                                                TYPE_SOURCE_NAME);
                                                               NAME : constant String :=
                                                                       PRINT_NAME
                                                                               (TYPE_SYMREP);
                                                      begin
                                                               if NAME =
                                                                       "BOOLEAN"
                                                               then
                                                                        EMIT (STO,
                                                                                 B);
                                                               elsif NAME =
                                                                       "CHARACTER"
                                                               then
                                                                        EMIT (STO,
                                                                                 C);
                                                               else
                                                                        EMIT (STO,
                                                                                 I);
                                                               end if;
                                                      end;
                                             when DN_INTEGER =>
                                                      EMIT (STO, I);
                                             when DN_UNIVERSAL_INTEGER =>
                                                      declare
                                                               COMP_UNIT :
                                                                       COMP_UNIT_NBR :=
                                                                       DI (CD_COMP_UNIT,
                                                                                TYPE_SPEC);
                                                               LVL : LEVEL_TYPE :=
                                                                       DI (CD_LEVEL,
                                                                                TYPE_SPEC);
                                                               OFS : INTEGER :=
                                                                       DI (CD_OFFSET,
                                                                                TYPE_SPEC);
                                                      begin
                                                               GEN_LOAD_ADDR
                                                                       (COMP_UNIT,
                                                                        LVL,
                                                                        OFS);
                                                               EMIT (CVB);
                                                               EMIT (STO, I);
                                                      end;
                                             when others =>
                                                      PUT_LINE ("!!! STORE_VAL TYPE_SPEC.TY ILLICITE " &
                                                               NODE_NAME'Image
                                                                       (TYPE_SPEC
                                                                                .TY));
                                                      raise Program_Error;
                                    end case;
                           end STORE_VAL;
                  begin
                           --|---------------------------------------------------------------------------
                           if NAME.TY = DN_ALL then
                                    CODE_ADRESSE (D (AS_NAME, NAME));
                                    CODE_EXP (D (AS_EXP, ASSIGN));
                                    STORE_VAL (D (SM_EXP_TYPE, NAME));
                                    --|---------------------------------------------------------------------------
                           elsif NAME.TY = DN_INDEXED then
                                    CODE_INDEXED (NAME);
                                    CODE_EXP (D (AS_EXP, ASSIGN));
                                    STORE_VAL (D (SM_EXP_TYPE, NAME));
                                    --|---------------------------------------------------------------------------
                           elsif NAME.TY = DN_USED_OBJECT_ID then
                                    declare
                                             NAMEXP    : TREE :=
                                                     D (SM_EXP_TYPE, NAME);
                                             DEFN : TREE := D (SM_DEFN, NAME);
                                             COMP_UNIT : COMP_UNIT_NBR;
                                             LVL       : LEVEL_TYPE;
                                             OFS       : OFFSET_TYPE;
                                    begin
                                             --|-----------------------------------------------------------------------
                                             if NAMEXP.TY = DN_ACCESS then
                                                      CODE_EXP (D
                                                                       (AS_EXP,
                                                                        ASSIGN));
                                                      EMITS.GET_CLO
                                                              (DEFN, COMP_UNIT,
                                                               LVL, OFS);
                                                      EMITS.GEN_STORE
                                                              (A, COMP_UNIT,
                                                               LVL, OFS);
                                                      --|-----------------------------------------------------------------------
                                             elsif NAMEXP.TY = DN_ARRAY then
                                                      CODE_OBJECT (DEFN);
                                                      declare
                                                               EXP : TREE :=
                                                                       D (AS_EXP,
                                                                                ASSIGN);
                                                      begin
                                                               if EXP.TY =
                                                                       DN_USED_OBJECT_ID
                                                               then
                                                                        CODE_OBJECT
                                                                                (D (SM_DEFN,
                                                                                          EXP));
                                                                        CODE_OBJECT
                                                                                (EXP);
                                                                        EMIT (LDC,
                                                                                 I,
                                                                                 NUMBER_OF_DIMENSIONS
                                                                                         (NAMEXP),
                                                                                 COMMENT =>
                                                                                         "NB DIM");
                                                                        EMIT (CYA);
                                                               else
                                                                        CODE_EXP (D
                                                                                         (AS_EXP,
                                                                                          ASSIGN));
                                                                        EMIT (LDC,
                                                                                 I,
                                                                                 NUMBER_OF_DIMENSIONS
                                                                                         (NAMEXP),
                                                                                 COMMENT =>
                                                                                         "NB DIM");
                                                                        EMIT (PUA);
                                                               end if;
                                                      end;
                                                      --|-----------------------------------------------------------------------
                                             elsif NAMEXP.TY = DN_ENUMERATION
                                             then
                                                      CODE_EXP (D
                                                                       (AS_EXP,
                                                                        ASSIGN));
                                                      EMITS.GET_CLO
                                                              (DEFN, COMP_UNIT,
                                                               LVL, OFS);
                                                      declare
                                                               CT : CODE_TYPE :=
                                                                       CODE_TYPE_OF
                                                                               (NAMEXP);
                                                      begin
                                                               GEN_STORE
                                                                       (CT, COMP_UNIT,
                                                                        LVL,
                                                                        OFS);
                                                      end;
                                                      --|-----------------------------------------------------------------------
                                             elsif NAMEXP.TY = DN_INTEGER then
                                                      CODE_EXP (D
                                                                       (AS_EXP,
                                                                        ASSIGN));
                                                      if NAMEXP.TY /=
                                                              DN_UNIVERSAL_INTEGER
                                                      then
                                                               EMITS.GET_CLO
                                                                       (NAMEXP,
                                                                        COMP_UNIT,
                                                                        LVL,
                                                                        OFS);
                                                               GEN_LOAD_ADDR
                                                                       (COMP_UNIT,
                                                                        LVL,
                                                                        OFS);
                                                               EMIT (CVB);
                                                      end if;
                                                      EMITS.GET_CLO
                                                              (DEFN, COMP_UNIT,
                                                               LVL, OFS);
                                                      EMITS.GEN_STORE
                                                              (I, COMP_UNIT,
                                                               LVL, OFS);
                                             end if;
                                    end;
                           end if;
                  end;
         end CODE_assign;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_if (ADA_if : TREE) is
         begin
                  declare
                           OLD_AFTER_IF_LBL : LABEL_TYPE := EMITS.AFTER_IF_LBL;
                  begin
                           EMITS.AFTER_IF_LBL := NEXT_LABEL;
                           CODE_test_clause_elem_s
                                   (D (as_test_clause_elem_s, ADA_if));
                           WRITE_LABEL
                                   (EMITS.AFTER_IF_LBL,
                                    COMMENT => "ETIQUETTE END IF");
                           EMITS.AFTER_IF_LBL := OLD_AFTER_IF_LBL;
                  end;
         end CODE_if;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_TEST_CLAUSE (TEST_CLAUSE : TREE) is
         begin

                  if TEST_CLAUSE.TY = DN_cond_clause then
                           CODE_cond_clause (TEST_CLAUSE);

                  elsif TEST_CLAUSE.TY = DN_select_alternative then
                           CODE_select_alternative (TEST_CLAUSE);

                  end if;
         end CODE_TEST_CLAUSE;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_cond_clause (cond_clause : TREE) is
         begin
                  declare
                           EXP             : TREE := D (AS_EXP, COND_CLAUSE);
                           NEXT_CLAUSE_LBL : LABEL_TYPE;
                  begin
                           CODE_EXP (EXP);
                           NEXT_CLAUSE_LBL := NEXT_LABEL;
                           EMIT (JMPF, NEXT_CLAUSE_LBL,
                                    COMMENT =>
                                            "NON CONDITION SAUT CLAUSE SUIVANTE");
                           CODE_stm_s (D (as_STM_S, cond_clause));
                           EMIT (JMP, EMITS.AFTER_IF_LBL,
                                    COMMENT => "SAUT END IF");
                           WRITE_LABEL
                                   (NEXT_CLAUSE_LBL,
                                    COMMENT => "LBL CONDITION SUIVANTE");
                  end;
         end CODE_cond_clause;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_case (ADA_case : TREE) is
         begin
                  null;
         end CODE_case;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_BLOCK_LOOP (BLOCK_LOOP : TREE) is
         begin

                  if BLOCK_LOOP.TY = DN_loop then
                           CODE_loop (BLOCK_LOOP);

                  elsif BLOCK_LOOP.TY = DN_block then
                           CODE_block (BLOCK_LOOP);

                  end if;
         end CODE_BLOCK_LOOP;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_block_loop_id (block_loop_id : TREE) is
         begin
                  null;
         end CODE_block_loop_id;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_ITERATION (ITERATION : TREE) is
         begin

                  if ITERATION.TY in CLASS_FOR_REV then
                           CODE_FOR_REV (ITERATION);

                  elsif ITERATION.TY = DN_while then
                           CODE_while (ITERATION);

                  end if;
         end CODE_ITERATION;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_loop (ADA_loop : TREE) is
         begin
                  declare
                           OLD_LOOP_STM_S      : TREE := EMITS.LOOP_STM_S;
                           OLD_BEFORE_LOOP_LBL : LABEL_TYPE :=
                                   EMITS.BEFORE_LOOP_LBL;
                           OLD_AFTER_LOOP_LBL  : LABEL_TYPE :=
                                   EMITS.AFTER_LOOP_LBL;
                  begin
                           LOOP_STM_S            := D (as_STM_S, ADA_LOOP);
                           EMITS.BEFORE_LOOP_LBL := NEXT_LABEL;
                           EMITS.AFTER_LOOP_LBL  := NEXT_LABEL;
                           DI (CD_AFTER_LOOP, ADA_LOOP,
                                    INTEGER (after_Loop_Lbl));
                           DI (CD_LEVEL, ADA_LOOP, EMITS.LEVEL);
                           declare
                                    ITERATION : TREE :=
                                            D (AS_ITERATION, ADA_LOOP);
                           begin
                                    if ITERATION = TREE_VOID then
                                             WRITE_LABEL (BEFORE_LOOP_LBL);
                                             CODE_stm_s (LOOP_STM_S);
                                             EMIT (JMP, BEFORE_LOOP_LBL);
                                    else
                                             CODE_ITERATION
                                                     (D (as_iteration,
                                                               ada_loop));
                                    end if;
                           end;
                           WRITE_LABEL (AFTER_LOOP_LBL);
                           EMITS.BEFORE_LOOP_LBL := OLD_BEFORE_LOOP_LBL;
                           EMITS.AFTER_LOOP_LBL  := OLD_AFTER_LOOP_LBL;
                           EMITS.LOOP_STM_S      := OLD_LOOP_STM_S;
                  end;
         end CODE_loop;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_FOR_REV (FOR_REV : TREE) is
         begin
                  declare
                           OLD_LOOP_OP_INC_DEC : OP_CODE     :=
                                   EMITS.LOOP_OP_INC_DEC;
                           OLD_LOOP_OP_GT_LT : OP_CODE := EMITS.LOOP_OP_GT_LT;
                           COUNTER, TEMP       : Integer;
                           OLD_OFFSET_ACT : OFFSET_TYPE := EMITS.OFFSET_ACT;
                           ITERATION_ID : TREE := D (AS_SOURCE_NAME, FOR_REV);
                           aCT                 : CODE_TYPE   :=
                                   EMITS.CODE_TYPE_OF
                                           (D (SM_OBJ_TYPE, ITERATION_ID));
                           procedure LOAD_DSCRT_RANGE (DSCRT_RANGE : TREE) is
                           begin
                                    null;
                           end LOAD_DSCRT_RANGE;
                  begin
                           EMITS.BEFORE_LOOP_LBL := NEXT_LABEL;
                           EMITS.AFTER_LOOP_LBL  := NEXT_LABEL;

                           if FOR_REV.TY = DN_for then
                                    CODE_for (FOR_REV);

                           elsif FOR_REV.TY = DN_reverse then
                                    CODE_reverse (FOR_REV);

                           end if;
                           case aCT is
                                    when B =>
                                             ALIGN (BOOL_AL);
                                             COUNTER := -EMITS.OFFSET_ACT;
                                             INC_OFFSET (BOOL_SIZE);
                                             ALIGN (BOOL_AL);
                                             TEMP := -EMITS.OFFSET_ACT;
                                             INC_OFFSET (BOOL_SIZE);
                                    when C =>
                                             ALIGN (CHAR_AL);
                                             COUNTER := -EMITS.OFFSET_ACT;
                                             INC_OFFSET (CHAR_SIZE);
                                             ALIGN (CHAR_AL);
                                             TEMP := -EMITS.OFFSET_ACT;
                                             INC_OFFSET (CHAR_SIZE);
                                    when I =>
                                             ALIGN (INTG_AL);
                                             COUNTER := -EMITS.OFFSET_ACT;
                                             INC_OFFSET (INTG_SIZE);
                                             ALIGN (INTG_AL);
                                             TEMP := -EMITS.OFFSET_ACT;
                                             INC_OFFSET (INTG_SIZE);
                                    when A =>
                                             Put_Line ("!!! compile_stm_loop_reverse aCT illicite " &
                                                      CODE_TYPE'Image (aCT));
                                             raise Program_Error;
                           end case;
                           DI (CD_LEVEL, ITERATION_ID, EMITS.LEVEL);
                           DI (CD_OFFSET, ITERATION_ID, COUNTER);
                           LOAD_DSCRT_RANGE (D (as_DISCRETE_RANGE, FOR_REV));
                           EMIT (STR, aCT, 0, TEMP);
                           WRITE_LABEL (EMITS.BEFORE_LOOP_LBL);
                           EMIT (STR, aCT, 0, COUNTER);
                           EMIT (LOD, aCT, 0, COUNTER);
                           EMIT (LOD, aCT, 0, TEMP);
                           EMIT (EMITS.LOOP_OP_GT_LT, aCT);
                           EMIT (JMPT, EMITS.AFTER_LOOP_LBL);
                           CODE_stm_s (LOOP_STM_S);
                           EMIT (LOD, aCT, 0, COUNTER);
                           EMIT (EMITS.LOOP_OP_INC_DEC, aCT, 1);
                           EMIT (JMP, EMITS.BEFORE_LOOP_LBL);
                           WRITE_LABEL (EMITS.AFTER_LOOP_LBL);
                           EMITS.OFFSET_ACT      := OLD_OFFSET_ACT;
                           EMITS.LOOP_OP_INC_DEC := OLD_LOOP_OP_INC_DEC;
                           EMITS.LOOP_OP_GT_LT   := OLD_LOOP_OP_GT_LT;
                  end;
         end CODE_FOR_REV;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_for (ADA_for : TREE) is
         begin
                  LOOP_OP_INC_DEC := INC;
                  LOOP_OP_GT_LT   := GT;
         end CODE_for;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_reverse (ADA_reverse : TREE) is
         begin
                  LOOP_OP_INC_DEC := DEC;
                  LOOP_OP_GT_LT   := LT;
         end CODE_reverse;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_iteration_id (iteration_id : TREE) is
         begin
                  null;
         end CODE_iteration_id;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_while (ADA_while : TREE) is
         begin
                  BEFORE_LOOP_LBL := NEXT_LABEL;
                  AFTER_LOOP_LBL  := NEXT_LABEL;
                  WRITE_LABEL (BEFORE_LOOP_LBL);
                  CODE_EXP (D (as_EXP, ADA_WHILE));
                  EMIT (JMPF, AFTER_LOOP_LBL);
                  CODE_stm_s (LOOP_STM_S);
                  EMIT (JMP, BEFORE_LOOP_LBL);
         end CODE_while;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_block (block : TREE) is
         begin
                  declare
                           AFTER_BLOCK_LBL : LABEL_TYPE := NEXT_LABEL;
                           PROC_LBL        : LABEL_TYPE := NEXT_LABEL;
                  begin
                           EMIT (MST, Integer (0), Integer (0),
                                    COMMENT => "POUR BLOC");
                           EMIT (CALL, EMITS.RELATIVE_RESULT_OFFSET, PROC_LBL,
                                    COMMENT => "APPEL DE BLOC");
                           EMIT (JMP, AFTER_BLOCK_LBL,
                                    COMMENT => "SAUT POST BLOC");
                           WRITE_LABEL (PROC_LBL);
                           declare
                                    OLD_OFFSET_ACT : OFFSET_TYPE :=
                                            EMITS.OFFSET_ACT;
                                    OLD_OFFSET_MAX : OFFSET_TYPE :=
                                            EMITS.OFFSET_MAX;
                           begin
                                    EMITS.OFFSET_ACT := FIRST_LOCAL_VAR_OFFSET;
                                    EMITS.OFFSET_MAX := FIRST_LOCAL_VAR_OFFSET;
                                    INC_LEVEL;
                                    CODE_block_body (D (as_block_body, block));
                                    DEC_LEVEL;
                                    EMITS.OFFSET_ACT := OLD_OFFSET_ACT;
                                    EMITS.OFFSET_MAX := OLD_OFFSET_MAX;
                           end;
                           WRITE_LABEL (AFTER_BLOCK_LBL);
                  end;
         end CODE_block;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_exit (ADA_exit : TREE) is
         begin
                  declare
                           LVB_LBL          : LABEL_TYPE;
                           EXP              : TREE := D (AS_EXP, ada_exit);
                           LOOP_STM         : TREE := D (SM_STM, ada_exit);
                           LOOP_LEVEL : LEVEL_TYPE := DI (CD_LEVEL, LOOP_STM);
                           AFTER_LOOP_LABEL : LABEL_TYPE :=
                                   LABEL_TYPE (DI (CD_AFTER_LOOP, LOOP_STM));
                  begin
                           if EXP = TREE_VOID then
                                    if LOOP_LEVEL /= EMITS.LEVEL then
                                             LVB_LBL := NEXT_LABEL;
                                             EMIT (LVB, LVB_LBL,
                                                      COMMENT =>
                                                              "NOMBRE DE NIVEAUX REMONTES");
                                             GEN_LBL_ASSIGNMENT
                                                     (LVB_LBL,
                                                      EMITS.LEVEL -
                                                      LOOP_LEVEL);
                                    end if;
                                    EMIT (JMP, AFTER_LOOP_LABEL,
                                             COMMENT => "SORTIE DE BOUCLE");
                           else
                                    CODE_EXP (EXP);
                                    if LOOP_LEVEL /= EMITS.LEVEL then
                                             declare
                                                      SKIP_LBL : LABEL_TYPE :=
                                                              NEXT_LABEL;
                                             begin
                                                      EMIT (JMPF, SKIP_LBL,
                                                               COMMENT =>
                                                                       "PAS D EXIT SI CONDITION FAUSSE");
                                                      LVB_LBL := NEXT_LABEL;
                                                      EMIT (LVB, LVB_LBL,
                                                               COMMENT =>
                                                                       "NOMBRE DE NIVEAUX REMONTES");
                                                      GEN_LBL_ASSIGNMENT
                                                              (LVB_LBL,
                                                               EMITS.LEVEL -
                                                               LOOP_LEVEL);
                                                      EMIT (JMP,
                                                               AFTER_LOOP_LABEL,
                                                               COMMENT =>
                                                                       "SORTIE DE BOUCLE");
                                                      WRITE_LABEL
                                                              (SKIP_LBL,
                                                               COMMENT =>
                                                                       "LABEL NO EXIT");
                                             end;
                                    else
                                             EMIT (JMPT, AFTER_LOOP_LABEL);
                                    end if;
                           end if;
                  end;
         end CODE_exit;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_return (ADA_return : TREE) is
         begin
                  declare
                           EXP : TREE := D (AS_EXP, ADA_RETURN);
                  begin
                           if EXP /= TREE_VOID then
                                    STORE_FUNCTION_RESULT :
                                    declare
                                             ENCLOSING_LEVEL : INTEGER :=
                                                     DI (CD_LEVEL,
                                                              EMITS.ENCLOSING_BODY);
                                             RESULT_OFFSET   : INTEGER :=
                                                     DI (CD_RESULT_OFFSET,
                                                              EMITS.ENCLOSING_BODY);
                                             EXPR_TYPE       : TREE    :=
                                                     D (SM_EXP_TYPE, EXP);
                                    begin
                                             if EXPR_TYPE.TY = DN_ARRAY then
                                                      EMIT (LDA,
                                                               EMITS.LEVEL -
                                                               ENCLOSING_LEVEL,
                                                               RESULT_OFFSET);
                                                      CODE_EXP (EXP);
                                                      EMIT (LDC, I,
                                                               EMITS.NUMBER_OF_DIMENSIONS
                                                                       (EXP));
                                                      EMIT (PUA);
                                             elsif EXPR_TYPE.TY =
                                                     DN_ENUM_LITERAL_S
                                             then
                                                      CODE_EXP (EXP);
                                                      EMIT (STR,
                                                               EMITS.CODE_TYPE_OF
                                                                       (EXP),
                                                               EMITS.LEVEL -
                                                               ENCLOSING_LEVEL,
                                                               RESULT_OFFSET);
                                             elsif EXPR_TYPE.TY = DN_INTEGER
                                             then
                                                      CODE_EXP (EXP);
                                                      EMIT (STR, I,
                                                               EMITS.LEVEL -
                                                               ENCLOSING_LEVEL,
                                                               RESULT_OFFSET);
                                             end if;
                                    end STORE_FUNCTION_RESULT;
                           end if;
                           EMITS.PERFORM_RETURN (EMITS.ENCLOSING_BODY);
                  end;
         end CODE_return;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_goto (ADA_goto : TREE) is
         begin
                  null;
         end CODE_goto;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_NON_TASK_NAME (NON_TASK_NAME : TREE) is
         begin

                  if NON_TASK_NAME.TY = DN_generic_id then
                           CODE_generic_id (NON_TASK_NAME);

                  elsif NON_TASK_NAME.TY in CLASS_SUBPROG_PACK_NAME then
                           CODE_SUBPROG_PACK_NAME (NON_TASK_NAME);

                  end if;
         end CODE_NON_TASK_NAME;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_SUBPROG_PACK_NAME (SUBPROG_PACK_NAME : TREE) is
         begin

                  if SUBPROG_PACK_NAME.TY = DN_package_id then
                           CODE_package_id (SUBPROG_PACK_NAME);

                  elsif SUBPROG_PACK_NAME.TY in CLASS_SUBPROG_NAME then
                           CODE_SUBPROG_NAME (SUBPROG_PACK_NAME);

                  end if;
         end CODE_SUBPROG_PACK_NAME;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_SUBPROG_NAME (SUBPROG_NAME : TREE) is
         begin

                  if SUBPROG_NAME.TY = DN_procedure_id then
                           CODE_procedure_id (SUBPROG_NAME);

                  elsif SUBPROG_NAME.TY = DN_function_id then
                           CODE_function_id (SUBPROG_NAME);

                  elsif SUBPROG_NAME.TY = DN_operator_id then
                           CODE_operator_id (SUBPROG_NAME);

                  end if;
         end CODE_SUBPROG_NAME;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_procedure_id (procedure_id : TREE) is
         begin
                  null;
         end CODE_procedure_id;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_function_id (function_id : TREE) is
         begin
                  null;
         end CODE_function_id;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_operator_id (operator_id : TREE) is
         begin
                  null;
         end CODE_operator_id;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_INIT_OBJECT_NAME (INIT_OBJECT_NAME : TREE) is
         begin

                  if INIT_OBJECT_NAME.TY = DN_number_id then
                           CODE_number_id (INIT_OBJECT_NAME);

                  elsif INIT_OBJECT_NAME.TY in CLASS_VC_NAME then
                           CODE_VC_NAME (INIT_OBJECT_NAME);

                  elsif INIT_OBJECT_NAME.TY in CLASS_COMP_NAME then
                           CODE_COMP_NAME (INIT_OBJECT_NAME);

                  elsif INIT_OBJECT_NAME.TY in CLASS_PARAM_NAME then
                           CODE_PARAM_NAME (INIT_OBJECT_NAME);

                  end if;
         end CODE_INIT_OBJECT_NAME;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_PARAM_NAME (PARAM_NAME : TREE) is
         begin

                  if PARAM_NAME.TY = DN_in_id then
                           CODE_in_id (PARAM_NAME);

                  elsif PARAM_NAME.TY in CLASS_PARAM_IO_O then
                           CODE_PARAM_IO_O (PARAM_NAME);

                  end if;
         end CODE_PARAM_NAME;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_PARAM_IO_O (PARAM_IO_O : TREE) is
         begin

                  if PARAM_IO_O.TY = DN_in_out_id then
                           CODE_in_out_id (PARAM_IO_O);

                  elsif PARAM_IO_O.TY = DN_out_id then
                           CODE_out_id (PARAM_IO_O);

                  end if;
         end CODE_PARAM_IO_O;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_in_id (in_id : TREE) is
         begin
                  null;
         end CODE_in_id;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_in_out_id (in_out_id : TREE) is
         begin
                  null;
         end CODE_in_out_id;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_out_id (out_id : TREE) is
         begin
                  null;
         end CODE_out_id;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_procedure_call (procedure_call : TREE) is
         begin
                  null;
         end CODE_procedure_call;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_function_call (function_call : TREE) is
         begin
                  null;
         end CODE_function_call;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_package_id (package_id : TREE) is
         begin
                  null;
         end CODE_package_id;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_private_type_id (private_type_id : TREE) is
         begin
                  null;
         end CODE_private_type_id;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_l_private_type_id (l_private_type_id : TREE) is
         begin
                  null;
         end CODE_l_private_type_id;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_task_body_id (task_body_id : TREE) is
         begin
                  null;
         end CODE_task_body_id;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_entry_id (entry_id : TREE) is
         begin
                  null;
         end CODE_entry_id;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_entry_call (entry_call : TREE) is
         begin
                  null;
         end CODE_entry_call;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_accept (ADA_accept : TREE) is
         begin
                  null;
         end CODE_accept;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_delay (ADA_delay : TREE) is
         begin
                  null;
         end CODE_delay;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_selective_wait (selective_wait : TREE) is
         begin
                  null;
         end CODE_selective_wait;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_TEST_CLAUSE_ELEM (TEST_CLAUSE_ELEM : TREE) is
         begin

                  if TEST_CLAUSE_ELEM.TY in CLASS_TEST_CLAUSE then
                           CODE_TEST_CLAUSE (TEST_CLAUSE_ELEM);

                  elsif TEST_CLAUSE_ELEM.TY = DN_select_alt_pragma then
                           CODE_select_alt_pragma (TEST_CLAUSE_ELEM);

                  end if;
         end CODE_TEST_CLAUSE_ELEM;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_test_clause_elem_s (test_clause_elem_s : TREE) is
         begin
                  declare
                           test_clause_elem_seq : SEQ_TYPE :=
                                   LIST (test_clause_elem_s);
                           test_clause_elem     : TREE;
                  begin
                           while not IS_EMPTY (test_clause_elem_seq) loop
                                    POP (test_clause_elem_seq,
                                             test_clause_elem);
                                    CODE_TEST_CLAUSE_ELEM (test_clause_elem);
                           end loop;
                  end;
         end CODE_test_clause_elem_s;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_select_alternative (select_alternative : TREE) is
         begin
                  null;
         end CODE_select_alternative;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_select_alt_pragma (select_alt_pragma : TREE) is
         begin
                  null;
         end CODE_select_alt_pragma;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_terminate (ADA_terminate : TREE) is
         begin
                  null;
         end CODE_terminate;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_ENTRY_STM (ENTRY_STM : TREE) is
         begin

                  if ENTRY_STM.TY = DN_cond_entry then
                           CODE_cond_entry (ENTRY_STM);

                  elsif ENTRY_STM.TY = DN_timed_entry then
                           CODE_timed_entry (ENTRY_STM);

                  end if;
         end CODE_ENTRY_STM;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_cond_entry (cond_entry : TREE) is
         begin
                  null;
         end CODE_cond_entry;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_timed_entry (timed_entry : TREE) is
         begin
                  null;
         end CODE_timed_entry;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_name_s (name_s : TREE) is
         begin
                  declare
                           name_seq : SEQ_TYPE := LIST (name_s);
                           name     : TREE;
                  begin
                           while not IS_EMPTY (name_seq) loop
                                    POP (name_seq, name);
                                    CODE_NAME (name);
                           end loop;
                  end;
         end CODE_name_s;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_abort (ADA_abort : TREE) is
         begin
                  null;
         end CODE_abort;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_exception_id (exception_id : TREE) is
         begin
                  declare
                           LBL : LABEL_TYPE := NEXT_LABEL;
                  begin
                           DI (CD_LABEL, EXCEPTION_ID, INTEGER (LBL));
                           EMIT (EXL, LBL,
                                    S       => PRINT_NAME
                                                    (D (LX_SYMREP,
                                                              EXCEPTION_ID)),
                                    COMMENT =>
                                            "NUMERO D EXCEPTION SUR DECLARATION");
                  end;
         end CODE_exception_id;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_raise (ADA_raise : TREE) is
         begin
                  declare
                           NAME : TREE := D (AS_NAME, ADA_RAISE);
                  begin
                           if NAME = TREE_VOID then
                                    EMIT (RAI);
                           else
                                    declare
                                             EXCEPTION_ID : TREE :=
                                                     D (SM_DEFN, NAME);
                                             LBL          : LABEL_TYPE;
                                    begin
                                             if D (CD_LABEL, EXCEPTION_ID)
                                                             .TY /=
                                                     DN_NUM_VAL
                                             then
                                                      LBL := NEXT_LABEL;
                                                      DI (CD_LABEL,
                                                               EXCEPTION_ID,
                                                               INTEGER (LBL));
                                                      EMIT (EXL, LBL,
                                                               S => PRINT_NAME
                                                                               (D (LX_SYMREP,
                                                                                         NAME)),
                                                               COMMENT =>
                                                                       "NUMERO D EXCEPTION EXTERNE SUR RAISE");
                                             end if;
                                             EMIT (RAI,
                                                     DI (CD_LABEL,
                                                               EXCEPTION_ID));
                                    end;
                           end if;
                  end;
         end CODE_raise;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_generic_id (generic_id : TREE) is
         begin
                  null;
         end CODE_generic_id;

         --|-------------------------------------------------------------------------------------------
         procedure CODE_code (code : TREE) is
         begin
                  null;
         end CODE_code;

begin
         OPEN_IDL_TREE_FILE (LIB_PATH (1 .. LIB_PATH_LENGTH) & "$$$.TMP");
         if DI (XD_ERR_COUNT, TREE_ROOT) = 0 then

                  CODE_root (TREE_ROOT);

         end if;
         CLOSE_IDL_TREE_FILE;
end CODE_GEN;
