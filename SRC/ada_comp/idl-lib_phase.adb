WITH SEQUENTIAL_IO;
SEPARATE ( IDL )
--|-------------------------------------------------------------------------------------------------
--|	PROCEDURE LIB_PHASE
PROCEDURE LIB_PHASE IS
   
  INITIAL_TIMESTAMP		: INTEGER;
  CUR_TIMESTAMP		: INTEGER;
  LIB_INFO_SEQ		: SEQ_TYPE	:= (TREE_NIL, TREE_NIL);			--| LISTE DES NOEUDS LIB_INFO
   
  GENERIC_LIST		: SEQ_TYPE	:= (TREE_NIL, TREE_NIL);
  LOADED_UNIT_LIST		: SEQ_TYPE	:= (TREE_NIL, TREE_NIL);
   
  NEW_UNIT_LIST		: SEQ_TYPE	:= (TREE_NIL, TREE_NIL);
  TRANS_WITH_SEQ		: SEQ_TYPE;						--| LISTE FERMETURE TRANSITIVE DES "WITH" D UNE UNITE DE LA COMPILATION
   
  CHTABLE			: CONSTANT STRING( 1..32 ) := "0123456789ABCDEFGHJKLMNPRSTVWXYZ";
   
  --|-----------------------------------------------------------------------------------------------
  --|	PROCEDURE OPEN_LIBRARY
  PROCEDURE OPEN_LIBRARY IS
    FCTL			: TEXT_IO.FILE_TYPE;					--| FICHIER DE CONTOLE DE LA LIBRAIRIE
    LIB_CHAR		: CHARACTER;
    DUMMY_CHAR		: CHARACTER;
    LIB_NUM		: INTEGER;
    LIB_SHORT		: STRING( 1 .. 256 );					--| NOM COURT INTERNE DE LIBRAIRIE POUR L'UNITE
    LIB_TEXT_1		: STRING( 1 .. 256 );					--| POUR LE NOM D'UNITE (NON SEPAREE) OU D'UNITE PARENTE (POUR UNITE SEPAREE)
    LIB_TEXT_2		: STRING( 1 .. 256 );					--| $ POUR UNITE NON SEPAREE, NOM D'UNITE SEPAREE SINON
    LIB_SHORT_LENGTH	: INTEGER;
    LIB_TEXT_1_LENGTH	: INTEGER;
    LIB_TEXT_2_LENGTH	: INTEGER;
    LAST			: INTEGER;
    LIB_INFO		: TREE;
    USE IDL.INT_IO;
  BEGIN
    OPEN( FCTL, IN_FILE, IDL.LIB_PATH( 1..LIB_PATH_LENGTH ) & "ADA__LIB.CTL" );			--| OUVRIR LE FICHIER CONTROLE LIBRAIRIE
         
    LOOP
      GET( FCTL, LIB_CHAR );								--| PREMIER CARACTERE DE LA LIGNE (TYPE DE LIGNE)
      IF LIB_CHAR = 'T' THEN								--| LIGNE ETIQUETTE DE VERSION (TIME STAMP)
        GET( FCTL, LIB_NUM );								--| LIRE LE No DE VERSION
        INITIAL_TIMESTAMP := LIB_NUM;							--| INITIALISER
        CUR_TIMESTAMP := LIB_NUM;
        EXIT;									--| SORTIR DE LA BOUCLE, C'EST LA DERNIERE LIGNE DU FICHIER CONTROLE
      ELSIF LIB_CHAR = 'P' THEN							--| LIGNE CHEMIN DE LA LIBRAIRIE (PATH)
        SKIP_LINE( FCTL );								--| SAUTER (INUTILE ICI)
      ELSIF LIB_CHAR = 'S' OR LIB_CHAR = 'U' THEN						--| LIGNE U OU S (UNITE OU UNITE SEPAREE
        GET( FCTL, DUMMY_CHAR );							--| PASSER LE BLANC
        GET_LINE( FCTL, LIB_SHORT, LAST );						--| LIRE LE NOM COURT
        LIB_SHORT_LENGTH := LAST;							--| LONGUEUR DU NOM INTERNE COURT
        GET_LINE( FCTL, LIB_TEXT_1, LAST );						--| LIRE LE NOM D'UNITE (SI PAS SEPAREE) OU LE NOM DE PARENTE (SI UNITE SEPAREE)
        LIB_TEXT_1_LENGTH := LAST;							--| SA LONGUEUR
        IF LIB_CHAR = 'U' THEN							--| LIGNE U (UNSEPARATED UNIT, LES UNITES NON "SEPARATE")
          LIB_TEXT_2( 1..1 ) := "$";							--| NOM SECONDAIRE EN $
          LIB_TEXT_2_LENGTH := 1;							--| LONGUEUR EGALE A UN
        ELSIF LIB_CHAR = 'S' THEN							--| LIGNE S (SEPARATED UNIT, LES UNITES "SEPARATE")
          GET_LINE( FCTL, LIB_TEXT_2, LAST );						--| LIRE LE NOM D'UNITE SEPAREE (PAS CONFONDRE AVEC LE NOM DE SA PARENTE ! )
          LIB_TEXT_2_LENGTH := LAST;							--| SA LONGUEUR
        ELSE									--| AUTRE PREMIER CARACTERE
          PUT_LINE( "FICHIER DE CONTROLE LIBRAIRIE MAL FORME : LETTRE TYPE LIGNE INCONNUE" );	--| ERREUR SUR LE PREMIER CARACTERE
          RAISE PROGRAM_ERROR;
        END IF;
               
        LIB_INFO := MAKE( DN_LIB_INFO );						--| FABRIQUER UN NOEUD LIB_INFO
        D( XD_SHORT, LIB_INFO, STORE_SYM( LIB_SHORT( 1 .. LIB_SHORT_LENGTH ) ) );		--| NOM COURT (INTERNE A LA LIBRAIRIE)
        D( XD_PRIMARY, LIB_INFO, STORE_SYM( LIB_TEXT_1( 1 .. LIB_TEXT_1_LENGTH ) ) );		--| NOM LONG (D'UNITE SI NON SEPAREE, D'UNITE PARENTE DE SEPAREE SINON)
        D( XD_SECONDARY, LIB_INFO, STORE_SYM( LIB_TEXT_2( 1.. LIB_TEXT_2_LENGTH ) ) );		--| $ SI UNITE NON SEPAREE, NOM D'UNITE SEPAREE SINON
        LIB_INFO_SEQ := APPEND( LIB_INFO_SEQ, LIB_INFO );					--| AJOUTER A LA LISTE DES NOEUDS LIB_INFO
      END IF;
    END LOOP;

    CLOSE( FCTL );									--| FERMER LE FICHIER CONTROLE LIBRAIRIE
  END OPEN_LIBRARY;
  --|-----------------------------------------------------------------------------------------------
  --|	PROCEDURE CLOSE_LIBRARY
  PROCEDURE CLOSE_LIBRARY IS
    FCTL			: TEXT_IO.FILE_TYPE;					--| FICHIER CONTROLE
    LIB_PREFIX		: CONSTANT STRING	:= GET_LIB_PREFIX;
  BEGIN
    CREATE( FCTL, OUT_FILE, IDL.LIB_PATH( 1..LIB_PATH_LENGTH ) & "ADA__LIB.CTL" );		--| RECREER LE FICHIER CONTROLE
    IF LIB_PREFIX'LENGTH /= 0 THEN							--| S'IL Y A UNE LIGNE DE PREFIXE LIBRAIRIE (CHEMIN DE CELLE-CI)
      PUT_LINE( FCTL, "P " & LIB_PREFIX );						--| METTRE LA LIGNE P (PREFIXE CHEMIN DU REPERTOIRE LIBRAIRIE)
    END IF;
         
    DECLARE
      LINFO_SEQ	: SEQ_TYPE	:= LIB_INFO_SEQ;					--| LISTE DES NOEUDS LIB_INFO
      LIB_INFO	: TREE;
    BEGIN
      WHILE NOT IS_EMPTY( LINFO_SEQ ) LOOP						--| TANT QUE LA LISTE DES LIB_INFO EST NON VIDE
        POP( LINFO_SEQ, LIB_INFO );							--| EXTRAIRE UN LIB_INFO
        DECLARE
          EXTEN	: TREE	:= D( XD_SECONDARY, LIB_INFO );				--| LIRE LE NOM SECONDAIRE (NOM D'UNITE SEPAREE OU SIMPLE $ POUR LES AUTRES NON SEPAREES)
          DOLLAR	: TREE	:= STORE_SYM( "$" );					--| STOCKER/RETROUVER LE SYMBOLE $
        BEGIN
          IF EXTEN = DOLLAR THEN							--| SI SECONDAIRE $ (UNITE NON SEPAREE)
            PUT( FCTL, "U ");								--| LIGNE U (UNSEPARATED UNIT)
            PUT_LINE( FCTL, PRINT_NAME ( D( XD_SHORT, LIB_INFO ) ) );				--| NOM COURT INTERNE	
            PUT_LINE( FCTL, PRINT_NAME ( D( XD_PRIMARY, LIB_INFO ) ) );			--| ET NOM PRIMAIRE (NOM COMPLET DE L'UNITE)
          ELSE
            PUT( FCTL, "S ");								--| LIGNE S (SEPARATED UNIT)
            PUT_LINE( FCTL, PRINT_NAME ( D( XD_SHORT, LIB_INFO ) ) );				--| NOM COURT
            PUT_LINE( FCTL, PRINT_NAME ( D( XD_PRIMARY, LIB_INFO ) ) );			--| NOM PRIMAIRE D'UNITE PARENTE DE SEPAREE
            PUT_LINE( FCTL, PRINT_NAME ( D( XD_SECONDARY, LIB_INFO ) ) );			--| NOM D'UNITE SEPAREE DANS CE CAS
          END IF;
        END;
      END LOOP;
    END;
         
    PUT( FCTL, "T " );								--| LIGNE T (ESTAMPILLE "TEMPS" OU No DE MODIFICATION)
    INT_IO.PUT( FCTL, CUR_TIMESTAMP, 0 );						--| INDICE TEMPOREL
    NEW_LINE( FCTL );								--| PASSER A LA LIGNE
    CLOSE( FCTL );									--| FERMER LE FICHIER DE CONTROLE LIBRAIRIE
  END CLOSE_LIBRARY;
  --|-----------------------------------------------------------------------------------------------
  --|	PROCEDURE MAKE_FILE_SYM
  FUNCTION MAKE_FILE_SYM ( PRI, SEC :STRING ) RETURN TREE IS
    PRISYM		: TREE;
    SECSYM		: TREE;
    TEMP_INFO_SEQ		: SEQ_TYPE;
    LIB_INFO		: TREE;
    EXTEN			: STRING( 1 .. 4 );
    FILESYM		: TREE;
  BEGIN
    IF SEC = ".DCL" OR ELSE SEC = ".BDY" THEN						--| UNITES PRIMAIRES ET SECONDAIRES
      IF PRI'LENGTH <= 8 THEN								--| NOM DE MOINS DE 9 CARACTERES
        RETURN STORE_SYM( PRI & SEC );							--| STOCKER LE NOM.EXT ET RETOURNER LE SYMBOLE
      ELSE									--| NOM DE 9 CARACTERES OU PLUS
        SECSYM := STORE_SYM( "$" );							--| STOCKER (OU RETROUVER) UN SYMBOLE $ POUR SEC_SYM
        EXTEN := SEC( SEC'FIRST..SEC'FIRST+3 );						--| JUSTE 4 CARACTERES DE LA CHAINE "SEC"
      END IF;
    ELSE										--| SOUS UNITE SEPAREE D'UNE UNITE DE LIBRAIRIE
      SECSYM := STORE_SYM( SEC );							--| STOCKER LE NOM DE CORPS SEPARE
      EXTEN := ".SUB";
    END IF;
    PRISYM := STORE_SYM( PRI );							--| STOCKER LE NOM PRIMAIRE
      
    TEMP_INFO_SEQ := LIB_INFO_SEQ;							--| LISTE DES LIB_INFO
    WHILE NOT IS_EMPTY( TEMP_INFO_SEQ ) LOOP						--| TANT QU'IL Y EN A
      POP( TEMP_INFO_SEQ, LIB_INFO );							--| EXTRAIRE UN LIB_INFO
      IF D( XD_PRIMARY, LIB_INFO ) = PRISYM						--| CONTIENT UN MEME NOM LONG
      AND THEN D( XD_SECONDARY, LIB_INFO ) = SECSYM					--| AVEC LA MEME EXTENSION
      THEN
        RETURN STORE_SYM( PRINT_NAME( D( XD_SHORT, LIB_INFO ) ) & EXTEN );			--| RETOURNER LE NOM COURT AVEC EXTENSION CORRESPONDANT
      END IF;
    END LOOP;
      					--| SI L'ON EST LA ON A PAS TROUVE DE NOM COURT DANS LA LIBRAIRIE
    DECLARE
      FILETEXT	: STRING( 1 .. 8 )	:= "$$$$$$$$";					--| CHAINE DE 8 CARACTERES
      NUM_WORK	: INTEGER;
    BEGIN
      NUM_WORK := PRI'LENGTH;								--| LONGUEUR DU NOM
      IF NUM_WORK > 4 THEN								--| DEPASSE 4 CARACTERES
        NUM_WORK := 4;								--| LIMITER A 4
      END IF;
      FILETEXT( 1..NUM_WORK ) := PRI( PRI'FIRST..PRI'FIRST+NUM_WORK-1 );			--| REPORTER LE NOM
      NUM_WORK := CUR_TIMESTAMP + 1;							--| ESTAMPILLE DE TEMPS INCREMENTEE
      FOR I IN REVERSE 6..8 LOOP							--| DE 8 A 6 A REBOURS
        FILETEXT( I ) := CHTABLE( NUM_WORK MOD 32 + 1 );					--| COMPLETER LES 4 (AU PLUS) CARACTERES DE NOM PAR DES CARACTERES CHOISIS DANS LA TABLE 
        NUM_WORK := NUM_WORK / 32;
      END LOOP;
      FILESYM := STORE_SYM( FILETEXT & EXTEN );						--| STOCKER CE SYMBOLE ARTIFICIEL
      LIB_INFO := MAKE( DN_LIB_INFO );							--| FABRIQUER UN LIB_INFO
      D( XD_SHORT, LIB_INFO, STORE_SYM( FILETEXT ) );					--| Y PORTER LE SYMBOLE
    END;
    D( XD_PRIMARY, LIB_INFO, PRISYM );							--| Y PORTER AUSSI LE SYMBOLE NOM PRIMAIRE (NOM D'UNITE OU D'UNITE PARENTE DE SEPAREE)
    D( XD_SECONDARY, LIB_INFO, SECSYM );						--| PORTER LE $ (UNITES NON SEPAREES) OU LE NOM D'UNITE SEPAREE
    LIB_INFO_SEQ := APPEND( LIB_INFO_SEQ, LIB_INFO );					--| CHAINER LE LIB_INFO
    RETURN FILESYM;
  END MAKE_FILE_SYM;
  --|-----------------------------------------------------------------------------------------------
  --|	PROCEDURE INSERT_FILE_NAME
  PROCEDURE INSERT_FILE_NAME ( COMP_UNIT :TREE ) IS
    UNIT_BODY		: TREE	:= D( AS_ALL_DECL, COMP_UNIT );
    FILE_SYM		: TREE;
  BEGIN
    IF UNIT_BODY.TY /= DN_SUBUNIT THEN							--| SI PAS UNE SOUS UNITE (PAS UNE UNITE "SEPARATE")
--|
--|		CAS UNITE CORPS : PACKAGE BODY / PROCEDURE ... IS
--|         
      IF UNIT_BODY.TY = DN_PACKAGE_BODY OR ELSE UNIT_BODY.TY = DN_SUBPROGRAM_BODY THEN		--| CORPS SOUS PROGRAMME OU PACKAGE
        FILE_SYM := MAKE_FILE_SYM(							--| FABRIQUER (OU TROUVER) UNE ENTREE DE LIBRAIRIE (UN LIB_INFO)
           		PRINT_NAME( D( LX_SYMREP, D( AS_SOURCE_NAME, UNIT_BODY ) ) ),	--| AVEC LE NOM D'UNITE
                  		".BDY"							--| ET UNE EXTENSION ".BDY"
                  		);
--|
--|		CAS UNITE SPEC : PACKAGE / PROCEDURE
--|
      ELSE									--| SPEC SOUS PROGRAMME, GENERIQUE OU PACKAGE
        FILE_SYM := MAKE_FILE_SYM(							--| FABRIQUER (OU TROUVER) UNE ENTREE DE LIBRAIRIE (UN LIB_INFO)
			PRINT_NAME ( D( LX_SYMREP, D( AS_SOURCE_NAME, UNIT_BODY ) ) ),	--| AVEC LE NOM D'UNITE
			".DCL"							--| ET EXTENSION ".DCL"
			);
      END IF;
--|
--|		CAS SEPARATE( X.Y.Z.A ) PACKAGE BODY / PROCEDURE ... IS
--|
    ELSE										--| SOUS UNITE (SEPAREE)
      DECLARE
        SEP_NAME		: TREE	:= D( AS_NAME, UNIT_BODY );				--| NOM MIS DANS LE "SEPARATE"
      BEGIN
FOLLOW_SELECTORS:
        WHILE SEP_NAME.TY = DN_SELECTED LOOP						--| TANT QUE NOM INTERMEDIAIRE X.Y.Z.A
          SEP_NAME := D( AS_NAME, SEP_NAME );						--| SUIVRE LA CHAINE DES POINTS
        END LOOP FOLLOW_SELECTORS;

        DECLARE
          SUBUNIT_BODY	: TREE	:= D( AS_SUBUNIT_BODY, UNIT_BODY );	--| LE CORPS SEPARE
          NAME		: TREE	:= D( AS_SOURCE_NAME, SUBUNIT_BODY );	--| LE NOM DU CORPS SEPARE
        BEGIN
          FILE_SYM := MAKE_FILE_SYM(
	PRINT_NAME( D( LX_SYMREP, SEP_NAME ) ),						--| NOM PRIMAIRE LE NOM FINAL "A" DU X.Y.Z.A OU PARENT DIRECT
	PRINT_NAME( D( LX_SYMREP, NAME ) )						--| NOM DU CORPS SEPARE LUI MEME
	);
        END;
      END;
    END IF;
         
    D( XD_LIB_NAME, COMP_UNIT, FILE_SYM );						--| RANGER LE SYMBOLE DE NOM DANS LE XD_LIB_NAME DU NOEUD DN_COMPILATION_UNIT
  END INSERT_FILE_NAME;
  --|-----------------------------------------------------------------------------------------------
  --|	PROCEDURE LOAD_UNIT
  FUNCTION LOAD_UNIT ( FILESYM_ARG :TREE ) RETURN TREE IS    
    FILESYM		: TREE		:= FILESYM_ARG;
    UNIT			: TREE		:= TREE_VOID;
    DLTA			: INTEGER;						--| DECALAGE DE PAGE DU AU CHARGEMENT D'UN ARBRE ANTERIEUREMENT COMPILE
    UNIT_TIMESTAMP		: INTEGER;
    --|---------------------------------------------------------------------------------------------
    FUNCTION OFFSET ( T :TREE ) RETURN TREE IS						--| DECALE LA PAGE D'UN POINTEUR ANTIQUE (COMPILATION ANTERIEURE) POUR EN FAIRE UN POINTEUR ACTUEL
      TEMP	: TREE	:= T;
    BEGIN
      TEMP.PG := PAGE_IDX( INTEGER( TEMP.PG ) + DLTA );					--| AJOUTER LE DECALAGE DE PAGE AU CHARGEMENT
      RETURN TEMP;
    END OFFSET;
    --|---------------------------------------------------------------------------------------------
    PROCEDURE LOAD_WITHED_UNIT ( WUNIT :TREE ) IS
      UNIT:	TREE;
    BEGIN
      UNIT := LOAD_UNIT( STORE_SYM (							--| APPEL RECURSIF POUR CHARGER UNE UNITE "WITHED" DE CELLE D'ABORD CHARGEE
	PRINT_NAME( OFFSET( D( TW_FILENAME, OFFSET( WUNIT ) ) ) )
 	) );

      IF UNIT = TREE_VOID THEN							--| PAS TROUVE L'UNITE A INCLURE
        RAISE NAME_ERROR;
      END IF;

      IF DI( XD_TIMESTAMP, UNIT) >= UNIT_TIMESTAMP THEN					--| L'UNITE "WITHED" EST PLUS RECENTE QUE CELLE QUI L'UTILISE (ANORMAL ! )
        PUT_LINE( "ANOMALIE : " & PRINT_NAME( D( XD_LIB_NAME,UNIT ) )
		& " PAS ANTERIEURE A " & PRINT_NAME( FILESYM ) );
        RAISE NAME_ERROR;
      END IF;
    END LOAD_WITHED_UNIT;
    --|---------------------------------------------------------------------------------------------
    PROCEDURE RELOCATE_UNIT ( UNIT :TREE; WUNIT_SEQ :SEQ_TYPE ) IS
      RELOC	: ARRAY( VPG_NUM ) OF PAGE_IDX	:= (OTHERS=> 0);			--| ASSEZ GRAND TABLEAU
      PNTR	: TREE				:= UNIT;
      LAST_PAGE	: PAGE_IDX			:= PNTR.PG
						+ PAGE_IDX( DI( XD_NBR_PAGES, UNIT ) ) - 1;
      NODE_KIND	: NODE_NAME;
      --|-------------------------------------------------------------------------------------------
      PROCEDURE RELOC_FOR_WUNIT ( WUNIT :TREE ) IS
        TRANS_WITH	: TREE		:= OFFSET( WUNIT );
        NEW_UNIT	: TREE		:= LOAD_UNIT(
			STORE_SYM( PRINT_NAME( OFFSET( D( TW_FILENAME, TRANS_WITH ) ) ) )
               		);
        FIRST_PAGE	: PAGE_IDX	:= NEW_UNIT.PG;
        UNIT_PNTR	: TREE		:= D( TW_COMP_UNIT, TRANS_WITH );			--| L'ANTIQUE POINTEUR (PAS RECALE)
        DLTA	: INTEGER		:= INTEGER( FIRST_PAGE ) - INTEGER( UNIT_PNTR.PG );	--| DECALAGE DE PAGE
        NBR_PAGES	: PAGE_IDX	:= PAGE_IDX( DI( XD_NBR_PAGES,
			(P, TY=> DN_COMPILATION_UNIT, PG=> FIRST_PAGE, LN=> 0) ) );
      BEGIN
        FOR I IN UNIT_PNTR.PG .. UNIT_PNTR.PG + NBR_PAGES - 1 LOOP
          RELOC( I ) := PAGE_IDX( INTEGER( I ) + DLTA );
        END LOOP;
      END RELOC_FOR_WUNIT;
         
    BEGIN
      FOR I IN UNIT.PG .. UNIT.PG + PAGE_IDX( DI ( XD_NBR_PAGES, UNIT ) ) - 1 LOOP
        RELOC( PAGE_IDX( INTEGER( I ) - DLTA ) ) := I;
      END LOOP;

      DECLARE
        WUNIT_LIST		: TREE		:= WUNIT_SEQ.FIRST;				--| POINTEUR ELEMENT DE LISTE DES UNITES "WITHED"
        WUNIT		: TREE;							--| UNE UNITE "WITHED" DE L'UNITE CHARGEE
      BEGIN
        IF WUNIT_LIST /= TREE_NIL THEN
          WHILE WUNIT_LIST.TY = DN_LIST LOOP
            WUNIT      := D( XD_HEAD, OFFSET( WUNIT_LIST ) );
            WUNIT_LIST := D( XD_TAIL, OFFSET( WUNIT_LIST ) );
            RELOC_FOR_WUNIT( WUNIT );
          END LOOP;
          RELOC_FOR_WUNIT( WUNIT_LIST );						--| LA DERNIERE DE LA LISTE
        END IF;
      END;

RELOCATE_PNTRS:					-- TABLE IS SET UP, DO THE RELOC
      WHILE PNTR.PG <= LAST_PAGE LOOP
        DECLARE    
          WORD_ZERO	: TREE	:= DABS( 0, PNTR);						--| ENTETE DE NOEUD
        BEGIN
          IF WORD_ZERO = TREE_VIRGIN THEN						--| NON INITIALISE
            PNTR.PG := PNTR.PG + 1;							--| PAGE SUIVANTE
            PNTR.LN := 0;								--| LIGNE 0
          ELSE
            NODE_KIND := WORD_ZERO.NOTY;
            PNTR.TY := NODE_KIND;
                  
            IF NODE_KIND = DN_TXTREP OR NODE_KIND = DN_NUM_VAL THEN				--| UN TERMINAL TEXTE OU NOMBRE
              NULL;									--| RIEN A FAIRE DEDANS
            ELSE
              FOR I IN 1 .. WORD_ZERO.NSIZ LOOP						--| POUR TOUS LES TREES DU NOEUD
                DECLARE
                  WORD	: TREE	:= DABS( I, PNTR );					--| PRENDRE LE TREE
                BEGIN
                  IF WORD.PT = HI THEN							--| UN HEADER/INTEGER
                    NULL;								--| RIEN A LUI FAIRE
                  ELSIF WORD.PT = S THEN						--| UN SOURCE POSITION
                    WORD.SPG := RELOC( WORD.SPG );					--| DECALER
                    DABS( I, PNTR, WORD );						--| REECRIRE
                  ELSE								--| POINTEUR SEGMENTE STANDARD
		IF WORD.PG /= 0 THEN
                      WORD.PG := RELOC( WORD.PG );					--| DECALER SA PAGE
                      DABS( I, PNTR, WORD );						--| REECRIRE
                      IF WORD.TY = DN_GENERIC_DECL THEN					--| UN POINTEUR A GENERIQUE
                        GENERIC_LIST := INSERT( GENERIC_LIST, WORD );				--| LE METTRE EN LISTE SPECIALE
		  END IF;
                    END IF;
                  END IF;
                END;
              END LOOP;
            END IF;
                  
            IF PNTR.LN < LINE_IDX'LAST - WORD_ZERO.NSIZ THEN				--| SI RESTE DE LA PLACE
	    PNTR.LN := PNTR.LN + WORD_ZERO.NSIZ + 1;					--| MONTER AU NOEUD SUIVANT
	  ELSE
	    PNTR.PG := PNTR.PG + 1;							--| PAGE SUIVANTE
	    PNTR.LN := 0;								--| LIGNE 1
            END IF;
          END IF;
        END;
      END LOOP RELOCATE_PNTRS;

    END RELOCATE_UNIT;
      
  BEGIN
    IF NOT IS_EMPTY( LIST( FILESYM ) ) THEN						--| LE SYMBOLE A DEJA UNE UNITE CHARGEE
      UNIT := HEAD( LIST( FILESYM ) );							--| RETOURNER CELLE-CI
      RETURN UNIT;
    END IF;
         
LIRE_BLOCS_PAGES:
    DECLARE
      PACKAGE SEQ_IO	IS NEW SEQUENTIAL_IO( SECTOR );
      LIB_FILE		: SEQ_IO.FILE_TYPE;
    BEGIN
      SEQ_IO.OPEN( LIB_FILE, SEQ_IO.IN_FILE, GET_LIB_PREFIX & PRINT_NAME( FILESYM ) );		--| OUVRIR LE FICHIER ARBRE LIBRARISE DE L'UNITE
LECTURES:
      DECLARE
        PAGET	: TREE	:= MAKE( NODE_NAME'VAL( 0 ), ATTR_NBR( LINE_IDX'LAST ) );		--| ALLOUER UN ESPACE D'UNE PAGE (SOUS FORME DE NOEUD) DANS L'ARBRE DE LA COMPILATION
        ENTETE	: TREE;
      BEGIN
        SEQ_IO.READ( LIB_FILE, PAG( ASSOC_PAGE( PAGET.PG ) ).DATA.ALL );			--| LIRE LA PREMIERE PAGE
        ENTETE := DABS( 0, PAGET );							--| PREMIER ENTETE DE PREMIER NOEUD D'UNITE (UN DN_COMPILATION_UNIT)
 
        UNIT := (P, TY=> ENTETE.NOTY, PG=> PAGET.PG, LN=> 0);				--| POINTEUR VERS CE NOEUD COMPTE TENU DE SON TYPE ET DE SON LIEU DE CHARGEMENT
         
        FOR I IN 2 .. DI( XD_NBR_PAGES, UNIT ) LOOP					--| POUR LE NOMBRE DES AUTRES PAGES
          PAGET := MAKE( NODE_NAME'VAL( 0 ), ATTR_NBR( LINE_IDX'LAST ) );			--| ALLOUER UNE NOUVELLE PAGE (SOUS FORME DE NOEUD) DANS L'ARBRE DE LA COMPILATION
          SEQ_IO.READ( LIB_FILE, PAG( ASSOC_PAGE( PAGET.PG ) ).DATA.ALL );			--| LIRE LA PAGE
        END LOOP;
      END LECTURES;
         
      SEQ_IO.CLOSE( LIB_FILE );							--| FERMER LE FICHIER ARBRE LIBRARISE
    END LIRE_BLOCS_PAGES;

    DECLARE      
      OLD_PTR	: TREE	:= D( XD_LIB_NAME, UNIT );					--| UN ANCIEN POINTEUR DANS LA PREMIERE PAGE
    BEGIN
      DLTA := INTEGER( UNIT.PG ) - INTEGER( OLD_PTR.PG );					--| DECALAGE DE PAGE SUITE AU CHARGEMENT
    END;
    UNIT_TIMESTAMP := DI( XD_TIMESTAMP, UNIT );						--| RECUPERER L'ESTAMPILLE TEMPORELLE
      
LOAD_WITHED:
    DECLARE
      WUNIT_SEQ		: SEQ_TYPE	:= LIST( UNIT );				--| LISTE XD_WITH_LIST DES UNITES "WITHED"
      WUNIT_LIST		: TREE		:= WUNIT_SEQ.FIRST;				--| POINTEUR ELEMENT DE LISTE DES UNITES "WITHED"
      WUNIT		: TREE;							--| UNE UNITE "WITHED" DE L'UNITE CHARGEE
    BEGIN
      IF WUNIT_LIST /= TREE_NIL THEN							--| SI LISTE NON VIDE
        WHILE WUNIT_LIST.TY = DN_LIST LOOP						--| TANT QUE LA LISTE SE POURSUIT
          WUNIT      := D( XD_HEAD, OFFSET( WUNIT_LIST ) );					--| POINTEUR D'UNITE "WITHED" COMPTE TENU DU DÉCALAGE DE PAGE AU CHARGEMENT
          WUNIT_LIST := D( XD_TAIL, OFFSET( WUNIT_LIST ) );					--| AVANCER LE POINTEUR DE LISTE
          LOAD_WITHED_UNIT( WUNIT );							--| CHARGER L'UNITE "WITHED" DE CELLE CHARGEE
        END LOOP;
        LOAD_WITHED_UNIT( WUNIT_LIST );							--| CHARGER LA DERNIERE EN QUEUE
      END IF;
    END LOAD_WITHED;

    RELOCATE_UNIT( UNIT, LIST( UNIT ) );							--| TRANSLATER LES POINTEURS DE L'UNITE ET DE SES WITHED
    LOADED_UNIT_LIST := INSERT( LOADED_UNIT_LIST, UNIT );					--| INSERER DANS LA LISTE DES UNITES CHARGEES
    LIST( FILESYM, INSERT( (TREE_NIL,TREE_NIL), UNIT ) );					--| REPORTER L'UNITE DANS LE SYMBOLE CORRESPONDANT
    RETURN UNIT;
         
  EXCEPTION
    WHEN NAME_ERROR =>
      PUT( "NOT FOUND " & GET_LIB_PREFIX );
      PUT_LINE( PRINT_NAME( FILESYM ) );
      LIST( FILESYM, INSERT( (TREE_NIL,TREE_NIL), TREE_VOID ) );
      RETURN TREE_VOID;
  END LOAD_UNIT;
  --|-----------------------------------------------------------------------------------------------
  --|	PROCEDURE LOAD_UNIT
  FUNCTION LOAD_UNIT ( PRI, SEC :STRING ) RETURN TREE IS
  BEGIN
    RETURN LOAD_UNIT( MAKE_FILE_SYM( PRI, SEC ) );
  END LOAD_UNIT;
  --|-----------------------------------------------------------------------------------------------
  --|	PROCEDURE INTEGRER_EN_FERMETURE_DES_WITH
  --|
  PROCEDURE INTEGRER_EN_FERMETURE_DES_WITH ( UNIT :TREE ) IS
  BEGIN

VERIFIER_SI_DEJA_EN_FERMETURE:
    DECLARE
      FERMETURE		: SEQ_TYPE	:= TRANS_WITH_SEQ;				--| FERMETURE TRANSITIVE EN COURS
      ELEMENT		: TREE;
    BEGIN
      WHILE NOT IS_EMPTY( FERMETURE ) LOOP
        POP( FERMETURE, ELEMENT );
        IF D( TW_COMP_UNIT, ELEMENT ) = UNIT THEN						--| L UNITE A INTEGRER EN FERMETURE L A ETE ET EST DEJA EN FERMETURE
          RETURN;									--| RIEN A FAIRE SORTIR
        END IF;
      END LOOP;
    END VERIFIER_SI_DEJA_EN_FERMETURE;

INTEGRER_LES_SUBWITHES:
    DECLARE
      SUB_WITH_SEQ		: SEQ_TYPE	:= LIST( UNIT );				--| LISTE DE UNITES WITHEES PAR L UNITE A INTEGRER
      SUB_ELEMENT		: TREE;
    BEGIN
      WHILE NOT IS_EMPTY( SUB_WITH_SEQ ) LOOP
        POP( SUB_WITH_SEQ, SUB_ELEMENT );
        INTEGRER_EN_FERMETURE_DES_WITH( D( TW_COMP_UNIT, SUB_ELEMENT ) );					--| RECURSION POUR INTEGRER CES "SOUS" UNITES
      END LOOP;
    END INTEGRER_LES_SUBWITHES;

INTEGRER_EN_FERMETURE: 
    DECLARE
      INTEGRAND		: TREE		:= MAKE( DN_TRANS_WITH );			--| CREER UN ELEMENT DE LIAISON DE LISTE WITH FERMETURE
    BEGIN     
      D( TW_FILENAME,  INTEGRAND, STORE_TEXT( PRINT_NAME( D( XD_LIB_NAME, UNIT ) ) ) );		--| NOM
      D( TW_COMP_UNIT, INTEGRAND, UNIT );						--| UNITE WITHEE
      TRANS_WITH_SEQ := APPEND( TRANS_WITH_SEQ, INTEGRAND );				--| ENFIN AJOUTER L ELEMENT DE LIAISON EN LISTE FERMETURE
    END INTEGRER_EN_FERMETURE;

  END INTEGRER_EN_FERMETURE_DES_WITH;
  --|-----------------------------------------------------------------------------------------------
  --|	PROCEDURE MAKE_USED_NAME_ID
  FUNCTION MAKE_USED_NAME_ID ( USED_ID :TREE) RETURN TREE IS
    USED_NAME_ID	: TREE	:= MAKE( DN_USED_NAME_ID );
  BEGIN
    D( LX_SYMREP, USED_NAME_ID, D( LX_SYMREP, USED_ID ) );
    D( LX_SRCPOS, USED_NAME_ID, D( LX_SRCPOS, USED_ID ) );
    RETURN USED_NAME_ID;
  END MAKE_USED_NAME_ID;
  --|-----------------------------------------------------------------------------------------------
  --|	PROCEDURE UNSELECTED
  FUNCTION UNSELECTED ( NAME :TREE ) RETURN TREE IS
  BEGIN
    IF NAME.TY = DN_SELECTED THEN
      RETURN D( AS_DESIGNATOR, NAME );
    ELSE
      RETURN NAME;
    END IF;
  END UNSELECTED;
  --|-----------------------------------------------------------------------------------------------
  --|	PROCEDURE LOAD_WITH_ANCESTOR
  PROCEDURE LOAD_WITH_ANCESTOR ( ANC_NAME :IN OUT TREE; ANC_PRISYM :OUT TREE ) IS
    PRISYM		: TREE;
    ANC_UNIT		: TREE;
    TEST_UNIT		: TREE;
    ANC_ANC_NAME		: TREE;
    USED_NAME_ID		: TREE;
  BEGIN
    IF ANC_NAME.TY /= DN_SELECTED THEN
      PRISYM := D( LX_SYMREP, ANC_NAME );
      ANC_UNIT := LOAD_UNIT( PRINT_NAME( PRISYM ), ".DCL" );
      IF ANC_UNIT /= TREE_VOID THEN
        IF D( AS_ALL_DECL, ANC_UNIT ).TY = DN_SUBPROGRAM_BODY THEN
          LIST( MAKE_FILE_SYM( PRINT_NAME( PRISYM ), ".BDY" ), SINGLETON( ANC_UNIT ) );
        ELSE
          ANC_UNIT := LOAD_UNIT( PRINT_NAME( PRISYM), ".BDY" );
        END IF;
      END IF;
      IF ANC_UNIT = TREE_VOID THEN
        ERROR( ANC_NAME, "CAN'T FIND ANCESTOR - "& PRINT_NAME( PRISYM ) );
        PRISYM := TREE_VOID;
      ELSE
        INTEGRER_EN_FERMETURE_DES_WITH( ANC_UNIT );
        ANC_NAME := MAKE_USED_NAME_ID( ANC_NAME );
					-- (OLD COMMENT:$$$$)SM_DEFN WILL BE ADJUSTED TO SM_FIRST(SM_DEFN) LATER
        D( SM_DEFN, ANC_NAME, D( SM_FIRST, SON_1( D( AS_ALL_DECL, ANC_UNIT ) ) ) );
      END IF;
    ELSE
					-- ANCESTOR IS ANOTHER SUBUNIT
      D( SM_EXP_TYPE, ANC_NAME, TREE_VOID );
      ANC_ANC_NAME := D( AS_NAME, ANC_NAME );
      LOAD_WITH_ANCESTOR( ANC_ANC_NAME, PRISYM );
      D( AS_NAME, ANC_NAME, ANC_ANC_NAME );
					-- USED_NAME_ID'S
      IF PRISYM /= TREE_VOID THEN
        TEST_UNIT := LOAD_UNIT( PRINT_NAME( PRISYM ),
		PRINT_NAME( D( LX_SYMREP, D( AS_DESIGNATOR, ANC_NAME ) ) )
		);
        IF TEST_UNIT = TREE_VOID THEN
          ERROR( ANC_NAME, "CAN'T FIND ANCESTOR SUBUNIT - " & PRINT_NAME( D( LX_SYMREP, D( AS_DESIGNATOR, ANC_NAME ) ) ) );
          PRISYM := TREE_VOID;
					-- (NOTE. COMPARE PRINTNAMES IN CASE IT IS STILL A TXTREP)
        ELSIF PRINT_NAME( D( LX_SYMREP, UNSELECTED( ANC_ANC_NAME ) ) )
                  /= PRINT_NAME( D( LX_SYMREP, UNSELECTED( D( AS_NAME, D( AS_ALL_DECL, TEST_UNIT ) ) ) ) )
        THEN
          ERROR( ANC_NAME, "CONFLICTING ANCESTOR NAMES - "
                                                & PRINT_NAME( D( LX_SYMREP, UNSELECTED( D( AS_DESIGNATOR, ANC_NAME ) ) ) )
                     );
          PRISYM := TREE_VOID;
        ELSE
          INTEGRER_EN_FERMETURE_DES_WITH( TEST_UNIT );
          USED_NAME_ID := MAKE_USED_NAME_ID( D( AS_DESIGNATOR, ANC_NAME ) );
          D( SM_DEFN, USED_NAME_ID, D( SM_FIRST, SON_1( D( AS_SUBUNIT_BODY, D( AS_ALL_DECL, TEST_UNIT ) ) ) ) );
          D( AS_DESIGNATOR, ANC_NAME, USED_NAME_ID );
        END IF;
      END IF;
    END IF;
    ANC_PRISYM := PRISYM;
  END LOAD_WITH_ANCESTOR;
  --|-----------------------------------------------------------------------------------------------
  --|	PROCEDURE WITH_FOR_ANCESTOR
  PROCEDURE WITH_FOR_ANCESTOR ( SUBUNIT :TREE ) IS
    ANC_NAME		: TREE;			-- NAME OF ANCESTOR, MAYBE SELECTED
    ANC_PRISYM		: TREE;			-- RETURNED LX_SYMREP OF FIRST SELECTOR
    UNIT			: TREE;
  BEGIN
    ANC_NAME := D( AS_NAME, SUBUNIT );
    LOAD_WITH_ANCESTOR( ANC_NAME, ANC_PRISYM );
    D( AS_NAME, SUBUNIT, ANC_NAME );
    IF ANC_PRISYM /= TREE_VOID AND THEN ANC_NAME.TY = DN_SELECTED THEN
      UNIT := LOAD_UNIT( PRINT_NAME( ANC_PRISYM ),
		PRINT_NAME( D( LX_SYMREP, SON_1( D( AS_SUBUNIT_BODY, SUBUNIT ) ) ) )
		);
      IF UNIT /= TREE_VOID THEN
        IF PRINT_NAME( D( LX_SYMREP, D( AS_DESIGNATOR, ANC_NAME ) ) )
 	/= PRINT_NAME( D( LX_SYMREP, D( AS_DESIGNATOR,  D( AS_NAME, D( AS_ALL_DECL, UNIT ) ) ) ) )
        THEN
          ERROR( SUBUNIT, "CONFLICTING SUBUNIT NAMES" );
        END IF;
      END IF;
    END IF;
  END WITH_FOR_ANCESTOR;
  --|-----------------------------------------------------------------------------------------------
  --|	PROCEDURE CHECK_USE_CLAUSES
  PROCEDURE CHECK_USE_CLAUSES ( CONTEXT_LIST_IN :SEQ_TYPE; CONTEXT_ITEM :TREE ) IS
    USE_CLAUSE_LIST		: SEQ_TYPE	:= LIST( D( AS_USE_PRAGMA_S, CONTEXT_ITEM ) );
    USE_CLAUSE		: TREE;
    USE_ID_LIST		: SEQ_TYPE;
    USE_ID		: TREE;
         
    --|---------------------------------------------------------------------------------------------
    --|	PROCEDURE CHECK_ONE_USE_ID
    PROCEDURE CHECK_ONE_USE_ID ( CONTEXT_LIST_IN :SEQ_TYPE; CONTEXT_ITEM, USE_ID : TREE ) IS
      SYMREP		: TREE;
      TEMP_CONTEXT_LIST	: SEQ_TYPE 	:= CONTEXT_LIST_IN;
      TEMP_CONTEXT_ITEM	: TREE;
      WITH_ID_LIST		: SEQ_TYPE;
      WITH_ID		: TREE;
    BEGIN
      IF USE_ID.TY = DN_PRAGMA THEN
        RETURN;
      END IF;
        
      IF USE_ID.TY /= DN_USED_OBJECT_ID THEN
        ERROR( D( LX_SRCPOS, USE_ID ), "ONLY SIMPLE NAMES ALLOWED IN CONTEXT USE");
      END IF;
         
      SYMREP := D( LX_SYMREP, USE_ID );
         
      LOOP
        POP( TEMP_CONTEXT_LIST, TEMP_CONTEXT_ITEM );
        IF TEMP_CONTEXT_ITEM.TY = DN_WITH THEN
          WITH_ID_LIST := LIST( D( AS_NAME_S, TEMP_CONTEXT_ITEM ) );
          WHILE NOT IS_EMPTY( WITH_ID_LIST) LOOP
            POP( WITH_ID_LIST, WITH_ID );
            IF D( LX_SYMREP, WITH_ID ) = SYMREP THEN
              D( SM_DEFN, USE_ID, D( SM_DEFN, WITH_ID ) );
              RETURN;
            END IF;
          END LOOP;
        END IF;
        EXIT WHEN TEMP_CONTEXT_ITEM = CONTEXT_ITEM;
      END LOOP;
         
      ERROR( D( LX_SRCPOS, USE_ID ),
             "USE'D NAME NOT WITHED IN CURRENT CONTEXT CLAUSE - " & PRINT_NAME( SYMREP ) );
      D( SM_DEFN, USE_ID, TREE_VOID );
    END CHECK_ONE_USE_ID;
         
  BEGIN					--CHECK_USE_CLAUSES
    WHILE NOT IS_EMPTY( USE_CLAUSE_LIST ) LOOP
      POP( USE_CLAUSE_LIST, USE_CLAUSE );
      IF USE_CLAUSE.TY = DN_USE THEN
        USE_ID_LIST := LIST( D( AS_NAME_S, USE_CLAUSE ) );
        WHILE NOT IS_EMPTY( USE_ID_LIST) LOOP
          POP( USE_ID_LIST, USE_ID );
          IF USE_ID.TY = DN_USED_OBJECT_ID THEN
            CHECK_ONE_USE_ID( CONTEXT_LIST_IN, CONTEXT_ITEM, USE_ID );
          END IF;
        END LOOP;
      END IF;
    END LOOP;
  END CHECK_USE_CLAUSES;
  --|-----------------------------------------------------------------------------------------------
  --|	PROCEDURE PROCESS_WITH_CLAUSES
  PROCEDURE PROCESS_WITH_CLAUSES ( COMP_UNIT : TREE ) IS
    UNIT_CONTEXT_LIST	: SEQ_TYPE	:= LIST( D( AS_CONTEXT_ELEM_S, COMP_UNIT ) );
    CONTEXT_ITEM_LIST	: SEQ_TYPE	:= UNIT_CONTEXT_LIST;
    CONTEXT_ITEM		: TREE;
    WITH_NAME_LIST		: SEQ_TYPE;
    WITH_NAME		: TREE;
    UNIT			: TREE;
    WITH_BODY		: TREE;
  BEGIN
    WHILE NOT IS_EMPTY( CONTEXT_ITEM_LIST) LOOP
      POP( CONTEXT_ITEM_LIST, CONTEXT_ITEM );
            
      IF CONTEXT_ITEM.TY = DN_WITH THEN
        WITH_NAME_LIST := LIST( D( AS_NAME_S, CONTEXT_ITEM ) );
        WHILE NOT IS_EMPTY( WITH_NAME_LIST ) LOOP
          POP( WITH_NAME_LIST, WITH_NAME );
          UNIT := LOAD_UNIT( PRINT_NAME( D( LX_SYMREP, WITH_NAME ) ), ".DCL" );
          IF UNIT = TREE_VOID THEN
            ERROR( D( LX_SRCPOS, WITH_NAME ),
 	"WITHED UNIT NOT FOUND - " & PRINT_NAME( D( LX_SYMREP, WITH_NAME ) )
	);
            D( SM_DEFN, WITH_NAME, TREE_VOID );
          ELSIF DI( XD_TIMESTAMP, UNIT) = CUR_TIMESTAMP THEN
            ERROR( D( LX_SRCPOS, WITH_NAME ),
                        "WITH CLAUSE REFERS TO CURRENT UNIT - " & PRINT_NAME( D( LX_SYMREP, WITH_NAME ) )
                        );
                                                -- AVOID ERROR WHEN CHECKING USE CLAUSE LATER
            D( SM_DEFN, WITH_NAME, TREE_VOID );
          ELSE
            INTEGRER_EN_FERMETURE_DES_WITH ( UNIT );
            WITH_BODY := D( AS_ALL_DECL, UNIT );
            D( SM_DEFN, WITH_NAME, SON_1( WITH_BODY ) );
          END IF;
        END LOOP;
      END IF;
      CHECK_USE_CLAUSES( UNIT_CONTEXT_LIST, CONTEXT_ITEM );
    END LOOP;
  END PROCESS_WITH_CLAUSES;
  --|-----------------------------------------------------------------------------------------------
  --|	PROCEDURE WITH_FOR_ONE_COMP_UNIT
  --|
  PROCEDURE WITH_FOR_ONE_COMP_UNIT ( COMP_UNIT_ARG :TREE ) IS
    COMP_UNIT		: TREE		:= COMP_UNIT_ARG;
    FILE_SYM		: TREE		:= D( XD_LIB_NAME, COMP_UNIT );
    UNIT_BODY		: TREE		:= D( AS_ALL_DECL, COMP_UNIT );
    UNIT_KIND		: NODE_NAME	:= UNIT_BODY.TY;
    WITH_LIST		: SEQ_TYPE	:= (TREE_NIL, TREE_NIL);
    UNIT			: TREE;
  BEGIN
    TRANS_WITH_SEQ := (TREE_NIL, TREE_NIL);						--| FERMETURE TRANSITIVE DES WITH INITIALEMENT VIDE
    UNIT := LOAD_UNIT( "_STANDRD", ".DCL" );						--| CHARGER L UNITE PREDEFINIE
    IF UNIT = TREE_VOID THEN
      PUT_LINE( "!! PREDEFINED ENVIRONMENT NOT FOUND.");
      RAISE PROGRAM_ERROR;
    END IF;
    INTEGRER_EN_FERMETURE_DES_WITH( UNIT );						--| LA METTRE EN FERMETURE TRANSITIVE
      
					-- CLEAR LIST OF TRANS-WITH UNITS TO AVOID ABORT IF SELF-REFERENCE
    LIST( COMP_UNIT, (TREE_NIL,TREE_NIL) );
      
    IF UNIT_KIND = DN_SUBPROG_ENTRY_DECL THEN
      NULL;
            
    ELSIF UNIT_KIND = DN_PACKAGE_DECL OR UNIT_KIND = DN_GENERIC_DECL THEN
      NULL;
           
    ELSIF UNIT_KIND = DN_PACKAGE_BODY OR UNIT_KIND = DN_SUBPROGRAM_BODY THEN
      DECLARE
        UNIT_PRI	: CONSTANT STRING	:= PRINT_NAME( D( LX_SYMREP, SON_1( UNIT_BODY ) ) );
      BEGIN
        UNIT := LOAD_UNIT( UNIT_PRI, ".DCL" );
        IF UNIT /= TREE_VOID THEN
          IF UNIT_KIND = DN_SUBPROGRAM_BODY
             AND THEN NOT (
		D( AS_ALL_DECL, UNIT ).TY = DN_SUBPROG_ENTRY_DECL
		AND THEN D( AS_UNIT_KIND, D( AS_ALL_DECL, UNIT ) ).TY /= DN_INSTANTIATION
		)
             AND THEN NOT (
		D( AS_ALL_DECL, UNIT ).TY = DN_GENERIC_DECL
		AND THEN D( AS_HEADER, D( AS_ALL_DECL, UNIT ) ).TY IN CLASS_SUBP_ENTRY_HEADER
		)
          THEN
            UNIT := TREE_VOID;
          END IF;
        END IF;
            
        IF UNIT /= TREE_VOID THEN
          INTEGRER_EN_FERMETURE_DES_WITH( UNIT );
          D( SM_FIRST, SON_1( UNIT_BODY ), SON_1( D( AS_ALL_DECL,UNIT ) ) );
          D( XD_PARENT, COMP_UNIT, UNIT );
        ELSE
          IF UNIT_KIND = DN_PACKAGE_BODY THEN
            ERROR( D( LX_SRCPOS, COMP_UNIT ), "CANNOT WITH SPEC FOR " & PRINT_NAME( D( LX_SYMREP, SON_1( UNIT_BODY ) ) ) );
          ELSE
            DECLARE
              FILESYM	: TREE := MAKE_FILE_SYM( UNIT_PRI, ".DCL" );
            BEGIN
              LIST( FILESYM, SINGLETON( COMP_UNIT ) );
              D( XD_LIB_NAME, COMP_UNIT, FILESYM );
            END;
          END IF;
        END IF;
      END;
    ELSE					--| UNIT_KIND = SUBUNIT
       WITH_FOR_ANCESTOR( UNIT_BODY );
    END IF;
      
    CUR_TIMESTAMP := CUR_TIMESTAMP + 1;
    DI( XD_TIMESTAMP, COMP_UNIT, CUR_TIMESTAMP );
    LIST( FILE_SYM, INSERT( (TREE_NIL,TREE_NIL), COMP_UNIT ) );
      
    PROCESS_WITH_CLAUSES( COMP_UNIT );
      
    LIST( COMP_UNIT, TRANS_WITH_SEQ );
    NEW_UNIT_LIST := APPEND( NEW_UNIT_LIST, COMP_UNIT );
         
  END WITH_FOR_ONE_COMP_UNIT;
  --|-----------------------------------------------------------------------------------------------
  --|	PROCEDURE COPY_NODE
  FUNCTION COPY_NODE ( NODE :TREE ) RETURN TREE IS
    WORD_ZERO	: TREE	:= DABS( 0, NODE );
    NEW_NODE	: TREE	:= MAKE( WORD_ZERO.NOTY, WORD_ZERO.NSIZ );
  BEGIN
    FOR I IN 1 .. WORD_ZERO.NSIZ LOOP
      DABS( I, NEW_NODE, DABS( I, NODE ) );
    END LOOP;
    RETURN NEW_NODE;
  END COPY_NODE;
  --|-----------------------------------------------------------------------------------------------
  --|	PROCEDURE GENERATE_DUMMY_SPEC
  PROCEDURE GENERATE_DUMMY_SPEC ( COMP_UNIT :TREE ) IS
					-- GENERATE LIBRARY UNIT FOR DEFAULT SUBPROGRAM SPEC
    SUBP_BODY		: TREE	:= D( AS_ALL_DECL, COMP_UNIT );
    SUBP_HEADER		: TREE	:= D( AS_HEADER, SUBP_BODY );
    NEW_UNIT		: TREE	:= COPY_NODE( COMP_UNIT );
    NEW_ID		: TREE	:= COPY_NODE( SON_1( SUBP_BODY ) );
    NEW_DECL		: TREE	:= MAKE( DN_SUBPROG_ENTRY_DECL );
  BEGIN
    D( SM_SPEC, NEW_ID, NEW_DECL );
    D( SM_FIRST, NEW_ID, NEW_ID );
      
    D( AS_SOURCE_NAME, NEW_DECL, NEW_ID );
    D( AS_HEADER, NEW_DECL, D( AS_HEADER, SUBP_BODY ) );
    D( AS_UNIT_KIND, NEW_DECL, TREE_VOID );
    D( LX_SRCPOS, NEW_DECL, D( LX_SRCPOS, SUBP_BODY ) );
      
					-- WORRY ABOUT DUPLICATED CONTEXT AND PRAGMAS $$$$$$$$
    D( AS_ALL_DECL, NEW_UNIT, NEW_DECL );
      
    INSERT_FILE_NAME( NEW_UNIT );
    WITH_FOR_ONE_COMP_UNIT( NEW_UNIT );
  END GENERATE_DUMMY_SPEC;
  --|-----------------------------------------------------------------------------------------------
  --|	PROCEDURE ENTER_DEFAULT_GENERIC_FORMALS
  PROCEDURE ENTER_DEFAULT_GENERIC_FORMALS IS
    GENERIC_DECL		: TREE;
    FORMAL_LIST		: SEQ_TYPE;
    FORMAL		: TREE;
    SUBPROGRAM_DEF		: TREE;
    --|---------------------------------------------------------------------------------------------
    --|	PROCEDURE INSERT_SYMBOL
    PROCEDURE INSERT_SYMBOL ( NAME :TREE ) IS
      DUMMY	: TREE;
    BEGIN
      IF NAME.TY = DN_SELECTED THEN
        INSERT_SYMBOL( D( AS_NAME, NAME ) );
        INSERT_SYMBOL( D( AS_DESIGNATOR, NAME ) );
      ELSE									--| DOIT ETRE UN DEF_ID, DEF_OP, USED_ID, USED_OP
        DUMMY := STORE_SYM( PRINT_NAME( D( LX_SYMREP, NAME ) ) );
      END IF;
    END INSERT_SYMBOL;
      
  BEGIN
    WHILE NOT IS_EMPTY( GENERIC_LIST) LOOP
      POP( GENERIC_LIST, GENERIC_DECL );
      FORMAL_LIST := LIST( D( AS_ITEM_S, GENERIC_DECL ) );
      WHILE NOT IS_EMPTY( FORMAL_LIST) LOOP
        POP( FORMAL_LIST, FORMAL );
        IF FORMAL.TY = DN_SUBPROG_ENTRY_DECL THEN
          SUBPROGRAM_DEF := D( AS_UNIT_KIND, FORMAL );
          IF SUBPROGRAM_DEF.TY = DN_BOX_DEFAULT THEN
            INSERT_SYMBOL( D( AS_SOURCE_NAME, FORMAL ) );
          END IF;
        END IF;
      END LOOP;
    END LOOP;
  END ENTER_DEFAULT_GENERIC_FORMALS;
  --|-----------------------------------------------------------------------------------------------
  --|	PROCEDURE ENTER_USED_DEFINING_IDS
  PROCEDURE ENTER_USED_DEFINING_IDS IS
    UNIT		: TREE;
    PNTR		: TREE;
    WORD_ZERO	: TREE;
    NODE_TYPE	: NODE_NAME;
    SYMREP	: TREE;
  BEGIN
    WHILE NOT IS_EMPTY( LOADED_UNIT_LIST ) LOOP
      POP( LOADED_UNIT_LIST, UNIT );							--| RETIRER UNE UNITE CHARGEE DE LA LISTE DES CHARGEES
      PNTR := UNIT;									--| POINTER LE DEBUT D UNITE
      FOR I IN 1 .. DI( XD_NBR_PAGES, UNIT ) LOOP
        PNTR.LN := LINE_IDX'FIRST;							--| A CHAQUE PAGE REVENIR A LA PREMIERE LIGNE

PARCOURS_BLOCS_NOEUDS:
        LOOP
          WORD_ZERO := DABS( 0, PNTR );							--| POSSIBLE ENTETE DE NOEUD
          EXIT PARCOURS_BLOCS_NOEUDS WHEN WORD_ZERO = TREE_VIRGIN;				--| SORTIR SI EN FAIT NON INITIALISE (FIN DE PARTIE DE PAGE REMPLIE)
          PNTR.TY   := WORD_ZERO.NOTY;
          NODE_TYPE := WORD_ZERO.NOTY;
                  
          CASE NODE_TYPE IS
          WHEN CLASS_DEF_NAME =>							--| TOUS LES ID (DE VARIABLE_ID A BLTN_OPERATOR_ID)
            SYMREP := D( LX_SYMREP, PNTR );						--| PRENDRE LE SYMREP (EN PRINCIPE UN SYMBOLE POUR L ID)
            IF SYMREP.TY = DN_TXTREP THEN						--| SI C'EST UN TXTREP (REMPLACEMENT FAIT PAR WRITE_LIB)
              IF NODE_TYPE IN CLASS_UNIT_NAME						--| PROCEDURE_ID, FUNCTION_ID, OPERATOR_ID
              OR ELSE (	NODE_TYPE = DN_VARIABLE_ID					--| OU VARIABLE
                           	AND THEN D( SM_OBJ_TYPE, PNTR).TY = DN_TASK_SPEC			--| DE TYPE TACHE
                           	)
              OR ELSE NODE_TYPE = DN_TYPE_ID						--| OU TYPE_ID
              THEN
                IF NODE_TYPE = DN_VARIABLE_ID OR ELSE D( SM_FIRST, PNTR ) = PNTR		--| VARIABLE_ID (TACHE) OU 
                THEN
                  SYMREP := STORE_SYM( PRINT_NAME( SYMREP ) );				--| STOCKER LE SYMBOLE
                ELSIF NODE_TYPE = DN_TYPE_ID THEN						--| TYPE_ID
                  IF D( SM_TYPE_SPEC, D( SM_FIRST, PNTR ) ).TY = DN_INCOMPLETE THEN		--| INCOMPLET
                    D( XD_FULL_TYPE_SPEC, D( SM_TYPE_SPEC, D( SM_FIRST, PNTR ) ), D( SM_TYPE_SPEC, PNTR ) );
                  END IF;
                END IF;
              ELSE									--| AUTRES DE LA CLASSE DEF_NAME
                SYMREP := FIND_SYM( PRINT_NAME( SYMREP ) );					--| CHERCHER SI LA COMPILATION PRESENTE MENTIONNE CE SYMBOLE
              END IF;
              IF SYMREP /= TREE_VOID THEN						--| S'IL EST PRESENT
                D( LX_SYMREP, PNTR, SYMREP );						--| LE METTRE DANS LE LX_SYMREP DU POINTEUR DE L'UNITE CHARGEE
              END IF;
            END IF;

          WHEN CLASS_DESIGNATOR =>							--| LES USED_OP, USED_NAME_ID, USED_CHAR, USED_OBJECT_ID 
            SYMREP := D( SM_DEFN, PNTR );						--| PRENDRE LE DEF_NAME
            IF SYMREP.PG > 0 AND THEN SYMREP.TY IN CLASS_DEF_NAME THEN			--| POINTEUR DE BONNE FACTURE
              SYMREP :=  D( LX_SYMREP, SYMREP );						--| PRENDRE LE SYMBOLE
              IF SYMREP.TY = DN_SYMBOL_REP THEN						--| SI C'EST UN SYMBOLE
                D( LX_SYMREP, PNTR, SYMREP );						--| LE RECOLLER DANS LE POINTEUR
              END IF;
            END IF;
 
          WHEN OTHERS =>
            NULL;
          END CASE;

	EXIT PARCOURS_BLOCS_NOEUDS WHEN PNTR.LN >= LINE_IDX'LAST - WORD_ZERO.NSIZ;
          PNTR.LN := PNTR.LN + WORD_ZERO.NSIZ + 1;
        END LOOP PARCOURS_BLOCS_NOEUDS;

        PNTR.PG := PNTR.PG + 1;
      END LOOP;

    END LOOP;
  END ENTER_USED_DEFINING_IDS;
   
BEGIN
  OPEN_IDL_TREE_FILE ( IDL.LIB_PATH( 1..LIB_PATH_LENGTH ) & "$$$.TMP" );			--| OUVRIR L'ARBRE DIANA DE TRAVAIL
      
  IF DI( XD_ERR_COUNT, TREE_ROOT) > 0 THEN						--| S'IL Y A DES ERREURS
    PUT_LINE( "IDL.LIB_PHASE : LIBPHASE PAS FAIT, IL Y A DES ERREURS ANTERIEURES");
  ELSE										--| PAS D'ERREUR
    DECLARE
      USER_ROOT	: TREE		:= D( XD_USER_ROOT, TREE_ROOT );			--| RACINE "USER" DU FICHIER
      COMPILATION	: TREE		:= D( XD_STRUCTURE, USER_ROOT );			--| NOEUD "COMPILATION"
      COMP_UNIT_SEQ	: SEQ_TYPE	:= LIST( D( AS_COMPLTN_UNIT_S, COMPILATION));		--| LISTE DES UNITES COMPILEES
      COMP_UNIT	: TREE;
      SRC_NAME	: CONSTANT STRING	:= PRINT_NAME( D( XD_SOURCENAME, USER_ROOT ) );
    BEGIN
      IF SRC_NAME /= "_STANDRD.ADA" THEN						--| PAS DE LIB_PHASE POUR LE PACKAGE SPECIAL _STANDRD
        OPEN_LIBRARY;								--| OUVRIR LE FICHIER DE CONTROLE DE LIBRAIRIE ET LIRE LES LIGNES
            
        WHILE NOT IS_EMPTY( COMP_UNIT_SEQ ) LOOP						--| TANT QU'IL Y A DES UNITES COMPILEES
          POP( COMP_UNIT_SEQ, COMP_UNIT );						--| PRENDRE UNE UNITE
          IF D( AS_ALL_DECL, COMP_UNIT ).TY = DN_VOID THEN					--| UNITE NE CONTENANT RIEN
            PUT_LINE ( "IDL.LIB_PHASE : PAS D'UNITE NE CONTENANT QUE DES PRAGMAS" );
          ELSE
            INSERT_FILE_NAME( COMP_UNIT );
            WITH_FOR_ONE_COMP_UNIT( COMP_UNIT );
          END IF;
        END LOOP;
            
        LIST( D( AS_COMPLTN_UNIT_S, COMPILATION ), NEW_UNIT_LIST );
        IF DI( XD_ERR_COUNT, TREE_ROOT ) = 0 THEN						--| PAS D'ERREUR
          CLOSE_LIBRARY;								--| MAJ ET FERMER LE FICHIER CONTROLE DE LIBRAIRIE
        END IF;
            
        ENTER_DEFAULT_GENERIC_FORMALS;
        ENTER_USED_DEFINING_IDS;
      END IF;
    END;
  END IF;
      
  CLOSE_IDL_TREE_FILE;								--| FERMER L'ARBRE DE TRAVAIL
      
--|-------------------------------------------------------------------------------------------------
END LIB_PHASE;