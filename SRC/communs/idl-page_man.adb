WITH DIRECT_IO;
SEPARATE( IDL )
--|-------------------------------------------------------------------------------------------------
--|		PAGE_MAN
--|-------------------------------------------------------------------------------------------------
PACKAGE BODY PAGE_MAN IS
   
  PACKAGE PAGE_IO		IS NEW DIRECT_IO( SECTOR );
  USE PAGE_IO;
        
  SUBTYPE POSITIVE_COUNT	IS PAGE_IO.POSITIVE_COUNT;
   
  WORK_FILE		: PAGE_IO.FILE_TYPE;
  RPG_ALLOC		: RPG_NUM			:= RPG_NUM'LAST;
   
--|-------------------------------------------------------------------------------------------------
--|		PROCEDURE INIT_PAGE_MAN
PROCEDURE INIT_PAGE_MAN IS
BEGIN
  ASSOC_PAGE := (OTHERS=> 0);								--| POUR TOUTE PAGE VIRTUELLE, PAS DE PAGE REELLE ASSOCIEE 
  PAG        := (OTHERS=> (	VP		=> 0,					--| INITIALISER LA TABLE DES PAGES PHYSIQUES
			AREA		=> 0,
			RECUPERABLE	=> TRUE,
			CHANGED		=> FALSE,
			DATA		=> NEW SECTOR )
            		);
  AREA       := (OTHERS=> (VP => 0, FREE_LINE => LINE_NBR'LAST ) );				--| INIT POUR FORCER UNE ALLOC LA PREMIERE FOIS
  RPG_ALLOC  := RPG_NUM'LAST;
END;
   
--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
--|		PROCEDURE CREATE_PAGE_MANAGER
--|
PROCEDURE CREATE_PAGE_MANAGER ( PAGE_FILE_NAME :STRING ) IS
BEGIN
  INIT_PAGE_MAN;									--| INITIALISER LES TABLES
  PAGE_IO.CREATE ( WORK_FILE, INOUT_FILE, PAGE_FILE_NAME );					--| CREATION DU FICHIER DE PAGES
  HIGH_VPG := 0;									--| PAS DE PAGE INITIALEMENT
  CUR_VP   := MAX_VPG;
EXCEPTION
  WHEN OTHERS => PUT_LINE( "ERREUR CREATE_PAGE_MANAGER (PAGE_FILE_NAME = " & PAGE_FILE_NAME & ")" );
END;
--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
--|		PROCEDURE OPEN_PAGE_MANAGER
--|
PROCEDURE OPEN_PAGE_MANAGER ( PAGE_FILE_NAME :STRING ) IS
BEGIN
  INIT_PAGE_MAN;									--| INITIALISER LES TABLES
  PAGE_IO.OPEN( WORK_FILE, INOUT_FILE, PAGE_FILE_NAME );					--| OUVRIR LE FICHIER DE PAGES
  CUR_RP := READ_PAGE( 1 );								--| LIRE LA RACINE (PAGE VIRTUELLE 1) DANS LA PAGE REELLE DE No RENDU
  CUR_VP := 1;									--| VIRTUELLE COURANTE = 1
  HIGH_VPG := VPG_IDX( PAG( CUR_RP ).DATA.ALL(1).VALU );					--| NUMERO DE LA DERNIÈRE PAGE VIRTUELLE (AUSSI NUMERO DE BLOC FICHIER)
EXCEPTION
  WHEN PAGE_IO.NAME_ERROR => PUT_LINE( "OPEN_PAGE_MANAGER : NAME_ERROR " & PAGE_FILE_NAME );
  WHEN OTHERS => PUT_LINE( "ERREUR OPEN_PAGE_MANAGER (PAGE_FILE_NAME = " & PAGE_FILE_NAME & ")" );
END;
--|-------------------------------------------------------------------------------------------------
--|		PROCEDURE INDIQUE_RECUPERABLE
--|
PROCEDURE INDIQUE_RECUPERABLE ( RP :RPG_NUM ) IS						--| RENDRE LA PAGE REELLE FLOTTANTE (OU RECUPERABLE)
  THE_PAGE	: RPG_DATA	RENAMES PAG( RP );
BEGIN
  IF THE_PAGE.RECUPERABLE THEN RETURN; END IF;						--| SI DEJA RECUPERABLE RIEN A FAIRE
  IF THE_PAGE.AREA > 0 THEN								--| IL Y A UNE ZONE D'INSERION
    THE_PAGE.AREA        := 0;							--| PLUS DE ZONE INSERTION
    THE_PAGE.CHANGED     := TRUE;							--| INDIQUER CE CHANGEMENT
    THE_PAGE.RECUPERABLE := TRUE;							--| INDIQUER PAGE PHYSIQUE RECUPERABLE
  END IF;
END INDIQUE_RECUPERABLE;
--|-------------------------------------------------------------------------------------------------
--|		PROCEDURE WRITE_PAGE
--|
PROCEDURE WRITE_PAGE ( RP :RPG_NUM ) IS
BEGIN
  PAGE_IO.WRITE ( WORK_FILE, PAG( RP ).DATA.ALL, POSITIVE_COUNT( PAG( RP ).VP ) );		--| ECRIRE LA PAGE
  PAG( RP ).CHANGED := FALSE;								--| PLUS DE CHANGEMENT
END;
--|-------------------------------------------------------------------------------------------------
--|		PROCEDURE FREE_PAGE
--|
PROCEDURE FREE_PAGE ( RP :RPG_NUM ) IS
  THE_PAGE	: RPG_DATA	RENAMES PAG( RP );
  VP		: VPG_IDX		RENAMES THE_PAGE.VP;				--| INDICE DE LA PAGE VIRTUELLE ASSOCIEE A LA PAGE RP
BEGIN
  IF VP = 0 THEN RETURN; END IF;							--| RIEN A FAIRE SI PAGE PHYSIQUE NON LIEE
  INDIQUE_RECUPERABLE ( RP );								--| LA RENDRE RECUPERABLE
  IF THE_PAGE.CHANGED THEN								--| SI PAGE PHYSIQUE MODIFIEE
    WRITE_PAGE( RP );								--| L'ECRIRE
  END IF;
  ASSOC_PAGE( VP ) := 0;								--| POUR LA VIRTUELLE VP : PLUS DE PAGE PHYSIQUE LIEE
  VP := 0;									--| POUR LA PHYSIQUE : PLUS DE PAGE VIRTUELLE LIEE
END FREE_PAGE;
--|-------------------------------------------------------------------------------------------------
--|		FUNCTION ASSIGN_PAGE
--|
FUNCTION ASSIGN_PAGE ( VP :VPG_NUM ) RETURN RPG_NUM IS					--| ASSOCIER UNE PAGE VIRTUELLE A UNE REELLE
BEGIN
CHERCHE_ET_DEGAGE:
  LOOP
    IF RPG_ALLOC < MAX_RPG THEN							--| LE POINTEUR D'ALLOCATION EST AU DESSOUS DE LA LIMITE
      RPG_ALLOC := RPG_ALLOC + 1;							--| LE MONTER
    ELSE
      RPG_ALLOC := 1;								--| SINON BOUCLER EN LE REMETTANT AU DEBUT
    END IF;
    EXIT WHEN PAG( RPG_ALLOC ).VP = 0 OR ELSE PAG( RPG_ALLOC ).RECUPERABLE;			--| SORTIR : ON A UNE PAGE PHYSIQUE NON LIEE OU RECUPERABLE
    INDIQUE_RECUPERABLE( RPG_ALLOC );							--| FAIRE DE LA PLACE : RENDRE UNE PAGE RECUPERABLE DE FORCE
  END LOOP CHERCHE_ET_DEGAGE;
      
  IF PAG( RPG_ALLOC ).RECUPERABLE THEN FREE_PAGE ( RPG_ALLOC); END IF;			--| SI RECUPERABLE LIBERER
  ASSOC_PAGE( VP ) := RPG_ALLOC;							--| INDIQUER LA PAGE PHYSIQUE RECUPEREE COMME ASSOCIEE A LA VIRTUELLE
  PAG( RPG_ALLOC ).VP := VP;								--| INDIQUER LA PAGE VIRTUELLE COMME ASSOCIEE A LA PHYSIQUE
  RETURN RPG_ALLOC;
END;
--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
--|		FUNCTION READ_PAGE
--|
FUNCTION READ_PAGE ( VP :VPG_NUM ) RETURN RPG_NUM IS
  RP		: RPG_IDX		RENAMES ASSOC_PAGE( VP );				--| No DE PAGE PHYSIQUE LIEE A LA VIRTUELLE
BEGIN
  IF RP = 0 THEN									--| SI PAS DE PHYSIQUE ASSOCIEE
    RP := ASSIGN_PAGE( VP );								--| ASSOCIER UNE NOUVELLE PAGE
    PAGE_IO.READ( WORK_FILE, PAG(RP).DATA.ALL, POSITIVE_COUNT(VP) );				--| LIRE LE BLOC DE LA PAGE PHYSIQUE ASSOCIEE A LA VIRTUELLE
  ELSIF PAG( RP ).RECUPERABLE THEN							--| SI LA PAGE PHYSIQUE EST RECUPERABLE
    PAG( RP ).RECUPERABLE := FALSE;							--| JUSTE REFIXER
  END IF;
  RETURN RP;
END;
--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
--|	PROCEDURE NEW_BLOCK
PROCEDURE NEW_BLOCK IS
BEGIN
  AREA( 1 ).FREE_LINE := LINE_NBR'LAST;							--| FORCERA UNE ALLOCATION DE BLOC
END;
--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
--|		PROCEDURE ALLOC_PAGE
--|
PROCEDURE ALLOC_PAGE ( AR :AREA_IDX; SIZE :LINE_NBR ) IS
  NB_FREE		: LINE_NBR	:= LINE_NBR( LINE_IDX'LAST ) - AREA( AR ).FREE_LINE + 1;	--| L ESPACE LIBRE						--| LE NUM DE PAGE REELLE ASSOCIEE
BEGIN
  IF NB_FREE >= SIZE THEN								--| IL Y A ASSEZ DE PLACE POUR CE LIEU D'INSERTION
    DECLARE
      THE_PAGE	: RPG_DATA	RENAMES PAG( ASSOC_PAGE( AREA( AR ).VP ) );
    BEGIN
      IF THE_PAGE.RECUPERABLE THEN							--| SI PAGE INDIQUEE RECUPERABLE
        THE_PAGE.RECUPERABLE := FALSE;							--| REFIXER
        THE_PAGE.AREA := AR;								--| REMETTRE UN POINT D INSERTION
      END IF;
      RETURN;									--| RIEN A FAIRE
    END;
            
  ELSE										--| PLACE INSUFFISANTE ALLOUER

LACHE_PAGE_REELLE_TROP_PLEINE:
    DECLARE
      VP		: VPG_IDX		:= AREA( AR ).VP;					--| LE NUM DE PAGE VIRTUELLE DU POINT D INSERTION
    BEGIN
      IF VP /= 0 THEN								--|  PAGE ASSOCIEE AU POINT D INSERTION
        INDIQUE_RECUPERABLE ( ASSOC_PAGE( VP ) );						--| PAGE DEVENANT RECUPERABLE
      END IF;
    END LACHE_PAGE_REELLE_TROP_PLEINE;

    BEGIN
      HIGH_VPG := HIGH_VPG + 1;							--| UNE PAGE VIRTUELLE DE PLUS
    EXCEPTION
      WHEN CONSTRAINT_ERROR =>							--| SI ON DEPASSE
        TEXT_IO.PUT_LINE ( "EXCES DE PAGES VIRTUELLES ! PLUS DE " & VPG_NUM'IMAGE( HIGH_VPG ) );	--| MESSAGE
        CLOSE_PAGE_MANAGER;								--| FERMER LE FICHIER
    END;

ASSIGNE_PAGE_REELLE:               
    DECLARE
      RP		: RPG_NUM		:= ASSIGN_PAGE ( HIGH_VPG );				--| ASSOCIER LA NOUVELLE PAGE VIRTUELLE
    BEGIN
      PAG( RP ).DATA.ALL := (OTHERS=> TREE_VIRGIN);					--| INITIALISER LE BLOC ALLOUE
      PAG( RP ).AREA := AR;								--| No DE LIEU D'INSERTION MENTIONNE
      PAG( RP ).CHANGED := TRUE;
    END ASSIGNE_PAGE_REELLE;

    AREA( AR ) := (	VP	=> HIGH_VPG,						--| No DE PAGE VIRTUELLE
		FREE_LINE	=> LINE_NBR'FIRST						--| LIGNE UTILISABLE
		);
  END IF;
END ALLOC_PAGE;
--||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
--|		PROCEDURE CLOSE_PAGE_MANAGER
--|
PROCEDURE CLOSE_PAGE_MANAGER IS
BEGIN
      
  DECLARE
    RP		: RPG_NUM		:= READ_PAGE ( 1 );					--| AMENER LA PAGE VIRTUELLE 1
  BEGIN
    IF PAG( RP ).DATA.ALL(1).VALU /= SSHORT( HIGH_VPG ) THEN				--| SI LE NOMBRE DE PAGES N'A PAS LA BONNE VALEUR 
      PAG( RP ).DATA.ALL(1).VALU := SSHORT( HIGH_VPG );					--| CHANGER LA VALEUR
      PAG( RP ).CHANGED := TRUE;							--| MENTIONNER LE CHANGEMENT
    END IF;
  END;
         
  FOR I IN RPG_NUM LOOP
    FREE_PAGE( I );									--| LIBERER LES PAGES (INCLUT UNE ECRITURE SI NECESSAIRE)
  END LOOP;
  PAGE_IO.CLOSE( WORK_FILE );								--| FERMER LE FICHIER DE PAGES
END CLOSE_PAGE_MANAGER;

--|-------------------------------------------------------------------------------------------------
END PAGE_MAN;